{"question": "BigQuery에서 새로운 데이터셋을 생성하는 방법은 무엇인가요?", "answer": "새로운 데이터셋을 생성하려면 다음의 API 메서드를 사용합니다: `insert` 메서드. 요청은 다음과 같이 구성됩니다:\n\n```\nPOST /bigquery/v2/projects/{projectId}/datasets\n```\n여기서 `{projectId}`는 데이터셋을 생성할 프로젝트의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "특정 데이터셋의 정보를 가져오는 방법은 무엇인가요?", "answer": "특정 데이터셋의 정보를 가져오려면 `get` 메서드를 사용합니다. 요청은 다음과 같이 구성됩니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/datasets/{datasetId}\n```\n여기서 `{projectId}`는 프로젝트의 ID이고, `{datasetId}`는 가져오려는 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 데이터셋을 삭제하는 방법은 무엇인가요?", "answer": "데이터셋을 삭제하려면 `delete` 메서드를 사용합니다. 요청은 다음과 같이 구성됩니다:\n\n```\nDELETE /bigquery/v2/projects/{projectId}/datasets/{datasetId}\n```\n여기서 `{projectId}`는 데이터셋이 포함된 프로젝트의 ID이고, `{datasetId}`는 삭제할 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 작업의 결과를 가져오는 방법은 무엇인가요?", "answer": "특정 작업의 결과를 가져오려면 `getQueryResults` 메서드를 사용합니다. 요청은 다음과 같이 구성됩니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/queries/{jobId}\n```\n여기서 `{projectId}`는 프로젝트의 ID이고, `{jobId}`는 결과를 가져오려는 작업의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 모델을 삭제하는 방법은 무엇인가요?", "answer": "모델을 삭제하려면 `delete` 메서드를 사용합니다. 요청은 다음과 같이 구성됩니다:\n\n```\nDELETE /bigquery/v2/projects/{projectId}/datasets/{datasetId}/models/{modelId}\n```\n여기서 `{projectId}`는 모델이 포함된 프로젝트의 ID, `{datasetId}`는 모델이 포함된 데이터셋의 ID, `{modelId}`는 삭제할 모델의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 작업의 정보를 가져오는 방법은 무엇인가요?", "answer": "특정 작업의 정보를 가져오려면 다음의 GET 요청을 사용합니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/jobs/{jobId}\n```\n여기서 `{projectId}`는 프로젝트 ID이고, `{jobId}`는 작업 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 쿼리 작업의 결과를 가져오는 방법은 무엇인가요?", "answer": "쿼리 작업의 결과를 가져오려면 다음의 GET 요청을 사용합니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/queries/{jobId}\n```\n여기서 `{projectId}`는 프로젝트 ID이고, `{jobId}`는 쿼리 작업 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 새로운 작업을 시작하는 방법은 무엇인가요?", "answer": "새로운 작업을 시작하려면 다음의 POST 요청을 사용합니다:\n\n```\nPOST /bigquery/v2/projects/{projectId}/jobs\n```\n여기서 `{projectId}`는 프로젝트 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 데이터셋의 모든 모델을 나열하는 방법은 무엇인가요?", "answer": "특정 데이터셋의 모든 모델을 나열하려면 다음의 GET 요청을 사용합니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/datasets/{datasetId}/models\n```\n여기서 `{projectId}`는 프로젝트 ID이고, `{datasetId}`는 데이터셋 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 루틴의 정보를 가져오는 방법은 무엇인가요?", "answer": "특정 루틴의 정보를 가져오려면 다음의 GET 요청을 사용합니다:\n\n```\nGET /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}\n```\n여기서 `{projectId}`는 프로젝트 ID, `{datasetId}`는 데이터셋 ID, `{routineId}`는 루틴 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 데이터셋에 새로운 루틴을 생성하는 방법은 무엇인가요?", "answer": "새로운 루틴을 생성하려면 다음의 REST API를 사용합니다: POST /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 데이터셋의 모든 루틴을 나열하는 방법은 무엇인가요?", "answer": "특정 데이터셋의 모든 루틴을 나열하려면 다음의 REST API를 사용합니다: GET /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 루틴의 정보를 업데이트하는 방법은 무엇인가요?", "answer": "특정 루틴의 정보를 업데이트하려면 다음의 REST API를 사용합니다: PUT /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 테이블의 모든 행 접근 정책을 나열하는 방법은 무엇인가요?", "answer": "특정 테이블의 모든 행 접근 정책을 나열하려면 다음의 REST API를 사용합니다: GET /bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/rowAccessPolicies", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 특정 테이블의 접근 제어 정책을 가져오는 방법은 무엇인가요?", "answer": "특정 테이블의 접근 제어 정책을 가져오려면 다음의 REST API를 사용합니다: POST /bigquery/v2/{resource=projects/*/datasets/*/tables/*}:getIamPolicy", "source": ["https://cloud.google.com/bigquery/docs/reference/rest"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest.txt"}
{"question": "BigQuery에서 쿼리의 기본 프로젝트를 설정하려면 어떤 connection property를 사용해야 하나요?", "answer": "쿼리의 기본 프로젝트를 설정하려면 connection property인 dataset_project_id를 사용해야 합니다. 이 속성은 쿼리에서 사용되는 데이터셋의 기본 프로젝트를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ConnectionProperty"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ConnectionProperty.txt"}
{"question": "쿼리의 기본 시간대를 설정하는 방법은 무엇인가요?", "answer": "쿼리의 기본 시간대를 설정하려면 connection property인 time_zone을 사용해야 합니다. 이 속성은 쿼리를 실행할 때 사용되는 기본 시간대를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ConnectionProperty"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ConnectionProperty.txt"}
{"question": "쿼리와 세션을 연결하기 위해 어떤 connection property를 사용하나요?", "answer": "쿼리와 세션을 연결하기 위해 connection property인 session_id를 사용합니다. 이 속성은 특정 세션과 쿼리를 연관시킵니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ConnectionProperty"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ConnectionProperty.txt"}
{"question": "쿼리에 레이블을 지정하려면 어떤 connection property를 사용해야 하나요?", "answer": "쿼리에 레이블을 지정하려면 connection property인 query_label을 사용해야 합니다. 이 속성을 설정하면 스크립트나 세션 내의 모든 후속 쿼리에 해당 레이블이 적용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ConnectionProperty"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ConnectionProperty.txt"}
{"question": "지속적인 쿼리를 실행할 때 사용할 서비스 계정을 지정하려면 어떤 connection property를 사용하나요?", "answer": "지속적인 쿼리를 실행할 때 사용할 서비스 계정을 지정하려면 connection property인 service_account를 사용해야 합니다. 이 속성을 설정하면 쿼리 작업이 Google Cloud 리소스에 접근하기 위해 해당 서비스 계정을 사용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ConnectionProperty"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ConnectionProperty.txt"}
{"question": "BigQuery에서 타임스탬프를 int64 형식으로 출력하려면 어떤 옵션을 설정해야 하나요?", "answer": "타임스탬프를 usec int64 형식으로 출력하려면 `useInt64Timestamp` 필드를 `true`로 설정해야 합니다. 기본값은 `false`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DataFormatOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DataFormatOptions.txt"}
{"question": "DataFormatOptions의 JSON 표현은 어떻게 되나요?", "answer": "DataFormatOptions의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"useInt64Timestamp\": boolean\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DataFormatOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DataFormatOptions.txt"}
{"question": "useInt64Timestamp 필드는 어떤 데이터 타입을 가지나요?", "answer": "useInt64Timestamp 필드는 boolean 타입입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DataFormatOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DataFormatOptions.txt"}
{"question": "useInt64Timestamp 필드를 설정하지 않으면 어떤 값이 사용되나요?", "answer": "useInt64Timestamp 필드를 설정하지 않으면 기본값인 `false`가 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DataFormatOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DataFormatOptions.txt"}
{"question": "DataFormatOptions에서 사용할 수 있는 필드는 무엇이 있나요?", "answer": "DataFormatOptions에서 사용할 수 있는 필드는 `useInt64Timestamp` 하나입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DataFormatOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DataFormatOptions.txt"}
{"question": "DatasetAccessEntry의 JSON 표현은 어떻게 되나요?", "answer": "DatasetAccessEntry의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"dataset\": {\n    object (DatasetReference)\n  },\n  \"targetTypes\": [\n    enum (TargetType [https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType])\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DatasetAccessEntry"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DatasetAccessEntry.txt"}
{"question": "DatasetAccessEntry의 dataset 필드는 어떤 역할을 하나요?", "answer": "dataset 필드는 이 항목이 적용되는 데이터셋을 나타냅니다. 데이터셋은 object (DatasetReference) 형식입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DatasetAccessEntry"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DatasetAccessEntry.txt"}
{"question": "targetTypes 필드는 무엇을 나타내며, 현재 어떤 리소스가 지원되나요?", "answer": "targetTypes 필드는 이 항목이 적용되는 데이터셋 내의 리소스를 나타냅니다. 현재는 오직 views만 지원되며, 향후 추가적인 target types가 추가될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DatasetAccessEntry"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DatasetAccessEntry.txt"}
{"question": "DatasetAccessEntry를 사용하여 리소스에 대한 읽기 권한을 부여하는 방법은 무엇인가요?", "answer": "DatasetAccessEntry는 특정 데이터셋 내의 특정 유형의 모든 리소스에 대해 읽기 권한을 부여합니다. 이 데이터셋에 대한 업데이트는 참조된 리소스에 대한 읽기 권한과 권한 부여 데이터셋에 대한 쓰기 권한이 필요합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DatasetAccessEntry"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DatasetAccessEntry.txt"}
{"question": "DatasetAccessEntry의 targetTypes에 추가될 수 있는 리소스 유형은 무엇인가요?", "answer": "현재 targetTypes에는 views만 지원되지만, 향후 추가적인 리소스 유형이 추가될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DatasetAccessEntry"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DatasetAccessEntry.txt"}
{"question": "BigQuery 데이터셋의 기본 테이블 만료 시간을 설정하는 방법은 무엇인가요?", "answer": "기본 테이블 만료 시간은 `defaultTableExpirationMs` 필드를 사용하여 설정할 수 있습니다. 이 필드는 밀리초 단위로 기본 테이블의 수명을 정의하며, 최소 값은 3600000 밀리초(1시간)입니다. 이 속성을 설정하면 새로 생성된 모든 테이블은 생성 시간에 이 값을 더한 `expirationTime` 속성을 가지게 됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋에 대한 접근 권한을 설정하는 방법은 무엇인가요?", "answer": "데이터셋에 대한 접근 권한은 `access` 배열을 사용하여 설정할 수 있습니다. 이 배열에는 사용자, 그룹, 도메인 등에 대한 접근 권한을 정의하는 객체들이 포함됩니다. 예를 들어, 특정 사용자의 이메일을 `access[].userByEmail` 필드에 지정하고, 해당 사용자에게 부여할 역할을 `access[].role` 필드에 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 설명을 추가하는 방법은 무엇인가요?", "answer": "데이터셋의 설명은 `description` 필드를 사용하여 추가할 수 있습니다. 이 필드는 사용자 친화적인 설명을 제공하는 선택적 필드입니다. 데이터셋을 생성하거나 업데이트할 때 이 필드를 포함하여 설명을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 생성 시간을 확인하는 방법은 무엇인가요?", "answer": "데이터셋의 생성 시간은 `creationTime` 필드를 통해 확인할 수 있습니다. 이 필드는 데이터셋이 생성된 시간을 나타내며, 출력 전용 필드입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 ID는 어떻게 구성되나요?", "answer": "데이터셋의 ID는 `id` 필드를 통해 확인할 수 있으며, 형식은 `projectId:datasetId`입니다. 이 필드는 데이터셋의 고유한 이름을 나타내며, 데이터셋을 생성할 때는 이 필드를 비워두고 대신 `datasetId` 필드를 지정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 테이블 만료 시간을 제거하는 방법은 무엇인가요?", "answer": "기존의 기본 만료 시간을 제거하려면 PATCH 요청을 사용하여 기본 만료 시간을 0으로 설정하면 됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 파티션 만료 시간을 설정하는 방법은 무엇인가요?", "answer": "새로운 시간 파티셔닝 테이블을 생성할 때, 데이터셋의 기본 파티션 만료 시간(defaultPartitionExpirationMs)을 설정하면 됩니다. 이 값은 새 테이블의 TimePartitioning.expirationMs 속성으로 전파됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋에 레이블을 추가하는 방법은 무엇인가요?", "answer": "데이터셋을 삽입하거나 업데이트할 때 레이블(labels) 속성을 설정하여 레이블을 추가할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 생성 시간을 확인하는 방법은 무엇인가요?", "answer": "데이터셋의 생성 시간은 creationTime 속성으로 확인할 수 있으며, 이는 epoch 이후의 밀리초로 표시됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 마지막 수정 시간을 확인하는 방법은 무엇인가요?", "answer": "데이터셋의 마지막 수정 시간은 lastModifiedTime 속성으로 확인할 수 있으며, 이는 epoch 이후의 밀리초로 표시됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 암호화 구성을 설정하는 방법은 무엇인가요?", "answer": "기본 암호화 구성(defaultEncryptionConfiguration)을 설정하려면, 데이터셋 생성 시 암호화 키를 지정해야 합니다. 이 속성이 설정되면, 데이터셋 내에서 새로 생성된 모든 테이블의 암호화 키는 이 값으로 설정됩니다. 테이블 생성 요청이나 쿼리가 명시적으로 키를 재정의하지 않는 한, 기본 암호화 키가 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 위치를 설정하는 방법은 무엇인가요?", "answer": "데이터셋의 위치(location)는 데이터셋을 생성할 때 지정해야 합니다. 지원되는 위치에 대한 자세한 내용은 [여기](https://cloud.google.com/bigquery/docs/locations)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 반올림 모드를 설정하는 방법은 무엇인가요?", "answer": "기본 반올림 모드(defaultRoundingMode)를 설정하려면, 데이터셋 생성 시 이 필드를 지정해야 합니다. 이 필드는 새로 생성된 테이블이 데이터셋의 기본 반올림 모드를 상속받도록 합니다. 기존 테이블에는 영향을 미치지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 최대 시간 여행 시간을 설정하는 방법은 무엇인가요?", "answer": "최대 시간 여행 시간(maxTimeTravelHours)을 설정하려면, 데이터셋 생성 시 이 필드를 지정해야 합니다. 값은 48시간에서 168시간(2일에서 7일) 사이여야 하며, 이 필드가 설정되지 않으면 기본값은 168시간입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 태그를 설정하는 방법은 무엇인가요?", "answer": "데이터셋에 태그(resourceTags)를 추가하려면, 데이터셋 생성 시 이 필드를 사용하여 태그를 설정해야 합니다. 태그 키는 전역적으로 고유해야 하며, 예를 들어 '123456789012/environment' 형식이어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 정렬 규칙을 설정하는 방법은 무엇인가요?", "answer": "기본 정렬 규칙(defaultCollation)을 설정하려면, 데이터셋을 생성할 때 해당 필드를 지정해야 합니다. 이 필드는 이후 생성되는 테이블에 적용되며, 명시적으로 정렬 규칙이 지정되지 않은 문자열 필드에 적용됩니다. 지원되는 값은 다음과 같습니다: 'und:ci' (정의되지 않은 로케일, 대소문자 구분 없음), '' (빈 문자열, 대소문자 구분 있음).", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 기본 반올림 모드를 설정하는 방법은 무엇인가요?", "answer": "기본 반올림 모드(defaultRoundingMode)를 설정하려면, 데이터셋을 생성할 때 해당 필드를 지정해야 합니다. 이 필드는 이후 생성되는 테이블에 적용되며, 테이블 생성 시 이 필드가 지정되면 테이블은 데이터셋의 기본 반올림 모드를 상속받습니다. 기존 테이블에는 영향을 미치지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 최대 시간 여행 시간을 설정하는 방법은 무엇인가요?", "answer": "최대 시간 여행 시간(maxTimeTravelHours)을 설정하려면, 데이터셋을 생성할 때 해당 필드를 지정해야 합니다. 이 값은 48시간에서 168시간(2일에서 7일) 사이의 값을 가질 수 있으며, 설정하지 않을 경우 기본값은 168시간입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋에 대한 태그를 설정하는 방법은 무엇인가요?", "answer": "데이터셋에 태그(resourceTags)를 추가하려면, 데이터셋을 생성할 때 해당 필드를 사용하여 태그를 지정해야 합니다. 태그 키는 전역적으로 고유해야 하며, 예를 들어 '123456789012/environment' 형식이어야 합니다. 태그 값은 짧은 이름이어야 하며, 예를 들어 'Production'과 같은 형식이어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery 데이터셋의 외부 데이터셋 참조를 설정하는 방법은 무엇인가요?", "answer": "외부 데이터셋 참조(externalDatasetReference)를 설정하려면, 데이터셋을 생성할 때 해당 필드를 사용하여 읽기 전용 외부 데이터셋을 정의해야 합니다. 이 필드는 데이터셋 유형이 EXTERNAL일 때 채워집니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets.txt"}
{"question": "BigQuery에서 데이터셋을 삭제할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "데이터셋을 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}\n```\n여기서 `{projectId}`는 삭제할 데이터셋이 포함된 프로젝트의 ID이고, `{datasetId}`는 삭제할 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_delete.txt"}
{"question": "데이터셋을 삭제하기 전에 어떤 조건을 충족해야 하나요?", "answer": "데이터셋을 삭제하기 전에 해당 데이터셋의 모든 테이블을 삭제해야 합니다. 이는 수동으로 삭제하거나 `deleteContents` 파라미터를 사용하여 삭제할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_delete.txt"}
{"question": "데이터셋 삭제 요청 시 `deleteContents` 파라미터의 기본값은 무엇인가요?", "answer": "`deleteContents` 파라미터의 기본값은 `False`입니다. 이 값이 `False`일 경우, 데이터셋에 테이블이 존재하면 요청이 실패합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_delete.txt"}
{"question": "데이터셋 삭제 요청의 응답 본문은 어떻게 되나요?", "answer": "데이터셋 삭제 요청이 성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_delete.txt"}
{"question": "데이터셋 삭제를 위한 권한은 어떤 OAuth 스코프가 필요한가요?", "answer": "데이터셋 삭제를 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_delete.txt"}
{"question": "BigQuery에서 특정 데이터셋을 가져오기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "특정 데이터셋을 가져오기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}\n```\n여기서 `{projectId}`는 요청하는 데이터셋의 프로젝트 ID이고, `{datasetId}`는 요청하는 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_get.txt"}
{"question": "datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?", "answer": "datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 `accessPolicyVersion`입니다. 이 파라미터는 선택 사항이며, 접근 정책 스키마의 버전을 가져오는 데 사용됩니다. 유효한 값은 0, 1, 3입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_get.txt"}
{"question": "datasets.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "datasets.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_get.txt"}
{"question": "datasets.get 메서드를 호출하기 위해 필요한 OAuth 스코프는 무엇인가요?", "answer": "datasets.get 메서드를 호출하기 위해 필요한 OAuth 스코프는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_get.txt"}
{"question": "accessPolicyVersion 파라미터가 0 또는 1로 설정된 경우 어떤 결과가 발생하나요?", "answer": "accessPolicyVersion 파라미터가 0 또는 1로 설정된 경우, 조건부 역할 바인딩이 있는 데이터셋에 대해 요청할 경우, 접근 항목에 조건이 있는 경우 역할 문자열에 'withcond' 문자열과 해시 값이 추가됩니다. 예를 들어:\n\n```\n{ \"access\": [ { \"role\": \"roles/bigquery.dataViewer_with_conditionalbinding_7a34awqsda\", \"userByEmail\": \"user@example.com\", } ] }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_get.txt"}
{"question": "BigQuery에서 새로운 데이터셋을 생성하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "새로운 데이터셋을 생성하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets\n```\n여기서 `{projectId}`는 새 데이터셋이 생성될 프로젝트의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_insert.txt"}
{"question": "데이터셋 생성 요청 시 필수로 포함해야 하는 파라미터는 무엇인가요?", "answer": "데이터셋 생성 요청 시 필수로 포함해야 하는 파라미터는 `projectId`입니다. 이는 새 데이터셋이 생성될 프로젝트의 ID를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_insert.txt"}
{"question": "데이터셋 생성 시 선택적으로 사용할 수 있는 `accessPolicyVersion` 파라미터의 유효한 값은 무엇인가요?", "answer": "`accessPolicyVersion` 파라미터의 유효한 값은 0, 1, 3입니다. 요청에서 유효하지 않은 값을 지정하면 요청이 거부됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_insert.txt"}
{"question": "조건부 역할 바인딩이 있는 데이터셋을 생성할 때 `accessPolicyVersion`은 어떻게 설정해야 하나요?", "answer": "조건부 역할 바인딩이 있는 데이터셋을 생성할 때는 `accessPolicyVersion`을 반드시 3으로 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_insert.txt"}
{"question": "데이터셋 생성 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "데이터셋 생성 요청이 성공적으로 처리되면 응답 본문에는 새로 생성된 데이터셋의 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_insert.txt"}
{"question": "BigQuery에서 특정 프로젝트의 데이터셋을 나열하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 프로젝트의 데이터셋을 나열하기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_list.txt"}
{"question": "datasets.list 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?", "answer": "datasets.list 메서드에서 사용할 수 있는 쿼리 파라미터는 다음과 같습니다:\n- `maxResults`: 한 페이지에서 반환할 최대 결과 수.\n- `pageToken`: 이전 호출에서 반환된 페이지 토큰으로, 다음 결과 페이지를 요청할 때 사용.\n- `all`: 숨겨진 데이터셋을 포함하여 모든 데이터셋을 나열할지 여부.\n- `filter`: 레이블로 요청 결과를 필터링하는 표현식.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_list.txt"}
{"question": "datasets.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "datasets.list 메서드의 응답 본문 구조는 다음과 같습니다:\n\n```\n{\n  \"kind\": string,\n  \"etag\": string,\n  \"nextPageToken\": string,\n  \"datasets\": [\n    {\n      \"kind\": string,\n      \"id\": string,\n      \"datasetReference\": {\n        object (DatasetReference)\n      },\n      \"labels\": {\n        string: string,\n        ...\n      },\n      \"friendlyName\": string,\n      \"location\": string,\n      \"externalDatasetReference\": {\n        object (ExternalDatasetReference)\n      }\n    }\n  ],\n  \"unreachable\": [\n    string\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_list.txt"}
{"question": "datasets.list 메서드를 호출할 때 필요한 권한 범위는 무엇인가요?", "answer": "datasets.list 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n- `https://www.googleapis.com/auth/bigquery.readonly`\n- `https://www.googleapis.com/auth/cloud-platform.read-only`", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_list.txt"}
{"question": "datasets.list 메서드의 응답에서 'unreachable' 필드는 무엇을 의미하나요?", "answer": "'unreachable' 필드는 접근할 수 없는 위치의 목록을 나타냅니다. 예를 들어, 다음과 같은 값이 포함될 수 있습니다: \"europe-west5\".", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_list.txt"}
{"question": "BigQuery에서 데이터셋을 업데이트할 때 PATCH 메서드(datasets.patch)를 사용하는 이유는 무엇인가요?", "answer": "PATCH 메서드(datasets.patch)는 제출된 데이터셋 리소스에서 제공된 필드만 교체하기 때문에, 전체 데이터셋 리소스를 교체하는 update 메서드와는 다릅니다. 이 메서드는 RFC5789 패치 구문을 지원합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_patch.txt"}
{"question": "PATCH 요청을 보낼 때 필요한 경로 매개변수는 무엇인가요?", "answer": "PATCH 요청을 보낼 때는 두 개의 경로 매개변수가 필요합니다: projectId(프로젝트 ID)와 datasetId(데이터셋 ID)입니다. 이 두 매개변수는 업데이트할 데이터셋을 지정하는 데 필수적입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_patch.txt"}
{"question": "accessPolicyVersion 쿼리 매개변수의 유효한 값은 무엇인가요?", "answer": "accessPolicyVersion 쿼리 매개변수의 유효한 값은 0, 1, 3입니다. 잘못된 값을 지정하면 요청이 거부됩니다. 이 필드는 요청에 제공된 접근 정책 스키마의 버전을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_patch.txt"}
{"question": "조건부 역할 바인딩이 있는 데이터셋의 경우 accessPolicyVersion을 어떻게 설정해야 하나요?", "answer": "조건부 역할 바인딩이 있는 데이터셋의 경우, accessPolicyVersion은 반드시 3으로 설정해야 합니다. 예를 들어, 조건이 있는 새로운 접근 정책 항목을 추가하거나 조건이 있는 접근 정책 항목을 제거하는 작업을 수행할 때 이 버전을 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_patch.txt"}
{"question": "PATCH 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "PATCH 요청이 성공적으로 처리되면 응답 본문에는 Dataset 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_patch.txt"}
{"question": "BigQuery에서 삭제된 데이터셋을 복구하는 방법은 무엇인가요?", "answer": "삭제된 데이터셋을 복구하려면 `datasets.undelete` 메서드를 사용합니다. 이 메서드는 데이터셋 ID(datasetId)를 기반으로 시간 여행(time travel) 창 내에서 데이터셋을 복구합니다. 만약 특정 시간이 지정되면, 해당 시간에 삭제된 데이터셋 버전이 복구되며, 그렇지 않으면 마지막으로 활성화된 버전이 복구됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/undelete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_undelete.txt"}
{"question": "데이터셋 복구 요청을 위한 HTTP 요청 형식은 어떻게 되나요?", "answer": "데이터셋 복구 요청은 다음과 같은 HTTP POST 요청 형식을 사용합니다:\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}:undelete\n```\n여기서 `{projectId}`는 복구할 데이터셋이 포함된 프로젝트의 ID이며, `{datasetId}`는 삭제된 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/undelete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_undelete.txt"}
{"question": "데이터셋 복구 요청 시 필요한 파라미터는 무엇인가요?", "answer": "데이터셋 복구 요청 시 필요한 파라미터는 다음과 같습니다:\n- `projectId`: 복구할 데이터셋이 포함된 프로젝트의 ID (필수)\n- `datasetId`: 삭제된 데이터셋의 ID (필수)\n요청 본문은 비어 있어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/undelete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_undelete.txt"}
{"question": "데이터셋 복구를 위한 인증 범위는 무엇인가요?", "answer": "데이터셋 복구를 위해서는 다음 중 하나의 OAuth 인증 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/undelete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_undelete.txt"}
{"question": "데이터셋 복구 요청의 응답 본문은 어떤 형식을 가지나요?", "answer": "데이터셋 복구 요청이 성공하면 응답 본문에는 `Dataset` 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/undelete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_undelete.txt"}
{"question": "BigQuery에서 데이터셋을 업데이트할 때 사용하는 HTTP 요청 방법은 무엇인가요?", "answer": "데이터셋을 업데이트할 때는 다음과 같은 HTTP 요청을 사용합니다:\n\n```\nPUT https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}\n```\n여기서 `{projectId}`는 업데이트할 데이터셋의 프로젝트 ID이고, `{datasetId}`는 업데이트할 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_update.txt"}
{"question": "datasets.update 메서드에서 accessPolicyVersion 파라미터의 유효한 값은 무엇인가요?", "answer": "accessPolicyVersion 파라미터의 유효한 값은 0, 1, 3입니다. 요청에서 유효하지 않은 값을 지정하면 요청이 거부됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_update.txt"}
{"question": "datasets.update 메서드의 요청 본문에는 어떤 정보가 포함되어야 하나요?", "answer": "요청 본문에는 Dataset의 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_update.txt"}
{"question": "datasets.update 메서드를 호출하기 위해 필요한 OAuth 스코프는 무엇인가요?", "answer": "datasets.update 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_update.txt"}
{"question": "datasets.update 메서드의 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "요청이 성공적으로 처리되면 응답 본문에는 Dataset의 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_datasets_update.txt"}
{"question": "DML 통계(DmlStats)에서 'insertedRowCount' 필드는 어떤 정보를 제공하나요?", "answer": "'insertedRowCount' 필드(string)는 DML INSERT 및 MERGE 문에 의해 삽입된 행(row)의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DmlStats"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DmlStats.txt"}
{"question": "DML 통계(DmlStats)에서 'deletedRowCount' 필드는 어떤 경우에 사용되나요?", "answer": "'deletedRowCount' 필드(string)는 DML DELETE, MERGE 및 TRUNCATE 문에 의해 삭제된 행(row)의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DmlStats"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DmlStats.txt"}
{"question": "DML 통계(DmlStats)에서 'updatedRowCount' 필드는 어떤 정보를 포함하나요?", "answer": "'updatedRowCount' 필드(string)는 DML UPDATE 및 MERGE 문에 의해 업데이트된 행(row)의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DmlStats"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DmlStats.txt"}
{"question": "DML 통계(DmlStats)의 JSON 표현은 어떻게 구성되나요?", "answer": "DML 통계(DmlStats)의 JSON 표현은 다음과 같이 구성됩니다:\n```\n{\n  \"insertedRowCount\": string,\n  \"deletedRowCount\": string,\n  \"updatedRowCount\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DmlStats"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DmlStats.txt"}
{"question": "DML 통계(DmlStats)에서 각 필드의 데이터 타입은 무엇인가요?", "answer": "'insertedRowCount', 'deletedRowCount', 'updatedRowCount' 필드는 모두 string (Int64Value format) 타입입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/DmlStats"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_DmlStats.txt"}
{"question": "Cloud KMS 암호화 설정을 위한 EncryptionConfiguration의 JSON 표현은 어떻게 되나요?", "answer": "Cloud KMS 암호화 설정을 위한 EncryptionConfiguration의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"kmsKeyName\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/EncryptionConfiguration"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_EncryptionConfiguration.txt"}
{"question": "kmsKeyName 필드는 어떤 용도로 사용되며, 어떤 형식을 가져야 하나요?", "answer": "kmsKeyName 필드는 Cloud KMS 암호화 키를 설명하며, 문자열(string) 형식을 가져야 합니다. 이 키는 BigQuery 테이블을 보호하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/EncryptionConfiguration"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_EncryptionConfiguration.txt"}
{"question": "BigQuery 서비스 계정이 Cloud KMS 암호화 키에 접근하기 위해 필요한 권한은 무엇인가요?", "answer": "BigQuery 서비스 계정은 프로젝트와 연결된 Cloud KMS 암호화 키에 접근할 수 있는 권한이 필요합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/EncryptionConfiguration"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_EncryptionConfiguration.txt"}
{"question": "EncryptionConfiguration을 설정할 때 필수 필드는 무엇인가요?", "answer": "EncryptionConfiguration에서 필수 필드는 없습니다. kmsKeyName 필드는 선택적(optional)입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/EncryptionConfiguration"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_EncryptionConfiguration.txt"}
{"question": "Cloud KMS 암호화 키를 사용하여 BigQuery 테이블을 보호하는 방법은 무엇인가요?", "answer": "Cloud KMS 암호화 키를 사용하여 BigQuery 테이블을 보호하려면, EncryptionConfiguration을 설정하고 kmsKeyName 필드에 해당 키의 이름을 지정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/EncryptionConfiguration"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_EncryptionConfiguration.txt"}
{"question": "tables.getIamPolicy 메서드를 사용할 때 GetPolicyOptions의 requestedPolicyVersion 필드는 어떤 역할을 하나요?", "answer": "requestedPolicyVersion 필드(integer)는 정책을 포맷하는 데 사용될 최대 정책 버전을 지정합니다. 유효한 값은 0, 1, 3이며, 잘못된 값을 지정하면 요청이 거부됩니다. 조건부 역할 바인딩이 있는 정책을 요청할 경우 반드시 버전 3을 지정해야 하며, 조건부 역할 바인딩이 없는 정책은 유효한 값을 지정하거나 필드를 설정하지 않을 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/GetPolicyOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_GetPolicyOptions.txt"}
{"question": "GetPolicyOptions의 requestedPolicyVersion 필드에 대해 어떤 유효한 값이 있나요?", "answer": "requestedPolicyVersion 필드에 대해 유효한 값은 0, 1, 3입니다. 요청에서 잘못된 값을 지정하면 요청이 거부됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/GetPolicyOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_GetPolicyOptions.txt"}
{"question": "정책 응답에서 사용되는 정책 버전은 요청한 requestedPolicyVersion과 항상 일치하나요?", "answer": "아니요, 정책 응답에서 사용되는 정책 버전은 요청한 requestedPolicyVersion과 일치하지 않을 수 있습니다. 예를 들어, 버전 3을 지정했지만 정책에 조건부 역할 바인딩이 없으면 응답은 버전 1을 사용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/GetPolicyOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_GetPolicyOptions.txt"}
{"question": "조건부 역할 바인딩이 있는 IAM 정책을 요청할 때 어떤 버전을 지정해야 하나요?", "answer": "조건부 역할 바인딩이 있는 IAM 정책을 요청할 때는 반드시 requestedPolicyVersion 필드에 버전 3을 지정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/GetPolicyOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_GetPolicyOptions.txt"}
{"question": "GetPolicyOptions의 JSON 표현은 어떻게 되나요?", "answer": "GetPolicyOptions의 JSON 표현은 다음과 같습니다:\n```\n{\n  \"requestedPolicyVersion\": integer\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/GetPolicyOptions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_GetPolicyOptions.txt"}
{"question": "BigQuery에서 작업(Job)의 상태를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업(Job)의 상태를 확인하려면 'status' 필드(object (JobStatus))를 사용해야 합니다. 이 필드는 비동기 작업을 폴링할 때 작업이 완료되었는지 확인하는 데 유용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 작업(Job)에서 타임아웃을 설정하려면 어떤 필드를 사용하나요?", "answer": "'jobTimeoutMs' 필드(string (Int64Value format))를 사용하여 작업의 타임아웃을 밀리초 단위로 설정할 수 있습니다. 이 시간 제한이 초과되면 BigQuery는 긴 작업을 중지하려고 시도하지만, 항상 성공하지는 않을 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업을 구성할 때 필수로 설정해야 하는 필드는 무엇인가요?", "answer": "'query' 필드(string)를 필수로 설정해야 합니다. 이 필드는 실행할 SQL 쿼리 텍스트를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 작업(Job)에서 레이블을 설정하는 방법은 무엇인가요?", "answer": "'labels' 필드(map (key: string, value: string))를 사용하여 작업에 레이블을 설정할 수 있습니다. 레이블 키와 값은 최대 63자까지 가능하며, 소문자, 숫자, 언더스코어 및 대시만 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 결과를 저장할 테이블을 지정하려면 어떤 필드를 사용해야 하나요?", "answer": "'destinationTable' 필드(object (TableReference))를 사용하여 쿼리 결과를 저장할 테이블을 지정할 수 있습니다. 이 필드는 큰 결과를 생성하는 쿼리의 경우 필수로 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 기본 데이터셋을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 기본 데이터셋을 설정하려면 `defaultDataset` 필드를 사용해야 합니다. 이 필드는 쿼리에서 비자격 테이블 이름에 사용할 기본 데이터셋을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리 작업에서 결과를 저장할 테이블을 지정할 때 어떤 필드를 사용해야 하나요?", "answer": "`destinationTable` 필드를 사용하여 쿼리 결과를 저장할 테이블을 지정할 수 있습니다. 이 필드는 큰 결과가 최대 응답 크기를 초과할 경우 반드시 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리 작업에서 테이블 생성 허용 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "`createDisposition` 필드를 사용하여 테이블 생성 허용 여부를 설정할 수 있습니다. 지원되는 값으로는 `CREATE_IF_NEEDED`와 `CREATE_NEVER`가 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리 작업에서 결과가 이미 존재하는 테이블에 대한 동작을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "`writeDisposition` 필드를 사용하여 결과가 이미 존재하는 테이블에 대한 동작을 설정할 수 있습니다. 지원되는 값으로는 `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY` 등이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리 작업에서 쿼리 캐시를 사용할지 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "`useQueryCache` 필드를 사용하여 쿼리 캐시를 사용할지 여부를 설정할 수 있습니다. 기본값은 true이며, 쿼리 캐시는 쿼리에 지정된 목적 테이블이 없을 때만 사용 가능합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 외부 테이블 정의를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "외부 테이블 정의를 설정하려면 'tableDefinitions' 필드를 사용해야 합니다. 이 필드는 JSON 맵을 사용하여 구성되며, 문자열 키는 테이블 식별자를 나타내고 값은 해당 외부 데이터 구성 객체를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 작업(Job)에서 테이블 생성 허용 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "'createDisposition' 필드를 사용하여 테이블 생성 허용 여부를 설정할 수 있습니다. 지원되는 값은 'CREATE_IF_NEEDED'와 'CREATE_NEVER'입니다. 기본값은 'CREATE_IF_NEEDED'입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 작업(Job)에서 결과 테이블이 이미 존재할 경우의 동작을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "'writeDisposition' 필드를 사용하여 결과 테이블이 이미 존재할 경우의 동작을 설정할 수 있습니다. 지원되는 값은 'WRITE_TRUNCATE', 'WRITE_TRUNCATE_DATA', 'WRITE_APPEND', 'WRITE_EMPTY'입니다. 기본값은 'WRITE_EMPTY'입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 기본 데이터셋을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "'defaultDataset' 필드를 사용하여 기본 데이터셋을 설정할 수 있습니다. 이 설정은 쿼리에서 비자격 테이블 이름을 사용할 때 적용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 쿼리 캐시를 사용할지 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "'useQueryCache' 필드를 사용하여 쿼리 캐시를 사용할지 여부를 설정할 수 있습니다. 기본값은 true입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 최대 청구 바이트 수를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리에서 최대 청구 바이트 수를 설정하려면 `maximumBytesBilled` 필드를 사용해야 합니다. 이 필드는 작업에 대해 청구되는 바이트 수의 한계를 설정하며, 이 한계를 초과하는 쿼리는 실패하게 됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 GoogleSQL을 사용하도록 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery 쿼리에서 GoogleSQL을 사용하도록 설정하려면 `useLegacySql` 필드를 사용해야 합니다. 이 필드를 `false`로 설정하면 쿼리는 GoogleSQL을 사용하게 됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 스키마 업데이트 옵션을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery 쿼리에서 스키마 업데이트 옵션을 설정하려면 `schemaUpdateOptions` 필드를 사용해야 합니다. 이 필드는 쿼리 작업의 부작용으로 대상 테이블의 스키마를 업데이트할 수 있도록 허용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 시간 기반 파티셔닝을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery 쿼리에서 시간 기반 파티셔닝을 설정하려면 `timePartitioning` 필드를 사용해야 합니다. 이 필드는 대상 테이블에 대한 시간 기반 파티셔닝 사양을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery 쿼리에서 클러스터링을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery 쿼리에서 클러스터링을 설정하려면 `clustering` 필드를 사용해야 합니다. 이 필드는 대상 테이블에 대한 클러스터링 사양을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 스크립트 실행 시 각 문(statement)의 타임아웃을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "각 문(statement)의 타임아웃을 설정하려면 `statementTimeoutMs` 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 스크립트 실행 시 각 문(statement)의 바이트 예산을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "각 문(statement)의 바이트 예산을 설정하려면 `statementByteBudget` 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 스크립트의 주요 결과를 결정하는 방법을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "스크립트의 주요 결과를 결정하는 방법을 설정하려면 `keyResultStatement` 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 로드 작업의 소스 URI를 설정할 때 어떤 형식으로 지정해야 하나요?", "answer": "소스 URI는 Google Cloud의 데이터를 가리키는 완전한 URI 형식으로 지정해야 하며, Google Cloud Storage URI의 경우 각 URI는 하나의 '*' 와일드카드 문자를 포함할 수 있고, 이는 '버킷' 이름 뒤에 와야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 로드 작업의 테이블 생성 허용 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 생성 허용 여부를 설정하려면 `createDisposition` 필드를 사용해야 하며, 이 필드는 `CREATE_IF_NEEDED` 또는 `CREATE_NEVER` 값을 가질 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 로드 작업의 소스 URI를 설정할 때 어떤 형식으로 지정해야 하나요?", "answer": "소스 URI(sourceUris[])는 Google Cloud의 데이터에 대한 완전한 URI를 지정해야 합니다. Google Cloud Storage URI의 경우, 각 URI는 하나의 '*' 와일드카드 문자를 포함할 수 있으며, 이는 'bucket' 이름 뒤에 와야 합니다. Google Cloud Bigtable URI의 경우, 정확히 하나의 URI를 지정해야 하며, 이는 Google Cloud Bigtable 테이블에 대한 완전하고 유효한 HTTPS URL이어야 합니다. Google Cloud Datastore 백업의 경우에도 정확히 하나의 URI를 지정해야 하며, '*' 와일드카드 문자는 허용되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 로드 작업의 스키마를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "데이터 로드 작업의 스키마는 schema(object (TableSchema)) 필드를 사용하여 설정할 수 있습니다. 이 필드는 선택 사항이며, 목적지 테이블이 이미 존재하거나 Google Cloud Datastore에서 데이터를 로드하는 경우 생략할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 로드 작업의 결과 테이블이 이미 존재할 경우의 동작을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "결과 테이블이 이미 존재할 경우의 동작은 writeDisposition(string) 필드를 사용하여 설정할 수 있습니다. 지원되는 값으로는 WRITE_TRUNCATE, WRITE_TRUNCATE_DATA, WRITE_APPEND, WRITE_EMPTY가 있으며, 기본값은 WRITE_APPEND입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일의 필드 구분자를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "CSV 파일의 필드 구분자는 fieldDelimiter(string) 필드를 사용하여 설정할 수 있습니다. 기본값은 쉼표(',', U+002C)이며, UTF-8로 인코딩된 파일의 경우 1-127의 싱글 바이트로 표현된 문자만 사용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 첫 번째 N개의 행을 건너뛰려면 어떤 필드를 사용해야 하나요?", "answer": "CSV 파일에서 첫 번째 N개의 행을 건너뛰려면 skipLeadingRows(integer) 필드를 사용해야 합니다. 기본값은 0이며, 이 필드는 파일의 헤더 행을 건너뛰는 데 유용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때, 첫 번째 N개의 행을 건너뛰려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery에서 CSV 파일을 로드할 때 첫 번째 N개의 행을 건너뛰려면 'skipLeadingRows' 필드를 사용해야 합니다. 이 필드는 CSV 파일의 상단에서 BigQuery가 건너뛸 행의 수를 지정합니다. 기본값은 0입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일의 필드 구분자를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery에서 CSV 파일의 필드 구분자를 설정하려면 'fieldDelimiter' 필드를 사용해야 합니다. 기본값은 쉼표(,)입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일의 문자 인코딩을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery에서 CSV 파일의 문자 인코딩을 설정하려면 'encoding' 필드를 사용해야 합니다. 지원되는 값으로는 UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LE가 있습니다. 기본값은 UTF-8입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때, 잘못된 레코드의 최대 수를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery에서 CSV 파일을 로드할 때 잘못된 레코드의 최대 수를 설정하려면 'maxBadRecords' 필드를 사용해야 합니다. 기본값은 0으로, 모든 레코드가 유효해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일의 데이터 섹션을 인용할 때 사용할 값을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "BigQuery에서 CSV 파일의 데이터 섹션을 인용할 때 사용할 값을 설정하려면 'quote' 필드를 사용해야 합니다. 기본값은 큰따옴표('\"')입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때, 줄 바꿈 문자가 포함된 인용된 데이터 섹션을 허용하려면 어떤 필드를 사용해야 하나요?", "answer": "줄 바꿈 문자가 포함된 인용된 데이터 섹션을 허용하려면 'allowQuotedNewlines' 필드를 사용해야 합니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일의 형식을 지정하려면 어떤 필드를 사용해야 하나요?", "answer": "'sourceFormat' 필드를 사용하여 CSV 파일의 형식을 지정할 수 있습니다. CSV 파일의 경우 'CSV'로 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때, 선택적 열이 누락된 행을 허용하려면 어떤 필드를 사용해야 하나요?", "answer": "'allowJaggedRows' 필드를 사용하여 선택적 열이 누락된 행을 허용할 수 있습니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 스키마에 없는 추가 값을 허용하려면 어떤 필드를 사용해야 하나요?", "answer": "'ignoreUnknownValues' 필드를 사용하여 테이블 스키마에 없는 추가 값을 허용할 수 있습니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 소스 형식이 AVRO일 때, 논리적 유형을 BigQuery 데이터 유형으로 해석하려면 어떤 필드를 사용해야 하나요?", "answer": "'useAvroLogicalTypes' 필드를 사용하여 소스 형식이 AVRO일 때 논리적 유형을 BigQuery 데이터 유형으로 해석할 수 있습니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 소스 테이블을 복사할 때 어떤 필드를 사용해야 하나요?", "answer": "소스 테이블을 복사할 때는 `sourceTable` 필드를 사용해야 합니다. 이 필드는 복사할 소스 테이블을 지정하는 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 결과 테이블을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "복사 작업의 결과 테이블을 설정하려면 `destinationTable` 필드를 사용해야 합니다. 이 필드는 복사된 데이터를 저장할 대상 테이블을 지정하는 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 생성 조건을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "복사 작업의 생성 조건을 설정하려면 `createDisposition` 필드를 사용해야 합니다. 이 필드는 테이블이 존재하지 않을 경우 테이블을 생성할지 여부를 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 쓰기 조건을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "복사 작업의 쓰기 조건을 설정하려면 `writeDisposition` 필드를 사용해야 합니다. 이 필드는 복사된 데이터가 기존 테이블에 어떻게 쓰일지를 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 암호화 구성을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "복사 작업의 암호화 구성을 설정하려면 `destinationEncryptionConfiguration` 필드를 사용해야 합니다. 이 필드는 복사된 데이터의 암호화 구성을 지정하는 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 SQL NULL 값을 나타내는 문자열을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "nullMarkers[] 필드를 사용하여 CSV 파일에서 SQL NULL 값을 나타내는 문자열 목록을 설정할 수 있습니다. nullMarker와 nullMarkers는 동시에 설정할 수 없으며, 둘 중 하나만 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DATE 값을 파싱할 때 사용할 날짜 형식을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "dateFormat 필드를 사용하여 DATE 값을 파싱할 때 사용할 날짜 형식을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 TIMESTAMP 값을 파싱할 때 사용할 날짜 형식을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "timestampFormat 필드를 사용하여 TIMESTAMP 값을 파싱할 때 사용할 날짜 형식을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 소스 테이블을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "sourceTable 필드를 사용하여 복사 작업의 소스 테이블을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 생성 조건을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "createDisposition 필드를 사용하여 복사 작업의 생성 조건을 설정할 수 있습니다. 지원되는 값으로는 CREATE_IF_NEEDED와 CREATE_NEVER가 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 복사 작업의 생성 조건을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 복사 작업의 생성 조건을 설정하려면 `createDisposition` 필드를 사용해야 합니다. 이 필드는 새 테이블을 생성할 수 있는지 여부를 지정합니다. 지원되는 값은 다음과 같습니다: `CREATE_IF_NEEDED` (테이블이 존재하지 않으면 BigQuery가 테이블을 생성함), `CREATE_NEVER` (테이블이 이미 존재해야 하며, 존재하지 않을 경우 'notFound' 오류가 반환됨)입니다. 기본값은 `CREATE_IF_NEEDED`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 복사 작업의 쓰기 조건을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 복사 작업의 쓰기 조건을 설정하려면 `writeDisposition` 필드를 사용해야 합니다. 이 필드는 대상 테이블이 이미 존재할 경우 수행할 작업을 지정합니다. 지원되는 값은 다음과 같습니다: `WRITE_TRUNCATE` (테이블이 이미 존재하면 BigQuery가 테이블 데이터를 덮어씀), `WRITE_APPEND` (테이블이 이미 존재하면 데이터를 테이블에 추가함), `WRITE_EMPTY` (테이블이 이미 존재하고 데이터가 포함되어 있으면 'duplicate' 오류가 반환됨)입니다. 기본값은 `WRITE_EMPTY`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 복사 작업의 암호화 구성을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 복사 작업의 암호화 구성을 설정하려면 `destinationEncryptionConfiguration` 필드를 사용해야 합니다. 이 필드는 사용자 정의 암호화 구성을 지정하며, 예를 들어 Cloud KMS 키를 사용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 복사 작업의 만료 시간을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 복사 작업의 만료 시간을 설정하려면 `destinationExpirationTime` 필드를 사용해야 합니다. 이 필드는 만료될 때의 시간을 설정하며, 만료된 테이블은 삭제되고 저장소가 회수됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 테이블 복사 작업의 지원되는 작업 유형을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "테이블 복사 작업의 지원되는 작업 유형을 설정하려면 `operationType` 필드를 사용해야 합니다. 이 필드는 테이블 복사 작업에서 지원되는 다양한 작업 유형을 나타냅니다. 지원되는 값은 `OPERATION_TYPE_UNSPECIFIED`, `COPY`, `SNAPSHOT`, `RESTORE`, `CLONE`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 추출 작업의 결과를 저장할 Google Cloud Storage URI를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "데이터 추출 작업의 결과를 저장할 Google Cloud Storage URI를 설정하려면 `destinationUris[]` 필드를 사용해야 합니다. 이 필드는 추출된 테이블이 작성될 완전한 Google Cloud Storage URI의 목록을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 CSV 형식으로 데이터를 추출할 때 필드 구분자를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "CSV 형식으로 데이터를 추출할 때 필드 구분자를 설정하려면 `fieldDelimiter` 필드를 사용해야 합니다. 이 필드는 추출된 데이터에서 필드 간의 구분자를 정의하며, 기본값은 ','입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 추출 작업의 파일 형식을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "데이터 추출 작업의 파일 형식을 설정하려면 `destinationFormat` 필드를 사용해야 합니다. 이 필드는 가능한 값으로 CSV, NEWLINE_DELIMITED_JSON, PARQUET, AVRO 등을 포함하며, 기본값은 CSV입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 데이터 추출 작업의 압축 형식을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "데이터 추출 작업의 압축 형식을 설정하려면 `compression` 필드를 사용해야 합니다. 이 필드는 DEFLATE, GZIP, NONE, SNAPPY, ZSTD와 같은 압축 형식을 지정할 수 있으며, 기본값은 NONE입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 모델을 추출할 때 하이퍼파라미터 튜닝 모델의 특정 트라이얼을 지정하려면 어떤 필드를 사용해야 하나요?", "answer": "하이퍼파라미터 튜닝 모델의 특정 트라이얼을 지정하려면 `trialId` 필드를 사용해야 합니다. 이 필드는 추출할 트라이얼의 1 기반 ID를 정의하며, 지정하지 않으면 기본 트라이얼이 추출됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 작업의 생성 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업의 생성 시간을 확인하려면 `creationTime` 필드를 사용해야 합니다. 이 필드는 밀리초 단위로 에포크 이후의 생성 시간을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 작업의 시작 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업의 시작 시간을 확인하려면 `startTime` 필드를 사용해야 합니다. 이 필드는 작업이 PENDING 상태에서 RUNNING 또는 DONE 상태로 전환될 때의 시작 시간을 밀리초 단위로 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 작업의 종료 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업의 종료 시간을 확인하려면 `endTime` 필드를 사용해야 합니다. 이 필드는 작업이 DONE 상태일 때의 종료 시간을 밀리초 단위로 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 작업의 총 처리 바이트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업의 총 처리 바이트 수를 확인하려면 `totalBytesProcessed` 필드를 사용해야 합니다. 이 필드는 작업에 대해 처리된 총 바이트 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 작업의 최종 실행 지속 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작업의 최종 실행 지속 시간을 확인하려면 `finalExecutionDurationMs` 필드를 사용해야 합니다. 이 필드는 작업의 최종 시도 실행 지속 시간을 밀리초 단위로 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 실행 계획을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 실행 계획을 확인하려면 'queryPlan' 필드를 사용해야 합니다. 이 필드는 쿼리의 실행 계획을 설명합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 총 처리 바이트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 총 처리 바이트 수를 확인하려면 'totalBytesProcessed' 필드를 사용해야 합니다. 이 필드는 작업에 대해 처리된 총 바이트 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 결과 스키마를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 결과 스키마를 확인하려면 'schema' 필드를 사용해야 합니다. 이 필드는 결과의 스키마를 나타내며, 비유산 SQL 쿼리의 성공적인 드라이런에 대해서만 존재합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 캐시 히트 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 캐시 히트 여부를 확인하려면 'cacheHit' 필드를 사용해야 합니다. 이 필드는 쿼리 결과가 쿼리 캐시에서 가져온 것인지 여부를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DML 문에 의해 영향을 받은 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "DML 문에 의해 영향을 받은 행 수를 확인하려면 'numDmlAffectedRows' 필드를 사용해야 합니다. 이 필드는 INSERT, UPDATE 또는 DELETE 문에 의해 영향을 받은 행 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 실행 계획을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 실행 계획을 확인하려면 'queryPlan' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 총 처리 바이트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 총 처리 바이트 수를 확인하려면 'totalBytesProcessed' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 캐시 히트 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 캐시 히트 여부를 확인하려면 'cacheHit' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DML 문에 의해 영향을 받은 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "DML 문에 의해 영향을 받은 행 수를 확인하려면 'numDmlAffectedRows' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 작업의 결과 스키마를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 작업의 결과 스키마를 확인하려면 'schema' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DML 문에 의해 영향을 받은 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "DML 문에 의해 영향을 받은 행 수를 확인하려면 'AffectedRows' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DML 문에 대한 자세한 통계를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "DML 문에 대한 자세한 통계를 확인하려면 'dmlStats' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 문장의 유형을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 문장의 유형을 확인하려면 'statementType' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 DDL 작업의 대상 테이블을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "DDL 작업의 대상 테이블을 확인하려면 'ddlTargetTable' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 ML 훈련 작업의 통계를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "ML 훈련 작업의 통계를 확인하려면 'mlStatistics' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 고유 ID를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 고유 ID는 'id' 필드에서 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 시작 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'startMs' 필드를 사용하여 쿼리 실행 단계의 시작 시간을 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 평균 대기 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'waitMsAvg' 필드를 사용하여 쿼리 실행 단계의 평균 대기 시간을 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 총 읽기 비율을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'readRatioAvg' 필드를 사용하여 쿼리 실행 단계의 총 읽기 비율을 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'status' 필드를 사용하여 쿼리 실행 단계의 현재 상태를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 평균 대기 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 평균 대기 시간을 확인하려면 'waitMsAvg' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 총 읽기 비율을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 총 읽기 비율을 확인하려면 'readRatioAvg' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 현재 상태를 확인하려면 'status' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 고유 ID를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 고유 ID를 확인하려면 'id' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 시작 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 시작 시간을 확인하려면 'startMs' 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 병렬 입력 세그먼트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 병렬 입력 세그먼트 수는 'parallelInputs' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 완료된 병렬 입력 세그먼트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 완료된 병렬 입력 세그먼트 수는 'completedParallelInputs' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 슬롯 밀리초(slot-milliseconds) 사용량을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 슬롯 밀리초 사용량은 'slotMs' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 실행 단계의 현재 상태는 'status' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 ML 훈련 작업의 최대 반복 횟수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "ML 훈련 작업의 최대 반복 횟수는 'maxIterations' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 EXPORT DATA 문에 의해 생성된 파일 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "EXPORT DATA 문에 의해 생성된 파일 수는 'fileCount' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 EXPORT DATA 문에 의해 생성된 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'rowCount' 필드를 사용하여 EXPORT DATA 문에 의해 생성된 행 수를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 외부 서비스 비용을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'ExternalServiceCost' 필드를 사용하여 외부 서비스 비용을 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BI Engine의 가속 모드를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'biEngineMode' 필드를 사용하여 BI Engine의 가속 모드를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 LOAD 쿼리의 입력 파일 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'inputFiles' 필드를 사용하여 LOAD 쿼리의 입력 파일 수를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BI Engine 가속 모드가 DISABLED인 경우, 어떤 필드에서 가속이 비활성화된 이유를 확인할 수 있나요?", "answer": "BI Engine 가속 모드가 DISABLED인 경우, biEngineReasons 필드에서 가속이 비활성화된 이유를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BI Engine 가속 모드가 PARTIAL인 경우, 어떤 필드에서 가속되지 않은 부분의 이유를 확인할 수 있나요?", "answer": "BI Engine 가속 모드가 PARTIAL인 경우, biEngineReasons 필드에서 가속되지 않은 부분의 이유를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 LOAD 쿼리의 입력 파일 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "LOAD 쿼리의 입력 파일 수를 확인하려면 inputFiles 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 LOAD 쿼리의 처리 중 발생한 잘못된 레코드 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "LOAD 쿼리의 처리 중 발생한 잘못된 레코드 수를 확인하려면 badRecords 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 검색 쿼리의 인덱스 사용 모드를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "검색 쿼리의 인덱스 사용 모드를 확인하려면 indexUsageMode 필드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 검색 쿼리의 인덱스 사용 모드를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "검색 쿼리의 인덱스 사용 모드는 'indexUsageMode' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'indexUnusedReasons' 필드를 사용하여 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 벡터 검색 쿼리의 인덱스 사용 모드를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "벡터 검색 쿼리의 인덱스 사용 모드는 'indexUsageMode' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'indexUnusedReasons' 필드를 사용하여 벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 저장된 열의 사용 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "'storedColumnsUsages' 필드를 사용하여 저장된 열의 사용 여부를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 벡터 검색 쿼리의 인덱스 사용 모드를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "벡터 검색 쿼리의 인덱스 사용 모드는 `indexUsageMode` 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유는 `indexUnusedReasons` 필드를 통해 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 저장된 열의 사용 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "저장된 열의 사용 여부는 `storedColumnsUsages` 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 저장된 열이 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "저장된 열이 사용되지 않은 이유는 `storedColumnsUnusedReasons` 필드를 통해 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 성능 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 성능 통찰력은 `PerformanceInsights` 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 저장된 열이 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "저장된 열이 사용되지 않은 이유를 확인하려면 StoredColumnsUnusedReason 필드를 사용해야 합니다. 이 필드는 사용되지 않은 저장된 열에 대한 이유를 설명합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 성능 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 성능 통찰력을 확인하려면 PerformanceInsights 필드를 사용해야 합니다. 이 필드는 작업에 대한 성능 통찰력을 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 특정 단계의 성능 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "특정 단계의 성능 통찰력을 확인하려면 StagePerformanceStandaloneInsight 필드를 사용해야 합니다. 이 필드는 특정 단계에 대한 독립적인 성능 통찰력을 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 쿼리 단계의 입력 데이터 변경 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "쿼리 단계의 입력 데이터 변경 통찰력을 확인하려면 StagePerformanceChangeInsight 필드를 사용해야 합니다. 이 필드는 이전 실행과 비교한 입력 데이터 변경 통찰력을 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 높은 카디널리티 조인의 세부 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "높은 카디널리티 조인의 세부 정보를 확인하려면 HighCardinalityJoin 필드를 사용해야 합니다. 이 필드는 특정 단계에서 높은 카디널리티 조인에 대한 정보를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 높은 카디널리티 조인(HighCardinalityJoin)의 왼쪽 입력 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "왼쪽 입력 행 수는 'leftRows' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 높은 카디널리티 조인(HighCardinalityJoin)의 오른쪽 입력 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "오른쪽 입력 행 수는 'rightRows' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 높은 카디널리티 조인(HighCardinalityJoin)의 출력 행 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "출력 행 수는 'outputRows' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 파티션 스큐(PartitionSkew)의 소스 단계 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "소스 단계 정보는 'skewSources' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 특정 단계의 성능 통찰력(StagePerformanceChangeInsight)을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "특정 단계의 성능 통찰력은 'stageId' 필드를 사용하여 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 Spark 작업의 Cloud KMS 암호화 키는 어떻게 결정되나요?", "answer": "Spark 작업이 호출자 보안 모드(invoker security mode)를 사용하는 경우, Cloud KMS 암호화 키는 제공된 시스템 변수 @@spark_proc_properties.kms_key_name에서 유추되거나, CMEK 조직 정책이 시행되는 경우 BigQuery 작업의 프로젝트의 기본 키에서 유추됩니다. 그렇지 않은 경우, Cloud KMS 키는 프로시저와 연결된 Spark 연결에서 유추되거나, CMEK 조직 정책이 시행되는 경우 Spark 연결의 프로젝트의 기본 키에서 유추됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "Spark 작업에서 gcsStagingBucket 필드는 어떤 경우에 사용되나요?", "answer": "gcsStagingBucket 필드는 Spark 프로시저가 호출자 보안 모드(invoker security mode)를 사용할 때만 채워집니다. 이 필드는 @@spark_proc_properties.staging_bucket 시스템 변수에서 유추되거나, 그렇지 않은 경우 BigQuery가 작업을 위해 기본 스테이징 버킷을 생성하고 이 필드에 버킷 이름을 반환합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "MaterializedViewStatistics에서 materializedView 필드는 어떤 정보를 포함하나요?", "answer": "materializedView 필드는 쿼리 작업에서 고려된 물리화된 뷰(materialized views)의 배열을 포함합니다. 특정 물리화된 뷰만 사용되며, 많은 물리화된 뷰가 고려되는 경우 목록이 불완전할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "MaterializedView의 chosen 필드는 어떤 의미인가요?", "answer": "chosen 필드는 물리화된 뷰가 쿼리를 위해 선택되었는지를 나타냅니다. 물리화된 뷰가 쿼리의 여러 부분을 재작성하기 위해 선택된 경우, 이 필드는 true로 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "MetadataCacheStatistics에서 tableMetadataCacheUsage 필드는 어떤 정보를 제공하나요?", "answer": "tableMetadataCacheUsage 필드는 쿼리에서 참조된 메타데이터 캐싱이 가능한 테이블에 대한 세부 정보를 제공합니다. 이 필드는 메타데이터 캐싱이 가능한 테이블에 대해서만 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BASE_TABLE_DATA_CHANGE가 발생한 이유는 무엇인가요?", "answer": "BASE_TABLE_DATA_CHANGE View는 하나 이상의 기본 테이블에서 데이터 변경으로 인해 무효화됩니다. maxStaleness 옵션이 설정되지 않은 경우 최근의 모든 변경이 원인이 될 수 있으며, 그렇지 않은 경우에는 스테일니스 창 밖의 변경이 원인이 됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BASE_TABLE_PARTITION_EXPIRATION_CHANGE가 발생하는 경우는 어떤 경우인가요?", "answer": "BASE_TABLE_PARTITION_EXPIRATION_CHANGE View는 기본 테이블의 파티션 만료가 변경되었을 때 무효화됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BASE_TABLE_EXPIRED_PARTITION이 발생하는 이유는 무엇인가요?", "answer": "BASE_TABLE_EXPIRED_PARTITION View는 기본 테이블의 파티션이 만료되었을 때 무효화됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE가 발생하는 경우는 어떤 경우인가요?", "answer": "BASE_TABLE_INCOMPATIBLE_METADATA_CHANGE View는 기본 테이블에서 호환되지 않는 메타데이터 변경이 발생했을 때 무효화됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 MetadataCacheStatistics의 tableMetadataCacheUsage 필드는 어떤 정보를 포함하나요?", "answer": "tableMetadataCacheUsage 필드는 쿼리에서 참조된 메타데이터 캐싱이 가능한 테이블에 대한 세부 정보를 포함합니다. 이 필드는 메타데이터 캐싱이 가능한 테이블에 대해서만 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 로드 작업의 badRecords 필드는 어떤 정보를 제공하나요?", "answer": "badRecords 필드는 로드 작업에서 발견된 나쁜 레코드의 수를 나타냅니다. 만약 작업이 로드 작업 구성에서 허용된 최대 나쁜 레코드 수를 초과하여 실패한 경우, 이 숫자는 입력 데이터에 존재하는 총 나쁜 레코드 수보다 적을 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 추출 작업의 inputBytes 필드는 어떤 정보를 포함하나요?", "answer": "inputBytes 필드는 결과로 추출된 사용자 바이트 수를 나타냅니다. 이는 BigQuery가 청구 목적으로 계산한 바이트 수이며, 원하는 형식으로 추출된 실제 결과 바이트 수와는 관계가 없습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 복사 작업의 copiedRows 필드는 어떤 정보를 제공하나요?", "answer": "copiedRows 필드는 목적 테이블로 복사된 행의 수를 나타냅니다. 이 값은 복사 작업의 결과로 생성된 행 수를 반영합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 ScriptStatistics의 evaluationKind 필드는 어떤 의미인가요?", "answer": "evaluationKind 필드는 자식 작업이 문(statement)인지 표현식(expression)인지를 나타냅니다. 이 필드는 작업이 스크립트에서 어떻게 평가되었는지를 설명합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 RowLevelSecurityStatistics의 rowLevelSecurityApplied 필드는 어떤 정보를 제공하나요?", "answer": "rowLevelSecurityApplied 필드는 접근된 데이터 중에 행 접근 정책에 의해 보호된 데이터가 있었는지를 나타냅니다. 이 필드는 데이터에 대한 행 수준 보안이 적용되었는지를 확인하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Job"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Job.txt"}
{"question": "BigQuery에서 JOB_CREATION_OPTIONAL 모드로 작업이 생성된 이유를 어떻게 확인할 수 있나요?", "answer": "작업이 생성된 이유는 JobCreationReason 리소스를 통해 확인할 수 있습니다. 이 리소스는 jobs.query 메서드와 함께 사용되며, JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"code\": enum (Code)\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobCreationReason"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobCreationReason.txt"}
{"question": "JobCreationReason의 code 필드에서 어떤 값들이 사용될 수 있나요?", "answer": "code 필드는 작업이 생성된 고수준의 이유를 나타내며, 다음과 같은 enum 값들이 있습니다:\n- CODE_UNSPECIFIED: 이유가 지정되지 않음.\n- REQUESTED: 작업 생성이 요청됨.\n- LONG_RUNNING: 쿼리 요청이 시스템 정의 타임아웃을 초과하여 긴 작업으로 간주됨.\n- LARGE_RESULTS: 쿼리 결과가 응답에 맞지 않음.\n- OTHER: BigQuery가 쿼리를 작업으로 실행해야 한다고 판단함.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobCreationReason"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobCreationReason.txt"}
{"question": "jobs.insert 메서드를 호출할 때 JobCreationReason의 code 필드는 어떻게 설정되나요?", "answer": "jobs.insert 메서드를 호출할 때 JobCreationReason의 code 필드는 항상 REQUESTED로 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobCreationReason"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobCreationReason.txt"}
{"question": "LONG_RUNNING 값은 어떤 상황에서 발생하나요?", "answer": "LONG_RUNNING 값은 쿼리 요청이 timeoutMs 필드에 의해 정의된 시스템 타임아웃을 초과할 때 발생합니다. 이 경우 작업이 긴 작업으로 간주되어 생성됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobCreationReason"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobCreationReason.txt"}
{"question": "LARGE_RESULTS 값은 어떤 경우에 나타나나요?", "answer": "LARGE_RESULTS 값은 쿼리의 결과가 응답에 맞지 않을 때 나타납니다. 이 경우 BigQuery는 결과를 처리하기 위해 작업을 생성합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobCreationReason"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobCreationReason.txt"}
{"question": "JobReference의 JSON 표현은 어떻게 되나요?", "answer": "JobReference의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"projectId\": string,\n  \"jobId\": string,\n  \"location\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobReference.txt"}
{"question": "JobReference에서 projectId 필드는 어떤 용도로 사용되나요?", "answer": "projectId 필드는 이 작업을 포함하는 프로젝트의 ID를 나타내며, 필수입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobReference.txt"}
{"question": "jobId 필드의 규칙은 무엇인가요?", "answer": "jobId 필드는 작업의 ID를 나타내며, 필수입니다. ID는 문자(a-z, A-Z), 숫자(0-9), 밑줄(_), 또는 대시(-)만 포함할 수 있으며, 최대 길이는 1,024자입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobReference.txt"}
{"question": "location 필드는 무엇을 의미하나요?", "answer": "location 필드는 작업의 지리적 위치를 나타내며, 선택 사항입니다. 기본값은 US입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobReference.txt"}
{"question": "BigQuery의 위치에 대한 추가 정보는 어디에서 찾을 수 있나요?", "answer": "BigQuery 위치에 대한 추가 정보는 다음 링크에서 확인할 수 있습니다: [BigQuery locations](https://cloud.google.com/bigquery/docs/locations)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_JobReference.txt"}
{"question": "BigQuery에서 비동기 작업을 시작하려면 어떤 메서드를 사용해야 하나요?", "answer": "비동기 작업을 시작하려면 `insert` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert)를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs.txt"}
{"question": "특정 작업의 정보를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "`get` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get)를 사용하여 특정 작업에 대한 정보를 가져올 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs.txt"}
{"question": "쿼리 작업의 결과를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "`getQueryResults` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults)를 사용하여 쿼리 작업의 결과를 가져올 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs.txt"}
{"question": "작업을 취소하려면 어떤 메서드를 사용해야 하나요?", "answer": "`cancel` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel)를 사용하여 작업을 취소할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs.txt"}
{"question": "특정 프로젝트에서 시작한 모든 작업을 나열하려면 어떤 메서드를 사용해야 하나요?", "answer": "`list` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list)를 사용하여 특정 프로젝트에서 시작한 모든 작업을 나열할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs.txt"}
{"question": "BigQuery에서 작업을 취소하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "작업을 취소하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/jobs/{jobId}/cancel\n```\n여기서 `{projectId}`는 취소할 작업의 프로젝트 ID이고, `{jobId}`는 취소할 작업의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_cancel.txt"}
{"question": "작업 취소 요청 시 필수로 제공해야 하는 경로 매개변수는 무엇인가요?", "answer": "작업 취소 요청 시 필수로 제공해야 하는 경로 매개변수는 다음과 같습니다:\n- `projectId`: 취소할 작업의 프로젝트 ID\n- `jobId`: 취소할 작업의 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_cancel.txt"}
{"question": "작업 취소 요청의 응답 본문 구조는 어떻게 되나요?", "answer": "작업 취소 요청의 응답 본문 구조는 다음과 같습니다:\n\n```\n{\n  \"kind\": string,\n  \"job\": {\n    object (Job [https://cloud.google.com/bigquery/docs/reference/rest/v2/Job])\n  }\n}\n```\n여기서 `kind`는 응답의 리소스 유형을 나타내고, `job`는 작업의 최종 상태를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_cancel.txt"}
{"question": "작업 취소 요청을 보낼 때 요청 본문에 포함해야 할 내용은 무엇인가요?", "answer": "작업 취소 요청을 보낼 때 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 포함할 내용이 없습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_cancel.txt"}
{"question": "작업 취소 요청을 수행하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "작업 취소 요청을 수행하기 위해 필요한 OAuth 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/cancel"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_cancel.txt"}
{"question": "BigQuery에서 작업의 메타데이터를 삭제하는 방법은 무엇인가요?", "answer": "작업의 메타데이터를 삭제하려면 다음과 같은 HTTP DELETE 요청을 사용합니다:\n\n```\nDELETE https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/jobs/{jobId}/delete\n```\n여기서 `{projectId}`는 작업이 속한 프로젝트의 ID이고, `{jobId}`는 삭제할 작업의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_delete.txt"}
{"question": "작업의 메타데이터를 삭제할 때 필요한 파라미터는 무엇인가요?", "answer": "작업의 메타데이터를 삭제하기 위해서는 다음 두 개의 경로 파라미터가 필요합니다:\n- `projectId`: 메타데이터를 삭제할 작업이 속한 프로젝트의 ID (필수)\n- `jobId`: 메타데이터를 삭제할 작업의 ID (필수). 만약 이 작업이 자식 작업을 가진 부모 작업이라면, 모든 자식 작업의 메타데이터도 삭제됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_delete.txt"}
{"question": "작업 메타데이터 삭제 요청 시 쿼리 파라미터로 어떤 것을 지정해야 하나요?", "answer": "작업 메타데이터 삭제 요청 시 `location` 쿼리 파라미터를 지정해야 합니다. 이는 작업의 지리적 위치를 나타내며 필수입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_delete.txt"}
{"question": "작업 메타데이터 삭제 요청의 본문은 어떻게 구성되나요?", "answer": "작업 메타데이터 삭제 요청의 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 빈 JSON 객체여야 합니다:\n\n```\n{}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_delete.txt"}
{"question": "작업 메타데이터 삭제를 위한 인증 범위는 무엇인가요?", "answer": "작업 메타데이터 삭제를 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_delete.txt"}
{"question": "jobs.get 메서드를 사용하여 특정 작업의 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 작업의 정보를 가져오기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/jobs/{jobId}\n```\n여기서 `{projectId}`는 요청한 작업의 프로젝트 ID이고, `{jobId}`는 요청한 작업의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_get.txt"}
{"question": "jobs.get 메서드를 호출할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "jobs.get 메서드를 호출할 때 필요한 경로 매개변수는 다음과 같습니다:\n- `projectId`: 요청한 작업의 프로젝트 ID (string, 필수)\n- `jobId`: 요청한 작업의 ID (string, 필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_get.txt"}
{"question": "jobs.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "jobs.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 필요하지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_get.txt"}
{"question": "jobs.get 메서드를 사용하기 위해 필요한 권한은 무엇인가요?", "answer": "jobs.get 메서드를 사용하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n- `https://www.googleapis.com/auth/bigquery.readonly`\n- `https://www.googleapis.com/auth/cloud-platform.read-only`", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_get.txt"}
{"question": "jobs.get 메서드를 사용할 때 지역(location) 매개변수는 언제 필요하나요?", "answer": "jobs.get 메서드를 사용할 때 지역(location) 매개변수는 다음과 같은 경우에 필요합니다:\n- 작업을 실행할 위치가 us 또는 eu 다중 지역이 아닐 때\n- 작업의 위치가 단일 지역(예: us-central1)일 때\n자세한 내용은 위치를 지정하는 방법을 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_get.txt"}
{"question": "jobs.getQueryResults 메서드를 호출할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "jobs.getQueryResults 메서드를 호출할 때 필요한 경로 매개변수는 projectId와 jobId입니다. projectId는 쿼리 작업의 프로젝트 ID이며, jobId는 쿼리 작업의 작업 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_getQueryResults.txt"}
{"question": "jobs.getQueryResults 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "jobs.getQueryResults 메서드에서 사용할 수 있는 쿼리 매개변수는 startIndex, pageToken, maxResults, timeoutMs, location, formatOptions입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_getQueryResults.txt"}
{"question": "jobs.getQueryResults 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "jobs.getQueryResults 메서드의 응답 본문 구조는 다음과 같습니다:\n```\n{\n  \"kind\": string,\n  \"etag\": string,\n  \"schema\": {\n    object (TableSchema)\n  },\n  \"jobReference\": {\n    object (JobReference)\n  },\n  \"totalRows\": string,\n  \"pageToken\": string,\n  \"rows\": [\n    {\n      object\n    }\n  ],\n  \"totalBytesProcessed\": string,\n  \"jobComplete\": boolean,\n  \"errors\": [\n    {\n      object (ErrorProto)\n    }\n  ],\n  \"cacheHit\": boolean,\n  \"numDmlAffectedRows\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_getQueryResults.txt"}
{"question": "jobs.getQueryResults 메서드의 timeoutMs 매개변수는 어떤 역할을 하나요?", "answer": "timeoutMs 매개변수는 클라이언트가 쿼리가 완료되기를 기다릴 최대 시간을 밀리초 단위로 지정합니다. 기본적으로 이 제한은 10초(10,000 밀리초)입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_getQueryResults.txt"}
{"question": "jobs.getQueryResults 메서드의 응답에서 jobComplete 필드는 어떤 의미인가요?", "answer": "jobComplete 필드는 쿼리가 완료되었는지를 나타냅니다. rows 또는 totalRows가 존재하는 경우 항상 true입니다. false인 경우 totalRows는 사용할 수 없습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/getQueryResults"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_getQueryResults.txt"}
{"question": "BigQuery API에서 새로운 비동기 작업을 시작하려면 어떤 메서드를 사용해야 하나요?", "answer": "새로운 비동기 작업을 시작하려면 BigQuery API의 `jobs.insert` 메서드를 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_insert.txt"}
{"question": "BigQuery API의 `jobs.insert` 메서드에서 사용할 수 있는 두 가지 URI는 무엇인가요?", "answer": "BigQuery API의 `jobs.insert` 메서드는 두 가지 URI를 지원합니다. 하나는 메타데이터 URI로, 대부분의 상호작용에 사용되며 작업 구성(job configuration)을 직접 수용합니다. 다른 하나는 업로드 URI로, 로드 작업 구성(load job configuration)과 데이터 스트림(data stream)을 함께 전송할 때만 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_insert.txt"}
{"question": "메타데이터 URI를 사용하여 `jobs.insert` 메서드를 호출할 때의 HTTP 요청 형식은 무엇인가요?", "answer": "메타데이터 URI를 사용하여 `jobs.insert` 메서드를 호출할 때의 HTTP 요청 형식은 다음과 같습니다:\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/jobs\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_insert.txt"}
{"question": "업로드 URI를 사용하여 `jobs.insert` 메서드를 호출할 때의 HTTP 요청 형식은 무엇인가요?", "answer": "업로드 URI를 사용하여 `jobs.insert` 메서드를 호출할 때의 HTTP 요청 형식은 다음과 같습니다:\n```\nPOST https://bigquery.googleapis.com/upload/bigquery/v2/projects/{projectId}/jobs\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_insert.txt"}
{"question": "`jobs.insert` 메서드를 호출할 때 필요한 권한 범위는 무엇인가요?", "answer": "`jobs.insert` 메서드를 호출할 때는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/devstorage.full_control\n- https://www.googleapis.com/auth/devstorage.read_only\n- https://www.googleapis.com/auth/devstorage.read_write", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_insert.txt"}
{"question": "jobs.list 메서드를 사용하여 특정 프로젝트의 작업 목록을 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/jobs\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_list.txt"}
{"question": "jobs.list 메서드에서 jobs의 상태를 필터링하려면 어떤 파라미터를 사용해야 하나요?", "answer": "jobs의 상태를 필터링하려면 `stateFilter[]` 파라미터를 사용해야 합니다. 유효한 값으로는 `DONE`, `PENDING`, `RUNNING`이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_list.txt"}
{"question": "jobs.list 메서드의 응답에서 각 작업의 고유 ID는 어떤 필드에서 확인할 수 있나요?", "answer": "각 작업의 고유 ID는 응답의 `jobs[].id` 필드에서 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_list.txt"}
{"question": "jobs.list 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 구성됩니다:\n\n```\n{ }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_list.txt"}
{"question": "jobs.list 메서드를 호출할 때 필요한 권한은 무엇인가요?", "answer": "이 메서드를 호출하려면 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_list.txt"}
{"question": "BigQuery SQL 쿼리를 실행할 때, 요청 본문에 포함해야 하는 필드는 무엇인가요?", "answer": "요청 본문에는 QueryRequest의 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드를 호출한 후, 쿼리 결과를 확인하기 위해 어떤 필드를 확인해야 하나요?", "answer": "쿼리 결과를 확인하기 위해 jobComplete 필드를 확인해야 합니다. 이 필드가 true이면 쿼리가 완료된 것입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 응답에서 totalRows 필드는 어떤 정보를 제공하나요?", "answer": "totalRows 필드는 전체 쿼리 결과 집합의 총 행 수를 제공합니다. 이 값은 단일 페이지의 행 수보다 클 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 응답에서 errors 필드는 어떤 정보를 포함하나요?", "answer": "errors 필드는 작업 실행 중에 발생한 첫 번째 오류 또는 경고를 포함합니다. 이 필드는 작업이 완료되었거나 실패했음을 반드시 의미하지는 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드를 사용할 때, 쿼리 결과가 캐시에서 가져온 것인지 확인하려면 어떤 필드를 확인해야 하나요?", "answer": "cacheHit 필드를 확인하면 쿼리 결과가 캐시에서 가져온 것인지 여부를 알 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 maxResults 필드는 어떤 역할을 하나요?", "answer": "maxResults 필드(‘maxResults’)는 결과 페이지당 반환할 최대 데이터 행 수를 지정합니다. 이 값을 작게 설정하면 결과 집합이 클 때 신뢰성을 높일 수 있습니다. 기본적으로 최대 행 수는 설정되어 있지 않으며, 바이트 제한만 적용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 timeoutMs 필드는 어떤 기능을 하나요?", "answer": "timeoutMs 필드(‘timeoutMs’)는 클라이언트가 쿼리 완료를 위해 기다릴 최대 시간을 밀리초 단위로 지정합니다. 기본값은 10초(10,000 밀리초)이며, 이 값을 초과하는 요청은 보장되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 dryRun 필드는 어떤 용도로 사용되나요?", "answer": "dryRun 필드(‘dryRun’)는 true로 설정하면 BigQuery가 작업을 실행하지 않고 쿼리가 유효한 경우 처리될 바이트 수와 같은 통계를 반환합니다. 쿼리가 유효하지 않으면 오류가 반환됩니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 useQueryCache 필드는 어떤 역할을 하나요?", "answer": "useQueryCache 필드(‘useQueryCache’)는 쿼리 결과를 쿼리 캐시에서 찾을지 여부를 지정합니다. 쿼리 캐시는 최선의 노력으로 캐시되며, 쿼리의 테이블이 수정될 때마다 플러시됩니다. 기본값은 true입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 useLegacySql 필드는 어떤 기능을 하나요?", "answer": "useLegacySql 필드(‘useLegacySql’)는 쿼리에 대해 BigQuery의 레거시 SQL 방언을 사용할지 여부를 지정합니다. 기본값은 true입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 defaultDataset 필드는 어떤 역할을 하나요?", "answer": "defaultDataset 필드(object (DatasetReference))는 쿼리에서 자격이 없는 테이블 이름에 대해 기본 datasetId와 projectId를 지정합니다. 이 필드가 설정되지 않으면 쿼리 문자열의 모든 테이블 이름은 'datasetId.tableId' 형식으로 자격이 부여되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 maximumBytesBilled 필드는 어떤 기능을 하나요?", "answer": "maximumBytesBilled 필드(string (Int64Value format))는 이 쿼리에 대해 청구될 최대 바이트 수를 제한합니다. 이 한도를 초과하는 쿼리는 실패하며, 청구가 발생하지 않습니다. 지정하지 않으면 프로젝트의 기본값이 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 requestId 필드는 어떤 용도로 사용되나요?", "answer": "requestId 필드(string)는 쿼리에 대한 고유한 사용자 제공 식별자로, 쿼리의 idempotent 동작을 보장합니다. 이 필드는 대소문자를 구분하며 최대 36개의 ASCII 문자로 제한됩니다. 동일한 requestId를 가진 두 요청이 15분 이상 간격으로 전송되면 idempotency가 보장되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 createSession 필드는 어떤 역할을 하나요?", "answer": "createSession 필드(boolean)는 true로 설정되면 무작위로 생성된 sessionId를 사용하여 새로운 세션을 생성합니다. false로 설정되면 ConnectionProperty에 전달된 기존 sessionId로 쿼리를 실행하거나 비세션 모드에서 쿼리를 실행합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 parameterMode 필드는 어떤 기능을 하나요?", "answer": "parameterMode 필드(string)는 GoogleSQL 전용으로, 쿼리 매개변수를 위치 기반(?) 또는 이름 기반(@myparam)으로 사용할지를 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 createSession 필드는 어떤 역할을 하나요?", "answer": "createSession 필드(boolean)는 새로운 세션을 생성할지 여부를 결정합니다. true로 설정하면 무작위로 생성된 sessionId를 사용하여 새로운 세션을 생성하고, false로 설정하면 ConnectionProperty에 전달된 기존 sessionId를 사용하여 쿼리를 실행합니다. 세션 위치는 QueryRequest.location이 존재할 경우 해당 위치로 설정되며, 그렇지 않으면 기존 라우팅 로직에 따라 기본 위치로 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 jobCreationMode 필드는 어떤 기능을 하나요?", "answer": "jobCreationMode 필드(enum)는 작업 생성에 대한 다양한 옵션을 제공합니다. 설정하지 않으면 기본적으로 JOB_CREATION_REQUIRED가 적용되어 항상 작업 생성이 필요합니다. JOB_CREATION_OPTIONAL로 설정하면 작업 생성이 선택적이 되며, 즉각적인 결과 반환이 우선시됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 jobTimeoutMs 필드는 어떤 역할을 하나요?", "answer": "jobTimeoutMs 필드(string)는 작업의 타임아웃을 밀리초 단위로 설정합니다. 이 시간 제한을 초과하면 BigQuery는 더 긴 작업을 중지하려고 시도하지만, 항상 성공하지는 않을 수 있습니다. 예를 들어, 60초 이상 걸리는 작업은 10초 걸리는 작업보다 중지될 가능성이 높습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 maximumBytesBilled 필드는 어떤 기능을 하나요?", "answer": "maximumBytesBilled 필드(string)는 이 쿼리에 대해 청구될 최대 바이트 수를 제한합니다. 이 한도를 초과하는 쿼리는 실패하며, 청구가 발생하지 않습니다. 지정하지 않으면 프로젝트의 기본값이 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "jobs.query 메서드의 요청 본문에서 labels 필드는 어떤 용도로 사용되나요?", "answer": "labels 필드(map)는 이 쿼리에 관련된 레이블을 지정하는 데 사용됩니다. 레이블은 쿼리 작업을 조직하고 그룹화하는 데 유용합니다. 레이블 키와 값은 최대 63자까지 가능하며, 소문자, 숫자, 밑줄 및 하이픈만 포함할 수 있습니다. 레이블 키는 반드시 문자로 시작해야 하며, 리스트 내의 각 레이블은 서로 다른 키를 가져야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/query"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_jobs_query.txt"}
{"question": "BigQuery에서 모델을 생성할 때, 모델의 설명(description) 필드는 어떤 용도로 사용되나요?", "answer": "description 필드는 모델에 대한 사용자 친화적인 설명을 제공하는 선택적 필드입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 expirationTime 필드는 무엇을 의미하며, 기본값은 어떻게 설정되나요?", "answer": "expirationTime 필드는 모델이 만료되는 시간을 밀리초 단위로 나타내며, 이 필드가 없으면 모델은 무기한 유지됩니다. 기본적으로, encapsulating dataset의 defaultTableExpirationMs 속성을 사용하여 새로 생성된 모델의 기본 expirationTime을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 featureColumns 필드는 어떤 정보를 포함하고 있나요?", "answer": "featureColumns 필드는 모델 추론을 위한 입력 특성 열을 포함하며, 모델이 TRANSFORM 절로 훈련된 경우, 이 필드는 TRANSFORM 절의 입력을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 labelColumns 필드는 어떤 역할을 하나요?", "answer": "labelColumns 필드는 이 모델을 훈련하는 데 사용된 레이블 열을 포함하며, 모델의 출력은 이러한 열에 'predicted_' 접두사가 붙습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 modelType 필드는 어떤 정보를 제공하나요?", "answer": "modelType 필드는 모델 리소스의 유형을 나타내며, 이는 열거형(enum)으로 정의되어 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 transformColumns 필드는 어떤 정보를 포함하고 있나요?", "answer": "transformColumns 필드는 TRANSFORM 절을 사용하여 모델을 훈련할 때 생성된 열 정보를 포함합니다. 이 필드는 TRANSFORM 절이 사용된 경우에만 채워집니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 hparamSearchSpaces 필드는 어떤 용도로 사용되나요?", "answer": "hparamSearchSpaces 필드는 이 모델에서 사용된 모든 하이퍼파라미터 검색 공간을 포함합니다. 이는 모델의 하이퍼파라미터 튜닝에 대한 정보를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingRun 객체의 evaluationMetrics 필드는 어떤 정보를 제공하나요?", "answer": "evaluationMetrics 필드는 훈련이 끝난 후 훈련 및 평가 데이터에 대해 계산된 평가 메트릭스를 포함합니다. 이는 모델의 성능을 평가하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 defaultTrialId 필드는 어떤 정보를 담고 있나요?", "answer": "defaultTrialId 필드는 trialId가 전달되지 않았을 때 TVF에서 사용할 기본 trialId를 나타냅니다. 단일 목표 하이퍼파라미터 튜닝 모델의 경우, 이는 가장 좋은 trial ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 learnRate 필드는 무엇을 의미하나요?", "answer": "learnRate 필드는 모델 훈련 시 사용되는 학습률을 나타냅니다. 이는 모델이 학습하는 속도를 조절하는 중요한 하이퍼파라미터입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingRun 객체의 startTime 필드는 어떤 정보를 제공하나요?", "answer": "startTime 필드는 이 훈련 실행의 시작 시간을 나타내며, Timestamp 형식으로 제공됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingRun 객체의 results 필드는 어떤 정보를 포함하나요?", "answer": "results 필드는 각 반복 실행의 출력을 포함하며, results.size()는 maxIterations 이하로 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 lossType 필드는 어떤 역할을 하나요?", "answer": "lossType 필드는 훈련에서 사용되는 손실 함수의 유형을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 earlyStop 필드는 어떤 기능을 하나요?", "answer": "earlyStop 필드는 훈련이 조기 종료될지를 결정하는 boolean 값으로, 훈련이 더 이상 개선되지 않을 때 조기 종료를 활성화합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 dataSplitMethod 필드는 어떤 정보를 제공하나요?", "answer": "dataSplitMethod 필드는 훈련 데이터의 분할 방법을 지정하는 enum 값입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 maxIterations 필드는 어떤 역할을 하나요?", "answer": "maxIterations 필드는 훈련에서 최대 반복 횟수를 지정합니다. 이는 반복 훈련 알고리즘에서만 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 dataSplitMethod 필드는 어떤 정보를 제공하나요?", "answer": "dataSplitMethod 필드는 훈련 및 평가를 위한 데이터 분할 유형을 지정합니다. 예를 들어, RANDOM과 같은 값을 가질 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 labelClassWeights 필드는 어떤 용도로 사용되나요?", "answer": "labelClassWeights 필드는 각 레이블 클래스에 대한 가중치를 지정하여 훈련 데이터를 재조정하는 데 사용됩니다. 이는 분류 모델에만 적용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 earlyStop 필드는 어떤 기능을 하나요?", "answer": "earlyStop 필드는 손실이 더 이상 유의미하게 개선되지 않을 때 훈련을 조기에 중단할지를 결정합니다. 이는 반복 훈련 알고리즘에서만 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrainingOptions 객체의 batchSize 필드는 무엇을 의미하나요?", "answer": "batchSize 필드는 DNN 모델을 위한 배치 크기를 지정합니다. 이는 훈련 시 한 번에 처리할 데이터 샘플의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 fitIntercept 필드는 어떤 역할을 하나요?", "answer": "fitIntercept 필드(boolean)는 모델이 절편(intercept)을 포함할지 여부를 결정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 pcaSolver 필드는 어떤 값을 가질 수 있나요?", "answer": "pcaSolver 필드(enum (PcaSolver))는 주성분 분석(PCA)에서 사용할 솔버의 유형을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 dropout 필드는 무엇을 의미하나요?", "answer": "dropout 필드(number)는 DNN 모델에서 드롭아웃 확률을 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 dataSplitMethod 필드는 어떤 값을 가질 수 있나요?", "answer": "dataSplitMethod 필드(enum (DataSplitMethod))는 훈련 및 평가를 위한 데이터 분할 방법을 지정합니다. 예를 들어, RANDOM이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 numClusters 필드는 어떤 정보를 제공하나요?", "answer": "numClusters 필드(string (int64 format))는 클러스터링 모델에서 생성할 클러스터의 수를 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "DNN 모델에서 batchSize 필드는 어떤 역할을 하나요?", "answer": "DNN 모델에서 batchSize 필드는 배치 크기를 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "boosted tree 모델의 maxTreeDepth 필드는 무엇을 의미하나요?", "answer": "boosted tree 모델의 maxTreeDepth 필드는 트리의 최대 깊이를 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "boosted tree 모델에서 subsample 필드는 어떤 용도로 사용되나요?", "answer": "boosted tree 모델에서 subsample 필드는 과적합을 방지하기 위해 트리를 성장시키는 데 사용할 훈련 데이터의 샘플 비율을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 timeSeriesTimestampColumn 필드는 어떤 정보를 포함하나요?", "answer": "ARIMA 모델에서 timeSeriesTimestampColumn 필드는 시계열 타임스탬프를 지정하는 열입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "autoArima 필드는 어떤 기능을 수행하나요?", "answer": "autoArima 필드는 자동 ARIMA 기능을 활성화할지 여부를 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 horizon 필드는 어떤 정보를 제공하나요?", "answer": "horizon 필드는 예측해야 하는 기간의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "autoArimaMaxOrder 필드는 어떤 값을 설정하나요?", "answer": "autoArimaMaxOrder 필드는 비계절적 p와 q의 합의 최대 값을 설정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "numTrials 필드는 하이퍼파라미터 튜닝 작업에서 어떤 역할을 하나요?", "answer": "numTrials 필드는 이 하이퍼파라미터 튜닝 작업에서 실행할 시험의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "decomposeTimeSeries 필드는 어떤 기능을 수행하나요?", "answer": "decomposeTimeSeries 필드가 true로 설정되면, 시계열을 분해하고 결과를 저장합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "maxParallelTrials 필드는 무엇을 의미하나요?", "answer": "maxParallelTrials 필드는 동시에 실행할 수 있는 최대 시험의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 maxTimeSeriesLength 필드는 어떤 정보를 제공하나요?", "answer": "maxTimeSeriesLength 필드는 모델링에 사용할 수 있는 시계열의 최대 시간 포인트 수를 정의합니다. 이 옵션은 timeSeriesLengthFraction 또는 minTimeSeriesLength 옵션과 함께 사용하지 않아야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "XGBoost 모델에서 approxGlobalFeatureContrib 필드는 어떤 기능을 하나요?", "answer": "approxGlobalFeatureContrib 필드는 XGBoost 모델 설명에서 전역 설명을 위한 근사적 특성 기여 방법을 사용할지를 결정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "PCA 모델에서 numPrincipalComponents 필드는 어떤 역할을 하나요?", "answer": "numPrincipalComponents 필드는 PCA 모델에서 유지할 주성분의 수를 정의합니다. 이 값은 특성의 수보다 작거나 같아야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 autoClassWeights 필드는 어떤 용도로 사용되나요?", "answer": "autoClassWeights 필드는 각 레이블의 인기도에 따라 클래스 가중치를 자동으로 계산할지를 결정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 DataSplitMethod 필드는 어떤 값을 가질 수 있나요?", "answer": "DataSplitMethod 필드는 입력 데이터를 여러 테이블로 분할하는 방법을 나타냅니다. 가능한 값으로는 DATA_SPLIT_METHOD_UNSPECIFIED, RANDOM, CUSTOM, SEQUENTIAL, NO_SPLIT, AUTO_SPLIT이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "KMeans 클러스터링 알고리즘에서 KmeansInitializationMethod 필드는 어떤 값을 가질 수 있나요?", "answer": "KmeansInitializationMethod 필드는 클러스터 중심을 초기화하는 방법을 나타내며, 다음과 같은 값을 가질 수 있습니다: \n\n- KMEANS_INITIALIZATION_METHOD_UNSPECIFIED: 초기화 방법이 지정되지 않음.\n- RANDOM: 클러스터 중심을 무작위로 초기화.\n- CUSTOM: kmeansInitializationColumn에 지정된 데이터를 사용하여 클러스터 중심을 초기화.\n- KMEANS_PLUS_PLUS: kmeans++를 사용하여 초기화.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 ArimaOrder 필드는 어떤 정보를 포함하나요?", "answer": "ArimaOrder 필드는 비계절적 및 계절적 부분 모두에 사용할 수 있는 ARIMA 모델의 순서를 나타내며, JSON 형식으로 다음과 같은 필드를 포함합니다:\n\n```json\n{\n  \"p\": string,\n  \"d\": string,\n  \"q\": string\n}\n```\n- p: 자기회귀 부분의 차수.\n- d: 차분 부분의 차수.\n- q: 이동 평균 부분의 차수.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 FeedbackType 필드는 어떤 값을 가질 수 있나요?", "answer": "FeedbackType 필드는 행렬 분해 모델에 사용할 훈련 알고리즘을 나타내며, 다음과 같은 값을 가질 수 있습니다:\n\n- FEEDBACK_TYPE_UNSPECIFIED: 기본값.\n- IMPLICIT: 암묵적 피드백 문제에 대해 weighted-als를 사용.\n- EXPLICIT: 명시적 피드백 문제에 대해 nonweighted-als를 사용.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 DataFrequency 필드는 어떤 값을 가질 수 있나요?", "answer": "DataFrequency 필드는 시계열 예측 모델에 대한 지원되는 데이터 빈도를 나타내며, 다음과 같은 값을 가질 수 있습니다:\n\n- DATA_FREQUENCY_UNSPECIFIED: 기본값.\n- AUTO_FREQUENCY: 타임스탬프에서 자동으로 추론.\n- YEARLY: 연간 데이터.\n- QUARTERLY: 분기별 데이터.\n- MONTHLY: 월간 데이터.\n- WEEKLY: 주간 데이터.\n- DAILY: 일간 데이터.\n- HOURLY: 시간별 데이터.\n- PER_MINUTE: 분 단위 데이터.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "모델의 HparamTuningObjective 필드는 어떤 평가 지표를 사용할 수 있나요?", "answer": "HparamTuningObjective 필드는 하이퍼파라미터 튜닝 목표로 사용할 수 있는 평가 지표를 나타내며, 다음과 같은 값을 가질 수 있습니다:\n\n- HPARAM_TUNING_OBJECTIVE_UNSPECIFIED: 지정되지 않은 평가 지표.\n- MEAN_ABSOLUTE_ERROR: 평균 절대 오차.\n- MEAN_SQUARED_ERROR: 평균 제곱 오차.\n- MEAN_SQUARED_LOG_ERROR: 평균 제곱 로그 오차.\n- MEDIAN_ABSOLUTE_ERROR: 중앙 절대 오차.\n- R_SQUARED: R^2 점수.\n- EXPLAINED_VARIANCE: 설명된 분산.\n- PRECISION: 정밀도.\n- RECALL: 재현율.\n- ACCURACY: 정확도.\n- F1_SCORE: F1 점수.\n- LOG_LOSS: 로그 손실.\n- ROC_AUC: ROC 곡선 아래 면적.\n- DAVIES_BOULDIN_INDEX: Davies-Bouldin 지수.\n- MEAN_AVERAGE_PRECISION: 평균 평균 정밀도.\n- NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN: 정규화된 할인 누적 이득.\n- AVERAGE_RANK: 평균 순위.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "IterationResult 객체의 trainingLoss 필드는 어떤 정보를 제공하나요?", "answer": "trainingLoss 필드는 반복(iteration) 종료 시점에서 훈련 데이터에 대한 손실(loss)을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ClusterInfo 객체의 clusterRadius 필드는 어떤 의미를 가지나요?", "answer": "clusterRadius 필드는 중심점(centroid)에서 클러스터에 할당된 각 점까지의 평균 거리인 클러스터 반경을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaResult 객체의 seasonalPeriods 필드는 어떤 정보를 포함하나요?", "answer": "seasonalPeriods 필드는 여러 시계열에 대해 지원되는 계절적 주기(seasonal periods)를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaModelInfo 객체의 hasDrift 필드는 어떤 정보를 제공하나요?", "answer": "hasDrift 필드는 Arima 모델이 드리프트(drift)와 함께 적합되었는지를 나타내며, d가 1이 아닐 경우 항상 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "IterationResult 객체의 evalLoss 필드는 어떤 역할을 하나요?", "answer": "evalLoss 필드는 반복 종료 시점에서 평가 데이터에 대한 손실(loss)을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ClusterInfo 객체의 clusterSize 필드는 어떤 정보를 제공하나요?", "answer": "ClusterInfo 객체의 clusterSize 필드는 클러스터에 할당된 총 포인트 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaResult 객체의 seasonalPeriods 필드는 어떤 정보를 포함하나요?", "answer": "ArimaResult 객체의 seasonalPeriods 필드는 여러 계절 주기를 지원하는 시계열에 대한 계절 주기를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaModelInfo 객체의 hasHolidayEffect 필드는 어떤 정보를 제공하나요?", "answer": "ArimaModelInfo 객체의 hasHolidayEffect 필드는 holiday_effect가 시계열 분해 결과의 일부인지 여부를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaCoefficients 객체의 autoRegressiveCoefficients 필드는 어떤 정보를 포함하나요?", "answer": "ArimaCoefficients 객체의 autoRegressiveCoefficients 필드는 자동 회귀 계수의 배열을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "EvaluationMetrics 객체의 metrics 필드는 어떤 역할을 하나요?", "answer": "EvaluationMetrics 객체의 metrics 필드는 회귀, 이진 분류, 다중 클래스 분류, 클러스터링, 순위 매기기, ARIMA 모델 등 다양한 모델에 대한 평가 지표를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 seasonalPeriods 필드는 어떤 정보를 포함하나요?", "answer": "seasonalPeriods 필드는 여러 계절 주기를 지원하는 배열로, 각 계절 주기는 SeasonalPeriodType 열거형(enum)으로 정의됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaCoefficients 객체의 interceptCoefficient 필드는 어떤 정보를 제공하나요?", "answer": "interceptCoefficient 필드는 단일 double 값으로, ARIMA 모델의 절편 계수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaFittingMetrics 객체의 logLikelihood 필드는 어떤 정보를 포함하나요?", "answer": "logLikelihood 필드는 ARIMA 모델의 로그 우도(log-likelihood) 값을 나타내며, 모델의 적합도를 평가하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "PrincipalComponentInfo 객체의 explainedVarianceRatio 필드는 어떤 역할을 하나요?", "answer": "explainedVarianceRatio 필드는 해당 주성분이 전체 설명된 분산에 대한 비율을 나타내며, 주성분 분석(PCA)에서 각 주성분의 중요성을 평가하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "BinaryClassificationMetrics 객체의 positiveLabel 필드는 어떤 정보를 제공하나요?", "answer": "positiveLabel 필드는 이진 분류 모델에서 긍정 클래스의 레이블을 나타내며, 모델의 예측 결과를 해석하는 데 중요한 역할을 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "회귀 모델에서 regressionMetrics 필드는 어떤 정보를 포함하나요?", "answer": "회귀 모델에서 regressionMetrics(object (RegressionMetrics))는 다음과 같은 평가 지표를 포함합니다: meanAbsoluteError, meanSquaredError, meanSquaredLogError, medianAbsoluteError, rSquared.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "이진 분류 모델에서 binaryClassificationMetrics 필드는 어떤 정보를 제공하나요?", "answer": "이진 분류 모델에서 binaryClassificationMetrics(object (BinaryClassificationMetrics))는 aggregateClassificationMetrics, binaryConfusionMatrixList, positiveLabel, negativeLabel을 포함하여 이진 분류의 성능을 평가합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "다중 클래스 분류 모델에서 confusionMatrixList 필드는 어떤 역할을 하나요?", "answer": "다중 클래스 분류 모델에서 confusionMatrixList(object (ConfusionMatrix))는 다양한 임계값에서의 혼동 행렬을 포함하여 모델의 예측 성능을 평가하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "클러스터링 모델에서 clusteringMetrics 필드는 어떤 정보를 포함하나요?", "answer": "클러스터링 모델에서 clusteringMetrics(object (ClusteringMetrics))는 daviesBouldinIndex, meanSquaredDistance, clusters를 포함하여 클러스터링 성능을 평가합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "다중 클래스 분류 모델의 aggregateClassificationMetrics 필드는 어떤 평가 지표를 포함하나요?", "answer": "다중 클래스 분류 모델의 aggregateClassificationMetrics(object (AggregateClassificationMetrics))는 precision, recall, accuracy, threshold, f1Score, logLoss, rocAuc를 포함하여 모델의 전반적인 성능을 평가합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "BinaryConfusionMatrix의 truePositives 필드는 어떤 정보를 제공하나요?", "answer": "truePositives 필드는 true로 예측된 실제 샘플의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "MultiClassClassificationMetrics의 confusionMatrixList 필드는 어떤 정보를 포함하나요?", "answer": "confusionMatrixList 필드는 다양한 임계값에서의 혼동 행렬(confusion matrix)을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ClusteringMetrics의 daviesBouldinIndex 필드는 어떤 의미를 가지나요?", "answer": "daviesBouldinIndex 필드는 클러스터의 품질을 평가하는 지표로, 낮을수록 클러스터가 잘 분리되어 있음을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "Cluster 객체의 featureValues 필드는 어떤 정보를 포함하나요?", "answer": "featureValues 필드는 해당 클러스터의 고변동 특성(feature) 값들을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "RankingMetrics의 meanAveragePrecision 필드는 어떤 정보를 제공하나요?", "answer": "meanAveragePrecision 필드는 모든 항목을 순위 매긴 후 사용자별로 정밀도를 계산하고, 이를 평균하여 제공하는 지표입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "Cluster 객체의 centroidId 필드는 어떤 정보를 제공하나요?", "answer": "centroidId 필드는 클러스터의 중심점 ID를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "FeatureValue 객체의 featureColumn 필드는 어떤 정보를 포함하나요?", "answer": "featureColumn 필드는 클러스터 내의 특정 피처의 열 이름을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "CategoricalValue 객체의 categoryCounts 필드는 어떤 정보를 제공하나요?", "answer": "categoryCounts 필드는 범주형 피처에 대한 모든 범주의 카운트를 포함하며, 10개 이상의 범주가 있을 경우 상위 10개 범주와 나머지 범주의 집계 카운트를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "RankingMetrics 객체의 meanAveragePrecision 필드는 어떤 역할을 하나요?", "answer": "meanAveragePrecision 필드는 모든 항목을 순위별로 정렬한 후, 각 사용자에 대한 정밀도를 계산하고 이를 평균하여 사용자별 정밀도를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ArimaSingleModelForecastingMetrics 객체의 hasHolidayEffect 필드는 어떤 정보를 제공하나요?", "answer": "hasHolidayEffect 필드는 휴일 효과가 시계열 분해 결과의 일부인지 여부를 나타내며, true일 경우 휴일 효과가 포함되어 있음을 의미합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 timeSeriesId 필드는 어떤 정보를 제공하나요?", "answer": "timeSeriesId 필드(timeSeriesId)는 이 시계열의 고유한 식별자입니다. 이 값은 ARIMA 모델 훈련 중 지정된 timeSeriesIdColumn에서 가져온 고유한 값 중 하나입니다. 이 필드는 timeSeriesIdColumn 훈련 옵션이 사용된 경우에만 존재합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델의 seasonalPeriods 필드는 어떤 정보를 포함하나요?", "answer": "seasonalPeriods 필드(seasonalPeriods)는 계절적 주기를 나타내며, 여러 주기가 하나의 시계열에 대해 지원되기 때문에 반복적으로 포함됩니다. 이 필드는 현재 사용되지 않으며(deprecated), 이전 버전에서 사용되던 항목입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델에서 hasHolidayEffect 필드는 어떤 역할을 하나요?", "answer": "hasHolidayEffect 필드(hasHolidayEffect)는 true일 경우, 시계열 분해 결과에 holiday_effect가 포함되어 있음을 나타냅니다. 이 필드는 ARIMA 모델의 특성을 이해하는 데 중요한 정보를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델의 hasSpikesAndDips 필드는 어떤 정보를 제공하나요?", "answer": "hasSpikesAndDips 필드(hasSpikesAndDips)는 true일 경우, 시계열 분해 결과에 spikes_and_dips가 포함되어 있음을 나타냅니다. 이 필드는 데이터의 변동성을 이해하는 데 도움을 줍니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "ARIMA 모델의 hasStepChanges 필드는 어떤 정보를 포함하나요?", "answer": "hasStepChanges 필드(hasStepChanges)는 true일 경우, 시계열 분해 결과에 step_changes가 포함되어 있음을 나타냅니다. 이 필드는 데이터의 단계적 변화를 분석하는 데 유용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "trainingTable 필드는 어떤 정보를 포함하나요?", "answer": "trainingTable 필드는 훈련 데이터의 테이블 참조를 포함합니다. 이 필드는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  \"trainingTable\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "evaluationTable 필드는 어떤 역할을 하나요?", "answer": "evaluationTable 필드는 평가 데이터의 테이블 참조를 포함합니다. 이 필드는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  \"evaluationTable\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "testTable 필드는 어떤 정보를 제공하나요?", "answer": "testTable 필드는 테스트 데이터의 테이블 참조를 포함합니다. 이 필드는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  \"testTable\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "GlobalExplanation 객체의 classLabel 필드는 어떤 정보를 포함하나요?", "answer": "GlobalExplanation 객체의 classLabel 필드는 이 글로벌 설명 세트의 클래스 레이블을 포함합니다. 이 필드는 이진 로지스틱 및 선형 회귀 모델의 경우 비어 있거나 null일 수 있습니다. JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"classLabel\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "Explanation 객체의 attribution 필드는 어떤 정보를 제공하나요?", "answer": "Explanation 객체의 attribution 필드는 특정 피처의 기여도를 나타냅니다. 이 필드는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  \"attribution\": number\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "hyperparameter tuning에서 learnRate 필드는 어떤 정보를 제공하나요?", "answer": "learnRate 필드는 훈련 작업의 학습률(Learning rate)을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "boosted tree 모델에서 minTreeChildWeight 필드는 어떤 역할을 하나요?", "answer": "minTreeChildWeight 필드는 boosted tree 모델에서 자식 노드에 필요한 최소 인스턴스 가중치의 합을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "numClusters 필드는 어떤 정보를 포함하나요?", "answer": "numClusters 필드는 k-means 알고리즘에서 사용할 클러스터의 수를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "IntHparamSearchSpace의 search_space 필드는 어떤 값을 가질 수 있나요?", "answer": "IntHparamSearchSpace의 search_space 필드는 range 또는 candidates 중 하나의 값을 가질 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "DoubleCandidates 객체의 candidates 필드는 어떤 정보를 포함하나요?", "answer": "DoubleCandidates 객체의 candidates 필드는 증가하는 순서로 나열된 double 파라미터의 후보 값을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "DoubleRange 객체의 min 필드는 어떤 정보를 포함하나요?", "answer": "DoubleRange 객체의 min 필드는 double 하이퍼파라미터의 최소값을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "IntHparamSearchSpace의 candidates 필드는 어떤 정보를 제공하나요?", "answer": "IntHparamSearchSpace의 candidates 필드는 int 하이퍼파라미터의 후보 값을 포함하며, 이 값들은 증가하는 순서로 정렬되어 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "IntArray 객체의 elements 필드는 어떤 정보를 포함하나요?", "answer": "IntArray 객체의 elements 필드는 int 배열의 요소들을 포함하며, 각 요소는 int64 형식으로 표현됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "HparamTuningTrial 객체의 status 필드는 어떤 정보를 제공하나요?", "answer": "HparamTuningTrial 객체의 status 필드는 현재 트라이얼의 상태를 나타내며, 가능한 값으로는 NOT_STARTED, RUNNING, SUCCEEDED, FAILED, INFEASIBLE, STOPPED_EARLY가 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "RemoteModelInfo 객체의 connection 필드는 어떤 정보를 포함하나요?", "answer": "RemoteModelInfo 객체의 connection 필드는 원격 모델의 사용자 제공 연결 객체의 완전한 이름을 포함하며, 형식은 'projects/{projectId}/locations/{locationId}/connections/{connectionId}'입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "TrialStatus의 각 상태(enum) 값은 무엇을 의미하나요?", "answer": "TrialStatus는 현재 트라이얼의 상태를 나타내며, 다음과 같은 값이 있습니다: TRIAL_STATUS_UNSPECIFIED(기본값), NOT_STARTED(예약되었지만 시작되지 않음), RUNNING(실행 중), SUCCEEDED(트라이얼 성공), FAILED(트라이얼 실패), INFEASIBLE(유효하지 않은 파라미터로 인해 트라이얼이 불가능함), STOPPED_EARLY(유망하지 않아 조기에 중단됨).", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "RemoteModelInfo 객체의 connection 필드는 어떤 정보를 포함하나요?", "answer": "RemoteModelInfo 객체의 connection 필드는 원격 모델의 사용자 제공 연결 객체의 완전한 이름을 포함합니다. 형식은 'projects/{projectId}/locations/{locationId}/connections/{connectionId}'입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "hparams 필드는 어떤 정보를 포함하나요?", "answer": "hparams 필드는 이 트라이얼에 대해 선택된 하이퍼파라미터를 포함하는 TrainingOptions 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "evaluationMetrics 필드는 어떤 정보를 제공하나요?", "answer": "evaluationMetrics 필드는 테스트 데이터에서 계산된 이 트라이얼의 평가 메트릭스를 포함합니다. Job API에서는 비어 있을 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "maxBatchingRows 필드는 어떤 역할을 하나요?", "answer": "maxBatchingRows 필드는 원격 서비스에 전송되는 각 배치의 최대 행 수를 나타냅니다. 설정되지 않은 경우, 각 배치의 행 수는 동적으로 설정됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models.txt"}
{"question": "BigQuery에서 모델을 삭제하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "모델을 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/models/{modelId}\n```\n여기서 `{projectId}`, `{datasetId}`, `{modelId}`는 각각 삭제할 모델의 프로젝트 ID, 데이터셋 ID, 모델 ID로 대체되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_delete.txt"}
{"question": "모델 삭제 요청 시 필요한 경로 파라미터는 무엇인가요?", "answer": "모델 삭제 요청 시 필요한 경로 파라미터는 다음과 같습니다:\n- `projectId`: 삭제할 모델의 프로젝트 ID (string, 필수)\n- `datasetId`: 삭제할 모델의 데이터셋 ID (string, 필수)\n- `modelId`: 삭제할 모델의 모델 ID (string, 필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_delete.txt"}
{"question": "모델 삭제 요청의 요청 본문은 어떻게 되나요?", "answer": "모델 삭제 요청의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n(빈 요청 본문)\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_delete.txt"}
{"question": "모델 삭제 요청이 성공했을 때의 응답 본문은 어떻게 되나요?", "answer": "모델 삭제 요청이 성공했을 때의 응답 본문은 빈 JSON 객체입니다. 즉, 응답 본문은 다음과 같습니다:\n\n```\n{}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_delete.txt"}
{"question": "모델 삭제를 위해 필요한 OAuth 권한 범위는 무엇인가요?", "answer": "모델 삭제를 위해 필요한 OAuth 권한 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_delete.txt"}
{"question": "모델 ID로 특정 모델 리소스를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 모델 리소스를 가져오려면 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/models/{modelId}\n```\n여기서 `{projectId}`, `{datasetId}`, `{modelId}`는 각각 요청하는 모델의 프로젝트 ID, 데이터셋 ID, 모델 ID로 대체해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_get.txt"}
{"question": "모델 리소스를 가져오기 위한 요청 본문은 어떻게 되나요?", "answer": "모델 리소스를 가져오기 위한 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n(빈 요청 본문)\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_get.txt"}
{"question": "모델 리소스를 가져오기 위해 필요한 권한 범위는 무엇인가요?", "answer": "모델 리소스를 가져오기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_get.txt"}
{"question": "모델 리소스를 가져오는 API 호출에서 필수로 제공해야 하는 경로 매개변수는 무엇인가요?", "answer": "모델 리소스를 가져오는 API 호출에서 필수로 제공해야 하는 경로 매개변수는 다음과 같습니다:\n- `projectId`: 요청하는 모델의 프로젝트 ID\n- `datasetId`: 요청하는 모델의 데이터셋 ID\n- `modelId`: 요청하는 모델의 모델 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_get.txt"}
{"question": "모델 리소스를 가져오는 API 호출이 성공했을 때 응답 본문은 어떤 형태인가요?", "answer": "모델 리소스를 가져오는 API 호출이 성공했을 때 응답 본문은 `Model` 인스턴스를 포함합니다. 즉, 응답 본문은 모델에 대한 정보를 담고 있는 구조체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_get.txt"}
{"question": "BigQuery에서 특정 데이터셋의 모든 모델을 나열하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 데이터셋의 모든 모델을 나열하려면 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/models\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_list.txt"}
{"question": "모델 목록을 요청할 때 필수로 포함해야 하는 파라미터는 무엇인가요?", "answer": "모델 목록을 요청할 때 필수로 포함해야 하는 파라미터는 `projectId`와 `datasetId`입니다. `projectId`는 모델을 나열할 프로젝트의 ID이고, `datasetId`는 모델을 나열할 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_list.txt"}
{"question": "모델 목록 요청 시 최대 결과 수를 제한하려면 어떤 쿼리 파라미터를 사용해야 하나요?", "answer": "모델 목록 요청 시 최대 결과 수를 제한하려면 `maxResults` 쿼리 파라미터를 사용해야 합니다. 이 파라미터는 한 페이지에서 반환할 최대 결과 수를 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_list.txt"}
{"question": "모델 목록을 요청한 후 다음 페이지의 결과를 요청하려면 어떻게 해야 하나요?", "answer": "모델 목록을 요청한 후 다음 페이지의 결과를 요청하려면 이전 호출에서 반환된 `nextPageToken`을 사용하여 요청해야 합니다. 이 토큰을 `pageToken` 쿼리 파라미터에 포함시켜야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_list.txt"}
{"question": "모델 목록을 요청하기 위해 필요한 권한은 무엇인가요?", "answer": "모델 목록을 요청하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_list.txt"}
{"question": "BigQuery에서 모델을 패치하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "모델을 패치하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPATCH https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/models/{modelId}\n```\n여기서 `{projectId}`, `{datasetId}`, `{modelId}`는 각각 패치할 모델의 프로젝트 ID, 데이터셋 ID, 모델 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_patch.txt"}
{"question": "모델 패치 요청 시 필요한 경로 매개변수는 무엇인가요?", "answer": "모델 패치 요청 시 필요한 경로 매개변수는 다음과 같습니다:\n- `projectId`: 패치할 모델의 프로젝트 ID (string, 필수)\n- `datasetId`: 패치할 모델의 데이터셋 ID (string, 필수)\n- `modelId`: 패치할 모델의 모델 ID (string, 필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_patch.txt"}
{"question": "모델 패치 요청의 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "모델 패치 요청의 본문에는 `Model` 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_patch.txt"}
{"question": "모델 패치 요청이 성공했을 때 응답 본문에는 어떤 내용이 포함되나요?", "answer": "모델 패치 요청이 성공했을 때 응답 본문에는 `Model` 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_patch.txt"}
{"question": "모델 패치 요청을 수행하기 위해 필요한 인증 범위는 무엇인가요?", "answer": "모델 패치 요청을 수행하기 위해 필요한 인증 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/models/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_models_patch.txt"}
{"question": "IAM 정책(Policy)에서 bindings의 역할은 무엇인가요?", "answer": "bindings는 하나 이상의 멤버(또는 주체)를 단일 역할(role)에 바인딩하는 역할을 합니다. 각 바인딩은 사용자 계정, 서비스 계정, Google 그룹 및 도메인(예: G Suite)과 같은 주체를 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책에서 조건(condition)을 사용하는 방법은 무엇인가요?", "answer": "조건은 리소스에 대한 접근을 허용하는 논리 표현식을 지정할 수 있습니다. 조건은 요청, 리소스 또는 두 가지 모두의 속성을 기반으로 제약을 추가할 수 있습니다. IAM 정책에서 조건을 지원하는 리소스에 대한 정보는 IAM 문서를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 version 필드는 어떤 역할을 하나요?", "answer": "version 필드는 정책의 형식을 지정합니다. 유효한 값은 0, 1, 3이며, 조건부 역할 바인딩을 포함하는 정책을 다루는 모든 작업은 반드시 version 3을 지정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "etag 필드는 IAM 정책에서 어떤 용도로 사용되나요?", "answer": "etag는 낙관적 동시성 제어를 위한 방법으로, 정책의 동시 업데이트가 서로 덮어쓰이지 않도록 돕습니다. setIamPolicy를 호출할 때 etag 필드를 포함해야 하며, 이를 생략하면 version 3 정책이 version 1 정책으로 덮어쓰여질 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 members 필드에 어떤 값이 포함될 수 있나요?", "answer": "members 필드는 Google Cloud 리소스에 접근을 요청하는 주체를 지정합니다. 포함될 수 있는 값으로는 allUsers, allAuthenticatedUsers, user:{emailid}, serviceAccount:{emailid}, group:{emailid}, domain:{domain} 등이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책에서 etag 필드를 사용하는 이유는 무엇인가요?", "answer": "etag 필드는 정책의 낙관적 동시성 제어(optimistic concurrency control)를 위해 사용됩니다. 이를 통해 정책의 동시 업데이트로 인한 덮어쓰기를 방지할 수 있습니다. getIamPolicy의 응답에서 etag가 반환되며, 시스템은 setIamPolicy 요청 시 이 etag를 포함시켜야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 bindings 필드에 포함될 수 있는 principal의 종류는 무엇인가요?", "answer": "bindings 필드에는 다음과 같은 principal이 포함될 수 있습니다: allUsers, allAuthenticatedUsers, user:{emailid}, serviceAccount:{emailid}, group:{emailid}, domain:{domain}, deleted:user:{emailid}?uid={uniqueid} 등. 각 principal은 IAM 정책에서 최대 1,500개까지 참조할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 condition 필드는 어떤 역할을 하나요?", "answer": "condition 필드는 특정 binding과 연관된 조건을 정의합니다. 이 조건이 true로 평가되면 해당 binding이 현재 요청에 적용됩니다. false로 평가되면 적용되지 않지만, 다른 role binding이 동일한 역할을 부여할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책에서 bindings의 최대 principal 수는 얼마인가요?", "answer": "IAM 정책의 bindings는 최대 1,500개의 principal을 참조할 수 있으며, 이 중 최대 250개는 Google 그룹이 될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 condition에서 사용하는 표현식의 문법은 무엇인가요?", "answer": "IAM 정책의 condition에서 사용하는 표현식은 Common Expression Language (CEL) 문법을 따릅니다. CEL은 C와 유사한 표현 언어로, 문법과 의미는 [CEL 문서](https://github.com/google/cel-spec)에서 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책에서 condition 필드의 Expr는 어떤 역할을 하나요?", "answer": "condition 필드의 Expr는 Common Expression Language (CEL) 구문으로 표현된 텍스트 표현을 나타냅니다. 이 표현식이 true로 평가되면, 해당 binding이 현재 요청에 적용됩니다. 반대로 false로 평가되면, 해당 binding은 현재 요청에 적용되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시는 무엇인가요?", "answer": "다음은 IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시입니다:\n\n```\ntitle: \"Summary size limit\"\ndescription: \"Determines if a summary is less than 100 chars\"\nexpression: \"document.summary.size() < 100\"\n```\n\n또 다른 예시는:\n```\ntitle: \"Requestor is owner\"\ndescription: \"Determines if requestor is the document owner\"\nexpression: \"document.owner == request.auth.claims.email\"\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 AuditConfig는 어떤 역할을 하나요?", "answer": "AuditConfig는 서비스에 대한 감사 구성을 지정합니다. 이 구성은 어떤 권한 유형이 기록되는지와 어떤 신원(identity)이 기록에서 면제되는지를 결정합니다. AuditConfig는 하나 이상의 AuditLogConfigs를 가져야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책에서 AuditConfig의 JSON 표현은 어떻게 되나요?", "answer": "IAM 정책에서 AuditConfig의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"service\": string,\n  \"auditLogConfigs\": [\n    {\n      object (AuditLogConfig)\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "IAM 정책의 AuditLogConfig는 어떤 정보를 포함하나요?", "answer": "AuditLogConfig는 권한 유형의 로깅 구성을 제공합니다. 예를 들어:\n\n```\n{\n  \"auditLogConfigs\": [\n    {\n      \"logType\": \"DATA_READ\",\n      \"exemptedMembers\": [\n        \"user:jose@example.com\"\n      ]\n    },\n    {\n      \"logType\": \"DATA_WRITE\"\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "Common Expression Language (CEL)에서 표현식의 예시는 무엇인가요?", "answer": "Common Expression Language (CEL)에서 표현식의 예시는 다음과 같습니다:\n\n예시 (비교):\n```\ntitle: \"Summary size limit\"\ndescription: \"Determines if a summary is less than 100 chars\"\nexpression: \"document.summary.size() < 100\"\n```\n\n예시 (동등성):\n```\ntitle: \"Requestor is owner\"\ndescription: \"Determines if requestor is the document owner\"\nexpression: \"document.owner == request.auth.claims.email\"\n```\n\n예시 (논리):\n```\ntitle: \"Public documents\"\ndescription: \"Determine whether the document should be publicly visible\"\nexpression: \"document.type != 'private' && document.type != 'internal'\"\n```\n\n예시 (데이터 조작):\n```\ntitle: \"Notification string\"\ndescription: \"Create a notification string with a timestamp.\"\nexpression: \"'New message received at ' + string(document.create_time)\"\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "AuditConfig의 역할은 무엇인가요?", "answer": "AuditConfig는 서비스에 대한 감사 구성을 지정합니다. 이 구성은 어떤 권한 유형이 기록되는지와 어떤 신원(identity)이 기록에서 면제되는지를 결정합니다. AuditConfig는 하나 이상의 AuditLogConfigs를 가져야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "AuditConfig의 JSON 표현은 어떻게 되나요?", "answer": "AuditConfig의 JSON 표현은 다음과 같습니다:\n```\n{\n  \"service\": string,\n  \"auditLogConfigs\": [\n    {\n      object (AuditLogConfig)\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "AuditLogConfig의 logType 필드는 어떤 역할을 하나요?", "answer": "AuditLogConfig의 logType 필드는 이 구성에서 활성화할 권한 유형을 지정합니다. 예를 들어, ADMIN_READ, DATA_WRITE, DATA_READ 등이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "AuditLogConfig에서 exemptedMembers 필드는 어떤 정보를 포함하나요?", "answer": "AuditLogConfig의 exemptedMembers 필드는 이 권한 유형에 대해 로깅을 발생시키지 않는 신원(identity)을 지정합니다. 이 필드는 Binding.members와 동일한 형식을 따릅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/Policy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_Policy.txt"}
{"question": "BigQuery에서 프로젝트를 참조할 때 필요한 필드는 무엇인가요?", "answer": "프로젝트를 참조할 때 필요한 필드는 'projectId'입니다. 이는 필수 필드로, 프로젝트의 ID를 나타냅니다. 이 ID는 숫자 ID 또는 할당된 ID일 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ProjectReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ProjectReference.txt"}
{"question": "ProjectReference의 JSON 표현은 어떻게 되나요?", "answer": "ProjectReference의 JSON 표현은 다음과 같습니다:\n```\n{\n  \"projectId\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ProjectReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ProjectReference.txt"}
{"question": "프로젝트 ID(projectId)는 어떤 형식으로 제공될 수 있나요?", "answer": "프로젝트 ID(projectId)는 숫자 ID 또는 할당된 ID 형식으로 제공될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ProjectReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ProjectReference.txt"}
{"question": "ProjectReference의 'projectId' 필드는 선택 사항인가요, 필수 사항인가요?", "answer": "'projectId' 필드는 필수 사항입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ProjectReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ProjectReference.txt"}
{"question": "BigQuery API에서 프로젝트를 참조할 때 JSON 구조는 어떻게 되나요?", "answer": "BigQuery API에서 프로젝트를 참조할 때의 JSON 구조는 다음과 같습니다:\n```\n{\n  \"projectId\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/ProjectReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_ProjectReference.txt"}
{"question": "BigQuery에서 특정 프로젝트의 서비스 계정(service account)을 가져오는 방법은 무엇인가요?", "answer": "특정 프로젝트의 서비스 계정을 가져오려면 `getServiceAccount` 메서드를 사용합니다. 이 메서드는 Google Cloud KMS와의 상호작용에 사용되는 프로젝트의 서비스 계정을 반환합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects.txt"}
{"question": "사용자가 권한을 가진 프로젝트 목록을 가져오는 방법은 무엇인가요?", "answer": "사용자가 권한을 가진 프로젝트 목록을 가져오려면 `list` 메서드를 사용합니다. 이 메서드는 사용자가 부여받은 모든 프로젝트 역할에 대한 프로젝트를 나열합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects.txt"}
{"question": "BigQuery의 projects 리소스에 대한 설명은 무엇인가요?", "answer": "BigQuery의 projects 리소스는 지속적인 데이터와 관련이 없습니다. 이 리소스는 프로젝트와 관련된 메서드를 통해 다양한 작업을 수행할 수 있도록 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects.txt"}
{"question": "BigQuery에서 프로젝트의 서비스 계정을 요청할 때 필요한 권한은 무엇인가요?", "answer": "서비스 계정을 요청하기 위해서는 해당 프로젝트에 대한 적절한 권한이 필요합니다. 이는 `getServiceAccount` 메서드를 호출할 때 요구됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects.txt"}
{"question": "BigQuery API에서 프로젝트 목록을 나열할 때 반환되는 데이터 구조는 어떻게 되나요?", "answer": "프로젝트 목록을 나열할 때 `list` 메서드는 사용자가 권한을 가진 프로젝트의 정보를 포함하는 응답을 반환합니다. 이 응답은 프로젝트의 ID, 이름 등과 같은 정보를 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects.txt"}
{"question": "BigQuery에서 프로젝트의 서비스 계정 이메일 주소를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "프로젝트의 서비스 계정 이메일 주소를 가져오려면 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/serviceAccount\n```\n여기서 `{projectId}`는 프로젝트의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/getServiceAccount"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_getServiceAccount.txt"}
{"question": "projects.getServiceAccount 메서드를 호출할 때 요청 본문은 어떻게 구성되나요?", "answer": "projects.getServiceAccount 메서드를 호출할 때 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n(빈 요청 본문)\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/getServiceAccount"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_getServiceAccount.txt"}
{"question": "projects.getServiceAccount 메서드의 성공적인 응답 구조는 어떻게 되나요?", "answer": "성공적인 응답 구조는 다음과 같은 JSON 형식으로 제공됩니다:\n\n```\n{\n  \"kind\": string,\n  \"email\": string\n}\n```\n여기서 `kind`는 응답의 리소스 유형을 나타내고, `email`은 서비스 계정의 이메일 주소입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/getServiceAccount"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_getServiceAccount.txt"}
{"question": "projects.getServiceAccount 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "projects.getServiceAccount 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/getServiceAccount"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_getServiceAccount.txt"}
{"question": "projects.getServiceAccount 메서드의 경로 매개변수로 어떤 값이 필요한가요?", "answer": "projects.getServiceAccount 메서드의 경로 매개변수로는 `projectId`가 필요합니다. 이 값은 필수이며, 프로젝트의 ID를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/getServiceAccount"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_getServiceAccount.txt"}
{"question": "BigQuery API를 사용하여 사용자가 접근할 수 있는 프로젝트 목록을 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "사용자는 다음과 같은 HTTP GET 요청을 사용하여 프로젝트 목록을 가져올 수 있습니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_list.txt"}
{"question": "projects.list 메서드의 응답에서 'projects' 필드는 어떤 정보를 포함하나요?", "answer": "응답의 'projects' 필드는 사용자가 최소한 READ 접근 권한을 가진 프로젝트의 정보를 포함합니다. 각 프로젝트는 다음과 같은 구조를 가집니다:\n\n```\n{\n  \"kind\": string,\n  \"id\": string,\n  \"numericId\": string,\n  \"projectReference\": {\n    object (ProjectReference)\n  },\n  \"friendlyName\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_list.txt"}
{"question": "projects.list 메서드에서 페이지네이션을 처리하기 위해 어떤 파라미터를 사용해야 하나요?", "answer": "페이지네이션을 처리하기 위해 'pageToken' 파라미터를 사용해야 합니다. 이전 호출에서 반환된 페이지 토큰을 사용하여 다음 페이지의 결과를 요청할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_list.txt"}
{"question": "projects.list 메서드의 'maxResults' 파라미터는 어떤 역할을 하나요?", "answer": "'maxResults' 파라미터는 한 페이지에 반환할 최대 프로젝트 수를 설정합니다. 이 파라미터가 설정되지 않으면 최대 50개의 결과가 반환됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_list.txt"}
{"question": "projects.list 메서드를 호출하기 위해 필요한 OAuth 스코프는 무엇인가요?", "answer": "이 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/projects/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_projects_list.txt"}
{"question": "QueryParameter의 JSON 표현에서 'name' 필드는 어떤 역할을 하나요?", "answer": "'name' 필드는 선택적이며, 설정되지 않은 경우 위치 매개변수(positional parameter)로 간주됩니다. 설정된 경우 쿼리 내에서 고유해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/QueryParameter"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_QueryParameter.txt"}
{"question": "QueryParameterType의 'type' 필드는 어떤 의미를 가지며, 필수인가요?", "answer": "'type' 필드는 필수이며, 이 필드는 해당 매개변수의 최상위 유형을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/QueryParameter"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_QueryParameter.txt"}
{"question": "QueryParameterValue의 'structValues' 필드는 어떤 구조를 가지며, 어떻게 사용되나요?", "answer": "'structValues' 필드는 키-값 쌍(map)으로 구성되어 있으며, 각 키는 문자열이고 값은 QueryParameterValue 객체입니다. 이는 구조체 필드 값을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/QueryParameter"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_QueryParameter.txt"}
{"question": "RangeValue의 'start'와 'end' 필드는 어떤 정보를 담고 있나요?", "answer": "'start' 필드는 범위의 시작 값을 나타내며, 'end' 필드는 범위의 끝 값을 나타냅니다. 값이 누락된 경우 각각 무한정 시작 또는 끝을 의미합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/QueryParameter"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_QueryParameter.txt"}
{"question": "QueryParameterType의 'arrayType' 필드는 어떤 경우에 사용되며, 필수인가요?", "answer": "'arrayType' 필드는 선택적이며, 이 매개변수가 배열인 경우 배열 요소의 유형을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/QueryParameter"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_QueryParameter.txt"}
{"question": "NUMERIC 또는 BIGNUMERIC 값을 저장할 때 사용할 수 있는 반올림 모드(Rounding Mode)에는 어떤 것들이 있나요?", "answer": "NUMERIC 또는 BIGNUMERIC 값을 저장할 때 사용할 수 있는 반올림 모드는 다음과 같습니다:\n\n- ROUNDING_MODE_UNSPECIFIED: 지정되지 않은 경우 기본적으로 ROUND_HALF_AWAY_FROM_ZERO를 사용합니다.\n- ROUND_HALF_AWAY_FROM_ZERO: 반올림할 때 반값을 0에서 멀어지도록 반올림합니다. 예를 들어, Scale이 0일 때 1.1, 1.2, 1.3, 1.4는 1로 반올림되고, 1.5, 1.6, 1.7, 1.8, 1.9는 2로 반올림됩니다.\n- ROUND_HALF_EVEN: 반올림할 때 반값을 가장 가까운 짝수로 반올림합니다. 예를 들어, Scale이 0일 때 1.1, 1.2, 1.3, 1.4는 1로 반올림되고, 1.5는 2로 반올림되며, 2.5도 2로 반올림됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/RoundingMode"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_RoundingMode.txt"}
{"question": "ROUND_HALF_AWAY_FROM_ZERO 반올림 모드의 동작 방식은 어떻게 되나요?", "answer": "ROUND_HALF_AWAY_FROM_ZERO 반올림 모드는 반올림할 때 반값을 0에서 멀어지도록 반올림합니다. 예를 들어, Scale이 0일 때 다음과 같은 값들이 반올림됩니다:\n\n- 1.1, 1.2, 1.3, 1.4 => 1\n- 1.5, 1.6, 1.7, 1.8, 1.9 => 2", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/RoundingMode"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_RoundingMode.txt"}
{"question": "ROUND_HALF_EVEN 반올림 모드의 동작 방식은 어떻게 되나요?", "answer": "ROUND_HALF_EVEN 반올림 모드는 반올림할 때 반값을 가장 가까운 짝수로 반올림합니다. 예를 들어, Scale이 0일 때 다음과 같은 값들이 반올림됩니다:\n\n- 1.1, 1.2, 1.3, 1.4 => 1\n- 1.5 => 2\n- 1.6, 1.7, 1.8, 1.9 => 2\n- 2.5 => 2", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/RoundingMode"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_RoundingMode.txt"}
{"question": "반올림 모드(Rounding Mode)를 지정하지 않으면 어떤 값이 사용되나요?", "answer": "반올림 모드(Rounding Mode)를 지정하지 않으면 기본적으로 ROUND_HALF_AWAY_FROM_ZERO가 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/RoundingMode"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_RoundingMode.txt"}
{"question": "NUMERIC 또는 BIGNUMERIC 값을 저장할 때 반올림 모드를 설정하는 방법은 무엇인가요?", "answer": "NUMERIC 또는 BIGNUMERIC 값을 저장할 때 반올림 모드를 설정하는 방법에 대한 구체적인 내용은 문서에 명시되어 있지 않습니다. 반올림 모드는 사용자가 선택할 수 있는 옵션으로 제공됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/RoundingMode"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_RoundingMode.txt"}
{"question": "BigQuery에서 사용자 정의 함수의 정의 본문(definitionBody)은 어떻게 작성하나요?", "answer": "사용자 정의 함수의 정의 본문(definitionBody)은 함수의 AS 절에 있는 표현식입니다. SQL 언어의 경우, 정의 본문은 괄호 안의 부분(괄호를 제외한 부분)입니다. 예를 들어, 다음과 같이 작성할 수 있습니다:\n\n```sql\nCREATE FUNCTION JoinLines(x string, y string) as (concat(x, \"\\n\", y))\n```\n이 경우, 정의 본문은 `concat(x, \"\\n\", y)`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 정의된 루틴의 반환 타입(returnType)은 어떻게 설정하나요?", "answer": "반환 타입(returnType)은 언어가 'SQL'인 경우 선택 사항이며, 그렇지 않은 경우 필수입니다. 반환 타입이 설정되지 않은 경우, 정의 본문(definitionBody)에서 쿼리 시간에 반환 타입이 유추됩니다. 예를 들어, 다음과 같이 함수를 생성할 수 있습니다:\n\n```sql\nCREATE FUNCTION Add(x FLOAT64, y FLOAT64) RETURNS FLOAT64 AS (x + y);\n```\n이 경우, `returnType`은 `{typeKind: \"FLOAT64\"}`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 strictMode 옵션은 무엇이며, 어떻게 설정하나요?", "answer": "strictMode는 루틴의 오류를 잡기 위해 사용되는 옵션입니다. 이 옵션이 TRUE로 설정되면, 루틴 본문에서 존재하지 않는 테이블이나 열과 같은 오류를 추가로 체크합니다. 기본값은 TRUE이며, FALSE로 설정하면 구문만 체크합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n\"strictMode\": true\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 arguments 필드는 어떤 정보를 포함하나요?", "answer": "arguments 필드는 함수 또는 저장 프로시저의 입력/출력 인수를 포함합니다. 각 인수는 이름(name), 인수 종류(argumentKind), 모드(mode), 데이터 타입(dataType)으로 구성됩니다. 예를 들어, 다음과 같이 정의할 수 있습니다:\n\n```json\n{\n  \"name\": \"x\",\n  \"argumentKind\": \"FIXED_TYPE\",\n  \"mode\": \"IN\",\n  \"dataType\": {\n    \"typeKind\": \"FLOAT64\"\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 routineReference 필드는 어떤 정보를 포함하나요?", "answer": "routineReference 필드는 루틴의 ID를 설명하는 정보를 포함합니다. 이 필드는 projectId, datasetId, routineId로 구성됩니다. 예를 들어, 다음과 같이 정의할 수 있습니다:\n\n```json\n{\n  \"projectId\": \"my_project\",\n  \"datasetId\": \"my_dataset\",\n  \"routineId\": \"my_routine\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 definitionBody 필드는 어떤 정보를 포함하나요?", "answer": "definitionBody 필드는 루틴의 본문을 포함합니다. 함수의 경우 AS 절에 있는 표현식입니다. 예를 들어, 다음과 같은 문으로 생성된 함수의 경우: \n```sql\nCREATE FUNCTION JoinLines(x string, y string) as (concat(x, \"\\n\", y))\n```\ndefinitionBody는 concat(x, \"\\n\", y)입니다. (\\n은 줄바꿈으로 대체됩니다.)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 strictMode 옵션은 어떻게 작동하나요?", "answer": "strictMode는 많은 일반 오류를 잡기 위해 사용됩니다. strictMode가 TRUE로 설정되면, 루틴 본문은 존재하지 않는 테이블이나 열과 같은 오류에 대해 추가로 검사됩니다. 만약 strictMode가 FALSE로 설정되면, 루틴 본문은 구문만 검사됩니다. 기본값은 TRUE입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 importedLibraries 필드는 어떤 용도로 사용되나요?", "answer": "importedLibraries 필드는 language가 'JAVASCRIPT'인 경우, 가져온 JAVASCRIPT 라이브러리의 경로를 저장하는 선택적 필드입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 RoutineReference 필드는 어떤 정보를 포함하나요?", "answer": "RoutineReference 필드는 루틴의 ID 경로를 포함합니다. JSON 표현은 다음과 같습니다: \n```json\n{\n  \"projectId\": string,\n  \"datasetId\": string,\n  \"routineId\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 dataGovernanceType 필드는 어떤 역할을 하나요?", "answer": "dataGovernanceType 필드는 DATA_MASKING으로 설정될 경우, 함수가 검증되고 마스킹 함수로 사용 가능하게 됩니다. 자세한 내용은 사용자 정의 마스킹 루틴 생성(Create custom masking routines)을 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 argument 필드는 어떤 정보를 포함하나요?", "answer": "argument 필드는 함수 또는 저장 프로시저의 입력/출력 인수를 나타냅니다. JSON 표현은 다음과 같습니다.\n\n```\n{\n  \"name\": string,\n  \"argumentKind\": enum (ArgumentKind),\n  \"mode\": enum (Mode),\n  \"dataType\": {\n    object (StandardSqlDataType [https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType])\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 ArgumentKind 열거형(enum)은 어떤 값을 가질 수 있나요?", "answer": "ArgumentKind 열거형은 다음과 같은 값을 가질 수 있습니다:\n- ARGUMENT_KIND_UNSPECIFIED: 기본값입니다.\n- FIXED_TYPE: 인수가 완전히 지정된 타입의 변수입니다. 구조체나 배열일 수 있지만 테이블은 아닙니다.\n- ANY_TYPE: 인수가 구조체나 배열을 포함한 모든 타입일 수 있지만 테이블은 아닙니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 Mode 열거형(enum)은 어떤 값을 가질 수 있나요?", "answer": "Mode 열거형은 다음과 같은 값을 가질 수 있습니다:\n- MODE_UNSPECIFIED: 기본값입니다.\n- IN: 인수는 입력 전용입니다.\n- OUT: 인수는 출력 전용입니다.\n- INOUT: 인수는 입력 및 출력 모두입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 루틴의 StandardSqlTableType 필드는 어떤 정보를 포함하나요?", "answer": "StandardSqlTableType 필드는 테이블 타입을 나타내며, JSON 표현은 다음과 같습니다.\n\n```\n{\n  \"columns\": [\n    {\n      object (StandardSqlField [https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField])\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 PythonOptions 필드는 어떤 정보를 포함하나요?", "answer": "PythonOptions 필드는 사용자 정의 Python 함수에 대한 옵션을 포함하며, JSON 표현은 다음과 같습니다.\n\n```\n{\n  \"entryPoint\": string,\n  \"packages\": [\n    string\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 사용자 정의 Spark 루틴의 SparkOptions 필드는 어떤 정보를 포함하나요?", "answer": "SparkOptions 필드는 사용자 정의 Spark 루틴에 대한 옵션을 포함합니다. JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"connection\": string,\n  \"runtimeVersion\": string,\n  \"containerImage\": string,\n  \"properties\": {\n    string: string,\n    ...\n  },\n  \"mainFileUri\": string,\n  \"pyFileUris\": [\n    string\n  ],\n  \"jarUris\": [\n    string\n  ],\n  \"fileUris\": [\n    string\n  ],\n  \"archiveUris\": [\n    string\n  ],\n  \"mainClass\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 사용자 정의 Python 함수의 PythonOptions 필드는 어떤 정보를 포함하나요?", "answer": "PythonOptions 필드는 사용자 정의 Python 함수에 대한 옵션을 포함합니다. JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"entryPoint\": string,\n  \"packages\": [\n    string\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 ExternalRuntimeOptions 필드는 어떤 정보를 포함하나요?", "answer": "ExternalRuntimeOptions 필드는 외부 시스템의 런타임에 대한 옵션을 포함합니다. JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"containerMemory\": string,\n  \"containerCpu\": number,\n  \"runtimeConnection\": string,\n  \"maxBatchingRows\": string,\n  \"runtimeVersion\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 maxBatchingRows 필드는 어떤 역할을 하나요?", "answer": "maxBatchingRows 필드는 원격 서비스에 전송되는 각 배치의 최대 행 수를 정의합니다. 값이 없거나 0인 경우, BigQuery는 배치의 행 수를 동적으로 결정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 DataGovernanceType 필드는 어떤 값을 가질 수 있나요?", "answer": "DataGovernanceType 필드는 데이터 거버넌스 유형 값을 가집니다. 지원되는 값은 DATA_MASKING입니다. 열거형(enum) 값은 다음과 같습니다:\n- DATA_GOVERNANCE_TYPE_UNSPECIFIED: 데이터 거버넌스 유형이 지정되지 않음.\n- DATA_MASKING: 데이터 거버넌스 유형이 데이터 마스킹.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines.txt"}
{"question": "BigQuery에서 특정 루틴을 삭제하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 루틴을 삭제하려면 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nDELETE https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}\n```\n여기서 `{projectId}`, `{datasetId}`, `{routineId}`는 각각 삭제할 루틴의 프로젝트 ID, 데이터셋 ID, 루틴 ID로 대체해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_delete.txt"}
{"question": "루틴 삭제 요청 시 필요한 경로 파라미터는 무엇인가요?", "answer": "루틴 삭제 요청 시 필요한 경로 파라미터는 다음과 같습니다:\n- `projectId`: 삭제할 루틴의 프로젝트 ID (string, 필수)\n- `datasetId`: 삭제할 루틴의 데이터셋 ID (string, 필수)\n- `routineId`: 삭제할 루틴의 루틴 ID (string, 필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_delete.txt"}
{"question": "루틴 삭제 요청의 요청 본문은 어떻게 구성되나요?", "answer": "루틴 삭제 요청의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n(빈 요청 본문)\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_delete.txt"}
{"question": "루틴 삭제 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "루틴 삭제 요청이 성공적으로 처리되면 응답 본문은 빈 JSON 객체입니다. 즉, 응답은 다음과 같습니다:\n\n```\n{}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_delete.txt"}
{"question": "루틴 삭제를 위해 필요한 인증 범위는 무엇인가요?", "answer": "루틴 삭제를 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_delete.txt"}
{"question": "routines.get 메서드를 사용하여 특정 루틴을 가져오려면 어떤 HTTP 요청을 보내야 하나요?", "answer": "특정 루틴 리소스를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 보내야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}\n```\n여기서 `{projectId}`, `{datasetId}`, `{routineId}`는 각각 요청하는 루틴의 프로젝트 ID, 데이터셋 ID, 루틴 ID로 대체되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_get.txt"}
{"question": "routines.get 메서드에서 사용되는 필수 경로 매개변수는 무엇인가요?", "answer": "routines.get 메서드에서 사용되는 필수 경로 매개변수는 다음과 같습니다:\n- `projectId`: 요청하는 루틴의 프로젝트 ID\n- `datasetId`: 요청하는 루틴의 데이터셋 ID\n- `routineId`: 요청하는 루틴의 루틴 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_get.txt"}
{"question": "routines.get 메서드의 쿼리 매개변수 readMask는 어떤 역할을 하나요?", "answer": "쿼리 매개변수 `readMask`는 응답에서 반환할 루틴 필드를 지정하는 역할을 합니다. 설정할 경우, 필드 마스크에 있는 루틴 필드만 응답으로 반환됩니다. 설정하지 않으면 모든 루틴 필드가 반환됩니다. 예를 들어, `user.displayName,photo`와 같은 형식으로 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_get.txt"}
{"question": "routines.get 메서드를 호출할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "routines.get 메서드를 호출할 때 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 포함하지 않아야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_get.txt"}
{"question": "routines.get 메서드를 사용하기 위한 인증 범위는 무엇인가요?", "answer": "routines.get 메서드를 사용하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n- `https://www.googleapis.com/auth/bigquery.readonly`\n- `https://www.googleapis.com/auth/cloud-platform.read-only`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_get.txt"}
{"question": "BigQuery에서 새로운 루틴(routine)을 생성하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "새로운 루틴을 생성하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines\n```\n여기서 `{projectId}`는 새로운 루틴의 프로젝트 ID이고, `{datasetId}`는 새로운 루틴의 데이터셋 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_insert.txt"}
{"question": "루틴(routine) 생성 요청 시 필요한 파라미터는 무엇인가요?", "answer": "루틴 생성 요청 시 필요한 파라미터는 다음과 같습니다:\n- `projectId`: 새로운 루틴의 프로젝트 ID (string, 필수)\n- `datasetId`: 새로운 루틴의 데이터셋 ID (string, 필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_insert.txt"}
{"question": "루틴(routine) 생성 요청의 본문(request body)에는 어떤 내용이 포함되나요?", "answer": "루틴 생성 요청의 본문(request body)에는 `Routine`의 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_insert.txt"}
{"question": "루틴(routine) 생성 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "루틴 생성 요청이 성공적으로 처리되면, 응답 본문(response body)에는 새로 생성된 `Routine`의 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_insert.txt"}
{"question": "루틴(routine) 생성 요청을 수행하기 위한 권한은 어떻게 설정하나요?", "answer": "루틴 생성 요청을 수행하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_insert.txt"}
{"question": "BigQuery에서 특정 데이터셋의 모든 루틴을 나열하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 데이터셋의 모든 루틴을 나열하려면 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_list.txt"}
{"question": "routines.list 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?", "answer": "routines.list 메서드에서 사용할 수 있는 쿼리 파라미터는 다음과 같습니다:\n- `maxResults`: 한 페이지에서 반환할 최대 결과 수.\n- `pageToken`: 이전 호출에서 반환된 페이지 토큰으로, 다음 페이지의 결과를 요청할 때 사용.\n- `readMask`: 반환할 루틴 필드를 지정하는 필드 마스크.\n- `filter`: 특정 조건에 맞는 루틴만 반환하도록 필터링.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_list.txt"}
{"question": "routines.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "routines.list 메서드의 응답 본문 구조는 다음과 같습니다:\n\n```\n{\n  \"routines\": [\n    {\n      object (Routine)\n    }\n  ],\n  \"nextPageToken\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_list.txt"}
{"question": "routines.list 메서드를 호출할 때 필요한 권한은 무엇인가요?", "answer": "routines.list 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n- `https://www.googleapis.com/auth/bigquery.readonly`\n- `https://www.googleapis.com/auth/cloud-platform.read-only`", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_list.txt"}
{"question": "routines.list 메서드에서 readMask 파라미터를 설정하면 어떤 필드가 반환되나요?", "answer": "readMask 파라미터를 설정하면 요청에서 지정한 루틴 필드와 함께 `projectId`, `datasetId`, `routineId`가 반환됩니다. 설정하지 않으면 다음 필드가 반환됩니다: `etag`, `projectId`, `datasetId`, `routineId`, `routineType`, `creationTime`, `lastModifiedTime`, `language`, `remoteFunctionOptions`.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_list.txt"}
{"question": "routines.update 메서드를 사용하여 기존 루틴을 업데이트할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "routines.update 메서드를 사용하여 기존 루틴을 업데이트할 때 필요한 경로 매개변수는 다음과 같습니다:\n- projectId: 업데이트할 루틴의 프로젝트 ID\n- datasetId: 업데이트할 루틴의 데이터셋 ID\n- routineId: 업데이트할 루틴의 루틴 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_update.txt"}
{"question": "routines.update 메서드의 HTTP 요청 형식은 어떻게 되나요?", "answer": "routines.update 메서드의 HTTP 요청 형식은 다음과 같습니다:\n```\nPUT https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_update.txt"}
{"question": "routines.update 메서드의 요청 본문에는 어떤 정보가 포함되어야 하나요?", "answer": "routines.update 메서드의 요청 본문에는 Routine의 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_update.txt"}
{"question": "routines.update 메서드가 성공적으로 실행되면 응답 본문에는 어떤 정보가 포함되나요?", "answer": "routines.update 메서드가 성공적으로 실행되면 응답 본문에는 Routine의 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_update.txt"}
{"question": "routines.update 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "routines.update 메서드를 호출하기 위해 필요한 OAuth 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_routines_update.txt"}
{"question": "RowAccessPolicy의 JSON 표현에서 'etag' 필드는 무엇을 나타내나요?", "answer": "'etag' 필드는 이 리소스의 해시를 나타내며, 출력 전용입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies.txt"}
{"question": "RowAccessPolicyReference의 'policyId' 필드에 대한 제약 조건은 무엇인가요?", "answer": "'policyId' 필드는 반드시 문자(a-z, A-Z), 숫자(0-9) 또는 밑줄(_)만 포함해야 하며, 최대 길이는 256자입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies.txt"}
{"question": "RowAccessPolicy의 'filterPredicate' 필드는 어떤 형식의 값을 가져야 하나요?", "answer": "'filterPredicate' 필드는 SQL 불리언 표현을 가져야 하며, SELECT 쿼리의 WHERE 절과 유사한 형식입니다. 다른 테이블, 루틴 및 임시 함수에 대한 참조는 지원되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies.txt"}
{"question": "RowAccessPolicy의 'creationTime' 필드는 어떤 정보를 제공하나요?", "answer": "'creationTime' 필드는 이 행 접근 정책이 생성된 시간을 밀리초 단위의 타임스탬프 형식으로 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies.txt"}
{"question": "RowAccessPolicy의 'lastModifiedTime' 필드는 어떤 정보를 나타내나요?", "answer": "'lastModifiedTime' 필드는 이 행 접근 정책이 마지막으로 수정된 시간을 밀리초 단위의 타임스탬프 형식으로 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies.txt"}
{"question": "rowAccessPolicies.getIamPolicy 메서드를 사용하여 리소스의 액세스 제어 정책을 가져오는 방법은 무엇인가요?", "answer": "rowAccessPolicies.getIamPolicy 메서드를 사용하여 리소스의 액세스 제어 정책을 가져오려면, 다음과 같은 HTTP POST 요청을 사용해야 합니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/{resource=projects/*/datasets/*/tables/*/rowAccessPolicies/*}:getIamPolicy\n```\n여기서 {resource}는 요청하는 정책의 리소스를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_getIamPolicy.txt"}
{"question": "rowAccessPolicies.getIamPolicy 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "rowAccessPolicies.getIamPolicy 메서드의 요청 본문은 다음과 같은 JSON 구조를 가집니다:\n\n```\n{\n  \"options\": {\n    object (GetPolicyOptions)\n  }\n}\n```\n여기서 options 필드는 선택적이며, GetPolicyOptions 객체를 사용하여 추가 옵션을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_getIamPolicy.txt"}
{"question": "rowAccessPolicies.getIamPolicy 메서드의 응답 본문은 어떤 형식을 가지나요?", "answer": "rowAccessPolicies.getIamPolicy 메서드가 성공적으로 실행되면, 응답 본문은 Policy 객체의 인스턴스를 포함합니다. 이 객체는 리소스에 대한 액세스 제어 정책을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_getIamPolicy.txt"}
{"question": "rowAccessPolicies.getIamPolicy 메서드를 호출하기 위한 권한 범위는 무엇인가요?", "answer": "rowAccessPolicies.getIamPolicy 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_getIamPolicy.txt"}
{"question": "rowAccessPolicies.getIamPolicy 메서드에서 resource 파라미터의 값은 어떻게 설정하나요?", "answer": "resource 파라미터는 요청하는 정책의 리소스를 나타내며, 다음과 같은 형식으로 설정해야 합니다:\n```\nprojects/*/datasets/*/tables/*/rowAccessPolicies/*\n```\n여기서 각 '*'는 해당 리소스의 ID로 대체되어야 합니다. 적절한 값에 대한 자세한 내용은 리소스 이름(Resource names) 문서를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_getIamPolicy.txt"}
{"question": "rowAccessPolicies.list 메서드를 사용하여 특정 테이블의 행 접근 정책을 나열하려면 어떤 HTTP 요청을 보내야 하나요?", "answer": "다음과 같은 HTTP GET 요청을 보내야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/rowAccessPolicies\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_list.txt"}
{"question": "rowAccessPolicies.list 메서드의 요청에 필요한 경로 매개변수는 무엇인가요?", "answer": "요청에 필요한 경로 매개변수는 다음과 같습니다:\n- projectId: 행 접근 정책을 나열할 프로젝트 ID\n- datasetId: 행 접근 정책을 나열할 데이터셋 ID\n- tableId: 행 접근 정책을 나열할 테이블 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_list.txt"}
{"question": "rowAccessPolicies.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "응답 본문은 다음과 같은 구조를 가집니다:\n\n```\n{\n  \"rowAccessPolicies\": [\n    {\n      object (RowAccessPolicy)\n    }\n  ],\n  \"nextPageToken\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_list.txt"}
{"question": "rowAccessPolicies.list 메서드를 호출할 때 사용할 수 있는 쿼리 매개변수는 무엇인가요?", "answer": "다음과 같은 쿼리 매개변수를 사용할 수 있습니다:\n- pageToken: 이전 호출에서 반환된 페이지 토큰으로, 다음 페이지의 결과를 요청할 때 사용\n- pageSize: 단일 응답 페이지에서 반환할 최대 결과 수", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_list.txt"}
{"question": "rowAccessPolicies.list 메서드를 호출하기 위해 필요한 인증 범위는 무엇인가요?", "answer": "다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_list.txt"}
{"question": "rowAccessPolicies.testIamPermissions 메서드를 사용하여 어떤 정보를 얻을 수 있나요?", "answer": "rowAccessPolicies.testIamPermissions 메서드는 호출자가 지정된 리소스에 대해 가지고 있는 권한을 반환합니다. 리소스가 존재하지 않는 경우, NOT_FOUND 오류 대신 빈 권한 집합이 반환됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_testIamPermissions.txt"}
{"question": "rowAccessPolicies.testIamPermissions 메서드의 HTTP 요청 형식은 어떻게 되나요?", "answer": "HTTP 요청 형식은 다음과 같습니다:\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/{resource=projects/*/datasets/*/tables/*/rowAccessPolicies/*}:testIamPermissions\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_testIamPermissions.txt"}
{"question": "rowAccessPolicies.testIamPermissions 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "요청 본문은 다음과 같은 구조를 가집니다:\n```\n{\n  \"permissions\": [\n    string\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_testIamPermissions.txt"}
{"question": "rowAccessPolicies.testIamPermissions 메서드에서 사용할 수 있는 권한의 형식은 무엇인가요?", "answer": "permissions 필드는 리소스에 대해 확인할 권한의 집합을 포함합니다. 와일드카드(예: *, storage.*)가 포함된 권한은 허용되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_testIamPermissions.txt"}
{"question": "rowAccessPolicies.testIamPermissions 메서드를 호출하기 위해 필요한 인증 범위는 무엇인가요?", "answer": "이 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/rowAccessPolicies/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_rowAccessPolicies_testIamPermissions.txt"}
{"question": "SessionInfo 리소스에서 sessionId 필드는 어떤 정보를 나타내나요?", "answer": "sessionId 필드(sessionId)는 세션의 ID를 나타내며, 출력 전용입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/SessionInfo"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_SessionInfo.txt"}
{"question": "SessionInfo 리소스의 JSON 표현은 어떻게 되나요?", "answer": "SessionInfo 리소스의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"sessionId\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/SessionInfo"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_SessionInfo.txt"}
{"question": "SessionInfo 리소스에서 sessionId 필드의 데이터 타입은 무엇인가요?", "answer": "sessionId 필드(sessionId)의 데이터 타입은 string입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/SessionInfo"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_SessionInfo.txt"}
{"question": "SessionInfo 리소스의 주요 목적은 무엇인가요?", "answer": "SessionInfo 리소스는 세션과 관련된 정보를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/SessionInfo"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_SessionInfo.txt"}
{"question": "SessionInfo 리소스의 sessionId 필드는 언제 사용되나요?", "answer": "sessionId 필드(sessionId)는 세션의 ID를 필요로 하는 상황에서 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/SessionInfo"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_SessionInfo.txt"}
{"question": "StandardSqlDataType에서 ARRAY 타입을 정의하는 방법은 무엇인가요?", "answer": "ARRAY 타입은 다음과 같이 정의됩니다:\n\n```\n{\n  \"typeKind\": \"ARRAY\",\n  \"arrayElementType\": {\"typeKind\": \"STRING\"}\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlDataType.txt"}
{"question": "STRUCT 타입을 정의할 때 필요한 필드는 무엇인가요?", "answer": "STRUCT 타입은 다음과 같이 정의되며, 필드는 'fields' 배열에 포함됩니다:\n\n```\n{\n  \"typeKind\": \"STRUCT\",\n  \"structType\":\n  {\n    \"fields\":\n    [\n      {\n        \"name\": \"x\",\n        \"type\": {\"typeKind\": \"STRING\"}\n      },\n      {\n        \"name\": \"y\",\n        \"type\":\n        {\n          \"typeKind\": \"ARRAY\",\n          \"arrayElementType\": {\"typeKind\": \"DATE\"}\n        }\n      }\n    ]\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlDataType.txt"}
{"question": "RANGE 타입의 정의는 어떻게 되나요?", "answer": "RANGE 타입은 다음과 같이 정의됩니다:\n\n```\n{\n  \"typeKind\": \"RANGE\",\n  \"rangeElementType\": {\"typeKind\": \"DATE\"}\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlDataType.txt"}
{"question": "StandardSqlDataType의 필드 중 'typeKind'의 역할은 무엇인가요?", "answer": "'typeKind' 필드는 이 필드의 최상위 타입을 나타내며, GoogleSQL 데이터 타입(예: \"INT64\", \"DATE\", \"ARRAY\") 중 하나가 될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlDataType.txt"}
{"question": "StandardSqlDataType의 'sub_type' 필드는 어떤 경우에 사용되나요?", "answer": "'sub_type' 필드는 복합 타입의 경우에 사용되며, 'arrayElementType', 'structType', 'rangeElementType' 중 하나의 정보를 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlDataType.txt"}
{"question": "StandardSqlField의 JSON 표현은 어떻게 되나요?", "answer": "StandardSqlField의 JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"name\": string,\n  \"type\": {\n    object (StandardSqlDataType)\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlField.txt"}
{"question": "StandardSqlField의 'name' 필드는 어떤 용도로 사용되나요?", "answer": "'name' 필드는 이 필드의 이름을 나타내며, 선택적입니다. struct 필드의 경우 생략될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlField.txt"}
{"question": "StandardSqlField의 'type' 필드는 무엇을 나타내나요?", "answer": "'type' 필드는 이 매개변수의 유형을 나타내며, 선택적입니다. 명시적으로 지정되지 않은 경우에는 생략될 수 있습니다. 예를 들어, CREATE FUNCTION 문에서는 반환 유형을 생략할 수 있으며, 이 경우 출력 매개변수는 'type' 필드를 가지지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlField.txt"}
{"question": "StandardSqlField에서 'type' 필드가 생략될 수 있는 경우는 어떤 경우인가요?", "answer": "'type' 필드는 명시적으로 지정되지 않은 경우에 생략될 수 있습니다. 예를 들어, CREATE FUNCTION 문에서 반환 유형을 생략할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlField.txt"}
{"question": "StandardSqlField의 'type' 필드에 대한 데이터 유형은 어디에서 확인할 수 있나요?", "answer": "'type' 필드는 StandardSqlDataType 객체를 참조하며, 이에 대한 자세한 내용은 [StandardSqlDataType](https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlDataType) 문서에서 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_StandardSqlField.txt"}
{"question": "BigQuery에서 데이터를 한 번에 여러 레코드로 삽입하는 방법은 무엇인가요?", "answer": "BigQuery에서는 `insertAll` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll)를 사용하여 데이터를 한 번에 여러 레코드로 삽입할 수 있습니다. 이 메서드는 로드 작업을 실행할 필요 없이 데이터를 BigQuery로 스트리밍합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata.txt"}
{"question": "BigQuery 테이블의 내용을 행 단위로 나열하는 방법은 무엇인가요?", "answer": "BigQuery에서는 `list` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list)를 사용하여 테이블의 내용을 행 단위로 나열할 수 있습니다. 이 메서드를 호출하면 테이블의 모든 행을 반환합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata.txt"}
{"question": "BigQuery의 tabledata 리소스에 대한 설명은 무엇인가요?", "answer": "BigQuery의 `tabledata` 리소스는 지속적인 데이터와 관련이 없으며, 데이터 삽입 및 목록화와 같은 작업을 수행하는 메서드를 제공합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata.txt"}
{"question": "BigQuery에서 `insertAll` 메서드를 사용할 때의 장점은 무엇인가요?", "answer": "`insertAll` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll)는 로드 작업을 실행할 필요 없이 데이터를 한 레코드씩 스트리밍할 수 있어, 실시간 데이터 처리가 가능합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata.txt"}
{"question": "BigQuery의 `list` 메서드를 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "`list` 메서드(https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list)를 사용할 때는 반환되는 데이터의 양이 많을 경우 페이지네이션을 고려해야 하며, 쿼터 제한에 유의해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata.txt"}
{"question": "BigQuery에 데이터를 스트리밍하기 위해 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "데이터를 BigQuery에 스트리밍하기 위해서는 다음과 같은 HTTP POST 요청을 사용해야 합니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll\n```\n여기서 `{projectId}`, `{datasetId}`, `{tableId}`는 각각 목적지의 프로젝트 ID, 데이터셋 ID, 테이블 ID를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_insertAll.txt"}
{"question": "요청 본문에서 'rows' 필드는 어떤 구조를 가져야 하나요?", "answer": "요청 본문에서 'rows' 필드는 다음과 같은 구조를 가져야 합니다:\n\n```\n\"rows\": [\n  {\n    \"insertId\": string,\n    \"json\": {\n      object\n    }\n  }\n]\n```\n각각의 행은 'insertId'와 'json' 객체를 포함해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_insertAll.txt"}
{"question": "'skipInvalidRows'와 'ignoreUnknownValues'의 기본값은 무엇인가요?", "answer": "'skipInvalidRows'의 기본값은 false로, 유효하지 않은 행이 존재할 경우 전체 요청이 실패합니다. 'ignoreUnknownValues'의 기본값도 false로, 스키마와 일치하지 않는 값을 포함한 행은 오류로 처리됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_insertAll.txt"}
{"question": "응답 본문에서 'insertErrors' 필드는 어떤 정보를 포함하나요?", "answer": "'insertErrors' 필드는 요청 처리 중 발생한 특정 오류에 대한 정보를 포함합니다. 각 오류는 다음과 같은 구조를 가집니다:\n\n```\n\"insertErrors\": [\n  {\n    \"index\": integer,\n    \"errors\": [\n      {\n        object (ErrorProto)\n      }\n    ]\n  }\n]\n```\n여기서 'index'는 오류가 발생한 행의 인덱스를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_insertAll.txt"}
{"question": "BigQuery에 데이터를 삽입하기 위해 필요한 OAuth 스코프는 무엇인가요?", "answer": "BigQuery에 데이터를 삽입하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.insertdata\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/insertAll"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_insertAll.txt"}
{"question": "BigQuery에서 특정 테이블의 데이터를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 테이블의 데이터를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/data\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_list.txt"}
{"question": "tabledata.list 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?", "answer": "tabledata.list 메서드에서 사용할 수 있는 쿼리 파라미터는 다음과 같습니다:\n- `startIndex`: 테이블의 시작 행 인덱스.\n- `maxResults`: 테이블의 행 제한.\n- `pageToken`: 이전 호출의 응답 본문에서 제공된 pageToken 필드의 문자열을 설정하여 다음 페이지의 테이블 데이터를 검색.\n- `selectedFields`: 반환할 필드의 하위 집합을 지원하며, 예를 들어 `selectedFields = \"a,e.d.f\"`와 같이 사용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_list.txt"}
{"question": "tabledata.list 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "tabledata.list 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_list.txt"}
{"question": "tabledata.list 메서드의 응답 구조는 어떻게 되나요?", "answer": "tabledata.list 메서드의 응답 구조는 다음과 같습니다:\n\n```\n{\n  \"kind\": string,\n  \"etag\": string,\n  \"totalRows\": string,\n  \"pageToken\": string,\n  \"rows\": [\n    {\n      object\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_list.txt"}
{"question": "tabledata.list 메서드를 사용하기 위해 필요한 인증 범위는 무엇인가요?", "answer": "tabledata.list 메서드를 사용하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n- `https://www.googleapis.com/auth/bigquery.readonly`\n- `https://www.googleapis.com/auth/cloud-platform.read-only`", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tabledata_list.txt"}
{"question": "BigQuery에서 테이블을 참조하기 위해 필요한 필드는 무엇인가요?", "answer": "BigQuery에서 테이블을 참조하기 위해 필요한 필드는 다음과 같습니다:\n\n```json\n{\n  \"projectId\": string,\n  \"datasetId\": string,\n  \"tableId\": string\n}\n```\n각 필드는 다음과 같은 의미를 가집니다:\n- `projectId`: 이 테이블이 포함된 프로젝트의 ID입니다. (필수)\n- `datasetId`: 이 테이블이 포함된 데이터셋의 ID입니다. (필수)\n- `tableId`: 테이블의 ID입니다. (필수) 테이블 ID는 Unicode 문자를 포함할 수 있으며, 최대 길이는 1,024자입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TableReference.txt"}
{"question": "테이블 ID(tableId)의 형식은 어떻게 되나요?", "answer": "테이블 ID(tableId)는 다음과 같은 형식을 가집니다:\n- Unicode 문자를 포함할 수 있으며, 카테고리는 L(문자), M(마크), N(숫자), Pc(연결자, 언더스코어 포함), Pd(대시), Zs(공백)입니다.\n- 최대 길이는 1,024자입니다.\n- 특정 작업에서는 테이블 ID에 파티션 장식(partition decorator)을 추가할 수 있습니다. 예: `sample_table$20190123`.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TableReference.txt"}
{"question": "테이블 참조를 위한 JSON 객체에서 각 필드의 데이터 타입은 무엇인가요?", "answer": "테이블 참조를 위한 JSON 객체에서 각 필드의 데이터 타입은 다음과 같습니다:\n- `projectId`: string (문자열)\n- `datasetId`: string (문자열)\n- `tableId`: string (문자열)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TableReference.txt"}
{"question": "테이블 ID(tableId)에 사용할 수 없는 문자는 무엇인가요?", "answer": "테이블 ID(tableId)에는 사용할 수 없는 문자가 명시되어 있지 않지만, Unicode 문자의 카테고리 L(문자), M(마크), N(숫자), Pc(연결자), Pd(대시), Zs(공백)만 사용할 수 있습니다. 따라서 이 카테고리에 포함되지 않는 문자는 사용할 수 없습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TableReference.txt"}
{"question": "BigQuery에서 테이블 참조를 만들 때 필수 필드는 무엇인가요?", "answer": "BigQuery에서 테이블 참조를 만들 때 필수 필드는 다음과 같습니다:\n- `projectId`: 이 테이블이 포함된 프로젝트의 ID\n- `datasetId`: 이 테이블이 포함된 데이터셋의 ID\n- `tableId`: 테이블의 ID\n이 세 가지 필드는 모두 필수입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TableReference.txt"}
{"question": "BigQuery 테이블의 생성 시간을 어떻게 확인할 수 있나요?", "answer": "테이블의 생성 시간은 `creationTime` 필드에서 확인할 수 있습니다. 이 필드는 밀리초 단위로 epoch 이후의 시간을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 만료 시간을 설정하는 방법은 무엇인가요?", "answer": "테이블의 만료 시간은 `expirationTime` 필드를 사용하여 설정할 수 있습니다. 이 필드는 밀리초 단위로 epoch 이후의 시간을 나타내며, 이 필드가 없으면 테이블은 무기한 유지됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 데이터 형식과 위치를 외부 데이터 소스에서 정의하는 방법은 무엇인가요?", "answer": "테이블의 외부 데이터 형식과 위치는 `externalDataConfiguration` 필드를 사용하여 정의할 수 있습니다. 이 필드는 BigQuery 외부에 저장된 테이블의 속성을 설명합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 레이블을 설정하는 방법은 무엇인가요?", "answer": "테이블의 레이블은 `labels` 필드를 사용하여 설정할 수 있습니다. 레이블 키와 값은 최대 63자까지 가능하며, 소문자, 숫자, 언더스코어 및 대시만 포함할 수 있습니다. 레이블 키는 반드시 문자로 시작해야 하며, 각 레이블은 서로 다른 키를 가져야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 유형을 확인하는 방법은 무엇인가요?", "answer": "테이블의 유형은 `type` 필드에서 확인할 수 있습니다. 이 필드는 테이블의 유형을 설명하며, 지원되는 값으로는 TABLE, VIEW, EXTERNAL, MATERIALIZED_VIEW, SNAPSHOT 등이 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 클러스터링을 설정하는 방법은 무엇인가요?", "answer": "클러스터링(Clustering) 사양은 테이블에 대해 지정해야 하며, 시간 기반 파티셔닝(time-based partitioning)과 함께 사용해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 위치를 확인하는 방법은 무엇인가요?", "answer": "테이블의 위치(location)는 출력 전용이며, 이 값은 데이터셋에서 상속됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 암호화 구성을 어떻게 설정하나요?", "answer": "암호화 구성(EncryptionConfiguration)은 사용자 정의 암호화 구성을 지정하는 데 사용됩니다. 예를 들어, Cloud KMS 키를 사용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 기본 정렬 사양을 설정하는 방법은 무엇인가요?", "answer": "기본 정렬(defaultCollation) 사양은 새 STRING 필드에 대해 정의할 수 있으며, 테이블 생성 또는 업데이트 시 명시적으로 정렬이 지정되지 않은 STRING 필드는 테이블의 기본 정렬을 상속받습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?", "answer": "테이블 또는 물리적 뷰에 존재하는 파티션 수(numPartitions)는 출력 전용입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 기본 정렬 사양을 설정하는 방법은 무엇인가요?", "answer": "기본 정렬 사양(default collation)은 새로운 STRING 필드의 기본 정렬 사양을 정의합니다. 테이블 생성 또는 업데이트 시, 명시적인 정렬 사양이 지정되지 않은 STRING 필드가 추가되면 테이블의 기본 정렬 사양을 상속받습니다. 이 필드는 다음과 같은 값을 지원합니다:\n- 'und:ci': 미정의 로케일, 대소문자 구분 없음.\n- '': 빈 문자열. 기본적으로 대소문자 구분 동작을 따릅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 암호화 구성을 어떻게 설정하나요?", "answer": "BigQuery 테이블의 암호화 구성(encryptionConfiguration)은 사용자 정의 암호화 구성을 지정합니다. 예를 들어, Cloud KMS 키를 사용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?", "answer": "테이블 또는 물리적 뷰에 존재하는 파티션 수는 numPartitions 필드를 통해 확인할 수 있습니다. 이 데이터는 실시간으로 유지되지 않으며, 몇 초에서 몇 분 정도 지연될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 물리적 크기를 확인하는 방법은 무엇인가요?", "answer": "테이블의 물리적 크기는 numTotalPhysicalBytes 필드를 통해 확인할 수 있습니다. 이 필드는 테이블의 물리적 크기를 바이트 단위로 나타내며, 시간 여행에 사용되는 저장소도 포함됩니다. 이 데이터는 실시간으로 유지되지 않으며, 몇 초에서 몇 분 정도 지연될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 최대 데이터 신선도를 설정하는 방법은 무엇인가요?", "answer": "최대 데이터 신선도(maxStaleness)는 쿼리 시 반환될 수 있는 데이터의 최대 신선도를 정의합니다. 신선도는 sql IntervalValue 유형의 문자열 인코딩으로 표현됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 파티션 수는 numPartitions 필드를 통해 확인할 수 있습니다. 이 필드는 테이블 또는 물리적 뷰에 존재하는 파티션의 수를 나타내며, 실시간으로 유지되지 않으므로 몇 초에서 몇 분 정도 지연될 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 기본 키와 외래 키 정보를 어떻게 확인하나요?", "answer": "BigQuery 테이블의 기본 키와 외래 키 정보는 tableConstraints 필드를 통해 확인할 수 있습니다. 이 필드는 선택적이며, 테이블의 제약 조건을 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블에 태그를 추가하는 방법은 무엇인가요?", "answer": "BigQuery 테이블에 태그를 추가하려면 resourceTags 필드를 사용해야 합니다. 이 필드는 태그를 키-값 쌍으로 저장하며, 태그 키는 전역적으로 고유해야 합니다. 예를 들어, '123456789012/environment'와 같은 형식으로 태그 키를 정의할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 필드에 대한 설명을 추가하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 필드에 대한 설명은 TableFieldSchema의 description 필드를 사용하여 추가할 수 있습니다. 이 필드는 선택적이며, 최대 길이는 1,024자입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 필드에 기본값을 설정하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 필드에 기본값을 설정하려면 defaultValueExpression 필드를 사용해야 합니다. 이 필드는 SQL 표현식을 통해 필드의 기본값을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 필드에 대한 최대 길이를 설정하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 필드에 대한 최대 길이는 maxLength 필드를 사용하여 설정할 수 있습니다. 이 필드는 STRINGS 또는 BYTES 유형의 필드에 대해 최대 길이를 정의합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"maxLength\": \"255\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 NUMERIC 또는 BIGNUMERIC 필드에 대한 정밀도와 스케일을 설정하는 방법은 무엇인가요?", "answer": "NUMERIC 또는 BIGNUMERIC 필드에 대한 정밀도(precision)와 스케일(scale)은 각각 precision 및 scale 필드를 사용하여 설정할 수 있습니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"precision\": \"38\",\n  \"scale\": \"9\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 필드에 대한 기본값을 설정하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 필드에 대한 기본값은 defaultValueExpression 필드를 사용하여 SQL 표현식으로 설정할 수 있습니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"defaultValueExpression\": \"CURRENT_TIMESTAMP()\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 RANGE 파티셔닝을 설정하는 방법은 무엇인가요?", "answer": "RANGE 파티셔닝은 rangePartitioning 필드를 사용하여 설정할 수 있습니다. 이 필드는 partitioning할 열의 이름과 범위를 정의합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"field\": \"age\",\n  \"range\": {\n    \"start\": \"0\",\n    \"end\": \"100\",\n    \"interval\": \"10\"\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 클러스터링을 설정하는 방법은 무엇인가요?", "answer": "BigQuery 테이블의 클러스터링은 clustering 필드를 사용하여 설정할 수 있습니다. 이 필드는 클러스터링할 필드의 목록을 포함합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"fields\": [\"field1\", \"field2\"]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 RANGE 파티셔닝을 설정하는 방법은 무엇인가요?", "answer": "RANGE 파티셔닝을 설정하려면 다음과 같은 JSON 구조를 사용해야 합니다. 이 구조에서 'field'는 파티셔닝할 열의 이름을 지정하고, 'range' 객체는 시작, 끝 및 간격을 정의합니다.\n\n```json\n{\n  \"field\": \"column_name\",\n  \"range\": {\n    \"start\": \"start_value\",\n    \"end\": \"end_value\",\n    \"interval\": \"interval_value\"\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 클러스터링을 설정하는 방법은 무엇인가요?", "answer": "클러스터링을 설정하려면 다음과 같은 JSON 구조를 사용해야 합니다. 'fields' 배열에는 클러스터링할 필드의 이름을 포함시킵니다.\n\n```json\n{\n  \"fields\": [\n    \"field1\",\n    \"field2\"\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 파티션 정보를 확인하는 방법은 무엇인가요?", "answer": "파티션 정보를 확인하려면 다음과 같은 JSON 구조를 사용하여 'partitionedColumn' 필드를 포함시킵니다. 이 필드는 각 파티셔닝 열에 대한 세부 정보를 제공합니다.\n\n```json\n{\n  \"partitionedColumn\": [\n    {\n      \"field\": \"partition_column_name\"\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 데이터 정책을 설정하는 방법은 무엇인가요?", "answer": "데이터 정책을 설정하려면 다음과 같은 JSON 구조를 사용해야 합니다. 'name' 필드는 데이터 정책 리소스의 이름을 지정합니다.\n\n```json\n{\n  \"name\": \"projects/projectId/locations/locationId/dataPolicies/data_policy_id\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery 테이블의 뷰 정의를 설정하는 방법은 무엇인가요?", "answer": "뷰 정의를 설정하려면 다음과 같은 JSON 구조를 사용해야 합니다. 'query' 필드는 BigQuery가 뷰를 참조할 때 실행할 쿼리를 포함합니다.\n\n```json\n{\n  \"query\": \"SELECT * FROM dataset.table\",\n  \"useLegacySql\": false\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 파티션된 테이블의 파티션 열 정보를 어떻게 확인할 수 있나요?", "answer": "파티션된 테이블의 파티션 열 정보는 `partitionedColumn` 필드를 통해 확인할 수 있습니다. 이 필드는 각 파티션 열에 대한 세부 정보를 포함하며, BigQuery 네이티브 테이블은 최대 1개의 파티션 열만 지원합니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"partitionedColumn\": [\n    {\n      \"field\": \"city\"\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 뷰 정의를 어떻게 설정하나요?", "answer": "뷰 정의는 `ViewDefinition` 객체를 사용하여 설정할 수 있습니다. 필수 필드는 `query`이며, BigQuery가 뷰를 참조할 때 실행할 쿼리를 포함합니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"query\": \"SELECT * FROM dataset.table\",\n  \"userDefinedFunctionResources\": [],\n  \"useLegacySql\": true\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 사용자 정의 함수(UDF) 리소스를 어떻게 정의하나요?", "answer": "사용자 정의 함수(UDF) 리소스는 `UserDefinedFunctionResource` 객체를 사용하여 정의할 수 있습니다. 이 객체는 Google Cloud Storage URI 또는 인라인 코드를 통해 UDF를 정의합니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"resourceUri\": \"gs://bucket/path/to/function.js\",\n  \"inlineCode\": \"function myFunction() { return 'Hello, World!'; }\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 물리적 뷰의 마지막 새로 고침 시간을 어떻게 확인하나요?", "answer": "물리적 뷰의 마지막 새로 고침 시간은 `lastRefreshTime` 필드를 통해 확인할 수 있습니다. 이 필드는 밀리초 단위로 표시됩니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"lastRefreshTime\": \"1633036800000\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 개인 정보 정책을 어떻게 설정하나요?", "answer": "개인 정보 정책은 `PrivacyPolicy` 객체를 사용하여 설정할 수 있습니다. 이 객체는 개인 정보 요구 사항을 포함하며, 현재는 뷰에서만 지원됩니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  \"aggregationThresholdPolicy\": {\n    \"privacyUnitColumns\": [\"column1\"],\n    \"threshold\": \"100\"\n  }\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 집계 임계값 정책(aggregation threshold policy)을 설정하는 방법은 무엇인가요?", "answer": "집계 임계값 정책(aggregation threshold policy)은 다음과 같은 JSON 형식으로 설정할 수 있습니다:\n\n```json\n{\n  \"privacyUnitColumns\": [\n    \"string\"\n  ],\n  \"threshold\": \"string\"\n}\n```\n\n- `privacyUnitColumns[]`: 이 정책과 관련된 개인 정보 단위 열입니다. 현재는 데이터 소스 객체(테이블, 뷰)당 하나의 열만 허용됩니다.\n- `threshold`: 집계 임계값 정책의 임계값입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 물리적 뷰의 마지막 새로 고침 시간을 확인하는 방법은 무엇인가요?", "answer": "물리적 뷰의 마지막 새로 고침 시간은 `MaterializedViewDefinition`의 `lastRefreshTime` 필드를 통해 확인할 수 있습니다. 이 필드는 밀리초 단위로 표현됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 물리적 뷰의 자동 새로 고침을 설정하는 방법은 무엇인가요?", "answer": "물리적 뷰의 자동 새로 고침은 `MaterializedViewDefinition`의 `enableRefresh` 필드를 사용하여 설정할 수 있습니다. 기본값은 `true`입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 물리적 뷰의 최대 새로 고침 주기를 설정하는 방법은 무엇인가요?", "answer": "물리적 뷰의 최대 새로 고침 주기는 `MaterializedViewDefinition`의 `refreshIntervalMs` 필드를 사용하여 설정할 수 있습니다. 기본값은 `1800000` (30분)입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 외부 데이터 구성(ExternalDataConfiguration)을 설정하는 방법은 무엇인가요?", "answer": "외부 데이터 구성은 다음과 같은 JSON 형식으로 설정할 수 있습니다:\n\n```json\n{\n  \"sourceUris\": [\n    \"string\"\n  ],\n  \"fileSetSpecType\": \"enum (FileSetSpecType)\",\n  \"schema\": {\n    \"object (TableSchema)\"\n  },\n  \"sourceFormat\": \"string\",\n  \"maxBadRecords\": \"integer\",\n  \"autodetect\": \"boolean\",\n  \"ignoreUnknownValues\": \"boolean\",\n  \"compression\": \"string\",\n  \"csvOptions\": {\n    \"object (CsvOptions)\"\n  },\n  \"jsonOptions\": {\n    \"object (JsonOptions)\"\n  },\n  \"bigtableOptions\": {\n    \"object (BigtableOptions)\"\n  },\n  \"googleSheetsOptions\": {\n    \"object (GoogleSheetsOptions)\"\n  },\n  \"hivePartitioningOptions\": {\n    \"object (HivePartitioningOptions)\"\n  },\n  \"connectionId\": \"string\",\n  \"decimalTargetTypes\": [\n    \"enum (DecimalTargetType)\"\n  ],\n  \"avroOptions\": {\n    \"object (AvroOptions)\"\n  },\n  \"jsonExtension\": \"enum (JsonExtension)\",\n  \"parquetOptions\": {\n    \"object (ParquetOptions)\"\n  },\n  \"referenceFileSchemaUri\": \"string\",\n  \"metadataCacheMode\": \"enum (MetadataCacheMode)\",\n  \"objectMetadata\": \"enum (ObjectMetadata)\",\n  \"timeZone\": \"string\",\n  \"dateFormat\": \"string\",\n  \"datetimeFormat\": \"string\",\n  \"timeFormat\": \"string\",\n  \"timestampFormat\": \"string\"\n}\n```\n\n각 필드는 외부 데이터 소스의 세부 정보를 정의합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 추가 옵션을 설정하는 방법은 무엇인가요?", "answer": "CSV 파일을 로드할 때 추가 옵션을 설정하려면 `csvOptions` 필드를 사용하여 필요한 속성을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 JSON 파일을 로드할 때 사용할 수 있는 추가 옵션은 무엇인가요?", "answer": "JSON 파일을 로드할 때는 `jsonOptions` 필드를 사용하여 추가 속성을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Google Sheets를 데이터 소스로 사용할 때 어떤 옵션을 설정할 수 있나요?", "answer": "Google Sheets를 데이터 소스로 사용할 때는 `googleSheetsOptions` 필드를 사용하여 추가 옵션을 설정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 데이터 소스의 압축 유형을 설정하는 방법은 무엇인가요?", "answer": "데이터 소스의 압축 유형을 설정하려면 `compression` 필드를 사용하여 GZIP 또는 NONE과 같은 값을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 소스 데이터의 최대 불량 레코드 수를 설정하는 방법은 무엇인가요?", "answer": "소스 데이터의 최대 불량 레코드 수를 설정하려면 `maxBadRecords` 필드를 사용하여 원하는 정수 값을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 필드 구분자를 설정하는 방법은 무엇인가요?", "answer": "CSV 파일의 필드 구분자는 `fieldDelimiter` 속성을 사용하여 설정할 수 있습니다. 기본값은 쉼표(\",\", U+002C)입니다. 예를 들어, 탭 구분자를 사용하려면 다음과 같이 설정할 수 있습니다.\n\n```json\n{\n  \"fieldDelimiter\": \"\\t\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 첫 번째 행을 건너뛰는 방법은 무엇인가요?", "answer": "CSV 파일에서 첫 번째 행을 건너뛰려면 `skipLeadingRows` 속성을 사용하여 건너뛸 행 수를 설정할 수 있습니다. 기본값은 0이며, 예를 들어 첫 번째 행을 건너뛰려면 다음과 같이 설정할 수 있습니다.\n\n```json\n{\n  \"skipLeadingRows\": \"1\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 JSON 파일을 로드할 때 사용할 수 있는 추가 옵션은 무엇인가요?", "answer": "JSON 파일을 로드할 때는 `jsonOptions` 속성을 사용하여 추가 옵션을 설정할 수 있습니다. 이 속성은 JSON 형식에 맞는 추가 속성을 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 외부 테이블을 생성할 때 참조 파일 스키마 URI를 설정하는 방법은 무엇인가요?", "answer": "외부 테이블을 생성할 때 `referenceFileSchemaUri` 속성을 사용하여 참조 파일의 스키마 URI를 설정할 수 있습니다. 이 속성은 AVRO, PARQUET, ORC 형식에서 사용 가능합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 소스 데이터의 시간대 정보를 설정하는 방법은 무엇인가요?", "answer": "소스 데이터의 시간대 정보를 설정하려면 `timeZone` 속성을 사용하여 IANA 시간대 문자열을 지정할 수 있습니다. 예를 들어, 'America/Los_Angeles'와 같이 설정할 수 있습니다.\n\n```json\n{\n  \"timeZone\": \"America/Los_Angeles\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 필드 구분자를 설정하는 방법은 무엇인가요?", "answer": "CSV 파일에서 필드 구분자를 설정하려면 `fieldDelimiter` 속성을 사용합니다. 이 속성은 CSV 파일의 필드를 구분하는 문자로, 기본값은 쉼표(\",\", U+002C)입니다. 예를 들어, 탭 구분자를 사용하려면 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"fieldDelimiter\": \"\\t\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 첫 번째 행을 건너뛰는 방법은 무엇인가요?", "answer": "CSV 파일에서 첫 번째 행을 건너뛰려면 `skipLeadingRows` 속성을 설정합니다. 이 속성의 기본값은 0이며, N이 0보다 큰 경우 N-1개의 행을 건너뛰고 N번째 행에서 헤더를 감지하려고 시도합니다. 예를 들어, 첫 번째 행을 건너뛰려면 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"skipLeadingRows\": \"1\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 인코딩을 설정하는 방법은 무엇인가요?", "answer": "CSV 파일의 문자 인코딩을 설정하려면 `encoding` 속성을 사용합니다. 지원되는 값으로는 UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LE가 있으며, 기본값은 UTF-8입니다. 예를 들어, ISO-8859-1 인코딩을 사용하려면 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"encoding\": \"ISO-8859-1\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 null 값을 나타내는 문자열을 설정하는 방법은 무엇인가요?", "answer": "CSV 파일에서 null 값을 나타내는 문자열을 설정하려면 `nullMarker` 속성을 사용합니다. 예를 들어, \"\\N\"을 null 값으로 설정하려면 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"nullMarker\": \"\\N\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 JSON 파일을 로드할 때 사용할 수 있는 인코딩 옵션은 무엇인가요?", "answer": "JSON 파일을 로드할 때 인코딩을 설정하려면 `encoding` 속성을 사용합니다. 지원되는 값은 UTF-8, ISO-8859-1, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LE입니다. 예를 들어, UTF-16LE 인코딩을 사용하려면 다음과 같이 설정할 수 있습니다:\n\n```json\n{\n  \"encoding\": \"UTF-16LE\"\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때, skipLeadingRows 파라미터의 역할은 무엇인가요?", "answer": "skipLeadingRows 파라미터는 CSV 파일에서 건너뛸 헤더 행의 수를 지정합니다. autodetect가 활성화된 경우, 다음과 같은 동작을 합니다: \n- skipLeadingRows가 지정되지 않은 경우: autodetect는 첫 번째 행에서 헤더를 감지하려고 시도합니다. 감지되지 않으면 해당 행은 데이터로 읽힙니다. 그렇지 않으면 데이터는 두 번째 행부터 읽힙니다.\n- skipLeadingRows가 0인 경우: 헤더가 없음을 지시하며 데이터는 첫 번째 행부터 읽힙니다.\n- skipLeadingRows = N > 0인 경우: N-1 행을 건너뛰고 N 행에서 헤더를 감지하려고 시도합니다. 헤더가 감지되지 않으면 N 행은 단순히 건너뛰고, 그렇지 않으면 N 행은 감지된 스키마의 열 이름을 추출하는 데 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CSV 파일을 로드할 때 quote 파라미터는 어떤 역할을 하나요?", "answer": "quote 파라미터는 CSV 파일에서 데이터 섹션을 인용하는 데 사용되는 문자열 값을 지정합니다. BigQuery는 이 문자열을 ISO-8859-1 인코딩으로 변환한 후, 인코딩된 문자열의 첫 번째 바이트를 사용하여 데이터를 원시 이진 상태로 분할합니다. 기본값은 큰따옴표(\")입니다. 데이터에 인용된 섹션이 포함되지 않은 경우, 이 속성 값을 빈 문자열로 설정해야 합니다. 인용된 줄 바꿈 문자가 포함된 경우, allowQuotedNewlines 속성을 true로 설정해야 합니다. 특정 인용 문자를 인용된 값 내에 포함하려면, 추가적인 일치하는 인용 문자로 앞서야 합니다. 예를 들어, 기본 문자인 '\"'를 이스케이프하려면 '\"\"'를 사용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 allowJaggedRows 파라미터의 기능은 무엇인가요?", "answer": "allowJaggedRows 파라미터는 BigQuery가 선택적 열이 누락된 행을 수용할지를 나타냅니다. true로 설정하면, 누락된 선택적 열은 null 값으로 처리됩니다. false로 설정하면, 누락된 선택적 열이 있는 레코드는 잘못된 레코드로 간주되며, 잘못된 레코드가 너무 많으면 작업 결과에서 유효하지 않은 오류가 반환됩니다. 기본값은 false입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 nullMarker와 nullMarkers의 차이점은 무엇인가요?", "answer": "nullMarker는 CSV 파일에서 null 값을 나타내는 문자열을 지정합니다. 예를 들어, \"\\N\"을 지정하면 BigQuery는 CSV 파일을 쿼리할 때 \"\\N\"을 null 값으로 해석합니다. 기본값은 빈 문자열입니다. nullMarkers는 CSV 파일에서 SQL NULL 값을 나타내는 문자열 목록입니다. nullMarker와 nullMarkers는 동시에 설정할 수 없으며, 하나가 설정되면 다른 하나는 설정되지 않아야 합니다. 둘 다 설정하면 사용자 오류가 발생합니다. nullMarkers에 나열된 모든 문자열은 SQL NULL로 해석됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 sourceColumnMatch 파라미터의 역할은 무엇인가요?", "answer": "sourceColumnMatch 파라미터는 로드된 열을 스키마와 일치시키는 데 사용되는 전략을 제어합니다. 설정되지 않은 경우, 스키마 제공 방식에 따라 합리적인 기본값이 선택됩니다. autodetect가 사용되는 경우, 열은 이름으로 일치합니다. 그렇지 않으면, 열은 위치로 일치합니다. 이는 이전 버전과의 호환성을 유지하기 위해 수행됩니다. 허용되는 값은 POSITION(위치로 일치)와 NAME(이름으로 일치)입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 JSON 파일을 로드할 때 사용할 수 있는 인코딩 옵션은 무엇인가요?", "answer": "BigQuery에서 JSON 파일을 로드할 때 사용할 수 있는 인코딩 옵션은 'encoding' 필드로 설정할 수 있으며, 지원되는 값은 UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LE입니다. 기본값은 UTF-8입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Google Cloud Bigtable 데이터 소스의 옵션을 어떻게 설정하나요?", "answer": "Google Cloud Bigtable 데이터 소스의 옵션은 'BigtableOptions'를 사용하여 설정할 수 있습니다. JSON 표현은 다음과 같습니다:\n\n```\n{\n  \"columnFamilies\": [\n    {\n      object (BigtableColumnFamily)\n    }\n  ],\n  \"ignoreUnspecifiedColumnFamilies\": boolean,\n  \"readRowkeyAsString\": boolean,\n  \"outputColumnFamiliesAsJson\": boolean\n}\n```\n각 필드는 선택적이며, 'columnFamilies'는 테이블 스키마에 노출할 열 패밀리 목록을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 BigtableColumnFamily의 'type' 필드는 어떤 역할을 하나요?", "answer": "BigtableColumnFamily의 'type' 필드는 해당 열 패밀리의 셀 값 변환 유형을 지정합니다. 허용되는 값은 BYTES, STRING, INTEGER, FLOAT, BOOLEAN, JSON이며, 기본값은 BYTES입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 BigtableColumn의 'qualifierEncoded' 필드는 무엇을 나타내나요?", "answer": "BigtableColumn의 'qualifierEncoded' 필드는 열의 식별자를 나타내며, 부모 열 패밀리에서 이 정확한 식별자를 가진 열이 <family field name>.<column field name> 필드로 노출됩니다. 유효한 UTF-8 문자열일 경우 'qualifierString' 필드에 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Google Sheets 데이터 소스의 'skipLeadingRows' 필드는 어떤 기능을 하나요?", "answer": "'skipLeadingRows' 필드는 BigQuery가 데이터를 읽을 때 시트 상단에서 건너뛸 행의 수를 지정합니다. 기본값은 0이며, 이 속성은 헤더 행이 있을 경우 유용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 BigtableColumn의 'qualifierEncoded' 필드는 어떤 역할을 하나요?", "answer": "'qualifierEncoded' 필드는 열의 자격을 나타내며, 부모 열 패밀리에서 이 정확한 자격을 가진 열이 <family field name>.<column field name> 필드로 노출됩니다. 자격이 유효한 UTF-8 문자열인 경우 'qualifierString' 필드에 지정할 수 있으며, 그렇지 않은 경우 base-64로 인코딩된 값을 'qualifierEncoded'에 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Google Sheets 데이터 소스의 'range' 필드는 어떤 기능을 하나요?", "answer": "'range' 필드는 쿼리할 시트의 범위를 지정하는 옵션입니다. 비어 있지 않은 경우에만 사용되며, 일반적인 형식은 sheet_name!top_left_cell_id:bottom_right_cell_id입니다. 예를 들어: sheet1!A1:B20", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 HivePartitioningOptions의 'requirePartitionFilter' 필드는 어떤 역할을 하나요?", "answer": "'requirePartitionFilter' 필드는 true로 설정되면 이 테이블에 대한 쿼리에서 파티션 필터를 지정해야 하며, 이를 통해 파티션 제거가 가능해집니다. 이 필드는 영구 외부 테이블을 생성하거나 임시 외부 테이블을 쿼리할 때만 true로 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 HivePartitioningOptions의 'mode' 필드는 어떤 값을 가질 수 있나요?", "answer": "'mode' 필드는 다음과 같은 값을 가질 수 있습니다: AUTO(자동으로 파티션 키 이름 및 유형을 유추), STRINGS(모든 유형이 문자열인 파티션 키 이름을 자동으로 유추), CUSTOM(소스 URI 접두사에 인코딩된 파티션 키 스키마).", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 AvroOptions의 'useAvroLogicalTypes' 필드는 어떤 기능을 하나요?", "answer": "'useAvroLogicalTypes' 필드는 sourceFormat이 'AVRO'로 설정된 경우, 논리적 유형을 해당 BigQuery 데이터 유형(예: TIMESTAMP)으로 해석할지 여부를 나타내는 옵션입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 skipLeadingRows 파라미터의 기본값은 무엇인가요?", "answer": "BigQuery에서 skipLeadingRows 파라미터의 기본값은 0입니다. 이 속성은 건너뛰어야 할 헤더 행이 있는 경우 유용합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 HivePartitioningOptions의 mode 필드는 어떤 값을 가질 수 있나요?", "answer": "HivePartitioningOptions의 mode 필드는 다음과 같은 값을 가질 수 있습니다: AUTO, STRINGS, CUSTOM. AUTO는 파티션 키 이름과 유형을 자동으로 유추하고, STRINGS는 모든 유형을 문자열로 유추하며, CUSTOM은 파티션 키 스키마가 소스 URI 접두사에 인코딩되어 있음을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 HivePartitioningOptions의 requirePartitionFilter 필드는 어떤 역할을 하나요?", "answer": "requirePartitionFilter 필드는 true로 설정되면 이 테이블에 대한 쿼리는 파티션 필터를 지정해야 하며, 이를 통해 파티션 제거가 가능해집니다. 이 필드는 영구 외부 테이블을 생성할 때만 true로 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 AvroOptions의 useAvroLogicalTypes 필드는 어떤 기능을 하나요?", "answer": "AvroOptions의 useAvroLogicalTypes 필드는 sourceFormat이 'AVRO'로 설정된 경우, 논리적 유형을 해당 BigQuery 데이터 유형(예: TIMESTAMP)으로 해석할지를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ParquetOptions의 enumAsString 필드는 어떤 역할을 하나요?", "answer": "ParquetOptions의 enumAsString 필드는 Parquet ENUM 논리 유형을 기본적으로 BYTES 대신 STRING으로 유추할지를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 AvroOptions의 useAvroLogicalTypes 필드는 어떤 기능을 하나요?", "answer": "useAvroLogicalTypes 필드는 sourceFormat이 'AVRO'로 설정된 경우, 논리적 타입을 해당 BigQuery 데이터 타입(예: TIMESTAMP)으로 해석할지, 아니면 원시 타입(예: INTEGER)을 사용할지를 나타내는 선택적 boolean 값입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ParquetOptions의 enumAsString 필드는 어떤 역할을 하나요?", "answer": "enumAsString 필드는 Parquet ENUM 논리 타입을 기본적으로 BYTES 대신 STRING으로 추론할지를 나타내는 선택적 boolean 값입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Streamingbuffer의 estimatedBytes 필드는 무엇을 나타내나요?", "answer": "estimatedBytes 필드는 현재 스트리밍 버퍼에 있는 바이트 수의 하한 추정치를 나타내며, 출력 전용입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 SnapshotDefinition의 baseTableReference 필드는 어떤 정보를 포함하나요?", "answer": "baseTableReference 필드는 스냅샷이 생성된 기본 테이블의 ID를 설명하는 TableReference 객체를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 TableConstraints의 primaryKey 필드는 어떤 역할을 하나요?", "answer": "primaryKey 필드는 테이블의 열에 대한 기본 키 제약 조건을 나타내며, 테이블에 기본 키가 있는 경우에만 존재합니다. 기본 키는 강제 적용되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 Apache Iceberg 형식의 테이블을 생성할 때 지원되는 파일 형식은 무엇인가요?", "answer": "BigQuery에서 Apache Iceberg 형식의 테이블을 생성할 때 지원되는 파일 형식은 다음과 같습니다: \n\n```\nFILE_FORMAT_UNSPECIFIED Default Value.\nPARQUET Apache Parquet format.\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 SnapshotDefinition의 baseTableReference 필드는 어떤 정보를 포함하나요?", "answer": "SnapshotDefinition의 baseTableReference 필드는 스냅샷을 생성한 기본 테이블의 ID를 설명하는 참조 정보를 포함합니다. JSON 표현은 다음과 같습니다: \n\n```\n{\n  \"baseTableReference\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  },\n  \"snapshotTime\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 CloneDefinition의 cloneTime 필드는 어떤 정보를 나타내나요?", "answer": "CloneDefinition의 cloneTime 필드는 기본 테이블이 복제된 시간을 나타냅니다. 이 값은 JSON 응답에서 RFC3339 형식으로 보고됩니다. JSON 표현은 다음과 같습니다: \n\n```\n{\n  \"baseTableReference\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  },\n  \"cloneTime\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 TableConstraints의 primaryKey 필드는 어떤 역할을 하나요?", "answer": "TableConstraints의 primaryKey 필드는 테이블의 열에 대한 기본 키 제약 조건을 나타냅니다. 이 필드는 테이블에 기본 키가 있는 경우에만 존재하며, 기본 키는 강제되지 않습니다. JSON 표현은 다음과 같습니다: \n\n```\n{\n  \"primaryKey\": {\n    object (PrimaryKey)\n  },\n  \"foreignKeys\": [\n    {\n      object (ForeignKey)\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ForeignKey의 columnReferences 필드는 어떤 정보를 포함하나요?", "answer": "ForeignKey의 columnReferences 필드는 외래 키를 구성하는 열에 대한 정보를 포함합니다. 이 필드는 필수이며, 외래 키 제약 조건을 정의하는 데 사용됩니다. JSON 표현은 다음과 같습니다: \n\n```\n{\n  \"name\": string,\n  \"referencedTable\": {\n    object (TableReference [https://cloud.google.com/bigquery/docs/reference/rest/v2/TableReference])\n  },\n  \"columnReferences\": [\n    {\n      object (ColumnReference)\n    }\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ForeignKey의 columnReferences 필드는 어떤 정보를 포함하나요?", "answer": "ForeignKey의 columnReferences 필드는 외래 키를 구성하는 열(column)과 기본 키(primary key) 열의 쌍을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ColumnReference의 JSON 표현은 어떻게 되나요?", "answer": "ColumnReference의 JSON 표현은 다음과 같습니다:\n```json\n{\n  \"referencingColumn\": string,\n  \"referencedColumn\": string\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 ExternalCatalogTableOptions의 parameters 필드는 어떤 역할을 하나요?", "answer": "ExternalCatalogTableOptions의 parameters 필드는 오픈 소스 테이블의 매개변수와 속성을 정의하는 키-값 쌍의 맵입니다. 이는 Hive 메타스토어 테이블 매개변수와 일치합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 StorageDescriptor의 locationUri 필드는 어떤 정보를 포함하나요?", "answer": "StorageDescriptor의 locationUri 필드는 테이블의 물리적 위치를 나타내며, 예를 들어 'gs://spark-dataproc-data/pangea-data/case_sensitive/'와 같은 형식입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 SerDeInfo의 serializationLibrary 필드는 어떤 정보를 포함하나요?", "answer": "SerDeInfo의 serializationLibrary 필드는 데이터의 테이블 표현과 저수준 입력 및 출력 형식 구조 간의 변환을 담당하는 직렬화 라이브러리의 완전한 클래스 이름을 지정합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables.txt"}
{"question": "BigQuery에서 특정 테이블을 삭제하는 방법은 무엇인가요?", "answer": "특정 테이블을 삭제하려면 다음과 같은 HTTP DELETE 요청을 사용합니다:\n\n```\nDELETE https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```\n여기서 `{projectId}`는 삭제할 테이블이 포함된 프로젝트의 ID, `{datasetId}`는 삭제할 테이블이 포함된 데이터셋의 ID, `{tableId}`는 삭제할 테이블의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_delete.txt"}
{"question": "테이블 삭제 요청 시 필요한 파라미터는 무엇인가요?", "answer": "테이블 삭제 요청 시 필요한 파라미터는 다음과 같습니다:\n- `projectId`: 삭제할 테이블이 포함된 프로젝트의 ID (필수)\n- `datasetId`: 삭제할 테이블이 포함된 데이터셋의 ID (필수)\n- `tableId`: 삭제할 테이블의 ID (필수)", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_delete.txt"}
{"question": "테이블 삭제 요청의 응답은 어떻게 되나요?", "answer": "테이블 삭제 요청이 성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_delete.txt"}
{"question": "테이블 삭제를 위한 인증 범위는 무엇인가요?", "answer": "테이블 삭제를 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_delete.txt"}
{"question": "테이블 삭제 요청 시 요청 본문은 어떻게 되나요?", "answer": "테이블 삭제 요청 시 요청 본문은 비어 있어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/delete"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_delete.txt"}
{"question": "tables.get 메서드를 사용하여 특정 테이블의 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```\n여기서 {projectId}, {datasetId}, {tableId}는 각각 요청하는 테이블의 프로젝트 ID, 데이터셋 ID, 테이블 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_get.txt"}
{"question": "tables.get 메서드에서 선택적으로 반환할 수 있는 필드는 무엇인가요?", "answer": "tables.get 메서드에서 선택적으로 반환할 수 있는 필드는 `selectedFields` 파라미터를 사용하여 지정할 수 있습니다. 이 파라미터는 반환할 테이블 스키마 필드를 쉼표로 구분하여 나열합니다. 지정하지 않으면 모든 필드가 반환됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_get.txt"}
{"question": "tables.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "tables.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_get.txt"}
{"question": "tables.get 메서드에서 사용할 수 있는 Authorization scopes는 무엇인가요?", "answer": "tables.get 메서드에서 사용할 수 있는 Authorization scopes는 다음과 같습니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_get.txt"}
{"question": "tables.get 메서드에서 반환되는 테이블 정보의 뷰는 어떤 것이 있나요?", "answer": "tables.get 메서드에서 반환되는 테이블 정보의 뷰는 다음과 같습니다:\n- `TABLE_METADATA_VIEW_UNSPECIFIED`: 기본값으로 STORAGE_STATS 뷰를 반환합니다.\n- `BASIC`: 기본 테이블 정보와 스키마, 파티셔닝 사양을 포함합니다. 저장 통계는 포함되지 않습니다.\n- `STORAGE_STATS`: BASIC 뷰의 모든 정보와 저장 통계(numBytes, numLongTermBytes, numRows, lastModifiedTime)를 포함합니다.\n- `FULL`: STORAGE_STATS 뷰의 모든 정보와 추가 정보를 포함할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_get.txt"}
{"question": "tables.getIamPolicy 메서드를 사용하여 리소스의 액세스 제어 정책을 가져오는 방법은 무엇인가요?", "answer": "tables.getIamPolicy 메서드는 리소스의 액세스 제어 정책을 가져옵니다. 요청은 다음과 같은 HTTP POST 형식으로 이루어집니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/{resource=projects/*/datasets/*/tables/*}:getIamPolicy\n```\n여기서 {resource}는 요청하는 정책의 리소스를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_getIamPolicy.txt"}
{"question": "tables.getIamPolicy 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "tables.getIamPolicy 메서드의 요청 본문은 다음과 같은 JSON 구조를 가집니다:\n\n```\n{\n  \"options\": {\n    object (GetPolicyOptions)\n  }\n}\n```\n여기서 options 필드는 선택적이며, GetPolicyOptions 객체를 사용하여 tables.getIamPolicy에 대한 옵션을 지정할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_getIamPolicy.txt"}
{"question": "tables.getIamPolicy 메서드의 응답 본문은 어떤 형식을 가지나요?", "answer": "tables.getIamPolicy 메서드가 성공적으로 실행되면 응답 본문은 Policy 객체의 인스턴스를 포함합니다. 이 객체는 리소스의 액세스 제어 정책을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_getIamPolicy.txt"}
{"question": "tables.getIamPolicy 메서드를 호출하기 위한 권한 범위는 무엇인가요?", "answer": "tables.getIamPolicy 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_getIamPolicy.txt"}
{"question": "tables.getIamPolicy 메서드에서 resource 파라미터의 값은 어떻게 설정하나요?", "answer": "tables.getIamPolicy 메서드의 resource 파라미터는 요청하는 정책의 리소스를 나타내며, 다음과 같은 형식으로 설정해야 합니다:\n```\nprojects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```\n여기서 {projectId}, {datasetId}, {tableId}는 각각 프로젝트 ID, 데이터셋 ID, 테이블 ID를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/getIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_getIamPolicy.txt"}
{"question": "BigQuery에서 새로운 테이블을 생성하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "새로운 테이블을 생성하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables\n```\n여기서 `{projectId}`는 새로운 테이블이 생성될 프로젝트의 ID이고, `{datasetId}`는 새로운 테이블이 생성될 데이터셋의 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_insert.txt"}
{"question": "테이블 생성 요청 시 필수로 포함해야 하는 파라미터는 무엇인가요?", "answer": "테이블 생성 요청 시 필수로 포함해야 하는 파라미터는 다음과 같습니다:\n- `projectId`: 새로운 테이블의 프로젝트 ID\n- `datasetId`: 새로운 테이블의 데이터셋 ID", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_insert.txt"}
{"question": "테이블 생성 요청의 본문(request body)에는 어떤 내용이 포함되어야 하나요?", "answer": "테이블 생성 요청의 본문(request body)에는 `Table` 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_insert.txt"}
{"question": "테이블 생성 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "테이블 생성 요청이 성공적으로 처리되면 응답 본문에는 새로 생성된 `Table` 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_insert.txt"}
{"question": "테이블 생성 요청을 위해 필요한 OAuth 스코프는 무엇인가요?", "answer": "테이블 생성 요청을 위해 필요한 OAuth 스코프는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/bigquery`\n- `https://www.googleapis.com/auth/cloud-platform`\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/insert"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_insert.txt"}
{"question": "BigQuery에서 특정 데이터셋의 모든 테이블을 나열하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 데이터셋의 모든 테이블을 나열하려면 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables\n```\n여기서 `{projectId}`는 테이블을 나열할 프로젝트 ID이고, `{datasetId}`는 테이블을 나열할 데이터셋 ID입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_list.txt"}
{"question": "tables.list 메서드에서 요청 본문은 어떻게 구성되나요?", "answer": "tables.list 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_list.txt"}
{"question": "tables.list 메서드의 응답 구조는 어떻게 되나요?", "answer": "tables.list 메서드의 응답 구조는 다음과 같습니다:\n\n```\n{\n  \"kind\": string,\n  \"etag\": string,\n  \"nextPageToken\": string,\n  \"tables\": [\n    {\n      \"kind\": string,\n      \"id\": string,\n      \"tableReference\": {\n        object (TableReference)\n      },\n      \"friendlyName\": string,\n      \"type\": string,\n      \"timePartitioning\": {\n        object (TimePartitioning)\n      },\n      \"rangePartitioning\": {\n        object (RangePartitioning)\n      },\n      \"clustering\": {\n        object (Clustering)\n      },\n      \"hivePartitioningOptions\": {\n        object (HivePartitioningOptions)\n      },\n      \"labels\": {\n        string: string,\n        ...\n      },\n      \"view\": {\n        \"useLegacySql\": boolean,\n        \"privacyPolicy\": {\n          object (PrivacyPolicy)\n        }\n      },\n      \"creationTime\": string,\n      \"expirationTime\": string,\n      \"requirePartitionFilter\": boolean\n    }\n  ],\n  \"totalItems\": integer\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_list.txt"}
{"question": "tables.list 메서드에서 maxResults 파라미터는 어떤 역할을 하나요?", "answer": "maxResults 파라미터는 한 번의 응답 페이지에서 반환할 최대 결과 수를 지정합니다. 이 파라미터를 사용하여 전체 컬렉션을 반복할 때 페이지 토큰을 활용할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_list.txt"}
{"question": "tables.list 메서드를 호출할 때 필요한 권한은 무엇인가요?", "answer": "tables.list 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/list"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_list.txt"}
{"question": "tables.patch 메서드를 사용하여 기존 테이블의 정보를 업데이트할 때, 어떤 방식으로 요청을 보내야 하나요?", "answer": "tables.patch 메서드를 사용하여 기존 테이블의 정보를 업데이트하려면 다음과 같은 HTTP 요청을 보내야 합니다:\n\n```\nPATCH https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```\n여기서 {projectId}, {datasetId}, {tableId}는 각각 업데이트할 테이블의 프로젝트 ID, 데이터셋 ID, 테이블 ID로 대체해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_patch.txt"}
{"question": "tables.patch 메서드에서 요청 본문(request body)에는 어떤 형식의 데이터가 포함되어야 하나요?", "answer": "tables.patch 메서드의 요청 본문(request body)에는 Table 인스턴스가 포함되어야 합니다. 이 인스턴스는 업데이트할 테이블의 정보를 담고 있어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_patch.txt"}
{"question": "tables.patch 메서드에서 autodetectSchema 파라미터는 어떤 역할을 하나요?", "answer": "autodetectSchema 파라미터는 선택적(boolean)으로, true로 설정하면 스키마를 자동으로 감지하고, false로 설정하면 원래의 스키마를 유지합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_patch.txt"}
{"question": "tables.patch 메서드를 호출하기 위해 필요한 권한은 무엇인가요?", "answer": "tables.patch 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_patch.txt"}
{"question": "tables.patch 메서드의 응답 본문(response body)은 어떤 정보를 포함하나요?", "answer": "tables.patch 메서드가 성공적으로 호출되면 응답 본문(response body)에는 Table 인스턴스가 포함됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/patch"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_patch.txt"}
{"question": "tables.setIamPolicy 메서드를 사용하여 특정 리소스의 접근 제어 정책을 설정하는 방법은 무엇인가요?", "answer": "tables.setIamPolicy 메서드는 지정된 리소스에 대한 접근 제어 정책을 설정합니다. 이 메서드는 기존 정책을 대체합니다. HTTP 요청은 다음과 같습니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/{resource=projects/*/datasets/*/tables/*}:setIamPolicy\n```\n여기서 {resource}는 정책이 지정되는 리소스를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/setIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_setIamPolicy.txt"}
{"question": "tables.setIamPolicy 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "요청 본문은 다음과 같은 구조를 가집니다:\n\n```\n{\n  \"policy\": {\n    object (Policy)\n  },\n  \"updateMask\": string\n}\n```\n여기서 'policy'는 리소스에 적용할 전체 정책을 포함하며, 'updateMask'는 수정할 정책의 필드를 지정하는 선택적 필드입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/setIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_setIamPolicy.txt"}
{"question": "tables.setIamPolicy 메서드에서 'updateMask' 필드는 어떤 역할을 하나요?", "answer": "'updateMask' 필드는 수정할 정책의 필드를 지정하는 역할을 합니다. 이 필드가 제공되지 않으면 기본 마스크가 사용되며, 기본 마스크는 'bindings, etag'입니다. 이는 수정할 필드의 완전한 이름 목록을 포함하는 쉼표로 구분된 문자열입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/setIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_setIamPolicy.txt"}
{"question": "tables.setIamPolicy 메서드를 호출할 때 발생할 수 있는 오류는 무엇이 있나요?", "answer": "tables.setIamPolicy 메서드는 다음과 같은 오류를 반환할 수 있습니다: NOT_FOUND, INVALID_ARGUMENT, PERMISSION_DENIED. 이러한 오류는 요청이 잘못되었거나 권한이 부족할 때 발생할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/setIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_setIamPolicy.txt"}
{"question": "tables.setIamPolicy 메서드를 사용하기 위한 인증 범위는 무엇인가요?", "answer": "tables.setIamPolicy 메서드를 사용하기 위해서는 다음 중 하나의 OAuth 범위가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/setIamPolicy"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_setIamPolicy.txt"}
{"question": "tables.testIamPermissions 메서드를 사용하여 특정 리소스에 대한 권한을 확인하는 방법은 무엇인가요?", "answer": "tables.testIamPermissions 메서드는 특정 리소스에 대해 호출자가 가진 권한을 반환합니다. 이 메서드는 권한이 없는 경우에도 NOT_FOUND 오류를 반환하지 않고 빈 권한 집합을 반환합니다. HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://bigquery.googleapis.com/bigquery/v2/{resource=projects/*/datasets/*/tables/*}:testIamPermissions\n```\n여기서 {resource}는 요청하는 정책 세부정보의 리소스를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_testIamPermissions.txt"}
{"question": "tables.testIamPermissions 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "요청 본문은 다음과 같은 구조를 가져야 합니다:\n\n```\n{\n  \"permissions\": [\n    string\n  ]\n}\n```\n여기서 permissions 필드는 리소스에 대해 확인할 권한의 집합을 포함합니다. 와일드카드(예: *, storage.*)는 허용되지 않습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_testIamPermissions.txt"}
{"question": "tables.testIamPermissions 메서드를 호출할 때 필요한 OAuth 스코프는 무엇인가요?", "answer": "tables.testIamPermissions 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_testIamPermissions.txt"}
{"question": "tables.testIamPermissions 메서드의 응답 본문은 어떤 형식을 가지나요?", "answer": "성공적으로 호출된 경우, 응답 본문은 TestIamPermissionsResponse 인스턴스를 포함합니다. 이 응답은 호출자가 요청한 권한의 상태를 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_testIamPermissions.txt"}
{"question": "tables.testIamPermissions 메서드의 사용 시 주의사항은 무엇인가요?", "answer": "tables.testIamPermissions 메서드는 권한 확인을 위한 것이 아니라 권한 인식 UI 및 명령줄 도구를 구축하기 위해 설계되었습니다. 이 작업은 경고 없이 'fail open'할 수 있습니다. 따라서 이 메서드를 사용할 때는 이러한 특성을 고려해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/testIamPermissions"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_testIamPermissions.txt"}
{"question": "BigQuery에서 테이블 정보를 업데이트할 때 사용하는 메서드는 무엇인가요?", "answer": "테이블 정보를 업데이트할 때 사용하는 메서드는 tables.update입니다. 이 메서드는 기존 테이블 리소스를 전체적으로 교체합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_update.txt"}
{"question": "tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 어떻게 되나요?", "answer": "tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n```\nPUT https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_update.txt"}
{"question": "tables.update 메서드의 요청 본문에는 어떤 정보가 포함되어야 하나요?", "answer": "tables.update 메서드의 요청 본문에는 Table 인스턴스가 포함되어야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_update.txt"}
{"question": "tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 무엇인가요?", "answer": "tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 autodetectSchema입니다. 이 파라미터가 true로 설정되면 스키마를 자동으로 감지하고, 그렇지 않으면 원래 스키마를 유지합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_update.txt"}
{"question": "tables.update 메서드를 사용하기 위해 필요한 인증 범위는 무엇인가요?", "answer": "tables.update 메서드를 사용하기 위해 필요한 인증 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/update"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_tables_update.txt"}
{"question": "BigQuery에서 TargetType의 사용 목적은 무엇인가요?", "answer": "TargetType은 데이터셋(dataset) 내에서 항목이 적용되는 리소스의 유형을 나타냅니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TargetType.txt"}
{"question": "TargetType에서 사용할 수 있는 enum 값은 무엇이 있나요?", "answer": "TargetType에서 사용할 수 있는 enum 값은 다음과 같습니다: \n\n```plaintext\nTARGET_TYPE_UNSPECIFIED Do not use. You must set a target type explicitly.\nVIEWS This entry applies to views in the dataset.\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TargetType.txt"}
{"question": "TARGET_TYPE_UNSPECIFIED의 의미는 무엇인가요?", "answer": "TARGET_TYPE_UNSPECIFIED는 사용하지 말아야 하며, 반드시 명시적으로 target type을 설정해야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TargetType.txt"}
{"question": "TargetType을 설정할 때 주의해야 할 점은 무엇인가요?", "answer": "TargetType을 설정할 때는 반드시 target type을 명시적으로 설정해야 하며, TARGET_TYPE_UNSPECIFIED는 사용하지 않아야 합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TargetType.txt"}
{"question": "TargetType의 VIEWS는 어떤 리소스에 적용되나요?", "answer": "VIEWS는 데이터셋(dataset) 내의 뷰(views)에 적용되는 항목입니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TargetType"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TargetType.txt"}
{"question": "TestIamPermissionsResponse의 JSON 구조는 어떻게 되나요?", "answer": "TestIamPermissionsResponse의 JSON 구조는 다음과 같습니다:\n\n```\n{\n  \"permissions\": [\n    string\n  ]\n}\n```", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TestIamPermissionsResponse"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TestIamPermissionsResponse.txt"}
{"question": "TestIamPermissionsResponse에서 permissions 필드는 어떤 정보를 담고 있나요?", "answer": "permissions 필드(permissions[])는 호출자가 허용된 TestPermissionsRequest.permissions의 하위 집합을 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TestIamPermissionsResponse"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TestIamPermissionsResponse.txt"}
{"question": "TestIamPermissionsResponse의 permissions 필드에 포함된 데이터 타입은 무엇인가요?", "answer": "permissions 필드(permissions[])는 string 타입의 데이터를 포함합니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TestIamPermissionsResponse"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TestIamPermissionsResponse.txt"}
{"question": "TestIamPermissionsResponse를 사용하여 어떤 정보를 확인할 수 있나요?", "answer": "TestIamPermissionsResponse를 사용하면 호출자가 특정 권한을 가지고 있는지를 확인할 수 있습니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TestIamPermissionsResponse"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TestIamPermissionsResponse.txt"}
{"question": "TestIamPermissionsResponse의 사용 예시는 무엇인가요?", "answer": "TestIamPermissionsResponse는 tables.testIamPermissions 메서드의 응답 메시지로 사용됩니다.", "source": ["https://cloud.google.com/bigquery/docs/reference/rest/v2/TestIamPermissionsResponse"], "tags": "bigquery", "last_verified": "2025-08-19", "source_file": "bigquery_docs_reference_rest_v2_TestIamPermissionsResponse.txt"}
{"question": "ACL 리소스의 액세스 제어 규칙을 삭제하는 방법은 무엇인가요?", "answer": "액세스 제어 규칙을 삭제하려면 DELETE 메서드를 사용하여 다음 URI를 호출합니다: \n\n```\nDELETE  /calendars/calendarId/acl/ruleId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "사용자의 캘린더 목록에서 특정 캘린더를 반환받으려면 어떤 메서드를 사용해야 하나요?", "answer": "특정 캘린더를 반환받으려면 GET 메서드를 사용하여 다음 URI를 호출합니다: \n\n```\nGET  /users/me/calendarList/calendarId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "사용자의 캘린더 목록에 새로운 캘린더를 삽입하는 방법은 무엇인가요?", "answer": "새로운 캘린더를 삽입하려면 POST 메서드를 사용하여 다음 URI를 호출합니다: \n\n```\nPOST  /users/me/calendarList\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "기존 캘린더를 업데이트할 때 PATCH 메서드를 사용하는 이유는 무엇인가요?", "answer": "PATCH 메서드는 기존 값을 대체하지 않고, 요청에 지정하지 않은 필드는 변경되지 않고 유지됩니다. 각 패치 요청은 3개의 할당량 단위를 사용합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "CalendarList 리소스의 변경사항을 확인하는 방법은 무엇인가요?", "answer": "CalendarList 리소스의 변경사항을 확인하려면 POST 메서드를 사용하여 다음 URI를 호출합니다: \n\n```\nPOST  /users/me/calendarList/watch\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "캘린더의 메타데이터를 업데이트할 때 PATCH 메서드를 사용하는 이유는 무엇인가요?", "answer": "PATCH 메서드는 캘린더의 메타데이터를 업데이트할 때 사용됩니다. 이 메소드는 패치 의미 체계를 지원하며, 각 패치 요청은 3개의 할당량 단위를 사용합니다. 지정하는 필드 값은 기존 값을 대체하며, 요청에 지정하지 않은 필드는 변경되지 않고 유지됩니다. 배열 필드(지정된 경우)는 기존 배열을 덮어씁니다. 이렇게 하면 이전 배열 요소가 삭제됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "기본 캘린더를 삭제하는 방법은 무엇인가요?", "answer": "기본 캘린더를 삭제하려면 POST 메서드를 사용하여 /calendars/calendarId/clear 엔드포인트에 요청을 보내야 합니다. 이 작업을 수행하면 계정의 기본 캘린더와 연결된 모든 일정이 삭제됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "보조 캘린더를 생성하는 방법은 무엇인가요?", "answer": "보조 캘린더를 생성하려면 POST 메서드를 사용하여 /calendars 엔드포인트에 요청을 보내야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "사용자의 캘린더 목록에서 특정 캘린더의 메타데이터를 반환받으려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자의 캘린더 목록에서 특정 캘린더의 메타데이터를 반환받으려면 GET 메서드를 사용하여 /users/me/calendarList/calendarId 엔드포인트에 요청을 보내야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "캘린더의 메타데이터를 업데이트할 때 PUT 메서드를 사용하는 이유는 무엇인가요?", "answer": "PUT 메서드는 캘린더의 메타데이터를 업데이트할 때 사용됩니다. 이 메서드는 기존의 메타데이터를 완전히 대체하며, 요청에 포함되지 않은 필드는 삭제됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "캘린더의 메타데이터를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 메타데이터를 가져오려면 GET 메서드와 함께 /calendars/calendarId 엔드포인트를 사용해야 합니다. 예시는 다음과 같습니다.\n\n```plaintext\nGET /calendars/calendarId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "보조 캘린더를 삭제하는 방법은 무엇인가요?", "answer": "보조 캘린더를 삭제하려면 DELETE 메서드와 함께 /calendars/calendarId 엔드포인트를 사용해야 합니다. 예시는 다음과 같습니다.\n\n```plaintext\nDELETE /calendars/calendarId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 삭제하려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 삭제하려면 DELETE 메서드와 함께 /calendars/calendarId/events/eventId 엔드포인트를 사용해야 합니다. 예시는 다음과 같습니다.\n\n```plaintext\nDELETE /calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 가져오려면 GET 메서드와 함께 /calendars/calendarId/events/eventId 엔드포인트를 사용해야 합니다. 예시는 다음과 같습니다.\n\n```plaintext\nGET /calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 다른 캘린더로 이동하려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 다른 캘린더로 이동하려면 POST 메서드와 함께 /calendars/calendarId/events/eventId/move 엔드포인트를 사용해야 하며, 필수 쿼리 매개변수로 destination을 지정해야 합니다. 예시는 다음과 같습니다.\n\n```plaintext\nPOST /calendars/calendarId/events/eventId/move?destination=destinationCalendarId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 가져오려면 GET 메서드를 사용하여 다음의 URI를 호출해야 합니다: `/calendars/calendarId/events/eventId`. 이 메서드는 Google Calendar ID를 기반으로 일정을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 삭제하려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 삭제하려면 DELETE 메서드를 사용하여 다음의 URI를 호출해야 합니다: `/calendars/calendarId/events/eventId`.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 다른 캘린더로 이동하려면 어떤 메서드를 사용해야 하나요?", "answer": "일정을 다른 캘린더로 이동하려면 POST 메서드를 사용하여 다음의 URI를 호출해야 합니다: `/calendars/calendarId/events/eventId/move`. 이때 필수 쿼리 매개변수로 `destination`을 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 업데이트할 때 PATCH 메서드를 사용하는 이유는 무엇인가요?", "answer": "PATCH 메서드는 부분 업데이트를 지원합니다. 각 패치 요청은 3개의 할당량 단위를 사용하며, 지정하는 필드 값은 기존 값을 대체하고 요청에 지정하지 않은 필드는 변경되지 않고 유지됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "간단한 텍스트 문자열을 기반으로 이벤트를 만드는 방법은 무엇인가요?", "answer": "간단한 텍스트 문자열을 기반으로 이벤트를 만들려면 POST 메서드를 사용하여 다음의 URI를 호출해야 합니다: `/calendars/calendarId/events/quickAdd`. 이때 필수 쿼리 매개변수로 `text`를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "이벤트를 업데이트할 때 PATCH 메서드를 사용하는 이유는 무엇인가요?", "answer": "PATCH 메서드는 일정을 업데이트할 때 사용되며, 패치 의미 체계를 지원합니다. 각 패치 요청은 3개의 할당량 단위를 사용합니다. 지정하는 필드 값은 기존 값을 대체하며, 요청에 지정하지 않은 필드는 변경되지 않고 유지됩니다. 배열 필드가 지정된 경우 기존 배열을 덮어씁니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "간단한 텍스트 문자열을 기반으로 이벤트를 생성하는 방법은 무엇인가요?", "answer": "간단한 텍스트 문자열을 기반으로 이벤트를 생성하려면 quickAdd 메서드를 사용합니다. 이 메서드는 POST 요청을 통해 다음과 같이 호출됩니다: \n``` \nPOST  /calendars/calendarId/events/quickAdd \n``` \n필수 쿼리 매개변수는 text입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "일정을 전체적으로 업데이트할 때 어떤 메서드를 사용해야 하나요?", "answer": "일정을 전체적으로 업데이트할 때는 PUT 메서드를 사용합니다. 이 메서드는 항상 전체 이벤트 리소스를 업데이트하며, 부분 업데이트를 수행하려면 get 다음에 etag를 사용하여 update를 실행해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "이벤트 리소스의 변경사항을 확인하는 방법은 무엇인가요?", "answer": "이벤트 리소스의 변경사항을 확인하려면 watch 메서드를 사용합니다. 이 메서드는 POST 요청을 통해 다음과 같이 호출됩니다: \n``` \nPOST  /calendars/calendarId/events/watch \n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "사용자 설정을 반환받으려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자 설정을 반환받으려면 get 메서드를 사용합니다. 이 메서드는 GET 요청을 통해 다음과 같이 호출됩니다: \n``` \nGET  /users/me/settings/setting \n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference?hl=ko"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference.txt"}
{"question": "ACL 규칙을 생성하는 방법은 무엇인가요?", "answer": "ACL 규칙을 생성하려면 `insert` 메서드를 사용합니다. 이 메서드는 새로운 액세스 제어 규칙을 만듭니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl.txt"}
{"question": "ACL 규칙의 역할(role)에는 어떤 값들이 있나요?", "answer": "ACL 규칙의 역할(role)에는 다음과 같은 값들이 있습니다: 'none', 'freeBusyReader', 'reader', 'writer', 'owner'. 각 역할은 특정한 액세스 권한을 제공합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl.txt"}
{"question": "ACL 규칙의 범위(scope)에는 어떤 유형이 있나요?", "answer": "ACL 규칙의 범위(scope)에는 다음과 같은 유형이 있습니다: 'default', 'user', 'group', 'domain'. 각 유형은 액세스 권한을 부여하는 범위를 정의합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl.txt"}
{"question": "ACL 규칙을 삭제하려면 어떤 메서드를 사용해야 하나요?", "answer": "ACL 규칙을 삭제하려면 `delete` 메서드를 사용합니다. 이 메서드는 특정 액세스 제어 규칙을 삭제합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl.txt"}
{"question": "ACL 규칙을 업데이트하는 방법은 무엇인가요?", "answer": "ACL 규칙을 업데이트하려면 `update` 메서드를 사용합니다. 이 메서드는 기존의 ACL 규칙을 새로운 값으로 업데이트합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl.txt"}
{"question": "ACL 규칙을 삭제하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "ACL 규칙을 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://www.googleapis.com/calendar/v3/calendars/calendarId/acl/ruleId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_delete.txt"}
{"question": "ACL 규칙 삭제 요청 시 필요한 경로 매개변수는 무엇인가요?", "answer": "ACL 규칙 삭제 요청 시 필요한 경로 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출하세요. 현재 로그인한 사용자의 기본 캘린더에 액세스하려면 'primary' 키워드를 사용하세요.\n- `ruleId`: ACL 규칙 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_delete.txt"}
{"question": "ACL 규칙 삭제 요청을 위해 필요한 승인 범위는 무엇인가요?", "answer": "ACL 규칙 삭제 요청을 위해 필요한 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_delete.txt"}
{"question": "ACL 규칙 삭제 요청 시 요청 본문은 어떻게 처리하나요?", "answer": "ACL 규칙 삭제 요청 시에는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_delete.txt"}
{"question": "ACL 규칙 삭제 요청이 성공했을 때의 응답은 어떻게 되나요?", "answer": "ACL 규칙 삭제 요청이 성공한 경우 이 메소드는 빈 응답 본문을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_delete.txt"}
{"question": "ACL 규칙을 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "ACL 규칙을 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId/acl/ruleId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_get.txt"}
{"question": "ACL 규칙을 가져오기 위해 필요한 매개변수는 무엇인가요?", "answer": "ACL 규칙을 가져오기 위해서는 두 개의 경로 매개변수가 필요합니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다. 현재 로그인한 사용자의 기본 캘린더에 액세스하려면 'primary' 키워드를 사용하세요.\n- `ruleId`: ACL 규칙 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_get.txt"}
{"question": "ACL 규칙을 가져오기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`\n- `https://www.googleapis.com/auth/calendar.acls.readonly`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_get.txt"}
{"question": "ACL 규칙을 가져오는 요청 본문은 어떻게 되나요?", "answer": "이 메소드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_get.txt"}
{"question": "ACL 규칙을 성공적으로 가져오면 어떤 응답을 받게 되나요?", "answer": "이 메서드는 성공하면 응답 본문에 Acl 리소스를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_get.txt"}
{"question": "ACL 규칙을 추가하기 위해 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "ACL 규칙을 추가하기 위해서는 다음과 같은 HTTP 요청 형식을 사용합니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/acl\n```\n여기서 `calendarId`는 캘린더 식별자를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_insert.txt"}
{"question": "ACL 규칙을 추가할 때 사용할 수 있는 역할(role) 값은 무엇이 있나요?", "answer": "ACL 규칙을 추가할 때 사용할 수 있는 역할(role) 값은 다음과 같습니다:\n- 'none': 액세스 권한을 제공하지 않습니다.\n- 'freeBusyReader': 비즈니스 일정 정보에 대한 읽기 액세스 권한을 제공합니다.\n- 'reader': 캘린더에 대한 읽기 액세스 권한을 제공합니다.\n- 'writer': 캘린더에 대한 읽기 및 쓰기 액세스 권한을 제공합니다.\n- 'owner': 캘린더의 소유권을 제공합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_insert.txt"}
{"question": "ACL 규칙을 추가할 때 선택적으로 사용할 수 있는 쿼리 매개변수는 무엇인가요?", "answer": "ACL 규칙을 추가할 때 선택적으로 사용할 수 있는 쿼리 매개변수는 `sendNotifications`입니다. 이 매개변수는 캘린더 공유 변경사항에 관한 알림을 전송할지 여부를 결정하며, 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_insert.txt"}
{"question": "ACL 규칙을 추가하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "ACL 규칙을 추가하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_insert.txt"}
{"question": "ACL 규칙의 범위(scope) 속성에 대해 설명해 주세요.", "answer": "ACL 규칙의 범위(scope) 속성은 캘린더 액세스가 부여되는 범위를 정의합니다. `scope` 객체는 다음과 같은 속성을 가집니다:\n- `type`: 범위 유형으로, 가능한 값은 'default', 'user', 'group', 'domain'이 있습니다.\n- `value`: 범위 유형에 따라 사용자 또는 그룹의 이메일 주소 또는 도메인 이름입니다. 'default' 유형의 경우 생략됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_insert.txt"}
{"question": "캘린더의 액세스 제어 목록을 가져오기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "캘린더의 액세스 제어 목록을 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId/acl\n```\n여기서 `calendarId`는 캘린더 식별자를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_list.txt"}
{"question": "요청 시 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "요청 시 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `maxResults`: 하나의 결과 페이지에 반환되는 최대 항목 수 (기본값: 100, 최대: 250)\n- `pageToken`: 반환할 결과 페이지를 지정하는 토큰\n- `showDeleted`: 삭제된 ACL을 결과에 포함할지 여부 (기본값: False)\n- `syncToken`: 이전 목록 요청의 결과에서 가져온 토큰으로, 변경된 항목만 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_list.txt"}
{"question": "syncToken이 만료되었을 때 서버는 어떤 응답 코드를 반환하나요?", "answer": "syncToken이 만료되면 서버는 410 GONE 응답 코드로 응답합니다. 이 경우 클라이언트는 저장소를 지우고 syncToken 없이 전체 동기화를 실행해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_list.txt"}
{"question": "이 메서드를 사용할 때 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "이 메서드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_list.txt"}
{"question": "캘린더의 액세스 제어 목록을 요청하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "캘린더의 액세스 제어 목록을 요청하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`\n- `https://www.googleapis.com/auth/calendar.acls.readonly`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_list.txt"}
{"question": "ACL 규칙을 업데이트하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "ACL 규칙을 업데이트하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```\nPATCH https://www.googleapis.com/calendar/v3/calendars/calendarId/acl/ruleId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_patch.txt"}
{"question": "ACL 규칙 업데이트 요청 시 필요한 경로 매개변수는 무엇인가요?", "answer": "ACL 규칙 업데이트 요청 시 필요한 경로 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.\n- `ruleId`: ACL 규칙 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_patch.txt"}
{"question": "ACL 규칙 업데이트 요청에서 선택적 쿼리 매개변수는 무엇이며, 기본값은 무엇인가요?", "answer": "ACL 규칙 업데이트 요청에서 선택적 쿼리 매개변수는 `sendNotifications`입니다. 이 매개변수는 캘린더 공유 변경사항에 관한 알림을 전송할지 여부를 결정합니다. 기본값은 `true`입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_patch.txt"}
{"question": "ACL 규칙 업데이트 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "ACL 규칙 업데이트 요청을 수행하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_patch.txt"}
{"question": "ACL 규칙 업데이트 요청의 응답으로 어떤 리소스가 반환되나요?", "answer": "ACL 규칙 업데이트 요청이 성공하면 응답 본문에 `Acl` 리소스가 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_patch.txt"}
{"question": "ACL 규칙을 업데이트하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "ACL 규칙을 업데이트하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPUT https://www.googleapis.com/calendar/v3/calendars/calendarId/acl/ruleId\n```\n여기서 `calendarId`는 캘린더 식별자이며, `ruleId`는 ACL 규칙 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_update.txt"}
{"question": "ACL 업데이트 요청에서 사용할 수 있는 선택적 쿼리 매개변수는 무엇인가요?", "answer": "ACL 업데이트 요청에서 사용할 수 있는 선택적 쿼리 매개변수는 `sendNotifications`입니다. 이 매개변수는 캘린더 공유 변경사항에 관한 알림을 전송할지 여부를 결정합니다. 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_update.txt"}
{"question": "ACL 업데이트 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "ACL 업데이트 요청을 수행하기 위해 필요한 승인 범위는 다음 중 하나 이상입니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.acls`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_update.txt"}
{"question": "ACL 업데이트 요청 본문에서 필수로 포함해야 하는 속성은 무엇인가요?", "answer": "ACL 업데이트 요청 본문에서 필수로 포함해야 하는 속성은 `scope`입니다. 이 속성은 ACL 규칙에서 캘린더 액세스가 부여되는 범위를 정의합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_update.txt"}
{"question": "ACL 규칙의 `scope.type` 속성에서 사용할 수 있는 값은 무엇인가요?", "answer": "`scope.type` 속성에서 사용할 수 있는 값은 다음과 같습니다:\n- `default`: 공개 범위입니다. 기본값입니다.\n- `user`: 범위를 단일 사용자로 제한합니다.\n- `group`: 범위를 그룹으로 제한합니다.\n- `domain`: 범위를 도메인으로 제한합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_update.txt"}
{"question": "ACL 리소스의 변경사항을 확인하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "ACL 리소스의 변경사항을 확인하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```plaintext\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/acl/watch\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_watch.txt"}
{"question": "ACL 리소스의 변경사항을 확인하기 위한 요청 본문은 어떤 구조를 가져야 하나요?", "answer": "ACL 리소스의 변경사항을 확인하기 위한 요청 본문은 다음과 같은 구조를 가져야 합니다.\n\n```json\n{\n  \"id\": string,\n  \"token\": string,\n  \"type\": string,\n  \"address\": string,\n  \"params\": {\n    \"ttl\": string\n  }\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_watch.txt"}
{"question": "ACL 리소스의 변경사항을 확인하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "ACL 리소스의 변경사항을 확인하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.acls\n- https://www.googleapis.com/auth/calendar.acls.readonly", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_watch.txt"}
{"question": "요청이 성공했을 때 반환되는 응답 본문의 구조는 어떻게 되나요?", "answer": "요청이 성공했을 때 반환되는 응답 본문의 구조는 다음과 같습니다.\n\n```json\n{\n  \"kind\": \"api#channel\",\n  \"id\": string,\n  \"resourceId\": string,\n  \"resourceUri\": string,\n  \"token\": string,\n  \"expiration\": long\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_watch.txt"}
{"question": "요청 본문에서 'params' 속성의 'ttl'은 무엇을 의미하나요?", "answer": "'params' 속성의 'ttl'은 알림 채널의 수명(초)을 의미합니다. 기본값은 604,800초입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/acl/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_acl_watch.txt"}
{"question": "캘린더의 기본 색상을 설정하려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 기본 색상(backgroundColor)을 설정하거나 변경하려면 insert, update, patch 메서드의 매개변수에서 colorRgbFormat=true를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 알림을 추가할 때 필요한 필드는 무엇인가요?", "answer": "캘린더의 알림(defaultReminders)을 추가할 때는 method와 minutes 필드가 필요합니다. method는 알림에서 사용하는 방법으로 'email' 또는 'popup' 중 하나를 선택할 수 있으며, minutes는 일정이 시작되기 전까지 알림이 트리거되어야 하는 시간(분)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 액세스 역할(accessRole)에는 어떤 값들이 있나요?", "answer": "캘린더의 액세스 역할(accessRole)에는 다음과 같은 값들이 있습니다: 'freeBusyReader', 'reader', 'writer', 'owner'.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더 목록 항목이 삭제되었는지 여부를 확인하는 필드는 무엇인가요?", "answer": "캘린더 목록 항목이 삭제되었는지 여부를 확인하는 필드는 deleted입니다. 이 필드는 읽기 전용이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 설명(description) 필드는 어떤 용도로 사용되나요?", "answer": "캘린더의 설명(description) 필드는 캘린더에 대한 설명을 제공하는 데 사용됩니다. 이 필드는 읽기 전용입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 기본 알림(defaultReminders)을 추가할 때 필요한 필드는 무엇인가요?", "answer": "캘린더의 기본 알림(defaultReminders)을 추가할 때 필요한 필드는 다음과 같습니다:\n\n- method: 이 알림에서 사용하는 방법입니다. 가능한 값은 다음과 같습니다.\n  - 'email' - 알림은 이메일을 통해 전송됩니다.\n  - 'popup' - 알림은 UI 팝업을 통해 전송됩니다.\n\n- minutes: 일정이 시작되기 전까지 알림이 트리거되어야 하는 시간(분)입니다. 유효한 값은 0에서 40320 (분 기준 4주) 사이입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 색상(backgroundColor, foregroundColor)을 설정하려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 색상(backgroundColor, foregroundColor)을 설정하거나 변경하려면 다음 메서드를 사용해야 합니다:\n- insert [https://developers.google.com/calendar/v3/reference/calendarList/insert?hl=ko]\n- update [https://developers.google.com/calendar/v3/reference/calendarList/update?hl=ko]\n- patch [https://developers.google.com/calendar/v3/reference/calendarList/patch?hl=ko]\n\n이 메서드의 매개변수에서 colorRgbFormat=true를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 회의 속성(conferenceProperties)에는 어떤 정보가 포함되나요?", "answer": "캘린더의 회의 속성(conferenceProperties)에는 이 캘린더의 회의 속성(예: 허용되는 회의 유형)이 포함됩니다. 이 속성의 allowedConferenceSolutionTypes[] 리스트에는 사용 가능한 회의 솔루션 유형이 포함되며, 가능한 값은 다음과 같습니다:\n- 'eventHangout'\n- 'eventNamedHangout'\n- 'hangoutsMeet'", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 숨김 처리 여부(hidden)를 확인하는 방법은 무엇인가요?", "answer": "캘린더의 숨김 처리 여부(hidden)는 선택사항이며, 이 속성은 캘린더가 숨겨져 있는 경우에만 반환됩니다. 이 경우 값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 기본 색상(backgroundColor)과 전경색(foregroundColor)을 설정할 때 주의해야 할 점은 무엇인가요?", "answer": "캘린더의 기본 색상(backgroundColor)과 전경색(foregroundColor)을 설정하거나 변경할 때는 반드시 insert, update, patch 메서드의 매개변수에서 colorRgbFormat=true를 지정해야 합니다. 이 속성은 색인 기반 colorId 속성을 대체합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 전경색(foregroundColor)을 설정하려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 전경색(foregroundColor)을 설정하거나 변경하려면 insert, update, patch 메서드의 매개변수에서 colorRgbFormat=true를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 지리적 위치(location) 필드는 어떤 용도로 사용되나요?", "answer": "캘린더의 지리적 위치(location) 필드는 자유 형식 텍스트로 된 캘린더의 위치 정보를 담고 있으며, 선택사항으로 읽기 전용입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 알림(notificationSettings) 설정은 어떻게 구성되나요?", "answer": "캘린더의 알림(notificationSettings)은 인증된 사용자가 이 캘린더에 대해 수신하는 알림을 설정하는 객체입니다. 이 객체는 notifications 배열을 포함하며, 각 알림은 method와 type 필드를 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 기본 캘린더(primary) 여부는 어떻게 확인하나요?", "answer": "캘린더의 기본 캘린더(primary) 여부는 읽기 전용 속성으로, 기본값은 False입니다. 이 필드를 통해 인증된 사용자의 기본 캘린더인지 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더의 시간대(timeZone) 필드는 어떤 정보를 담고 있나요?", "answer": "캘린더의 시간대(timeZone) 필드는 선택사항으로 읽기 전용이며, 캘린더의 시간대를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList.txt"}
{"question": "캘린더를 삭제하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더를 삭제하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```\nDELETE https://www.googleapis.com/calendar/v3/users/me/calendarList/calendarId\n```\n여기서 `calendarId`는 삭제할 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_delete.txt"}
{"question": "캘린더 삭제 요청 시 어떤 매개변수가 필요한가요?", "answer": "캘린더 삭제 요청 시 필요한 매개변수는 다음과 같습니다:\n- 경로 매개변수:\n  - `calendarId` (string): 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_delete.txt"}
{"question": "캘린더 삭제 요청을 수행하기 위해 어떤 승인 범위가 필요한가요?", "answer": "캘린더 삭제 요청을 수행하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendarlist`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_delete.txt"}
{"question": "캘린더 삭제 요청 시 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "캘린더 삭제 요청을 수행할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_delete.txt"}
{"question": "캘린더 삭제 요청이 성공하면 어떤 응답을 받게 되나요?", "answer": "캘린더 삭제 요청이 성공한 경우 이 메소드는 빈 응답 본문을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_delete.txt"}
{"question": "캘린더 목록에서 특정 캘린더를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 캘린더를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/users/me/calendarList/calendarId\n```\n여기서 `calendarId`는 가져오고자 하는 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_get.txt"}
{"question": "캘린더 ID를 어떻게 가져올 수 있나요?", "answer": "캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다. 이 메서드는 사용자의 캘린더 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_get.txt"}
{"question": "이 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendarlist`\n- `https://www.googleapis.com/auth/calendar.calendarlist.readonly`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_get.txt"}
{"question": "이 메서드를 사용할 때 요청 본문은 어떻게 처리하나요?", "answer": "이 메서드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_get.txt"}
{"question": "요청이 성공적으로 수행되면 어떤 응답을 받게 되나요?", "answer": "요청이 성공하면 응답 본문에서 `CalendarList` 리소스를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_get.txt"}
{"question": "캘린더를 삽입하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "캘린더를 삽입하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/users/me/calendarList\n```\n이 요청은 사용자의 캘린더 목록에 기존 캘린더를 삽입합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 시 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 삽입 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.calendarlist\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 본문에 포함해야 하는 필수 속성은 무엇인가요?", "answer": "캘린더 삽입 요청 본문에는 다음과 같은 필수 속성이 포함되어야 합니다:\n- `id` (string): 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더의 기본 색상을 설정하기 위해 요청 본문에서 어떤 속성을 사용해야 하나요?", "answer": "캘린더의 기본 색상을 설정하기 위해 요청 본문에서 `backgroundColor` (string) 속성을 사용해야 합니다. 이 속성은 16진수 형식 '#0088aa'로 캘린더 기본 색상을 지정합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 시 기본 리마인더를 설정하는 방법은 무엇인가요?", "answer": "캘린더 삽입 시 기본 리마인더를 설정하려면 `defaultReminders[]` (list) 속성을 사용해야 합니다. 각 리마인더는 `method` (string)과 `minutes` (integer) 속성을 포함해야 하며, `method`는 'email' 또는 'popup' 중 하나로 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 시 기본 리마인더를 설정하기 위해 어떤 속성을 사용해야 하나요?", "answer": "기본 리마인더를 설정하기 위해서는 요청 본문에 defaultReminders[] 속성을 사용해야 합니다. 이 속성은 인증된 사용자가 이 캘린더에 설정한 기본 리마인더를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더의 전경 색상을 설정하기 위해 요청 본문에서 어떤 속성을 사용해야 하나요?", "answer": "캘린더의 전경 색상을 설정하기 위해서는 foregroundColor 속성을 사용해야 합니다. 이 속성은 16진수 형식으로 '#ffffff'의 값을 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 시 알림 설정을 추가하려면 어떤 속성을 사용해야 하나요?", "answer": "알림 설정을 추가하려면 notificationSettings 속성을 사용해야 합니다. 이 속성은 인증된 사용자가 이 캘린더에 대해 수신하는 알림을 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 시 숨김 여부를 설정하기 위해 어떤 속성을 사용해야 하나요?", "answer": "캘린더의 숨김 여부를 설정하기 위해서는 hidden 속성을 사용해야 합니다. 이 속성은 캘린더가 목록에서 숨겨져 있는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 삽입 요청 시 선택 여부를 설정하기 위해 어떤 속성을 사용해야 하나요?", "answer": "캘린더의 선택 여부를 설정하기 위해서는 selected 속성을 사용해야 합니다. 이 속성은 캘린더 콘텐츠가 캘린더 UI에 표시되는지 여부를 나타내며, 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_insert.txt"}
{"question": "캘린더 목록을 가져오기 위한 HTTP 요청은 어떻게 하나요?", "answer": "캘린더 목록을 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용합니다.\n\n```\nGET https://www.googleapis.com/calendar/v3/users/me/calendarList\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청 시 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "캘린더 목록 요청 시 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `maxResults`: 하나의 결과 페이지에 반환되는 최대 항목 수입니다. 기본값은 100개입니다.\n- `minAccessRole`: 반환된 항목에서 사용자의 최소 액세스 역할입니다. 기본값은 제한이 없습니다.\n- `pageToken`: 반환할 결과 페이지를 지정하는 토큰입니다.\n- `showDeleted`: 삭제된 캘린더 목록 항목을 결과에 포함할지 여부입니다. 기본값은 False입니다.\n- `showHidden`: 숨겨진 항목을 표시할지 여부입니다. 기본값은 False입니다.\n- `syncToken`: 이전 목록 요청의 결과 마지막 페이지에서 반환된 nextSyncToken 필드에서 가져온 토큰입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청 시 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 목록 요청을 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.calendarlist`\n- `https://www.googleapis.com/auth/calendar.calendarlist.readonly`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청의 응답 구조는 어떻게 되나요?", "answer": "캘린더 목록 요청에 성공할 경우, 응답 본문은 다음과 같은 구조를 가집니다:\n```json\n{\n  \"kind\": \"calendar#calendarList\",\n  \"etag\": etag,\n  \"nextPageToken\": string,\n  \"nextSyncToken\": string,\n  \"items\": [\n    calendarList Resource\n  ]\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "syncToken이 만료되면 서버는 어떤 응답 코드를 반환하나요?", "answer": "syncToken이 만료되면 서버는 410 GONE 응답 코드로 응답합니다. 이 경우 클라이언트는 저장소를 지우고 syncToken 없이 전체 동기화를 실행해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "syncToken이 만료되었을 때 서버는 어떤 응답 코드를 반환하나요?", "answer": "syncToken이 만료되면 서버는 410 GONE 응답 코드로 응답합니다. 클라이언트는 저장소를 지우고 syncToken 없이 전체 동기화를 실행해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청 시 사용 가능한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.calendarlist\n- https://www.googleapis.com/auth/calendar.calendarlist.readonly", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청의 응답 본문 구조는 어떻게 되나요?", "answer": "요청에 성공할 경우 이 메소드는 다음과 같은 구조의 응답 본문을 반환합니다.\n{\n  \"kind\": \"calendar#calendarList\",\n  \"etag\": etag,\n  \"nextPageToken\": string,\n  \"nextSyncToken\": string,\n  \"items\": [\n    calendarList Resource [https://developers.google.com/workspace/calendar/api/v3/reference/calendarList?hl=ko#resource]\n  ]\n}", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청 시 showDeleted 또는 showHidden 매개변수는 어떻게 작동하나요?", "answer": "이 목록 요청의 결과에 그 이후에 변경된 항목만 포함되도록 하려면 syncToken을 사용해야 합니다. 이전 목록 요청 이후에 삭제되고 숨겨진 모든 항목은 항상 결과 세트에 포함되며 showDeleted 또는 showHidden를 False로 설정할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "캘린더 목록 요청 시 minAccessRole 쿼리 매개변수는 어떻게 사용하나요?", "answer": "클라이언트 상태 일관성을 보장하기 위해 minAccessRole 쿼리 매개변수를 nextSyncToken과 함께 지정할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_list.txt"}
{"question": "PATCH 메서드를 사용하여 캘린더를 업데이트할 때 어떤 요청 본문을 제공해야 하나요?", "answer": "요청 본문에 패치 시맨틱스의 규칙에 따라 CalendarList 리소스의 관련 부분을 제공합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_patch.txt"}
{"question": "캘린더 업데이트 요청 시 어떤 매개변수를 사용해야 하나요?", "answer": "경로 매개변수로 calendarId(string)를 사용해야 하며, 캘린더 ID를 가져오려면 calendarList.list 메서드를 호출해야 합니다. 또한 선택적 쿼리 매개변수로 colorRgbFormat(boolean)를 사용할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_patch.txt"}
{"question": "캘린더 색상을 RGB 형식으로 설정하려면 어떤 매개변수를 사용해야 하나요?", "answer": "colorRgbFormat(boolean) 매개변수를 사용하여 foregroundColor 및 backgroundColor 필드를 사용하여 캘린더 색상을 RGB로 작성할 수 있습니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_patch.txt"}
{"question": "캘린더 업데이트 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다: https://www.googleapis.com/auth/calendar, https://www.googleapis.com/auth/calendar.app.created, https://www.googleapis.com/auth/calendar.calendarlist.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_patch.txt"}
{"question": "캘린더 업데이트 요청이 성공하면 어떤 응답을 받게 되나요?", "answer": "이 메서드는 요청에 성공하면 응답 본문에서 CalendarList 리소스를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_patch.txt"}
{"question": "캘린더를 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "캘린더를 업데이트할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPUT https://www.googleapis.com/calendar/v3/users/me/calendarList/calendarId\n```\n여기서 `calendarId`는 업데이트할 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더 업데이트 요청 시 사용할 수 있는 선택적 쿼리 매개변수는 무엇인가요?", "answer": "캘린더 업데이트 요청 시 사용할 수 있는 선택적 쿼리 매개변수는 `colorRgbFormat`입니다. 이 매개변수는 `foregroundColor` 및 `backgroundColor` 필드를 사용하여 캘린더 색상(RGB)을 작성할지 여부를 결정합니다. 기본값은 `False`입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더 업데이트 요청 본문에 포함해야 하는 속성은 무엇인가요?", "answer": "캘린더 업데이트 요청 본문에는 다음 속성이 포함되어야 합니다:\n- `backgroundColor`: 16진수 형식의 캘린더 기본 색상입니다.\n- `colorId`: 캘린더의 색상 ID입니다.\n- `defaultReminders`: 기본 리마인더 설정입니다.\n- `foregroundColor`: 16진수 형식의 캘린더 전경 색상입니다.\n- `hidden`: 캘린더가 목록에서 숨겨져 있는지 여부입니다.\n- `notificationSettings`: 알림 설정입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더의 색상 속성을 업데이트하려면 어떤 매개변수를 설정해야 하나요?", "answer": "캘린더의 색상 속성을 업데이트하려면 요청 본문에서 `colorRgbFormat` 매개변수를 `true`로 설정해야 합니다. 이 경우 `backgroundColor` 및 `foregroundColor` 속성을 사용할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더 업데이트 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 업데이트 요청을 수행하기 위해 필요한 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendarlist`\n이 중 하나 이상에 대한 승인이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더 업데이트 요청 본문에 포함할 수 있는 선택 속성은 무엇인가요?", "answer": "요청 본문에는 다음과 같은 선택 속성을 포함할 수 있습니다: \n- backgroundColor: 16진수 형식 '#0088aa'의 캘린더 기본 색상입니다. 이 속성은 색인 기반 colorId 속성을 대체합니다. \n- colorId: 캘린더의 색상입니다. 색상 정의의 calendar 섹션에 있는 항목을 참조하는 ID입니다. \n- defaultReminders: 인증된 사용자가 이 캘린더에 설정한 기본 리마인더입니다. \n- foregroundColor: 16진수 형식 '#ffffff'의 캘린더 전경 색상입니다. \n- hidden: 캘린더가 목록에서 숨겨져 있는지 여부입니다. \n- notificationSettings: 인증된 사용자가 이 캘린더에 대해 수신하는 알림입니다. \n- selected: 캘린더 콘텐츠가 캘린더 UI에 표시되는지 여부입니다. \n- summaryOverride: 인증된 사용자가 이 캘린더에 설정한 요약입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더의 기본 리마인더를 설정할 때 필요한 속성은 무엇인가요?", "answer": "캘린더의 기본 리마인더를 설정할 때는 다음과 같은 속성이 필요합니다: \n- defaultReminders[].method: 이 리마인더에서 사용하는 메서드로, 가능한 값은 'email' (이메일을 통해 전송) 또는 'popup' (UI 팝업을 통해 전송)입니다. \n- defaultReminders[].minutes: 이벤트 시작 전 리마인더가 트리거되어야 하는 시간(분)으로, 유효한 값은 0~40320(4주(분))입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더의 색상 속성을 업데이트하기 위해 어떤 매개변수를 설정해야 하나요?", "answer": "캘린더의 색상 속성을 업데이트하기 위해서는 insert, update, patch 메서드의 매개변수에 colorRgbFormat=true를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더의 알림 설정을 추가할 때 필요한 속성은 무엇인가요?", "answer": "캘린더의 알림 설정을 추가할 때는 다음과 같은 속성이 필요합니다: \n- notificationSettings.notifications[].method: 알림을 전송하는 데 사용되는 방법으로, 가능한 값은 'email'입니다. \n- notificationSettings.notifications[].type: 알림의 유형으로, 가능한 값은 'eventCreation', 'eventChange', 'eventCancellation', 'eventResponse', 'agenda'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "캘린더가 숨겨져 있는지 여부를 확인하는 속성은 무엇인가요?", "answer": "캘린더가 숨겨져 있는지 여부를 확인하는 속성은 hidden입니다. 이 속성은 캘린더가 숨겨진 경우에만 반환되며, 이 경우 값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_update.txt"}
{"question": "CalendarList 리소스의 변경사항을 확인하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "CalendarList 리소스의 변경사항을 확인하기 위해서는 다음과 같은 HTTP POST 요청을 사용해야 합니다.\n\n```plaintext\nPOST https://www.googleapis.com/calendar/v3/users/me/calendarList/watch\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_watch.txt"}
{"question": "CalendarList: watch 메서드의 요청 본문 구조는 어떻게 되나요?", "answer": "요청 본문은 다음과 같은 구조의 데이터를 제공합니다.\n\n```json\n{\n  \"id\": \nstring,\n  \"token\": \nstring,\n  \"type\": \nstring,\n  \"address\": \nstring,\n  \"params\": {\n    \"ttl\": \nstring\n  }\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_watch.txt"}
{"question": "CalendarList: watch 메서드에서 사용해야 하는 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.calendarlist\n- https://www.googleapis.com/auth/calendar.calendarlist.readonly\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_watch.txt"}
{"question": "CalendarList: watch 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "요청에 성공할 경우 이 메소드는 다음과 같은 구조의 응답 본문을 반환합니다.\n\n```json\n{\n  \"kind\": \"api#channel\",\n  \"id\": \nstring,\n  \"resourceId\": \nstring,\n  \"resourceUri\": \nstring,\n  \"token\": \nstring,\n  \"expiration\": \nlong\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_watch.txt"}
{"question": "CalendarList: watch 메서드의 params.ttl 속성은 무엇을 의미하나요?", "answer": "params.ttl 속성은 알림 채널의 수명(초)을 의미합니다. 기본값은 604,800초입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendarList/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendarList_watch.txt"}
{"question": "캘린더의 메타데이터를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 메타데이터를 가져오려면 `get` 메서드([https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get?hl=ko](https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get?hl=ko))를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars.txt"}
{"question": "보조 캘린더를 생성하는 방법은 무엇인가요?", "answer": "보조 캘린더를 생성하려면 `insert` 메서드([https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert?hl=ko](https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert?hl=ko))를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars.txt"}
{"question": "캘린더의 메타데이터를 업데이트하려면 어떤 메서드를 사용해야 하나요?", "answer": "캘린더의 메타데이터를 업데이트하려면 `update` 메서드([https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update?hl=ko](https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update?hl=ko))를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars.txt"}
{"question": "캘린더의 회의 속성에 대해 설명해 주세요.", "answer": "캘린더의 회의 속성은 `conferenceProperties` nested object로, 이 캘린더의 회의 속성(예: 허용되는 회의 유형)을 포함합니다. `conferenceProperties.allowedConferenceSolutionTypes[]`는 이 캘린더에서 지원되는 회의 솔루션 유형을 나타내며, 사용할 수 있는 값은 'eventHangout', 'eventNamedHangout', 'hangoutsMeet'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars.txt"}
{"question": "캘린더를 삭제하는 방법은 무엇인가요?", "answer": "보조 캘린더를 삭제하려면 `delete` 메서드([https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete?hl=ko](https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete?hl=ko))를 사용해야 합니다. 기본 캘린더의 모든 일정을 삭제하려면 `calendar.clear` 메서드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars.txt"}
{"question": "캘린더를 비우기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더를 비우기 위해서는 다음과 같은 HTTP POST 요청을 사용해야 합니다.\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/clear\n```\n여기서 `calendarId`는 비우고자 하는 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/clear"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_clear.txt"}
{"question": "캘린더를 비우기 위해 필요한 승인 범위는 무엇인가요?", "answer": "캘린더를 비우기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.calendars`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/clear"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_clear.txt"}
{"question": "캘린더를 비우기 위한 요청 본문은 어떻게 되나요?", "answer": "이 메소드를 사용할 때는 요청 본문을 제공하지 않아야 합니다. 즉, 요청 본문은 비워두어야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/clear"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_clear.txt"}
{"question": "캘린더를 비운 후의 응답은 어떻게 되나요?", "answer": "요청에 성공한 경우 이 메소드는 빈 응답 본문을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/clear"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_clear.txt"}
{"question": "기본 캘린더를 비우면 어떤 결과가 발생하나요?", "answer": "기본 캘린더를 비우면 계정의 기본 캘린더와 연결된 모든 일정이 삭제됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/clear"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_clear.txt"}
{"question": "캘린더를 삭제하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더를 삭제하기 위해서는 다음의 HTTP 요청을 사용해야 합니다.\n\n```\nDELETE https://www.googleapis.com/calendar/v3/calendars/calendarId\n```\n여기서 `calendarId`는 삭제할 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_delete.txt"}
{"question": "캘린더 삭제 요청 시 어떤 매개변수가 필요한가요?", "answer": "캘린더 삭제 요청 시 필요한 매개변수는 다음과 같습니다:\n- `calendarId` (string): 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_delete.txt"}
{"question": "캘린더 삭제 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 삭제 요청을 수행하기 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendars`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_delete.txt"}
{"question": "캘린더 삭제 요청 시 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "캘린더 삭제 요청을 수행할 때는 요청 본문을 제공하지 않아야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_delete.txt"}
{"question": "캘린더 삭제 요청이 성공했을 때의 응답은 어떻게 되나요?", "answer": "캘린더 삭제 요청이 성공한 경우, 이 메소드는 빈 응답 본문을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_delete.txt"}
{"question": "캘린더의 메타데이터를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더의 메타데이터를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId\n```\n여기서 `calendarId`는 요청하려는 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_get.txt"}
{"question": "캘린더 ID를 어떻게 가져올 수 있나요?", "answer": "캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다. 이 메서드는 현재 로그인한 사용자의 캘린더 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_get.txt"}
{"question": "이 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendars`\n- `https://www.googleapis.com/auth/calendar.calendars.readonly`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_get.txt"}
{"question": "이 메서드를 사용할 때 요청 본문은 어떻게 처리하나요?", "answer": "이 메서드를 사용할 때는 요청 본문을 제공하지 마세요. 요청 본문 없이 HTTP GET 요청을 수행해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_get.txt"}
{"question": "요청이 성공했을 때 어떤 응답을 받게 되나요?", "answer": "요청이 성공하면 응답 본문에서 `Calendars` 리소스를 반환합니다. 이 리소스는 요청한 캘린더의 메타데이터를 포함하고 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_get.txt"}
{"question": "Google Calendar API를 사용하여 보조 캘린더를 생성하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "보조 캘린더를 생성하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_insert.txt"}
{"question": "캘린더 생성 요청 시 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 생성 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.app.created\n- https://www.googleapis.com/auth/calendar.calendars", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_insert.txt"}
{"question": "캘린더 생성 요청 본문에서 필수로 포함해야 하는 속성은 무엇인가요?", "answer": "캘린더 생성 요청 본문에서는 다음과 같은 필수 속성을 포함해야 합니다:\n- `summary` (string): 캘린더의 제목입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_insert.txt"}
{"question": "캘린더 생성 요청이 성공적으로 처리되면 어떤 응답을 받게 되나요?", "answer": "이 메서드는 요청에 성공하면 응답 본문에서 Calendars 리소스를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_insert.txt"}
{"question": "Google Calendar API에서 캘린더를 생성하기 위한 요청 본문 예시는 무엇인가요?", "answer": "캘린더 생성 요청 본문 예시는 다음과 같습니다:\n\n```\n{\n  \"summary\": \"새로운 캘린더\"\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_insert.txt"}
{"question": "캘린더의 메타데이터를 업데이트하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더의 메타데이터를 업데이트하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```\nPATCH https://www.googleapis.com/calendar/v3/calendars/calendarId\n```\n여기서 `calendarId`는 업데이트할 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_patch.txt"}
{"question": "캘린더 업데이트 요청 시 어떤 매개변수를 사용해야 하나요?", "answer": "캘린더 업데이트 요청 시 사용해야 하는 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_patch.txt"}
{"question": "캘린더 업데이트 요청을 위해 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 업데이트 요청을 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendars`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_patch.txt"}
{"question": "캘린더 업데이트 요청 본문에는 어떤 내용을 포함해야 하나요?", "answer": "캘린더 업데이트 요청 본문에는 패치 시맨틱스의 규칙에 따라 `Calendars` 리소스의 관련 부분을 제공해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_patch.txt"}
{"question": "캘린더 업데이트 요청이 성공하면 어떤 응답을 받게 되나요?", "answer": "캘린더 업데이트 요청이 성공하면 응답 본문에서 `Calendars` 리소스를 반환받게 됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_patch.txt"}
{"question": "캘린더의 메타데이터를 업데이트하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "캘린더의 메타데이터를 업데이트하기 위해서는 다음과 같은 HTTP 요청을 사용합니다:\n\n```\nPUT https://www.googleapis.com/calendar/v3/calendars/calendarId\n```\n여기서 `calendarId`는 업데이트할 캘린더의 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_update.txt"}
{"question": "캘린더 업데이트 요청 시 필요한 승인 범위는 무엇인가요?", "answer": "캘린더 업데이트 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.calendars`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_update.txt"}
{"question": "캘린더 업데이트 요청 본문에서 사용할 수 있는 속성은 무엇인가요?", "answer": "캘린더 업데이트 요청 본문에서는 다음과 같은 속성을 사용할 수 있습니다:\n- `description`: 캘린더에 대한 설명 (선택사항, 쓰기 가능)\n- `location`: 캘린더의 지리적 위치 (선택사항, 쓰기 가능)\n- `summary`: 캘린더의 제목 (선택사항, 쓰기 가능)\n- `timeZone`: 캘린더의 시간대 (선택사항, 쓰기 가능, IANA 시간대 데이터베이스 이름 형식)", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_update.txt"}
{"question": "캘린더 업데이트 요청이 성공했을 때의 응답은 어떤 형식인가요?", "answer": "캘린더 업데이트 요청이 성공하면 응답 본문에서 Calendars 리소스를 반환합니다. 이 리소스는 업데이트된 캘린더의 메타데이터를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_update.txt"}
{"question": "기본 캘린더에 접근하기 위해서는 어떤 값을 사용해야 하나요?", "answer": "현재 로그인한 사용자의 기본 캘린더에 접근하기 위해서는 `primary` 키워드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/calendars/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_calendars_update.txt"}
{"question": "Channels 리소스의 메소드는 무엇이 있나요?", "answer": "Channels 리소스에는 'stop' 메소드가 있습니다. 이 메소드는 채널을 통해 리소스를 시청하지 않도록 중지합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels.txt"}
{"question": "Channels 리소스는 영구 데이터가 연결되어 있나요?", "answer": "아니요, Channels 리소스에는 영구 데이터가 연결되어 있지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels.txt"}
{"question": "Channels 리소스를 사용하여 리소스를 시청하는 방법은 무엇인가요?", "answer": "Channels 리소스를 사용하여 리소스를 시청하는 방법에 대한 구체적인 내용은 문서에 명시되어 있지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels.txt"}
{"question": "Channels 리소스의 리소스 표현에 대한 정보는 어디에서 찾을 수 있나요?", "answer": "Channels 리소스의 리소스 표현에 대한 정보는 [리소스 표현](https://developers.google.com/workspace/calendar/api/v3/reference/channels?hl=ko#resource-representations) 섹션에서 찾을 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels.txt"}
{"question": "Channels 리소스의 메소드 목록은 어디에서 확인할 수 있나요?", "answer": "Channels 리소스의 메소드 목록은 이 페이지의 하단에 나와 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels.txt"}
{"question": "채널을 중지하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "채널을 중지하기 위한 HTTP 요청은 다음과 같이 구성됩니다.\n\n```http\nPOST https://www.googleapis.com/calendar/v3/channels/stop\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels/stop"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels_stop.txt"}
{"question": "채널 중지 요청 시 필요한 요청 본문의 구조는 무엇인가요?", "answer": "채널 중지 요청 시 요청 본문은 다음과 같은 구조의 데이터를 포함해야 합니다.\n\n```json\n{\n  \"id\": string,\n  \"resourceId\": string\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels/stop"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels_stop.txt"}
{"question": "채널 중지 요청 본문에서 'id'와 'resourceId'의 역할은 무엇인가요?", "answer": "'id'는 이 채널을 식별하는 UUID 또는 이와 유사한 고유한 문자열이며, 'resourceId'는 이 채널에서 시청 중인 리소스를 식별하는 불투명 ID입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels/stop"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels_stop.txt"}
{"question": "채널 중지 요청 시 선택적으로 포함할 수 있는 'token'의 용도는 무엇인가요?", "answer": "'token'은 대상 주소로 전송되는 임의 문자열로, 각 알림이 이 채널을 통해 전달됩니다. 이는 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels/stop"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels_stop.txt"}
{"question": "채널 중지 요청이 성공했을 때의 응답은 어떻게 되나요?", "answer": "채널 중지 요청에 성공한 경우, 이 메소드는 빈 응답 본문을 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/channels/stop"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_channels_stop.txt"}
{"question": "캘린더 색상 정의를 가져오는 메서드는 무엇인가요?", "answer": "캘린더 색상 정의를 가져오는 메서드는 `get`입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors.txt"}
{"question": "리소스 표현에서 'calendar' 객체의 구조는 어떻게 되나요?", "answer": "리소스 표현에서 'calendar' 객체는 다음과 같은 구조를 가집니다:\n```json\n{\n  \"calendar\": {\n    (key): {\n      \"background\": string,\n      \"foreground\": string\n    }\n  }\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors.txt"}
{"question": "이벤트 색상 정의의 'foreground' 속성은 무엇을 의미하나요?", "answer": "'foreground' 속성은 '배경'을 사용하여 배경 위에 쓰는 데 사용할 수 있는 전경 색상을 의미합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors.txt"}
{"question": "리소스 표현에서 'updated' 필드는 어떤 정보를 담고 있나요?", "answer": "'updated' 필드는 색상 팔레트의 마지막 수정 시간을 담고 있으며, RFC3339 타임스탬프 형식입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors.txt"}
{"question": "캘린더 색상 정의에서 'background' 속성의 역할은 무엇인가요?", "answer": "'background' 속성은 이 색상 정의와 연결된 배경 색상을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors.txt"}
{"question": "Google Calendar API에서 색상 정보를 가져오기 위한 HTTP 요청은 어떻게 하나요?", "answer": "색상 정보를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/colors\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors_get.txt"}
{"question": "Google Calendar API의 색상 정보를 요청할 때 필요한 승인 범위는 무엇인가요?", "answer": "색상 정보를 요청하기 위해서는 다음 범위 중 하나 이상으로 승인이 필요합니다:\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar.app.created\n- https://www.googleapis.com/auth/calendar.calendarlist\n- https://www.googleapis.com/auth/calendar.calendarlist.readonly\n- https://www.googleapis.com/auth/calendar.events.freebusy\n- https://www.googleapis.com/auth/calendar.events.owned\n- https://www.googleapis.com/auth/calendar.events.owned.readonly\n- https://www.googleapis.com/auth/calendar.events.public.readonly\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors_get.txt"}
{"question": "Google Calendar API에서 색상 정보를 요청할 때 요청 본문은 어떻게 되나요?", "answer": "이 메소드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors_get.txt"}
{"question": "Google Calendar API에서 색상 정보를 성공적으로 요청했을 때의 응답은 어떤 형식인가요?", "answer": "성공적으로 요청할 경우 응답 본문에 Colors 리소스가 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors_get.txt"}
{"question": "Google Calendar API에서 색상 정보를 요청하기 전에 확인해야 할 사항은 무엇인가요?", "answer": "요청을 보내기 전에 적절한 승인 범위가 설정되어 있는지 확인해야 합니다. 승인 범위는 요청에 따라 다를 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/colors/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_colors_get.txt"}
{"question": "이벤트에 첨부파일을 추가하려면 어떤 요청 매개변수를 설정해야 하나요?", "answer": "이벤트의 파일 첨부파일을 수정하려면 `supportsAttachments` 요청 매개변수를 `true`로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 참석자 목록을 채우기 위해 어떤 권한이 필요한가요?", "answer": "서비스 계정에서 참석자 목록을 채우려면 도메인 전체 권한 위임(Domain-wide delegation of authority)을 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 참석자 정보를 업데이트할 때 어떤 속성을 사용할 수 있나요?", "answer": "이벤트를 업데이트할 때 `attendeesOmitted` 속성을 사용하여 참석자의 응답만 업데이트할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 참석자 이메일 주소는 어떤 형식을 따라야 하나요?", "answer": "참석자의 이메일 주소는 RFC5322에 따라 유효한 이메일 주소여야 하며, 참석자를 추가할 때 이 필드가 있어야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 `reminders` 속성에서 기본값을 사용하려면 어떻게 설정하나요?", "answer": "이벤트의 `reminders` 속성에서 기본값을 사용하려면 `useDefault`를 `true`로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트에 첨부파일을 추가할 때 필요한 필드는 무엇인가요?", "answer": "이벤트에 첨부파일을 추가할 때는 다음 필드가 필요합니다: \n- attachments[].fileId: 첨부된 파일의 ID입니다. 읽기 전용입니다. \n- attachments[].fileUrl: 첨부파일의 URL 링크입니다. Google Drive 파일 첨부파일을 추가하려면 Drive API의 Files 리소스의 alternateLink 속성과 동일한 형식을 사용합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자의 응답 상태를 설정할 때 사용할 수 있는 값은 무엇인가요?", "answer": "이벤트 참석자의 응답 상태(attendees[].responseStatus)를 설정할 때 사용할 수 있는 값은 다음과 같습니다: \n- 'needsAction': 참석자가 초대에 응답하지 않았습니다. \n- 'declined': 참석자가 초대를 거부했습니다. \n- 'tentative': 참석자가 초대를 잠정적으로 수락했습니다. \n- 'accepted': 참석자가 초대를 수락했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자 정보를 추가할 때 필수로 포함해야 하는 속성은 무엇인가요?", "answer": "이벤트 참석자 정보를 추가할 때 필수로 포함해야 하는 속성은 attendees[].email입니다. 이 필드는 참석자의 이메일 주소로, RFC5322에 따라 유효한 이메일 주소여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자의 추가 투숙객 수를 설정하는 방법은 무엇인가요?", "answer": "이벤트 참석자의 추가 투숙객 수는 attendees[].additionalGuests 속성을 사용하여 설정할 수 있습니다. 이 속성은 선택사항이며 기본값은 0입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자의 선택 여부를 설정하는 방법은 무엇인가요?", "answer": "이벤트 참석자의 선택 여부는 attendees[].optional 속성을 사용하여 설정할 수 있습니다. 이 속성은 선택사항이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자의 응답 상태를 설정할 때 사용할 수 있는 문자열 값은 무엇인가요?", "answer": "이벤트 참석자의 응답 상태는 다음과 같은 문자열 값으로 설정할 수 있습니다:\n- 'needsAction' - 참석자가 초대에 응답하지 않았습니다.\n- 'declined' - 참석자가 초대를 거부했습니다.\n- 'tentative' - 참석자가 초대를 잠정적으로 수락했습니다.\n- 'accepted' - 참석자가 초대를 수락했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 참석자가 리소스인지 여부를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트 참석자가 리소스인지 여부를 설정하려면 `attendees[].resource` 필드를 사용해야 합니다. 이 필드는 참석자가 이벤트에 처음 추가될 때만 설정할 수 있으며, 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 생일 또는 특별한 날 데이터는 어떤 속성을 포함하나요?", "answer": "이벤트의 생일 또는 특별한 날 데이터는 `birthdayProperties`라는 nested object를 포함하며, 다음과 같은 속성을 가집니다:\n- `contact`: 이 생일 이벤트가 연결된 연락처의 리소스 이름입니다.\n- `customTypeName`: 이 이벤트에 지정된 맞춤 유형 라벨입니다.\n- `type`: 생일 또는 특별 이벤트 유형입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 색상을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 색상을 설정하려면 `colorId` 필드를 사용해야 합니다. 이 필드는 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "Google Meet 회의 세부정보를 추가하려면 어떤 필드를 사용해야 하나요?", "answer": "Google Meet 회의 세부정보를 추가하려면 `conferenceData`라는 nested object를 사용해야 합니다. 이 필드 내에서 `createRequest`를 사용하여 새 회의 세부정보를 만들 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 특별 이벤트 유형을 설정할 때 사용할 수 있는 값은 무엇인가요?", "answer": "\"anniversary\", \"birthday\", \"custom\", \"other\", \"self\"와 같은 값이 있습니다. 이 중 \"birthday\"는 기본값입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 색상을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 색상을 설정하려면 colorId 필드를 사용해야 합니다. 이 필드는 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "Google Meet 회의 세부정보를 생성하기 위해 어떤 요청 매개변수를 설정해야 하나요?", "answer": "Google Meet 회의 세부정보를 생성하려면 conferenceData.createRequest 필드를 사용해야 합니다. 이 필드는 새 회의를 생성하고 이벤트에 연결하기 위한 요청입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청의 상태를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "회의 생성 요청의 상태를 확인하려면 conferenceData.createRequest.status 필드를 사용해야 합니다. 이 필드는 회의 생성 요청의 현재 상태를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청이 실패했을 때 어떤 상태 코드가 반환되나요?", "answer": "회의 생성 요청이 실패했을 때는 statusCode가 \"failure\"로 설정됩니다. 이 경우 진입점이 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청의 상태를 확인하기 위해 어떤 필드를 사용해야 하나요?", "answer": "회의 생성 요청의 상태를 확인하기 위해 `conferenceData.createRequest.status` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청이 성공했는지 확인하려면 어떤 상태 코드를 확인해야 하나요?", "answer": "회의 생성 요청이 성공했는지 확인하려면 `conferenceData.createRequest.status.statusCode` 필드의 값이 'success'인지 확인해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 진입점의 유형을 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "회의 진입점의 유형을 설정할 때 사용할 수 있는 값은 다음과 같습니다: 'video', 'phone', 'sip', 'more'.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의에 액세스하기 위한 비밀번호를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "회의에 액세스하기 위한 비밀번호를 설정할 때 `conferenceData.entryPoints[].passcode` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청에 대한 고유 ID는 어떤 필드에 설정하나요?", "answer": "회의 생성 요청에 대한 고유 ID는 `conferenceData.createRequest.requestId` 필드에 설정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 생성 요청의 상태를 확인하기 위해 어떤 필드를 사용해야 하나요?", "answer": "회의 생성 요청의 상태를 확인하기 위해 `conferenceData.createRequest.status` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 진입점의 유형을 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "회의 진입점의 유형을 설정할 때 사용할 수 있는 값은 다음과 같습니다.\n- \"video\": HTTP를 통해 회의에 참여합니다.\n- \"phone\": 전화번호를 다이얼하여 회의에 참여합니다.\n- \"sip\": SIP를 통해 회의에 참여합니다.\n- \"more\": 추가 전화번호와 같은 추가 회의 참석 안내입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의에 액세스하기 위한 비밀번호를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "회의에 액세스하기 위한 비밀번호를 설정할 때는 `conferenceData.entryPoints[].passcode` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의에 액세스하기 위한 회의 코드는 어떤 필드에 설정하나요?", "answer": "회의에 액세스하기 위한 회의 코드는 `conferenceData.entryPoints[].meetingCode` 필드에 설정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "회의 진입점의 URI를 설정할 때 어떤 형식을 따라야 하나요?", "answer": "회의 진입점의 URI를 설정할 때는 다음과 같은 형식을 따라야 합니다:\n- video: http: 또는 https: 스키마\n- phone: tel: 스키마 (예: tel:+12345678900,,,123456789;1234)\n- sip: sip: 스키마 (예: sip:12345678@myprovider.com)", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 종료 시간을 설정할 때 어떤 형식을 사용해야 하나요?", "answer": "이벤트의 종료 시간은 'end.dateTime' 필드에 결합된 날짜-시간 값으로 설정해야 하며, RFC3339 형식이어야 합니다. 시간대가 명시적으로 지정되어 있지 않은 경우 시간대 오프셋이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 설명을 추가할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트에 관한 설명은 'description' 필드를 사용하여 추가할 수 있으며, HTML을 포함할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 종료 시간이 지정되지 않았는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 종료 시간이 실제로 지정되지 않았는지 여부는 'endTimeUnspecified' 필드를 사용하여 확인할 수 있습니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 특정 유형을 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 특정 유형은 'eventType' 필드를 사용하여 설정할 수 있으며, 가능한 값은 다음과 같습니다: 'birthday', 'default', 'focusTime', 'fromGmail', 'outOfOffice', 'workingLocation'.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 크리에이터 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트를 만든 사용자에 대한 정보는 'creator' 객체를 사용하여 확인할 수 있으며, 'creator.displayName', 'creator.email', 'creator.id', 'creator.self'와 같은 필드를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 종료 시간을 설정할 때 어떤 형식을 사용해야 하나요?", "answer": "이벤트의 종료 시간은 'yyyy-mm-dd' 형식의 날짜(end.date) 또는 결합된 날짜-시간 값(RFC3339 형식, end.dateTime)으로 설정할 수 있습니다. 시간대는 end.timeZone 필드를 사용하여 지정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 설명을 추가할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트에 대한 설명은 description 필드를 사용하여 추가할 수 있습니다. 이 필드는 HTML을 포함할 수 있으며 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 특정 유형을 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 특정 유형은 eventType 필드를 사용하여 설정할 수 있으며, 가능한 값은 'birthday', 'default', 'focusTime', 'fromGmail', 'outOfOffice', 'workingLocation'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 크리에이터 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 크리에이터 정보는 creator 객체를 통해 확인할 수 있으며, 이 객체에는 크리에이터의 이름(creator.displayName), 이메일(creator.email), 프로필 ID(creator.id), 그리고 크리에이터가 이 이벤트 사본이 표시되는 캘린더와 일치하는지 여부(creator.self)가 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 확장 속성을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 확장 속성은 extendedProperties 객체를 사용하여 설정할 수 있습니다. 이 객체에는 비공개 속성(extendedProperties.private)과 공유 속성(extendedProperties.shared)을 포함할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 비공식 속성을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 비공식 속성을 설정할 때는 `extendedProperties.private` 필드를 사용해야 합니다. 이 필드는 비공식 속성의 이름과 해당 값을 포함하는 객체입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 방해 금지 시간 속성을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 방해 금지 시간 속성을 설정할 때는 `focusTimeProperties` 객체를 사용해야 합니다. 이 객체 내에서 `autoDeclineMode`, `chatStatus`, `declineMessage` 등의 필드를 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트에 공유 속성을 추가하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트에 공유 속성을 추가하려면 `extendedProperties.shared` 필드를 사용해야 합니다. 이 필드는 다른 참석자의 캘린더에 있는 일정 사본 간에 공유되는 속성을 포함하는 객체입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 참석자가 다른 사용자를 초대할 수 있는지 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 참석자가 다른 사용자를 초대할 수 있는지 여부를 설정하려면 `guestsCanInviteOthers` 필드를 사용해야 합니다. 이 필드는 기본값이 True이며, 주최자가 아닌 참석자가 일정에 다른 사용자를 초대할 수 있는지를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 고유 식별자를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 고유 식별자를 설정할 때는 `iCalUID` 필드를 사용해야 합니다. 이 필드는 RFC5545에 정의된 이벤트 고유 식별자로, 캘린더 시스템에서 이벤트를 고유하게 식별하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 주최자 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 주최자 정보를 확인하려면 'organizer' 객체를 사용해야 합니다. 이 객체에는 주최자의 이름(organizer.displayName), 이메일 주소(organizer.email), 프로필 ID(organizer.id) 등의 정보가 포함되어 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 고유 식별자를 설정할 때 어떤 규칙을 따라야 하나요?", "answer": "이벤트의 고유 식별자(id)를 설정할 때는 다음 규칙을 따라야 합니다: ID에 허용되는 문자는 base32hex 인코딩에 사용되는 문자(소문자 a~v 및 숫자 0~9)여야 하며, ID 길이는 5~1,024자(영문 기준)여야 합니다. ID는 캘린더마다 고유해야 하며, ID를 지정하지 않으면 서버에서 자동으로 생성됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 위치 정보를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 위치 정보를 설정할 때는 'location' 필드를 사용해야 합니다. 이 필드는 자유 형식 텍스트로 표시된 이벤트의 지리적 위치를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 참석자가 다른 사용자를 초대할 수 있는지 여부를 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 참석자가 다른 사용자를 초대할 수 있는지 여부를 설정하려면 'guestsCanInviteOthers' 필드를 사용해야 합니다. 이 필드는 주최자가 아닌 참석자가 일정에 다른 사용자를 초대할 수 있는지 여부를 나타내며, 기본값은 True입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 고유 식별자(iCalUID)를 사용하여 이벤트를 검색하려면 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트의 고유 식별자(iCalUID)를 사용하여 이벤트를 검색하려면 'iCalUID' 매개변수를 사용하여 이벤트 목록 메서드(events.list)를 호출해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트 ID를 설정할 때 어떤 규칙을 따라야 하나요?", "answer": "이벤트 ID는 5~1,024자(영문 기준)여야 하며, 캘린더마다 고유해야 합니다. ID 충돌을 최소화하기 위해 RFC4122에 설명된 UUID 알고리즘을 사용하는 것이 좋습니다. ID를 지정하지 않으면 서버에서 자동으로 생성됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 주최자 정보를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 주최자 정보를 설정할 때는 'organizer' 객체를 사용해야 합니다. 이 객체에는 'displayName', 'email', 'id', 'self' 필드가 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "반복 일정의 시작 시간을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "반복 일정의 시작 시간을 설정할 때는 'originalStartTime' 객체를 사용해야 하며, 이 객체 내에서 'date', 'dateTime', 'timeZone' 필드를 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "부재중 이벤트의 자동 거부 모드를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "부재중 이벤트의 자동 거부 모드를 설정할 때는 'outOfOfficeProperties.autoDeclineMode' 필드를 사용하며, 유효한 값으로는 'declineNone', 'declineAllConflictingInvitations', 'declineOnlyNewConflictingInvitations'이 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 비공식 속성을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 비공식 속성을 설정할 때는 'privateCopy' 필드를 사용해야 하며, 이 필드를 true로 설정하면 이벤트 전파가 사용 중지됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 시작 시간을 설정할 때 어떤 형식을 사용해야 하나요?", "answer": "이벤트의 시작 시간을 설정할 때는 'start.date' 필드에 'yyyy-mm-dd' 형식의 날짜를 사용하거나, 'start.dateTime' 필드에 datetime 형식(결합된 날짜-시간 값, RFC3339 형식)을 사용해야 합니다. 시간대가 명시적으로 지정되어 있지 않은 경우 시간대 오프셋이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "부재중 이벤트의 자동 거부 모드를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "부재중 이벤트의 자동 거부 모드를 설정할 때는 'outOfOfficeProperties.autoDeclineMode' 필드에 다음과 같은 유효한 값을 사용할 수 있습니다: 'declineNone' (회의 초대가 거부되지 않음), 'declineAllConflictingInvitations' (일정과 충돌하는 모든 회의 초대가 거부됨), 'declineOnlyNewConflictingInvitations' (부재중 일정이 있는 동안 충돌하는 새로운 회의 초대만 거부됨).", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 리마인더를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 리마인더를 설정할 때는 'reminders' 객체를 사용해야 하며, 'reminders.overrides' 리스트에 리마인더를 추가할 수 있습니다. 각 리마인더는 'method' (이메일 또는 팝업)와 'minutes' (이벤트 시작 몇 분 전에 리마인더가 트리거되는지)를 포함해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 반복 일정 ID를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 반복 일정 ID를 확인하려면 'recurringEventId' 필드를 사용해야 합니다. 이 필드는 반복 일정의 인스턴스가 속한 반복 일정의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 소스 정보를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 소스 정보를 설정할 때는 'source' 객체를 사용해야 하며, 'source.title' 필드에 소스의 제목을, 'source.url' 필드에 리소스를 가리키는 URL을 설정해야 합니다. URL 스키마는 HTTP 또는 HTTPS여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 리마인더를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 리마인더를 설정할 때는 'reminders' 객체를 사용해야 합니다. 이 객체 내에서 'overrides' 배열을 통해 리마인더를 추가할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 시작 시간을 설정할 때 어떤 형식을 사용해야 하나요?", "answer": "이벤트의 시작 시간을 설정할 때는 'start' 객체를 사용하며, 'start.date' 또는 'start.dateTime' 필드를 통해 설정할 수 있습니다. 'start.date'는 'yyyy-mm-dd' 형식의 날짜를 사용하고, 'start.dateTime'은 RFC3339 형식의 날짜-시간 값을 사용합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 상태를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 상태를 설정할 때는 'status' 필드를 사용하며, 가능한 값은 'confirmed', 'tentative', 'cancelled'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 소스 정보를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 소스 정보를 설정할 때는 'source' 객체를 사용해야 하며, 이 객체 내에서 'source.title'과 'source.url' 필드를 통해 소스의 제목과 URL을 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 반복 일정 ID를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 반복 일정 ID를 확인하려면 'recurringEventId' 필드를 사용해야 합니다. 이 필드는 반복 일정의 인스턴스에 속한 반복 일정의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 상태를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 상태(status)를 설정할 때 사용할 수 있는 값은 다음과 같습니다. 'confirmed': 이벤트가 확인되었습니다. 이는 기본 상태입니다. 'tentative': 이벤트가 잠정적으로 확인되었습니다. 'cancelled': 이벤트가 취소(삭제됨)되었습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 투명도를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 투명도(transparency)를 설정할 때 사용할 수 있는 값은 다음과 같습니다. 'opaque': 기본값으로, 캘린더에서 일정의 시간을 차단합니다. 'transparent': 일정이 캘린더에서 시간을 차단하지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 공개 상태를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 공개 상태(visibility)를 설정할 때 사용할 수 있는 값은 다음과 같습니다. 'default': 캘린더의 일정에 기본 공개 상태를 사용합니다. 'public': 일정이 공개되어 있으며 캘린더의 모든 독자가 일정 세부정보를 볼 수 있습니다. 'private': 비공개 일정으로, 일정 참석자만 일정 세부정보를 볼 수 있습니다. 'confidential': 이벤트가 비공개입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 마지막 수정 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 마지막 수정 시간(updated)을 확인하려면 'updated' 필드를 사용해야 합니다. 이 필드는 기본 이벤트 데이터의 마지막 수정 시간을 RFC3339 타임스탬프로 표시합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 주최자가 변경되었을 때 어떤 필드가 남게 되나요?", "answer": "이벤트의 주최자가 변경되고 원래 주최자가 참석자 목록에 없으면 'id' 필드만 채워지는 취소된 이벤트가 남게 됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 투명도(transparency)를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 투명도(transparency)를 설정할 때 사용할 수 있는 값은 다음과 같습니다. 'opaque' - 기본값으로, 캘린더에서 일정의 시간을 차단합니다. 'transparent' - 일정이 캘린더에서 시간을 차단하지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 공개 상태(visibility)를 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 공개 상태(visibility)를 설정할 때 사용할 수 있는 값은 다음과 같습니다. 'default' - 캘린더의 일정에 기본 공개 상태를 사용합니다. 'public' - 일정이 공개되어 있으며 캘린더의 모든 독자가 일정 세부정보를 볼 수 있습니다. 'private' - 비공개 일정으로, 일정 참석자만 일정 세부정보를 볼 수 있습니다. 'confidential' - 이벤트가 비공개입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 마지막 수정 시간(updated)을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 마지막 수정 시간(updated)을 확인하려면 'updated' 필드를 사용해야 합니다. 이 필드는 기본 이벤트 데이터의 마지막 수정 시간을 RFC3339 타임스탬프로 표시합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 근무 위치 속성을 추가할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 근무 위치 속성을 추가할 때는 'workingLocationProperties' 필드를 사용해야 합니다. 이 필드는 근무 위치 이벤트 데이터를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 사무실 위치(officeLocation) 정보를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 사무실 위치(officeLocation) 정보를 설정할 때는 'workingLocationProperties.officeLocation' 필드를 사용해야 합니다. 이 필드는 사무실에서 작업 중임을 나타내며, 추가적으로 'buildingId', 'deskId', 'floorId', 'floorSectionId', 'label' 등의 하위 필드를 포함할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 근무 위치 속성을 추가할 때 어떤 필드를 사용해야 하나요?", "answer": "근무 위치 속성을 추가할 때는 다음 필드를 사용해야 합니다: \n- buildingId: 건물 식별자입니다. 이는 조직의 리소스 데이터베이스에 있는 건물 ID를 참조해야 합니다. \n- officeLocation: 사무실 위치에 대한 세부정보를 포함하는 객체입니다. 이 객체 내에는 deskId, floorId, floorSectionId, label, type 필드가 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 사무실 이름을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 사무실 이름을 설정할 때는 workingLocationProperties.officeLocation.label 필드를 사용해야 합니다. 이 필드는 Calendar 웹 및 모바일 클라이언트에 표시되는 사무실 이름입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트의 근무 위치 유형을 설정할 때 어떤 값을 사용할 수 있나요?", "answer": "이벤트의 근무 위치 유형을 설정할 때는 다음과 같은 값을 사용할 수 있습니다: \n- 'homeOffice': 사용자가 집에서 작업 중입니다. \n- 'officeLocation': 사용자가 사무실에서 작업 중입니다. \n- 'customLocation': 사용자가 맞춤 위치에서 작업 중입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트를 삭제하려면 어떤 메서드를 사용해야 하나요?", "answer": "이벤트를 삭제하려면 delete 메서드를 사용해야 합니다. 이 메서드는 일정을 삭제하는 기능을 제공합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "이벤트를 가져오려면 import 메서드를 사용해야 합니다. 이 메서드는 기존 일정의 비공식 사본을 캘린더에 추가하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events.txt"}
{"question": "이벤트를 삭제하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "이벤트를 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다.\n\n```\nDELETE https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_delete.txt"}
{"question": "이벤트 삭제 시 필요한 경로 매개변수는 무엇인가요?", "answer": "이벤트 삭제 시 필요한 경로 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출하세요.\n- `eventId`: 이벤트 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_delete.txt"}
{"question": "이벤트 삭제 시 알림을 전송할지 여부를 설정하는 방법은 무엇인가요?", "answer": "이벤트 삭제 시 알림을 전송할지 여부는 선택적 쿼리 매개변수 `sendUpdates`를 사용하여 설정할 수 있습니다. 허용되는 값은 다음과 같습니다:\n- `all`: 모든 참석자에게 알림이 전송됩니다.\n- `externalOnly`: Google Calendar를 사용하지 않는 참석자에게만 알림이 전송됩니다.\n- `none`: 알림이 전송되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_delete.txt"}
{"question": "이벤트 삭제 요청에 필요한 승인 범위는 무엇인가요?", "answer": "이벤트 삭제 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.owned`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_delete.txt"}
{"question": "이벤트 삭제 요청 시 요청 본문은 어떻게 처리하나요?", "answer": "이 메소드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/delete"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_delete.txt"}
{"question": "Google Calendar API에서 특정 이벤트를 가져오기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "특정 이벤트를 가져오기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_get.txt"}
{"question": "이벤트를 가져오기 위해 필요한 경로 매개변수는 무엇인가요?", "answer": "이벤트를 가져오기 위해 필요한 경로 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.\n- `eventId`: 이벤트 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_get.txt"}
{"question": "이벤트를 가져올 때 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "이벤트를 가져올 때 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `alwaysIncludeEmail`: 지원 중단되고 무시됩니다.\n- `maxAttendees`: 응답에 포함할 참석자 최대 수입니다.\n- `timeZone`: 응답에 사용된 시간대입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_get.txt"}
{"question": "이벤트를 가져오기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이벤트를 가져오기 위해 필요한 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events.readonly`\n- `https://www.googleapis.com/auth/calendar.events`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_get.txt"}
{"question": "이벤트를 가져오는 메서드의 응답 본문에는 어떤 리소스가 포함되나요?", "answer": "이벤트를 가져오는 메서드의 응답 본문에는 `Events` 리소스가 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_get.txt"}
{"question": "이벤트를 가져오기 위해 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "이벤트를 가져오기 위한 HTTP 요청의 형식은 다음과 같습니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/events/import\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청에서 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "이벤트 가져오기 요청에서 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `conferenceDataVersion` (integer): API 클라이언트에서 지원하는 회의 데이터의 버전 번호입니다. 기본값은 0입니다.\n- `supportsAttachments` (boolean): 작업을 실행하는 API 클라이언트가 이벤트 첨부파일을 지원하는지 여부입니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청 본문에서 필수 속성으로 요구되는 것은 무엇인가요?", "answer": "이벤트 가져오기 요청 본문에서 필수 속성으로 요구되는 것은 다음과 같습니다:\n- `end` (nested object): 이벤트의 종료 시간입니다.\n- `iCalUID` (string): 이벤트 고유 식별자로, 캘린더 시스템 전반에서 이벤트를 고유하게 식별하는 데 사용됩니다.\n- `start` (nested object): 이벤트의 시작 시간입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이벤트 가져오기 요청을 수행하기 위해 필요한 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.owned`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청에서 `iCalUID`와 `id`의 차이점은 무엇인가요?", "answer": "`iCalUID` (string)와 `id` (string)는 이벤트를 식별하는 데 사용되지만, 두 식별자는 동일하지 않으며 이벤트 생성 시 둘 중 하나만 제공해야 합니다. 반복되는 이벤트에서 한 이벤트의 모든 발생 횟수는 다른 `id`를 가지지만 모두 동일한 `iCalUID`를 공유합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청에서 `supportsAttachments` 필드는 어떤 역할을 하나요?", "answer": "`supportsAttachments` boolean 작업을 실행하는 API 클라이언트가 이벤트 첨부파일을 지원하는지 여부입니다. 선택사항입니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.events\n- https://www.googleapis.com/auth/calendar.app.created\n- https://www.googleapis.com/auth/calendar.events.owned\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청 본문에서 `attendees` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`attendees[] list` 이벤트 참석자입니다. 참석자를 추가할 때 이 필드가 있어야 합니다. 참석자의 이메일 주소는 RFC5322에 따라 유효한 이메일 주소여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청에서 `iCalUID`와 `id`의 차이점은 무엇인가요?", "answer": "`iCalUID`는 RFC5545에 정의된 이벤트 고유 식별자로, 캘린더 시스템 전반에서 이벤트를 고유하게 식별하는 데 사용됩니다. `id`는 이벤트 생성 시 둘 중 하나만 제공해야 하며, 반복되는 이벤트에서 한 이벤트의 모든 발생 횟수에 다른 `id`가 있지만 모두 동일한 `iCalUID`를 공유합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 가져오기 요청에서 `attendees[].responseStatus` 필드는 어떤 값을 가질 수 있나요?", "answer": "`attendees[].responseStatus` 참석자의 응답 상태입니다. 가능한 값은 다음과 같습니다.\n- 'needsAction' - 참석자가 초대에 응답하지 않았습니다.\n- 'declined' - 참석자가 초대를 거부했습니다.\n- 'tentative' - 참석자가 초대를 잠정적으로 수락했습니다.\n- 'accepted' - 참석자가 초대를 수락했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `attendees[].email` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`attendees[].email` 필드는 참석자의 이메일 주소를 포함해야 하며, 이 필드는 참석자를 추가할 때 필수입니다. 이메일 주소는 RFC5322에 따라 유효해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`attendees[].responseStatus` 필드는 어떤 값을 가질 수 있나요?", "answer": "`attendees[].responseStatus` 필드는 참석자의 응답 상태를 나타내며, 가능한 값은 다음과 같습니다. \n- 'needsAction' - 참석자가 초대에 응답하지 않았습니다. \n- 'declined' - 참석자가 초대를 거부했습니다. \n- 'tentative' - 참석자가 초대를 잠정적으로 수락했습니다. \n- 'accepted' - 참석자가 초대를 수락했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`attendeesOmitted` 필드는 어떤 경우에 사용되며 기본값은 무엇인가요?", "answer": "`attendeesOmitted` 필드는 참석자가 이벤트의 표현에서 누락되었을 수 있는지 여부를 나타내며, 이벤트를 검색할 때 `maxAttendee` 쿼리 매개변수로 지정된 제한사항으로 인해 발생할 수 있습니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `colorId` 필드는 어떤 역할을 하나요?", "answer": "`colorId` 필드는 이벤트의 색상을 지정하는 데 사용되며, 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다. 이 필드는 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`conferenceData` 필드는 어떤 정보를 포함하나요?", "answer": "`conferenceData` 필드는 Google Meet 회의 세부정보와 같은 회의 관련 정보를 포함하는 nested object입니다. 새 회의 세부정보를 만들려면 `createRequest` 필드를 사용해야 하며, 모든 이벤트 수정 요청에 대해 `conferenceDataVersion` 요청 매개변수를 1로 설정해야 변경사항을 유지할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `colorId` 필드는 어떤 값을 가질 수 있나요?", "answer": "`colorId` 필드는 이벤트의 색상을 나타내며, 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다. 이 필드는 선택사항이며 쓰기 가능합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`guestsCanModify` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanModify` 필드는 주최자 이외의 참석자가 일정을 수정할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`guestsCanInviteOthers` 필드는 어떤 기능을 제공하나요?", "answer": "`guestsCanInviteOthers` 필드는 주최자 이외의 참석자가 일정에 다른 사용자를 초대할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`location` 필드는 어떤 정보를 포함하나요?", "answer": "`location` 필드는 이벤트의 지리적 위치를 자유 형식 텍스트로 포함합니다. 이 필드는 선택사항이며 쓰기 가능합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`organizer` 필드는 어떤 정보를 포함하나요?", "answer": "`organizer` 필드는 이벤트 주최자에 대한 정보를 포함합니다. 주최자가 참석자이기도 한 경우, `attendees`에 별도의 항목이 표시되고 `organizer` 필드가 True로 설정됩니다. 이 필드는 읽기 전용이며, 주최자를 변경하려면 이동 작업을 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `gadget` 필드는 어떤 정보를 포함하나요?", "answer": "`gadget` 필드는 가젯의 디스플레이 모드, 높이, 아이콘 URL, 링크, 환경설정, 제목, 유형, 너비 등의 정보를 포함합니다. 이 필드는 지원 중단되었습니다. 예시는 다음과 같습니다:\n```json\n\"gadget\": {\n  \"display\": \"icon\",\n  \"height\": 100,\n  \"iconLink\": \"https://example.com/icon.png\",\n  \"link\": \"https://example.com\",\n  \"preferences\": {},\n  \"title\": \"My Gadget\",\n  \"type\": \"myGadget\",\n  \"width\": 200\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`guestsCanModify` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanModify` 필드는 주최자 이외의 참석자가 일정을 수정할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`originalStartTime` 필드는 어떤 정보를 포함하나요?", "answer": "`originalStartTime` 필드는 이벤트의 원래 시작 시간을 나타내며, `date`, `dateTime`, `timeZone` 필드를 포함합니다. `date`는 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜를, `dateTime`은 결합된 날짜-시간 값을, `timeZone`은 IANA 시간대 데이터베이스 이름 형식으로 시간을 지정합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`recurrence` 필드는 어떤 정보를 포함하나요?", "answer": "`recurrence` 필드는 반복되는 일정의 RRULE, EXRULE, RDATE, EXDATE 행 목록을 포함합니다. 이 필드는 단일 이벤트 또는 반복 이벤트의 인스턴스의 경우 생략될 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`reminders` 필드에서 `overrides`의 역할은 무엇인가요?", "answer": "`reminders.overrides` 필드는 이벤트에서 기본 리마인더를 사용하지 않는 경우 이벤트에 관한 리마인더를 표시합니다. 이 필드는 최대 5개의 재정의 리마인더를 포함할 수 있으며, 각 리마인더는 메서드와 시작 전 트리거되는 시간을 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `originalStartTime` 필드는 어떤 정보를 포함하나요?", "answer": "`originalStartTime` 필드는 이벤트의 원래 시작 시간을 나타내며, 다음과 같은 하위 필드를 포함합니다: `date`, `dateTime`, `timeZone`. `date`는 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜를 나타내고, `dateTime`은 결합된 날짜-시간 값으로 표시된 시간을 나타냅니다. `timeZone`은 시간이 지정된 시간대를 나타내며, 반복되는 일정의 경우 필수입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`recurrence` 필드는 어떤 정보를 포함하나요?", "answer": "`recurrence` 필드는 반복되는 일정의 RRULE, EXRULE, RDATE, EXDATE 행 목록을 포함합니다. 이 필드는 단일 이벤트 또는 반복 이벤트의 인스턴스의 경우 생략될 수 있으며, 이벤트 시작 시간 및 종료 시간은 `start` 및 `end` 필드에 지정됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`reminders.overrides` 필드는 어떤 역할을 하나요?", "answer": "`reminders.overrides` 필드는 이벤트에서 기본 리마인더를 사용하지 않는 경우 이벤트에 관한 리마인더를 표시합니다. 설정되지 않은 경우 이 이벤트에 리마인더가 설정되지 않았음을 나타내며, 재정의 리마인더의 최대 개수는 5개입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`reminders.overrides[].method` 필드는 어떤 값을 가질 수 있나요?", "answer": "`reminders.overrides[].method` 필드는 이 리마인더에서 사용하는 메서드를 나타내며, 가능한 값은 다음과 같습니다: 'email' - 리마인더가 이메일을 통해 전송됩니다. 'popup' - UI 팝업을 통해 리마인더가 전송됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`start` 필드는 어떤 정보를 포함하나요?", "answer": "`start` 필드는 이벤트의 시작 시간을 나타내며, 다음과 같은 하위 필드를 포함합니다: `date`, `dateTime`, `timeZone`. `date`는 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜를 나타내고, `dateTime`은 결합된 날짜-시간 값으로 표시된 시간을 나타냅니다. `timeZone`은 시간이 지정된 시간대를 나타내며, 반복되는 일정의 경우 필수입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트 요청 본문에서 `reminders` 필드는 어떤 정보를 포함하나요?", "answer": "`reminders` 필드는 리마인더가 트리거되어야 하는 시간(분)과 캘린더의 기본 리마인더가 일정에 적용되는지 여부를 포함합니다. 유효한 값은 0~40320(4주(분))입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`start.date` 필드는 어떤 형식의 날짜를 요구하나요?", "answer": "`start.date` 필드는 'yyyy-mm-dd' 형식의 날짜를 요구합니다. 이는 종일 일정인 경우에 사용됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`start.dateTime` 필드는 어떤 형식으로 값을 제공해야 하나요?", "answer": "`start.dateTime` 필드는 결합된 날짜-시간 값으로 표시된 시간이며, RFC3339 형식으로 제공해야 합니다. 시간대가 명시적으로 지정되어 있지 않은 한 시간대 오프셋이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`status` 필드는 어떤 값을 가질 수 있으며, 각 값의 의미는 무엇인가요?", "answer": "`status` 필드는 이벤트의 상태를 나타내며, 가능한 값은 'confirmed' (이벤트가 확인됨), 'tentative' (잠정적으로 확인됨), 'cancelled' (이벤트가 취소됨)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "`visibility` 필드는 어떤 값을 가질 수 있으며, 각 값의 의미는 무엇인가요?", "answer": "`visibility` 필드는 이벤트의 공개 상태를 나타내며, 가능한 값은 'default' (기본 공개 상태 사용), 'public' (일정이 공개됨), 'private' (비공개 일정), 'confidential' (비공개 이벤트, 호환성을 위해 제공됨)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "취소된 이벤트의 경우 어떤 필드가 채워질 수 있나요?", "answer": "취소된 예외는 id, recurringEventId, originalStartTime 필드의 값만 채워질 수 있습니다. 다른 필드는 비어 있을 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "삭제된 이벤트는 어떤 정보를 포함하나요?", "answer": "삭제된 이벤트는 id 필드만 채워질 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "주최자의 캘린더에서 취소된 일정은 어떻게 처리되나요?", "answer": "주최자의 캘린더에서 취소된 일정은 복원(삭제 취소)할 수 있도록 일정 세부정보(요약, 위치 등)를 계속 표시합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "showDeleted가 false로 설정된 증분 동기화 요청은 어떤 결과를 반환하나요?", "answer": "showDeleted가 false로 설정된 증분 동기화 요청은 취소된 일정의 세부정보를 반환하지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트의 transparency 필드는 어떤 값을 가질 수 있나요?", "answer": "transparency 필드는 'opaque'와 'transparent' 값을 가질 수 있습니다. 'opaque'는 기본값으로, 일정이 캘린더에서 시간을 차단합니다. 'transparent'는 일정이 캘린더에서 시간을 차단하지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/import"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_import.txt"}
{"question": "이벤트를 생성하기 위해 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "이벤트를 생성하기 위한 HTTP 요청은 다음과 같은 형식을 가집니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/events\n```\n여기서 `calendarId`는 캘린더 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "이벤트 생성 시 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `conferenceDataVersion`: API 클라이언트에서 지원하는 회의 데이터의 버전 번호입니다. 기본값은 0입니다.\n- `maxAttendees`: 응답에 포함할 참석자 최대 수입니다.\n- `sendUpdates`: 새 이벤트 생성에 관한 알림을 전송할지 여부입니다. 허용되는 값은 'all', 'externalOnly', 'none'입니다.\n- `supportsAttachments`: 작업을 실행하는 API 클라이언트가 이벤트 첨부파일을 지원하는지 여부입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 요청 본문에서 필수 속성은 무엇인가요?", "answer": "이벤트 생성 요청 본문에서 필수 속성은 다음과 같습니다:\n- `start`: 이벤트의 시작 시간 (양 끝값 포함)입니다.\n- `end`: 이벤트의 종료 시간 (제외)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `sendUpdates` 매개변수의 'none' 값을 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "`sendUpdates` 매개변수의 'none' 값을 사용하면 이벤트가 외부 캘린더에 동기화되지 않거나 일부 사용자의 경우 이벤트가 완전히 손실되는 등 심각한 부작용이 발생할 수 있습니다. 따라서 캘린더 이전 작업의 경우 대신 `events.import` 메서드를 사용하는 것이 좋습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 요청에 필요한 승인 범위는 무엇인가요?", "answer": "이벤트 생성 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.owned`\n자세한 내용은 인증 및 승인 페이지를 참고하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `supportsAttachments` 매개변수의 기본값은 무엇인가요?", "answer": "`supportsAttachments` 매개변수의 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 요청 본문에서 `attendees` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`attendees` 필드는 이벤트 참석자의 이메일 주소(있는 경우)를 포함해야 하며, 참석자를 추가할 때 이 필드가 있어야 합니다. RFC5322에 따라 유효한 이메일 주소여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `attendees[].responseStatus` 필드의 가능한 값은 무엇인가요?", "answer": "`attendees[].responseStatus` 필드의 가능한 값은 다음과 같습니다.\n'needsAction' - 참석자가 초대에 응답하지 않았습니다.\n'accepted' - 참석자가 초대를 수락했습니다.\n'tentative' - 참석자가 초대를 잠정적으로 수락했습니다.\n'declined' - 참석자가 초대를 거부했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `attendees[].optional` 필드는 어떤 역할을 하나요?", "answer": "`attendees[].optional` 필드는 참석자가 선택사항인지 여부를 나타내며, 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `birthdayProperties` 필드는 어떤 경우에 사용되나요?", "answer": "`birthdayProperties` 필드는 eventType이 'birthday'인 경우에 사용되며, 변경할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `attendees[].email` 필드에 대한 요구사항은 무엇인가요?", "answer": "`attendees[].email` 필드는 참석자의 이메일 주소를 포함해야 하며, 참석자를 추가할 때 이 필드가 있어야 합니다. 이메일 주소는 RFC5322에 따라 유효해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "`attendees[].responseStatus` 필드의 사용 시 주의해야 할 점은 무엇인가요?", "answer": "`attendees[].responseStatus` 필드는 참석자의 응답 상태를 나타내며, 'declined', 'tentative', 'accepted' 값을 사용하여 일정을 추가하면 참석자의 응답이 'needsAction'으로 재설정될 수 있습니다. 또한, 일정에 초대된 참석자가 200명을 초과하면 응답 상태가 참석자에게 전파되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `birthdayProperties` 필드는 어떤 경우에 사용되나요?", "answer": "`birthdayProperties` 필드는 eventType이 'birthday'인 경우에 사용되며, 변경할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `colorId` 필드는 어떤 정보를 포함하나요?", "answer": "`colorId` 필드는 이벤트의 색상을 나타내며, 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `conferenceData` 필드는 어떤 정보를 포함하나요?", "answer": "`conferenceData` 필드는 Google Meet 회의 세부정보와 같은 회의 관련 정보를 포함합니다. 새 회의 세부정보를 만들려면 createRequest 필드를 사용해야 하며, 모든 이벤트 수정 요청에 대해 conferenceDataVersion 요청 매개변수를 1로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `eventType` 필드에서 사용할 수 있는 값은 무엇인가요?", "answer": "이벤트 생성 시 `eventType` (eventType) 필드에서 사용할 수 있는 값은 다음과 같습니다.\n- 'birthday': 매년 반복되는 특별한 종일 일정입니다.\n- 'default': 일반 이벤트 또는 추가로 지정되지 않은 이벤트입니다.\n- 'focusTime': 방해 금지 시간 이벤트입니다.\n- 'fromGmail': Gmail의 일정입니다. 이 유형의 일정은 만들 수 없습니다.\n- 'outOfOffice': 부재중 일정입니다.\n- 'workingLocation': 근무 위치 이벤트입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `guestsCanModify` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanModify` (guestsCanModify) 필드는 주최자 이외의 참석자가 일정을 수정할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `guestsCanInviteOthers` 필드의 기본값은 무엇인가요?", "answer": "`guestsCanInviteOthers` (guestsCanInviteOthers) 필드는 주최자 이외의 참석자가 일정에 다른 사용자를 초대할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "`birthdayProperties` 필드는 어떤 경우에 사용되나요?", "answer": "`birthdayProperties` (birthdayProperties) 필드는 생일 또는 특별한 날 데이터에 사용됩니다. 이 필드는 `eventType` (eventType)이 'birthday'인 경우에만 사용되며, 변경할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `colorId` 필드는 어떤 정보를 포함하나요?", "answer": "`colorId` (colorId) 필드는 이벤트의 색상입니다. 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다. 이 필드는 선택사항이며 쓰기 가능합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `eventType` 필드에서 사용할 수 있는 값은 무엇인가요?", "answer": "`eventType` 필드에서 사용할 수 있는 값은 다음과 같습니다.\n- 'birthday': 매년 반복되는 특별한 종일 일정입니다.\n- 'default': 일반 이벤트 또는 추가로 지정되지 않은 이벤트입니다.\n- 'focusTime': 방해 금지 시간 이벤트입니다.\n- 'fromGmail': Gmail의 일정입니다. 이 유형의 일정은 만들 수 없습니다.\n- 'outOfOffice': 부재중 일정입니다.\n- 'workingLocation': 근무 위치 이벤트입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `extendedProperties` 필드는 어떤 정보를 포함하나요?", "answer": "`extendedProperties` 필드는 비공식적인 속성을 포함하는 객체입니다. 이 객체는 두 개의 하위 필드를 가집니다:\n- `private`: 이 캘린더에 표시되는 일정 사본에 비공식적인 속성입니다.\n- `shared`: 다른 참석자의 캘린더에 있는 일정 사본 간에 공유되는 속성입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `gadget` 필드는 어떤 정보를 포함하나요?", "answer": "`gadget` 필드는 가젯에 대한 정보를 포함하는 객체입니다. 이 객체는 다음과 같은 속성을 가집니다:\n- `display`: 가젯의 디스플레이 모드입니다. ('icon' 또는 'chip')\n- `height`: 가젯의 높이(픽셀)입니다.\n- `iconLink`: 가젯의 아이콘 URL입니다.\n- `link`: 가젯의 URL입니다.\n- `preferences`: 환경설정입니다.\n- `title`: 가젯의 제목입니다.\n- `type`: 가젯의 유형입니다.\n- `width`: 가젯의 너비(픽셀)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `guestsCanModify` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanModify` 필드는 주최자 이외의 참석자가 일정을 수정할 수 있는지 여부를 나타냅니다. 이 필드는 선택사항이며 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `originalStartTime` 필드는 어떤 정보를 포함하나요?", "answer": "`originalStartTime` 필드는 이벤트의 원래 시작 시간을 나타내며 다음과 같은 하위 필드를 포함합니다:\n- `date`: 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜입니다.\n- `dateTime`: 결합된 날짜-시간 값으로 표시된 시간입니다. (RFC3339 형식)\n- `timeZone`: 시간이 지정된 시간대입니다. IANA 시간대 데이터베이스 이름 형식입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `guestsCanSeeOtherGuests` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanSeeOtherGuests` 필드는 주최자 이외의 참석자가 이벤트 참석자를 볼 수 있는지 여부를 결정합니다. 이 필드는 선택사항이며 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `id` 필드에 대한 요구사항은 무엇인가요?", "answer": "`id` 필드는 이벤트의 불투명 식별자로, 새 단일 또는 반복 이벤트를 만들 때 지정할 수 있습니다. ID에 허용되는 문자는 base32hex 인코딩에 사용되는 문자(소문자 a~v 및 숫자 0~9)이며, ID 길이는 5~1,024자(영문 기준)여야 합니다. ID는 캘린더마다 고유해야 하며, ID를 지정하지 않으면 서버에서 자동으로 생성됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `originalStartTime` 필드는 어떤 정보를 포함하나요?", "answer": "`originalStartTime` 필드는 이벤트의 원래 시작 시간을 나타내며, 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜 또는 결합된 날짜-시간 값(RFC3339 형식)으로 표시됩니다. 이 필드는 반복되는 일정의 경우 필수이며, 단일 이벤트의 경우 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `reminders` 필드의 사용 방법은 무엇인가요?", "answer": "`reminders` 필드는 이벤트에 대한 리마인더 설정을 포함합니다. 기본 리마인더를 사용하지 않는 경우 `reminders.overrides`를 통해 최대 5개의 재정의 리마인더를 설정할 수 있으며, 각 리마인더는 `method`와 `minutes` 필드를 포함해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `recurrence` 필드는 어떤 정보를 포함하나요?", "answer": "`recurrence` 필드는 반복되는 일정의 RRULE, EXRULE, RDATE, EXDATE 행 목록을 포함합니다. 이 필드는 단일 이벤트 또는 반복 이벤트의 인스턴스의 경우 생략될 수 있으며, DTSTART 및 DTEND 행은 허용되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `reminders.overrides` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`reminders.overrides` 필드는 이벤트에서 기본 리마인더를 사용하지 않는 경우 이벤트에 관한 리마인더를 표시합니다. 설정되지 않은 경우 이 이벤트에 리마인더가 설정되지 않았음을 나타냅니다. 재정의 리마인더의 최대 개수는 5개입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `reminders.overrides[].method` 필드에서 사용할 수 있는 값은 무엇인가요?", "answer": "`reminders.overrides[].method` 필드는 이 리마인더에서 사용하는 메서드를 지정합니다. 가능한 값은 다음과 같습니다.\n'email' - 리마인더가 이메일을 통해 전송됩니다.\n'popup' - UI 팝업을 통해 리마인더가 전송됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `reminders.overrides[].minutes` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`reminders.overrides[].minutes` 필드는 이벤트 시작 전 리마인더가 트리거되어야 하는 시간을 분 단위로 지정합니다. 유효한 값은 0~40320(4주(분))입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `start.date` 필드는 어떤 형식으로 날짜를 지정해야 하나요?", "answer": "`start.date` 필드는 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜를 지정해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `status` 필드는 어떤 값을 가질 수 있나요?", "answer": "`status` 필드는 이벤트의 상태를 나타내며, 가능한 값은 다음과 같습니다.\n'confirmed': 이벤트가 확인되었습니다. 이는 기본 상태입니다.\n'tentative' - 이벤트가 잠정적으로 확인되었습니다.\n'cancelled' - 이벤트가 취소되었습니다 (삭제됨).", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `start.dateTime` 필드는 어떤 형식으로 날짜-시간 값을 지정해야 하나요?", "answer": "`start.dateTime` 필드는 RFC3339 형식으로 표시된 날짜-시간 값을 사용해야 합니다. 시간대(timeZone)가 명시적으로 지정되어 있지 않은 경우 시간대 오프셋이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `start.timeZone` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`start.timeZone` 필드는 IANA 시간대 데이터베이스 이름 형식(예: 'Europe/Zurich')으로 지정된 시간이 포함되어야 합니다. 반복되는 일정의 경우 이 필드는 필수이며, 단일 이벤트의 경우 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `status` 필드의 가능한 값은 무엇인가요?", "answer": "`status` 필드는 다음과 같은 값을 가질 수 있습니다: 'confirmed' (이벤트가 확인됨), 'tentative' (이벤트가 잠정적으로 확인됨), 'cancelled' (이벤트가 취소됨).", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `transparency` 필드는 어떤 역할을 하나요?", "answer": "`transparency` 필드는 일정이 캘린더에서 시간을 차단하는지 여부를 나타냅니다. 가능한 값은 'opaque' (기본값, 시간을 차단함)와 'transparent' (시간을 차단하지 않음)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `visibility` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`visibility` 필드는 이벤트의 공개 상태를 나타냅니다. 가능한 값은 'default' (기본 공개 상태 사용), 'public' (일정이 공개됨), 'private' (비공개 일정), 'confidential' (비공개 이벤트, 호환성을 위해 제공됨)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `transparency` 필드는 어떤 값을 가질 수 있나요?", "answer": "`transparency` 필드는 일정이 캘린더에서 시간을 차단하는지 여부를 나타냅니다. 가능한 값은 다음과 같습니다.\n- 'opaque' - 기본값입니다. 일정이 캘린더에서 시간을 차단합니다. 이는 캘린더 UI에서 나를 바쁨으로 설정하는 것과 같습니다.\n- 'transparent' - 일정이 캘린더에서 시간을 차단하지 않습니다. 이는 캘린더 UI에서 나를 표시를 한가함으로 설정하는 것과 같습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `visibility` 필드는 어떤 값을 가질 수 있나요?", "answer": "`visibility` 필드는 이벤트의 공개 상태를 나타냅니다. 가능한 값은 다음과 같습니다.\n- 'default' - 캘린더의 일정에 기본 공개 상태를 사용합니다. 기본값입니다.\n- 'public' - 일정이 공개되어 있으며 캘린더의 모든 독자가 일정 세부정보를 볼 수 있습니다.\n- 'private' - 비공개 일정으로, 일정 참석자만 일정 세부정보를 볼 수 있습니다.\n- 'confidential' - 이벤트가 비공개입니다. 이 값은 호환성을 위해 제공됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `workingLocationProperties` 필드는 어떤 정보를 포함하나요?", "answer": "`workingLocationProperties` 필드는 작업 위치 이벤트 데이터를 포함합니다. 이 필드는 다음과 같은 하위 필드를 가질 수 있습니다:\n- `customLocation` - 사용자가 맞춤 위치에서 작업 중임을 나타냅니다.\n- `homeOffice` - 사용자가 재택근무 중임을 나타냅니다.\n- `officeLocation` - 사용자가 사무실에서 작업 중임을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `workingLocationProperties.officeLocation` 필드의 하위 필드는 무엇이 있나요?", "answer": "`workingLocationProperties.officeLocation` 필드는 사용자가 사무실에서 작업 중임을 나타내며, 다음과 같은 하위 필드를 포함할 수 있습니다:\n- `buildingId` - 선택사항인 건물 식별자입니다.\n- `deskId` - 선택적 데스크 식별자입니다.\n- `floorId` - 층 식별자(선택사항).\n- `floorSectionId` - 선택사항인 층 섹션 식별자입니다.\n- `label` - Calendar 웹 및 모바일 클라이언트에 표시되는 사무실 이름입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 생성 시 `workingLocationProperties.type` 필드는 어떤 값을 가질 수 있나요?", "answer": "`workingLocationProperties.type` 필드는 근무 위치 유형을 나타내며, 가능한 값은 다음과 같습니다:\n- 'homeOffice' - 사용자가 집에서 작업 중입니다.\n- 'officeLocation' - 사용자가 사무실에서 작업 중입니다.\n- 'customLocation' - 사용자가 맞춤 위치에서 작업 중입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/insert"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_insert.txt"}
{"question": "이벤트 인스턴스를 가져오기 위한 HTTP 요청의 형식은 무엇인가요?", "answer": "이벤트 인스턴스를 가져오기 위한 HTTP 요청은 다음과 같은 형식을 가집니다.\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId/instances\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "이벤트 인스턴스를 요청할 때 필요한 경로 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.\n- `eventId`: 반복 이벤트 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "응답에서 반환되는 JSON 구조는 어떻게 되나요?", "answer": "응답에 성공할 경우 이 메소드는 다음과 같은 구조의 응답 본문을 반환합니다.\n\n```\n{\n  \"kind\": \"calendar#events\",\n  \"etag\": etag,\n  \"summary\": string,\n  \"description\": string,\n  \"updated\": datetime,\n  \"timeZone\": string,\n  \"accessRole\": string,\n  \"defaultReminders\": [\n    {\n      \"method\": string,\n      \"minutes\": integer\n    }\n  ],\n  \"nextPageToken\": string,\n  \"nextSyncToken\": string,\n  \"items\": [\n    events Resource\n  ]\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "이벤트 인스턴스를 요청할 때 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `maxAttendees`: 응답에 포함할 참석자 최대 수입니다.\n- `maxResults`: 하나의 결과 페이지에 반환되는 최대 이벤트 수입니다.\n- `originalStart`: 결과에서 인스턴스의 원래 시작 시간입니다.\n- `pageToken`: 반환할 결과 페이지를 지정하는 토큰입니다.\n- `showDeleted`: 결과에 삭제된 이벤트를 포함할지 여부입니다.\n- `timeMax`: 필터링할 이벤트 시작 시간의 상한입니다.\n- `timeMin`: 필터링할 이벤트 종료 시간의 하한입니다.\n- `timeZone`: 응답에 사용된 시간대입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 승인 범위는 무엇이 있나요?", "answer": "이 요청은 다음 범위 중 하나 이상으로 승인할 수 있습니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events.readonly`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.freebusy`\n- `https://www.googleapis.com/auth/calendar.events.owned`\n- `https://www.googleapis.com/auth/calendar.events.owned.readonly`\n- `https://www.googleapis.com/auth/calendar.events.public.readonly`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 사용할 수 있는 선택적 필드에는 어떤 것들이 있나요?", "answer": "이벤트 인스턴스를 요청할 때 사용할 수 있는 선택적 필드는 다음과 같습니다:\n- originalStart: 결과에서 인스턴스의 원래 시작 시간입니다.\n- pageToken: 반환할 결과 페이지를 지정하는 토큰입니다.\n- showDeleted: 결과에 삭제된 이벤트 (status이 'cancelled'인 경우)를 포함할지 여부입니다. 기본값은 False입니다.\n- timeMax: 필터링할 이벤트 시작 시간의 상한 (제외)입니다. 필수 시간대 오프셋이 있는 RFC3339 타임스탬프여야 합니다.\n- timeMin: 필터링할 이벤트 종료 시간의 하한 (양 끝값 포함)입니다. 필수 시간대 오프셋이 있는 RFC3339 타임스탬프여야 합니다.\n- timeZone: 응답에 사용된 시간대입니다. 기본값은 캘린더의 시간대입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 'showDeleted' 필드의 기본값은 무엇인가요?", "answer": "'showDeleted' 필드의 기본값은 False입니다. 이 필드를 사용하여 결과에 삭제된 이벤트 (status이 'cancelled'인 경우)를 포함할지 여부를 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 'timeMax' 필드는 어떤 형식이어야 하나요?", "answer": "'timeMax' 필드는 필터링할 이벤트 시작 시간의 상한을 지정하는 선택적 필드로, 필수 시간대 오프셋이 있는 RFC3339 타임스탬프여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 'timeZone' 필드의 기본값은 무엇인가요?", "answer": "'timeZone' 필드의 기본값은 캘린더의 시간대입니다. 이 필드를 사용하여 응답에 사용된 시간대를 지정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "이벤트 인스턴스를 요청할 때 승인해야 하는 범위는 무엇이 있나요?", "answer": "이 요청은 다음 범위 중 하나 이상으로 승인할 수 있습니다:\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.events.readonly\n- https://www.googleapis.com/auth/calendar.events\n- https://www.googleapis.com/auth/calendar.app.created\n- https://www.googleapis.com/auth/calendar.events.freebusy\n- https://www.googleapis.com/auth/calendar.events.owned\n- https://www.googleapis.com/auth/calendar.events.owned.readonly\n- https://www.googleapis.com/auth/calendar.events.public.readonly", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "캘린더의 'accessRole' 필드에서 가능한 값은 무엇인가요?", "answer": "'accessRole' 필드의 가능한 값은 다음과 같습니다.\n- 'none' - 사용자에게 액세스 권한이 없습니다.\n- 'freeBusyReader' - 사용자에게 한가함/바쁨 정보에 대한 읽기 액세스 권한이 있습니다.\n- 'reader' - 사용자에게 캘린더에 대한 읽기 액세스 권한이 있습니다. 비공개 일정은 독자 액세스 권한이 있는 사용자에게 표시되지만 일정 세부정보는 숨겨집니다.\n- 'writer' - 사용자에게 캘린더에 대한 읽기 및 쓰기 액세스 권한이 있습니다. 비공식 일정은 작성자 액세스 권한이 있는 사용자에게 표시되며 일정 세부정보가 표시됩니다.\n- 'owner' - 사용자가 캘린더의 소유권을 보유합니다. 이 역할에는 ACL을 보고 조작하는 추가 기능이 있는 작성자 역할의 모든 권한이 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "캘린더의 'defaultReminders' 필드는 어떤 정보를 포함하나요?", "answer": "'defaultReminders' 필드는 인증된 사용자의 캘린더에 있는 기본 리마인더를 포함합니다. 이러한 리마인더는 이 캘린더의 모든 일정에 적용되며, 이 일정은 리마인더를 명시적으로 재정의하지 않습니다. 각 리마인더는 다음과 같은 정보를 포함합니다:\n- 'method' - 이 리마인더에서 사용하는 메서드. 가능한 값은 'email' (이메일을 통해 전송) 또는 'popup' (UI 팝업을 통해 전송)입니다.\n- 'minutes' - 이벤트 시작 전 리마인더가 트리거되어야 하는 시간(분)입니다. 유효한 값은 0~40320(4주(분))입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "'nextPageToken' 필드는 어떤 용도로 사용되나요?", "answer": "'nextPageToken' 필드는 이 결과의 다음 페이지에 액세스하는 데 사용되는 토큰입니다. 더 이상 결과를 사용할 수 없는 경우 생략되며 이 경우 'nextSyncToken'이 제공됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "'nextSyncToken' 필드는 어떤 상황에서 사용되나요?", "answer": "'nextSyncToken' 필드는 이 결과가 반환된 이후 변경된 항목만 검색하는 데 나중에 사용되는 토큰입니다. 추가 결과를 사용할 수 있는 경우 생략되며 이 경우 'nextPageToken'이 제공됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "캘린더의 'updated' 필드는 어떤 정보를 나타내나요?", "answer": "'updated' 필드는 캘린더의 마지막 수정 시간을 나타내며, RFC3339 타임스탬프로 표시됩니다. 이 필드는 읽기 전용입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/instances"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_instances.txt"}
{"question": "캘린더의 이벤트를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "캘린더의 이벤트를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/calendar/v3/calendars/calendarId/events\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트를 필터링하기 위해 사용할 수 있는 매개변수는 무엇이 있나요?", "answer": "이벤트를 필터링하기 위해 사용할 수 있는 매개변수는 다음과 같습니다:\n- `eventTypes`: 반환할 이벤트 유형을 지정합니다. 여러 번 반복하여 다양한 유형의 이벤트를 반환할 수 있습니다.\n- `iCalUID`: iCalendar 형식의 이벤트 ID를 지정합니다.\n- `maxAttendees`: 응답에 포함할 참석자 최대 수를 지정합니다.\n- `maxResults`: 하나의 결과 페이지에 반환되는 최대 이벤트 수를 지정합니다.\n- `orderBy`: 결과에 반환된 이벤트의 순서를 지정합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트를 검색할 때 사용할 수 있는 검색어는 무엇인가요?", "answer": "이벤트를 검색할 때 사용할 수 있는 검색어는 다음과 같습니다:\n- `summary`\n- `description`\n- `location`\n- `참석자 displayName`\n- `참석자 email`\n- `주최자의 displayName`\n- `주최자의 email`\n또한, 사전 정의된 키워드와 근무 위치, 부재중, 집중 시간 이벤트의 모든 표시 제목 번역을 일치시킬 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "응답에서 최대 몇 개의 이벤트를 받을 수 있나요?", "answer": "응답에서 최대 2,500개의 이벤트를 받을 수 있으며, 기본값은 250개 이벤트입니다. `maxResults` 매개변수를 사용하여 하나의 결과 페이지에 반환되는 최대 이벤트 수를 조정할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "삭제된 이벤트를 포함하여 결과를 가져오려면 어떤 매개변수를 사용해야 하나요?", "answer": "삭제된 이벤트를 포함하여 결과를 가져오려면 `showDeleted` 매개변수를 사용해야 합니다. 이 매개변수를 true로 설정하면 삭제된 이벤트(status가 'cancelled'인 경우)를 포함할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트를 정렬할 때 사용할 수 있는 매개변수는 무엇인가요?", "answer": "이벤트를 정렬할 때 사용할 수 있는 매개변수는 orderBy입니다. 허용되는 값은 다음과 같습니다. 'startTime': 시작 날짜/시간순으로 정렬합니다 (오름차순). 단일 이벤트를 쿼리하는 경우에만 사용할 수 있습니다 (즉, 매개변수 singleEvents가 True임). 'updated': 마지막 수정 시간순으로 정렬 (오름차순)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "응답에서 최대 참석자 수를 제한하려면 어떤 매개변수를 사용해야 하나요?", "answer": "응답에서 최대 참석자 수를 제한하려면 maxAttendees 매개변수를 사용해야 합니다. 이 매개변수는 응답에 포함할 참석자 최대 수를 지정합니다. 참석자가 지정된 수보다 많으면 참석자만 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 시작 및 종료 시간을 필터링하기 위해 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트의 시작 및 종료 시간을 필터링하기 위해 timeMin 및 timeMax 매개변수를 사용해야 합니다. timeMin은 필터링할 이벤트 종료 시간의 하한 (제외)이며, timeMax는 필터링할 이벤트 시작 시간의 상한 (제외)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "삭제된 이벤트를 포함하여 결과를 가져오려면 어떤 매개변수를 사용해야 하나요?", "answer": "삭제된 이벤트를 포함하여 결과를 가져오려면 showDeleted 매개변수를 사용해야 합니다. 이 매개변수는 결과에 삭제된 이벤트 (status이 'cancelled'인 경우)를 포함할지 여부를 결정합니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트 검색 시 특정 확장 속성을 기준으로 필터링하려면 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트 검색 시 특정 확장 속성을 기준으로 필터링하려면 privateExtendedProperty 또는 sharedExtendedProperty 매개변수를 사용해야 합니다. 이 매개변수는 propertyName=value 형식으로 지정된 확장 속성 제약조건에 따라 이벤트를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 마지막 수정 시간을 필터링하기 위해 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트의 마지막 수정 시간을 필터링하기 위해서는 updatedMin (updatedMin) 매개변수를 사용해야 합니다. 이 매개변수는 RFC3339 타임스탬프로 표시된 시간 이후에 수정된 이벤트만 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "응답에서 사용된 시간대는 어떻게 확인하나요?", "answer": "응답에서 사용된 시간대는 timeZone (timeZone) 필드를 통해 확인할 수 있습니다. 이 필드는 캘린더의 시간대를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 시작 및 종료 시간을 필터링할 때 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트의 시작 및 종료 시간을 필터링하기 위해서는 timeMin (timeMin)과 timeMax (timeMax) 매개변수를 사용해야 합니다. timeMin은 종료 시간의 하한을, timeMax는 시작 시간의 상한을 설정합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "동기화 토큰(syncToken)을 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "동기화 토큰(syncToken)을 사용할 때는 이전 목록 요청의 결과 마지막 페이지에서 반환된 nextSyncToken 필드에서 가져온 토큰을 사용해야 하며, 이 경우 iCalUID, orderBy, privateExtendedProperty, q, sharedExtendedProperty, timeMin, timeMax, updatedMin 등의 쿼리 매개변수는 함께 지정할 수 없습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "삭제된 이벤트를 포함하여 결과를 가져오려면 어떤 매개변수를 사용해야 하나요?", "answer": "삭제된 이벤트를 포함하여 결과를 가져오려면 showDeleted (showDeleted) 매개변수를 true로 설정해야 합니다. 이 매개변수는 결과에 삭제된 이벤트(status가 'cancelled'인 경우)를 포함할지 여부를 결정합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 마지막 수정 시간을 필터링하기 위해 어떤 매개변수를 사용해야 하나요?", "answer": "이벤트의 마지막 수정 시간을 필터링하기 위해서는 updatedMin(datetime) 매개변수를 사용해야 합니다. 이 매개변수는 필터링할 이벤트의 마지막 수정 시간 하한값을 RFC3339 타임스탬프로 표시합니다. 지정된 경우 이 시간 이후에 삭제된 항목은 showDeleted와 관계없이 항상 포함됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "응답에서 사용된 시간대를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "응답에서 사용된 시간대를 확인하려면 timeZone(string) 필드를 참조해야 합니다. 이 필드는 캘린더의 시간대를 나타내며, 기본값은 캘린더의 시간대입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 기본 리마인더를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트의 기본 리마인더를 설정할 때는 defaultReminders[] 리스트를 사용해야 합니다. 이 리스트는 인증된 사용자의 캘린더에 있는 기본 리마인더를 포함하며, 각 리마인더는 method(string)와 minutes(integer) 필드를 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "응답에서 다음 페이지의 이벤트에 접근하기 위해 어떤 필드를 사용해야 하나요?", "answer": "응답에서 다음 페이지의 이벤트에 접근하기 위해 nextPageToken(string) 필드를 사용해야 합니다. 이 필드는 이 결과의 다음 페이지에 액세스하는 데 사용되는 토큰입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트의 액세스 역할을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "이벤트의 액세스 역할을 확인하려면 accessRole(string) 필드를 참조해야 합니다. 이 필드는 사용자의 캘린더에 대한 액세스 역할을 나타내며, 가능한 값은 'none', 'freeBusyReader', 'reader', 'writer', 'owner'가 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "캘린더의 기본 리마인더를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "캘린더의 기본 리마인더를 설정할 때는 'defaultReminders' 필드를 사용해야 합니다. 이 필드는 인증된 사용자의 캘린더에 있는 기본 리마인더를 포함하며, 이 리마인더는 이 캘린더의 모든 일정에 적용됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트 시작 전 리마인더가 트리거되는 시간을 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "이벤트 시작 전 리마인더가 트리거되는 시간을 설정할 때는 'defaultReminders[].minutes' 필드를 사용해야 합니다. 유효한 값은 0에서 40320(4주(분)) 사이의 정수입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "캘린더의 시간대를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "캘린더의 시간대를 확인하려면 'timeZone' 필드를 참조해야 합니다. 이 필드는 읽기 전용입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "캘린더의 마지막 수정 시간을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "캘린더의 마지막 수정 시간을 확인하려면 'updated' 필드를 참조해야 합니다. 이 필드는 RFC3339 타임스탬프로 표시되며 읽기 전용입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "사용자의 캘린더에 대한 액세스 역할을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "사용자의 캘린더에 대한 액세스 역할을 확인하려면 'accessRole' 필드를 참조해야 합니다. 이 필드는 읽기 전용이며, 가능한 값은 'none', 'freeBusyReader', 'reader', 'writer', 'owner'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_list.txt"}
{"question": "이벤트를 다른 캘린더로 이동하기 위해 필요한 HTTP 요청은 무엇인가요?", "answer": "이벤트를 다른 캘린더로 이동하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId/move\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/move"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_move.txt"}
{"question": "이벤트 이동 시 필수로 제공해야 하는 매개변수는 무엇인가요?", "answer": "이벤트 이동 시 필수로 제공해야 하는 매개변수는 다음과 같습니다:\n- `calendarId`: 현재 일정이 있는 소스 캘린더의 캘린더 식별자입니다.\n- `eventId`: 이벤트 식별자입니다.\n- `destination`: 일정을 이동할 대상 캘린더의 캘린더 식별자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/move"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_move.txt"}
{"question": "이벤트 이동 시 알림을 전송할지 여부를 설정하는 방법은 무엇인가요?", "answer": "이벤트 이동 시 알림을 전송할지 여부는 `sendUpdates` 쿼리 매개변수를 사용하여 설정할 수 있습니다. 허용되는 값은 다음과 같습니다:\n- `'all'`: 모든 참석자에게 알림이 전송됩니다.\n- `'externalOnly'`: Google Calendar를 사용하지 않는 참석자에게만 알림이 전송됩니다.\n- `'none'`: 알림이 전송되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/move"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_move.txt"}
{"question": "이벤트 이동 요청 시 요청 본문에 포함해야 할 내용은 무엇인가요?", "answer": "이 메소드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/move"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_move.txt"}
{"question": "이벤트 이동 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.events.owned`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/move"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_move.txt"}
{"question": "PATCH 메서드를 사용하여 Google Calendar 이벤트를 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "이벤트를 업데이트하기 위해서는 다음과 같은 HTTP 요청 형식을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_patch.txt"}
{"question": "이벤트 업데이트 요청 시 사용할 수 있는 선택적 쿼리 매개변수에는 어떤 것들이 있나요?", "answer": "이벤트 업데이트 요청 시 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `alwaysIncludeEmail` (boolean): 지원 중단되고 무시됩니다.\n- `conferenceDataVersion` (integer): API 클라이언트에서 지원하는 회의 데이터의 버전 번호입니다.\n- `maxAttendees` (integer): 응답에 포함할 참석자 최대 수입니다.\n- `sendUpdates` (string): 이벤트 업데이트에 관한 알림을 받아야 하는 참석자입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_patch.txt"}
{"question": "이벤트 업데이트 요청에서 `sendUpdates` 파라미터의 허용 값은 무엇인가요?", "answer": "`sendUpdates` 파라미터의 허용 값은 다음과 같습니다:\n- `all`: 모든 참석자에게 알림이 전송됩니다.\n- `externalOnly`: Google Calendar를 사용하지 않는 참석자에게만 알림이 전송됩니다.\n- `none`: 알림이 전송되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_patch.txt"}
{"question": "이벤트 업데이트 요청을 보내기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.owned`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_patch.txt"}
{"question": "이벤트 업데이트 요청의 응답으로 어떤 형식의 데이터가 반환되나요?", "answer": "이 메서드는 성공하면 응답 본문에 Events 리소스가 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/patch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_patch.txt"}
{"question": "quickAdd 메서드를 사용하여 이벤트를 생성할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "quickAdd 메서드를 사용하여 이벤트를 생성할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/events/quickAdd\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/quickAdd"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_quickAdd.txt"}
{"question": "quickAdd 메서드에서 calendarId는 어떻게 설정하나요?", "answer": "quickAdd 메서드에서 calendarId는 캘린더 식별자입니다. 캘린더 ID를 가져오려면 calendarList.list 메서드를 호출해야 합니다. 현재 로그인한 사용자의 기본 캘린더에 액세스하려면 'primary' 키워드를 사용하세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/quickAdd"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_quickAdd.txt"}
{"question": "quickAdd 메서드의 필수 쿼리 매개변수는 무엇인가요?", "answer": "quickAdd 메서드의 필수 쿼리 매개변수는 text입니다. 이 매개변수는 생성할 이벤트를 설명하는 텍스트입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/quickAdd"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_quickAdd.txt"}
{"question": "quickAdd 메서드에서 sendNotifications 매개변수는 어떻게 사용하나요?", "answer": "sendNotifications 매개변수는 지원 중단되었습니다. 대신 sendUpdates 매개변수를 사용해야 합니다. 이 매개변수는 이벤트 생성에 관한 알림을 전송할지 여부를 설정합니다. 기본값은 false입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/quickAdd"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_quickAdd.txt"}
{"question": "quickAdd 메서드를 호출할 때 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "quickAdd 메서드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/quickAdd"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_quickAdd.txt"}
{"question": "이벤트를 업데이트할 때 어떤 HTTP 요청을 사용해야 하나요?", "answer": "이벤트를 업데이트할 때는 다음의 HTTP 요청을 사용해야 합니다.\n\n```\nPUT https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 필수로 포함해야 하는 속성은 무엇인가요?", "answer": "이벤트 업데이트 요청 시 필수로 포함해야 하는 속성은 다음과 같습니다:\n- `start` (nested object): 이벤트의 시작 시간 (양 끝값 포함)입니다.\n- `end` (nested object): 이벤트의 종료 시간 (제외)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 시 `sendUpdates` 파라미터의 허용 값은 무엇인가요?", "answer": "`sendUpdates` 파라미터의 허용 값은 다음과 같습니다:\n- `all`: 모든 참석자에게 알림이 전송됩니다.\n- `externalOnly`: Google Calendar를 사용하지 않는 참석자에게만 알림이 전송됩니다.\n- `none`: 알림이 전송되지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `conferenceDataVersion` 파라미터는 어떤 역할을 하나요?", "answer": "`conferenceDataVersion` 파라미터는 API 클라이언트에서 지원하는 회의 데이터의 버전 번호를 지정합니다. 버전 0은 회의 데이터 지원이 없다고 가정하고 이벤트 본문의 회의 데이터를 무시합니다. 버전 1에서는 ConferenceData의 복사와 conferenceData의 createRequest 필드를 사용하여 새 회의를 만드는 것을 지원합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청을 위해 필요한 승인 범위는 무엇인가요?", "answer": "이벤트 업데이트 요청을 위해서는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.events`\n- `https://www.googleapis.com/auth/calendar.app.created`\n- `https://www.googleapis.com/auth/calendar.events.owned`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `maxAttendees` 파라미터는 어떤 역할을 하나요?", "answer": "`maxAttendees` 파라미터는 응답에 포함할 참석자 최대 수를 지정합니다. 참석자가 지정된 수보다 많으면 참석자만 반환됩니다. 이 파라미터는 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `supportsAttachments` 파라미터의 기본값은 무엇인가요?", "answer": "`supportsAttachments` 파라미터의 기본값은 False입니다. 이 파라미터는 작업을 실행하는 API 클라이언트가 이벤트 첨부파일을 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `attendees` 필드에 포함해야 하는 정보는 무엇인가요?", "answer": "`attendees` 필드에는 이벤트 참석자의 이메일 주소가 포함되어야 하며, 이 필드는 참석자를 추가할 때 필요합니다. 이메일 주소는 RFC5322에 따라 유효해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `attendees[].responseStatus` 필드의 가능한 값은 무엇인가요?", "answer": "`attendees[].responseStatus` 필드의 가능한 값은 다음과 같습니다: 'needsAction', 'declined', 'tentative', 'accepted'. 이 필드는 참석자의 응답 상태를 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `attachments[].fileUrl` 필드는 어떤 형식을 가져야 하나요?", "answer": "`attachments[].fileUrl` 필드는 첨부파일의 URL 링크를 포함해야 하며, Google Drive 파일 첨부파일을 추가하려면 Drive API의 Files 리소스의 alternateLink 속성과 동일한 형식을 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `attendees[].email` 필드에 어떤 정보가 필요하나요?", "answer": "`attendees[].email` 필드는 참석자의 이메일 주소(있는 경우)를 포함해야 하며, 참석자를 추가할 때 이 필드가 있어야 합니다. RFC5322에 따라 유효한 이메일 주소여야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `attendees[].responseStatus` 필드의 가능한 값은 무엇인가요?", "answer": "`attendees[].responseStatus` 필드의 가능한 값은 다음과 같습니다.\n- 'needsAction' - 참석자가 초대에 응답하지 않았습니다 (신규 일정에 권장됨).\n- 'declined' - 참석자가 초대를 거부했습니다.\n- 'tentative' - 참석자가 초대를 잠정적으로 수락했습니다.\n- 'accepted' - 참석자가 초대를 수락했습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `attendees[].optional` 필드는 어떤 역할을 하나요?", "answer": "`attendees[].optional` 필드는 참석자가 선택사항인지 여부를 나타내며, 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `attendees[].displayName` 필드는 어떤 정보를 포함하나요?", "answer": "`attendees[].displayName` 필드는 참석자 이름을 포함하며, 제공되는 경우에만 사용됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `colorId` 필드는 어떤 정보를 나타내나요?", "answer": "`colorId` 필드는 이벤트의 색상을 나타내며, 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다. 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `attendeesOmitted` 필드는 어떤 의미인가요?", "answer": "`attendeesOmitted` boolean 참석자가 이벤트의 표현에서 누락되었을 수 있는지 여부입니다. 이벤트를 검색할 때 maxAttendee 쿼리 매개변수로 지정된 제한사항으로 인해 이러한 문제가 발생할 수 있습니다. 이벤트를 업데이트할 때 참여자의 응답만 업데이트하는 데 사용할 수 있습니다. 선택사항입니다. 기본값은 False입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `colorId` 필드는 어떤 정보를 나타내나요?", "answer": "`colorId` string 이벤트의 색상입니다. 색상 정의의 event 섹션에 있는 항목을 참조하는 ID입니다 (색상 엔드포인트 [https://developers.google.com/calendar/v3/reference/colors?hl=ko] 참고). 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `description` 필드는 어떤 정보를 포함하나요?", "answer": "`description` string 이벤트에 관한 설명입니다. HTML을 포함할 수 있습니다. 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `guestsCanInviteOthers` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanInviteOthers` boolean 주최자 이외의 참석자가 일정에 다른 사용자를 초대할 수 있는지 여부입니다. 선택사항입니다. 기본값은 true입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `location` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`location` string 이벤트의 지리적 위치(자유 형식 텍스트)입니다. 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `extendedProperties` 필드는 어떤 정보를 포함하나요?", "answer": "`extendedProperties` 필드는 비공식적인 속성을 포함하는 객체로, `private`와 `shared` 두 가지 속성을 가집니다. `private`는 캘린더에 표시되는 일정 사본에 비공식적인 속성을 나타내며, `shared`는 다른 참석자의 캘린더에 있는 일정 사본 간에 공유되는 속성을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `focusTimeProperties` 필드는 어떤 경우에 사용되나요?", "answer": "`focusTimeProperties` 필드는 이벤트 데이터의 `eventType`이 `focusTime`인 경우에 사용됩니다. 이 필드는 방해 금지 시간에 대한 정보를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `gadget` 필드의 `display` 속성은 어떤 값을 가질 수 있나요?", "answer": "`gadget.display` 속성은 가젯의 디스플레이 모드를 나타내며, 가능한 값은 'icon'과 'chip'입니다. 'icon'은 캘린더 보기에서 일정 제목 옆에 가젯이 표시되며, 'chip'은 이벤트를 클릭하면 가젯이 표시됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `guestsCanModify` 필드는 어떤 역할을 하나요?", "answer": "`guestsCanModify` 필드는 주최자 이외의 참석자가 일정을 수정할 수 있는지 여부를 나타내며, 기본값은 `False`입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `reminders.overrides` 필드는 어떤 정보를 포함하나요?", "answer": "`reminders.overrides` 필드는 이벤트에서 기본 리마인더를 사용하지 않는 경우에 대한 리마인더 정보를 포함하며, 최대 5개의 재정의 리마인더를 설정할 수 있습니다. 각 리마인더는 `method`와 `minutes` 속성을 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `originalStartTime` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`originalStartTime` 필드는 결합된 날짜-시간 값으로 표시된 시간입니다 (RFC3339 형식). 이 필드는 쓰기 가능하며, 시간대에 대한 명시적인 지정이 없을 경우 시간대 오프셋이 필요합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `recurrence` 필드는 어떤 경우에 사용되나요?", "answer": "`recurrence` 필드는 반복되는 일정의 RRULE, EXRULE, RDATE, EXDATE 행 목록을 포함합니다. 이 필드는 단일 이벤트 또는 반복 이벤트의 인스턴스의 경우 생략될 수 있으며, 이벤트 시작 시간 및 종료 시간은 `start` 및 `end` 필드에 지정됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `reminders.overrides` 필드는 어떤 정보를 포함하나요?", "answer": "`reminders.overrides` 필드는 이벤트에서 기본 리마인더를 사용하지 않는 경우 이벤트에 관한 리마인더를 표시합니다. 설정되지 않은 경우 이 이벤트에 리마인더가 설정되지 않았음을 나타내며, 재정의 리마인더의 최대 개수는 5개입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `reminders.overrides[].method` 필드는 어떤 값을 가질 수 있나요?", "answer": "`reminders.overrides[].method` 필드는 이 리마인더에서 사용하는 메서드를 나타내며, 가능한 값은 'email' (리마인더가 이메일을 통해 전송됨)과 'popup' (UI 팝업을 통해 리마인더가 전송됨)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `status` 필드는 어떤 정보를 포함하나요?", "answer": "`status` 필드는 이벤트의 상태를 나타내며, 선택사항입니다. 가능한 값은 'confirmed' (이벤트가 확인됨), 'tentative' (이벤트가 잠정적으로 확인됨), 'cancelled' (이벤트가 취소됨)입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `source.title` 필드는 어떤 정보를 포함해야 하나요?", "answer": "`source.title` 필드는 소스의 제목을 나타내며, 예를 들어 웹페이지 제목 또는 이메일 제목을 포함할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `start.date` 필드는 어떤 형식을 가져야 하나요?", "answer": "`start.date` 필드는 종일 일정인 경우 'yyyy-mm-dd' 형식의 날짜를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `start.dateTime` 필드는 어떤 형식으로 제공되어야 하나요?", "answer": "`start.dateTime` 필드는 결합된 날짜-시간 값으로 표시되어야 하며, RFC3339 형식에 따라 제공되어야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청에서 `status` 필드는 어떤 값을 가질 수 있나요?", "answer": "`status` 필드는 이벤트의 상태를 나타내며, 가능한 값은 'confirmed', 'tentative', 'cancelled'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `transparency` 필드는 어떤 역할을 하나요?", "answer": "`transparency` 필드는 일정이 캘린더에서 시간을 차단하는지 여부를 나타내며, 가능한 값은 'opaque'와 'transparent'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `transparency` 필드는 어떤 값을 가질 수 있나요?", "answer": "`transparency` 필드는 일정이 캘린더에서 시간을 차단하는지 여부를 나타냅니다. 가능한 값은 다음과 같습니다.\n- 'opaque' - 기본값입니다. 일정이 캘린더에서 시간을 차단합니다. 이는 캘린더 UI에서 나를 바쁨으로 설정하는 것과 같습니다.\n- 'transparent' - 일정이 캘린더에서 시간을 차단하지 않습니다. 이는 캘린더 UI에서 나를 표시를 한가함으로 설정하는 것과 같습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `visibility` 필드는 어떤 값을 가질 수 있나요?", "answer": "`visibility` 필드는 이벤트의 공개 상태를 나타냅니다. 가능한 값은 다음과 같습니다.\n- 'default' - 캘린더의 일정에 기본 공개 상태를 사용합니다. 기본값입니다.\n- 'public' - 일정이 공개되어 있으며 캘린더의 모든 독자가 일정 세부정보를 볼 수 있습니다.\n- 'private' - 비공개 일정으로, 일정 참석자만 일정 세부정보를 볼 수 있습니다.\n- 'confidential' - 이벤트가 비공개입니다. 이 값은 호환성을 위해 제공됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `workingLocationProperties` 필드는 어떤 정보를 포함하나요?", "answer": "`workingLocationProperties` 필드는 작업 위치 이벤트 데이터를 포함합니다. 이 필드는 다음과 같은 하위 필드를 가질 수 있습니다:\n- `customLocation` - 사용자가 맞춤 위치에서 작업 중임을 나타냅니다.\n- `homeOffice` - 사용자가 재택근무 중임을 나타냅니다.\n- `officeLocation` - 사용자가 사무실에서 작업 중임을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `workingLocationProperties.officeLocation` 필드의 하위 필드는 어떤 것들이 있나요?", "answer": "`workingLocationProperties.officeLocation` 필드는 사용자가 사무실에서 작업 중임을 나타내며, 다음과 같은 하위 필드를 포함할 수 있습니다:\n- `buildingId` - 선택사항인 건물 식별자입니다. 이는 조직의 리소스 데이터베이스에 있는 건물 ID를 참조해야 합니다.\n- `deskId` - 선택적 데스크 식별자입니다.\n- `floorId` - 층 식별자(선택사항).\n- `floorSectionId` - 선택사항인 층 섹션 식별자입니다.\n- `label` - Calendar 웹 및 모바일 클라이언트에 표시되는 사무실 이름입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 업데이트 요청 시 `workingLocationProperties.type` 필드는 어떤 값을 가질 수 있나요?", "answer": "`workingLocationProperties.type` 필드는 근무 위치 유형을 나타내며, 가능한 값은 다음과 같습니다:\n- 'homeOffice' - 사용자가 집에서 작업 중입니다.\n- 'officeLocation' - 사용자가 사무실에서 작업 중입니다.\n- 'customLocation' - 사용자가 맞춤 위치에서 작업 중입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/update"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_update.txt"}
{"question": "이벤트 리소스의 변경사항을 확인하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "이벤트 리소스의 변경사항을 확인하기 위해서는 다음의 HTTP 요청을 사용해야 합니다.\n\n```plaintext\nPOST https://www.googleapis.com/calendar/v3/calendars/calendarId/events/watch\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "이벤트를 모니터링하기 위해 필요한 매개변수는 무엇인가요?", "answer": "이벤트를 모니터링하기 위해 필요한 매개변수는 다음과 같습니다:\n- `calendarId`: 캘린더 식별자입니다. 캘린더 ID를 가져오려면 `calendarList.list` 메서드를 호출해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "이벤트 유형을 지정할 때 사용할 수 있는 허용된 값은 무엇인가요?", "answer": "이벤트 유형을 지정할 때 사용할 수 있는 허용된 값은 다음과 같습니다:\n- 'birthday': 연간 반복되는 특별 종일 일정입니다.\n- 'default': 일반 이벤트입니다.\n- 'focusTime': 방해 금지 시간 일정입니다.\n- 'fromGmail': Gmail에 포함된 일정입니다.\n- 'outOfOffice': 부재중 일정입니다.\n- 'workingLocation': 근무 위치 이벤트입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "요청 본문에 포함해야 하는 데이터 구조는 어떻게 되나요?", "answer": "요청 본문에 포함해야 하는 데이터 구조는 다음과 같습니다:\n```json\n{\n  \"id\": string,\n  \"token\": string,\n  \"type\": string,\n  \"address\": string,\n  \"params\": {\n    \"ttl\": string\n  }\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "요청이 성공했을 때 반환되는 응답 본문의 구조는 어떻게 되나요?", "answer": "요청이 성공했을 때 반환되는 응답 본문의 구조는 다음과 같습니다:\n```json\n{\n  \"kind\": \"api#channel\",\n  \"id\": string,\n  \"resourceId\": string,\n  \"resourceUri\": string,\n  \"token\": string,\n  \"expiration\": long\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "알림 채널을 설정할 때 'params' 필드에 포함할 수 있는 추가 매개변수는 무엇인가요?", "answer": "'params' 필드에는 전송 채널 동작을 제어하는 추가 매개변수인 'ttl'이 포함될 수 있습니다. 'ttl'은 알림 채널의 수명(초)을 나타내며, 기본값은 604,800초입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "요청 본문에서 'type' 필드에 지정할 수 있는 유효한 값은 무엇인가요?", "answer": "'type' 필드에는 'web_hook' 또는 'webhook'이라는 유효한 값이 지정될 수 있습니다. 이 값은 메시지를 전송하는 데 HTTP 요청이 사용되는 채널을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "알림 채널을 통해 전송되는 각 알림과 함께 전송되는 문자열은 어떤 필드에 포함되나요?", "answer": "알림 채널을 통해 전송되는 각 알림과 함께 전송되는 문자열은 'token' 필드에 포함됩니다. 이 필드는 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "요청이 성공했을 때 반환되는 응답 본문에서 'kind' 필드는 어떤 값을 가지나요?", "answer": "요청이 성공했을 때 반환되는 응답 본문에서 'kind' 필드는 리소스 변경사항을 감시하는 데 사용되는 알림 채널을 식별하는 값인 'api#channel'을 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "응답 본문에서 'expiration' 필드는 어떤 정보를 제공하나요?", "answer": "'expiration' 필드는 알림 채널 만료 날짜 및 시간을 제공하며, Unix 타임스탬프로 밀리초 단위로 표시됩니다. 이 필드는 선택사항입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/events/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_events_watch.txt"}
{"question": "Freebusy API의 주요 기능은 무엇인가요?", "answer": "Freebusy API는 캘린더 모음의 한가함(free) 및 바쁨(busy) 정보를 반환하는 기능을 제공합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy.txt"}
{"question": "Freebusy API에서 사용할 수 있는 메소드는 무엇이 있나요?", "answer": "Freebusy API에서 사용할 수 있는 메소드는 query입니다. 이 메소드는 캘린더 모음의 한가함/바쁨 정보를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy.txt"}
{"question": "Freebusy API의 리소스 표현은 어떻게 되나요?", "answer": "Freebusy API의 리소스 표현은 영구 데이터가 연결되어 있지 않습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy.txt"}
{"question": "Freebusy API를 사용하기 위해 필요한 요청 형식은 무엇인가요?", "answer": "Freebusy API를 사용하기 위해서는 query 메소드를 호출하여 캘린더 모음의 한가함/바쁨 정보를 요청해야 합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy.txt"}
{"question": "Freebusy API의 응답 구조는 어떻게 되나요?", "answer": "Freebusy API의 응답 구조는 캘린더 모음의 한가함 및 바쁨 정보를 포함하는 JSON 형식으로 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy.txt"}
{"question": "FreeBusy API의 요청 본문에서 'timeMin'과 'timeMax'의 역할은 무엇인가요?", "answer": "'timeMin'은 RFC3339 형식에 따라 쿼리 간격의 시작을 나타내고, 'timeMax'는 쿼리 간격의 끝을 나타냅니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API를 호출할 때 필요한 승인 범위는 무엇인가요?", "answer": "이 요청은 다음 범위 중 하나 이상으로 승인할 수 있습니다: https://www.googleapis.com/auth/calendar.readonly, https://www.googleapis.com/auth/calendar, https://www.googleapis.com/auth/calendar.events.freebusy, https://www.googleapis.com/auth/calendar.freebusy.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 'groups' 필드는 어떤 정보를 포함하나요?", "answer": "'groups' 필드는 그룹 확장을 나타내며, 각 그룹의 구성원인 캘린더 목록과 선택적 오류 정보를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 요청 본문에서 'groupExpansionMax'의 최대값은 얼마인가요?", "answer": "'groupExpansionMax'의 최대값은 100입니다. 이 값보다 많은 구성원이 있는 그룹에는 오류가 반환됩니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 'calendars' 필드는 어떤 정보를 제공하나요?", "answer": "'calendars' 필드는 각 캘린더의 한가함/바쁨 정보 목록을 제공하며, 각 캘린더의 약속 있음/없음 확장을 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 요청 본문에서 'calendarExpansionMax'의 역할은 무엇인가요?", "answer": "'calendarExpansionMax'는 FreeBusy 정보를 제공할 캘린더의 최대 개수를 지정하는 선택적 파라미터입니다. 최대값은 50입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 'kind' 필드는 어떤 정보를 제공하나요?", "answer": "'kind' 필드는 리소스 유형을 나타내며, 이 경우 'calendar#freeBusy'라는 값을 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 'calendars' 필드는 어떤 구조로 되어 있나요?", "answer": "'calendars' 필드는 단일 캘린더의 약속 있음/없음 정보를 포함하는 객체로, 각 캘린더에 대해 'errors'와 'busy' 필드를 포함합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 'busy' 필드는 어떤 정보를 포함하나요?", "answer": "'busy' 필드는 이 캘린더가 바쁜 것으로 간주되는 시간 범위 목록을 포함하며, 각 시간 범위는 'start'와 'end' 속성을 가집니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "FreeBusy API의 응답에서 오류가 발생했을 때 'errors' 필드는 어떤 정보를 포함하나요?", "answer": "'errors' 필드는 선택적 오류 목록을 포함하며, 각 오류는 'domain'과 'reason' 속성을 가집니다. 'reason'은 오류의 구체적인 이유를 설명합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/freebusy/query"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_freebusy_query.txt"}
{"question": "Google Calendar API에서 사용자의 기본 이벤트 길이를 설정하려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자의 기본 이벤트 길이(defaultEventLength)를 설정하려면 list 메서드 또는 get 메서드를 사용하여 현재 설정을 가져온 후, 필요한 값을 수정하여 업데이트할 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings.txt"}
{"question": "사용자가 Google Calendar에서 주말을 숨기려면 어떤 설정을 변경해야 하나요?", "answer": "주말을 숨기려면 hideWeekends 설정을 'true'로 변경해야 합니다. 기본값은 'false'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings.txt"}
{"question": "사용자의 언어(locale) 설정을 변경하려면 어떤 값들을 사용할 수 있나요?", "answer": "사용자의 언어(locale) 설정은 다음과 같은 값들을 사용할 수 있습니다: 'in', 'ca', 'cs', 'da', 'de', 'en_GB', 'en', 'es', 'es_419', 'tl', 'fr', 'hr', 'it', 'lv', 'lt', 'hu', 'nl', 'no', 'pl', 'pt_BR', 'pt_PT', 'ro', 'sk', 'sl', 'fi', 'sv', 'tr', 'vi', 'el', 'ru', 'sr', 'uk', 'bg', 'iw', 'ar', 'fa', 'hi', 'th', 'zh_TW', 'zh_CN', 'ja', 'ko'. 기본값은 'en'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings.txt"}
{"question": "사용자가 초대된 이벤트에 대한 응답을 하지 않은 경우, 해당 이벤트를 숨기려면 어떤 설정을 사용해야 하나요?", "answer": "사용자가 초대된 이벤트에 대한 응답을 하지 않은 경우 해당 이벤트를 숨기려면 hideInvitations 설정을 'true'로 변경해야 합니다. 기본값은 'false'입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings.txt"}
{"question": "Google Calendar API에서 사용자의 시간대 설정을 확인하려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자의 시간대 설정을 확인하려면 get 메서드를 사용하여 단일 사용자 설정을 반환받을 수 있습니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings.txt"}
{"question": "GET 요청을 통해 사용자 설정을 가져오려면 어떤 URL을 사용해야 하나요?", "answer": "사용자 설정을 가져오기 위해서는 다음의 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/users/me/settings/setting\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_get.txt"}
{"question": "사용자 설정을 가져오기 위해 필요한 매개변수는 무엇인가요?", "answer": "사용자 설정을 가져오기 위해서는 경로 매개변수로 `setting`을 제공해야 합니다. 이 `setting`은 사용자 설정의 ID입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_get.txt"}
{"question": "이 API 요청을 수행하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청에는 다음 범위 중 하나 이상에 대한 승인이 필요합니다:\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.settings.readonly", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_get.txt"}
{"question": "이 메서드를 사용할 때 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "이 메서드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_get.txt"}
{"question": "이 메서드가 성공적으로 실행되면 어떤 응답을 받게 되나요?", "answer": "이 메서드는 성공하면 응답 본문에 Settings 리소스를 반환합니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/get"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_get.txt"}
{"question": "Google Calendar API에서 사용자 설정을 가져오기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "사용자 설정을 가져오기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nGET https://www.googleapis.com/calendar/v3/users/me/settings\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_list.txt"}
{"question": "Google Calendar API의 settings.list 메서드에서 사용할 수 있는 선택적 쿼리 매개변수는 무엇이 있나요?", "answer": "settings.list 메서드에서 사용할 수 있는 선택적 쿼리 매개변수는 다음과 같습니다:\n- `maxResults` (integer): 하나의 결과 페이지에 반환되는 최대 항목 수입니다. 기본값은 항목 100개이며, 페이지 크기는 항목 250개를 초과할 수 없습니다.\n- `pageToken` (string): 반환할 결과 페이지를 지정하는 토큰입니다.\n- `syncToken` (string): 이전 목록 요청의 결과 마지막 페이지에서 반환된 nextSyncToken 필드에서 가져온 토큰입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_list.txt"}
{"question": "settings.list 메서드를 호출할 때 요청 본문에 어떤 내용을 포함해야 하나요?", "answer": "settings.list 메서드를 사용할 때는 요청 본문을 제공하지 마세요.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_list.txt"}
{"question": "settings.list 메서드의 성공적인 응답 구조는 어떻게 되나요?", "answer": "settings.list 메서드의 성공적인 응답 구조는 다음과 같습니다:\n\n```\n{\n  \"kind\": \"calendar#settings\",\n  \"etag\": etag,\n  \"nextPageToken\": string,\n  \"nextSyncToken\": string,\n  \"items\": [\n    settings Resource\n  ]\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_list.txt"}
{"question": "settings.list 메서드를 호출하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "settings.list 메서드를 호출하기 위해 필요한 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/calendar.readonly`\n- `https://www.googleapis.com/auth/calendar`\n- `https://www.googleapis.com/auth/calendar.settings.readonly`", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/list"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_list.txt"}
{"question": "Google Calendar API에서 설정 리소스의 변경사항을 확인하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "설정 리소스의 변경사항을 확인하기 위해 다음과 같은 HTTP 요청을 사용합니다.\n\n```plaintext\nPOST https://www.googleapis.com/calendar/v3/users/me/settings/watch\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_watch.txt"}
{"question": "설정 리소스의 변경사항을 확인하기 위한 요청 본문은 어떤 구조를 가져야 하나요?", "answer": "요청 본문은 다음과 같은 구조의 데이터를 제공합니다.\n\n```json\n{\n  \"id\": string,\n  \"token\": string,\n  \"type\": string,\n  \"address\": string,\n  \"params\": {\n    \"ttl\": string\n  }\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_watch.txt"}
{"question": "설정 리소스의 변경사항을 확인하기 위해 필요한 승인 범위는 무엇인가요?", "answer": "이 요청을 처리하려면 다음 범위 중 하나 이상의 승인이 필요합니다.\n- https://www.googleapis.com/auth/calendar.readonly\n- https://www.googleapis.com/auth/calendar\n- https://www.googleapis.com/auth/calendar.settings.readonly", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_watch.txt"}
{"question": "알림 채널의 TTL(수명)을 설정하는 방법은 무엇인가요?", "answer": "알림 채널의 TTL(수명)은 요청 본문의 `params` 객체 내 `ttl` 속성을 통해 설정할 수 있습니다. 기본값은 604,800초입니다.", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_watch.txt"}
{"question": "요청에 성공할 경우 반환되는 응답 본문의 구조는 어떻게 되나요?", "answer": "요청에 성공할 경우 이 메소드는 다음과 같은 구조의 응답 본문을 반환합니다.\n\n```json\n{\n  \"kind\": \"api#channel\",\n  \"id\": string,\n  \"resourceId\": string,\n  \"resourceUri\": string,\n  \"token\": string,\n  \"expiration\": long\n}\n```", "source": ["https://developers.google.com/workspace/calendar/api/v3/reference/settings/watch"], "tags": "calendar", "last_verified": "2025-08-19", "source_file": "workspace_calendar_api_v3_reference_settings_watch.txt"}
{"question": "Google Drive API에서 현재 사용자에 대한 정보를 가져오는 방법은 무엇인가요?", "answer": "현재 사용자에 대한 정보를 가져오려면 다음의 GET 메서드를 사용합니다: GET /drive/v2/about. 이 메서드는 Drive API 설정과 함께 현재 사용자에 대한 정보를 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "특정 앱의 정보를 가져오는 API 요청은 어떻게 하나요?", "answer": "특정 앱의 정보를 가져오려면 다음의 GET 메서드를 사용합니다: GET /drive/v2/apps/{appId}. 여기서 {appId}는 가져오려는 앱의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "사용자의 설치된 앱을 나열하는 방법은 무엇인가요?", "answer": "사용자의 설치된 앱을 나열하려면 다음의 GET 메서드를 사용합니다: GET /drive/v2/apps. 이 요청을 통해 사용자가 설치한 모든 앱의 목록을 받을 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "사용자의 변경사항을 구독하는 방법은 무엇인가요?", "answer": "사용자의 변경사항을 구독하려면 다음의 POST 메서드를 사용합니다: POST /drive/v2/changes/watch. 이 요청을 통해 사용자의 변경사항을 실시간으로 모니터링할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "폴더에 파일을 삽입하는 API 요청은 어떻게 하나요?", "answer": "폴더에 파일을 삽입하려면 다음의 POST 메서드를 사용합니다: POST /drive/v2/files/{folderId}/children. 여기서 {folderId}는 파일을 삽입할 폴더의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 특정 앱의 정보를 가져오는 방법은 무엇인가요?", "answer": "특정 앱의 정보를 가져오려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/apps/{appId}\n```\n여기서 `{appId}`는 가져오려는 앱의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 사용자의 변경사항을 나열하는 방법은 무엇인가요?", "answer": "사용자의 변경사항을 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/changes\n```\n이 요청은 사용자 또는 공유 드라이브의 변경사항을 표시합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 폴더의 하위 요소를 나열하는 방법은 무엇인가요?", "answer": "폴더의 하위 요소를 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{folderId}/children\n```\n여기서 `{folderId}`는 하위 요소를 나열할 폴더의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 댓글을 추가하는 방법은 무엇인가요?", "answer": "지정된 파일에 새 댓글을 추가하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v2/files/{fileId}/comments\n```\n여기서 `{fileId}`는 댓글을 추가할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 공유 드라이브를 생성하는 방법은 무엇인가요?", "answer": "새 공유 드라이브를 생성하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v2/drives\n```\n이 요청을 통해 새로운 공유 드라이브를 만들 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 폴더에 파일을 삽입하는 방법은 무엇인가요?", "answer": "폴더에 파일을 삽입하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v2/files/{folderId}/children\n```\n여기서 `{folderId}`는 파일을 삽입할 폴더의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 특정 파일의 댓글을 삭제하는 방법은 무엇인가요?", "answer": "특정 파일의 댓글을 삭제하려면 다음과 같은 DELETE 요청을 사용합니다:\n\n```\nDELETE /drive/v2/files/{fileId}/comments/{commentId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{commentId}`는 삭제할 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 댓글을 나열하는 방법은 무엇인가요?", "answer": "파일의 댓글을 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{fileId}/comments\n```\n여기서 `{fileId}`는 댓글을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 공유 드라이브의 메타데이터를 가져오는 방법은 무엇인가요?", "answer": "공유 드라이브의 메타데이터를 가져오려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/drives/{driveId}\n```\n여기서 `{driveId}`는 메타데이터를 가져올 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 공유 드라이브를 생성하는 방법은 무엇인가요?", "answer": "새 공유 드라이브를 생성하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v2/drives\n```\n이 요청을 통해 새로운 공유 드라이브를 만들 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 메타데이터를 업데이트하는 방법은 무엇인가요?", "answer": "파일의 메타데이터 또는 콘텐츠를 업데이트하려면 다음과 같은 API 요청을 사용합니다.\n\n```\nPUT /drive/v2/files/{fileId}\n```\n여기서 `{fileId}`는 업데이트할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일을 영구적으로 삭제하는 방법은 무엇인가요?", "answer": "파일을 휴지통으로 이동하지 않고 영구적으로 삭제하려면 다음과 같은 API 요청을 사용합니다.\n\n```\nDELETE /drive/v2/files/{fileId}\n```\n여기서 `{fileId}`는 삭제할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일을 휴지통으로 이동하는 방법은 무엇인가요?", "answer": "파일을 휴지통으로 이동하려면 다음과 같은 API 요청을 사용합니다.\n\n```\nPOST /drive/v2/files/{fileId}/trash\n```\n여기서 `{fileId}`는 이동할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일을 복원하는 방법은 무엇인가요?", "answer": "휴지통에서 파일을 복원하려면 다음과 같은 API 요청을 사용합니다.\n\n```\nPOST /drive/v2/files/{fileId}/untrash\n```\n여기서 `{fileId}`는 복원할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 라벨을 나열하는 방법은 무엇인가요?", "answer": "파일의 라벨을 나열하려면 다음과 같은 API 요청을 사용합니다.\n\n```\nGET /drive/v2/files/{fileId}/listLabels\n```\n여기서 `{fileId}`는 라벨을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 업데이트 시간을 현재 서버 시간으로 설정하는 방법은 무엇인가요?", "answer": "파일의 업데이트 시간을 현재 서버 시간으로 설정하려면 다음과 같은 API 요청을 사용합니다:\n\n```http\nPOST /drive/v2/files/{fileId}/touch\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일을 휴지통으로 이동하는 방법은 무엇인가요?", "answer": "파일을 휴지통으로 이동하려면 다음과 같은 API 요청을 사용합니다:\n\n```http\nPOST /drive/v2/files/{fileId}/trash\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 휴지통에서 파일을 복원하는 방법은 무엇인가요?", "answer": "휴지통에서 파일을 복원하려면 다음과 같은 API 요청을 사용합니다:\n\n```http\nPOST /drive/v2/files/{fileId}/untrash\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 메타데이터 또는 콘텐츠를 업데이트하는 방법은 무엇인가요?", "answer": "파일의 메타데이터 또는 콘텐츠를 업데이트하려면 다음과 같은 API 요청을 사용합니다:\n\n```http\nPUT /drive/v2/files/{fileId}\nPUT /upload/drive/v2/files/{fileId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일 변경사항을 구독하는 방법은 무엇인가요?", "answer": "파일 변경사항을 구독하려면 다음과 같은 API 요청을 사용합니다:\n\n```http\nPOST /drive/v2/files/{fileId}/watch\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 권한을 삽입하는 방법은 무엇인가요?", "answer": "파일 또는 공유 드라이브의 권한을 삽입하기 위해서는 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v2/files/{fileId}/permissions\n```\n여기서 `{fileId}`는 권한을 삽입할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 속성을 나열하는 방법은 무엇인가요?", "answer": "파일의 속성을 나열하기 위해서는 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{fileId}/properties\n```\n여기서 `{fileId}`는 속성을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 특정 파일의 속성을 가져오는 방법은 무엇인가요?", "answer": "특정 파일의 속성을 가져오기 위해서는 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{fileId}/properties/{propertyKey}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{propertyKey}`는 가져올 속성의 키입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 댓글에 대한 모든 답글을 나열하는 방법은 무엇인가요?", "answer": "댓글에 대한 모든 답글을 나열하기 위해서는 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{fileId}/comments/{commentId}/replies\n```\n여기서 `{fileId}`는 파일의 ID이고, `{commentId}`는 답글을 나열할 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive API에서 파일의 버전을 나열하는 방법은 무엇인가요?", "answer": "파일의 버전을 나열하기 위해서는 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v2/files/{fileId}/revisions\n```\n여기서 `{fileId}`는 버전을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2.txt"}
{"question": "Google Drive에서 지원하는 최대 업로드 크기는 어떻게 확인하나요?", "answer": "최대 업로드 크기는 maxUploadSizes 필드를 통해 확인할 수 있습니다. 이 필드는 각 파일 유형의 최대 업로드 크기 목록을 포함하고 있습니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  \"maxUploadSizes\": [\n    {\n      \"type\": \"application/pdf\",\n      \"size\": \"10MB\"\n    }\n  ]\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용 가능한 폴더 색상 팔레트는 어떻게 확인하나요?", "answer": "허용되는 폴더 색상 팔레트는 folderColorPalette 필드를 통해 확인할 수 있습니다. 이 필드는 RGB 16진수 문자열로 표현된 색상 목록을 포함합니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  \"folderColorPalette\": [\n    \"#FF0000\",\n    \"#00FF00\",\n    \"#0000FF\"\n  ]\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 현재 도메인 공유 정책은 어떻게 확인하나요?", "answer": "현재 사용자의 도메인 공유 정책은 domainSharingPolicy 필드를 통해 확인할 수 있습니다. 이 필드는 가능한 값으로 'allowed', 'allowedWithWarning', 'incomingOnly', 'disallowed' 중 하나를 가집니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  \"domainSharingPolicy\": \"allowed\"\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 총 할당량 바이트 수는 어떻게 확인하나요?", "answer": "총 할당량 바이트 수는 quotaBytesTotal 필드를 통해 확인할 수 있습니다. 이 필드는 quotaType이 LIMITED인 경우에만 관련됩니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  \"quotaBytesTotal\": \"1000000000\"\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 이름은 어떻게 확인하나요?", "answer": "현재 사용자의 이름은 name 필드를 통해 확인할 수 있습니다. 이 필드는 사용자의 이름을 문자열로 포함합니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  \"name\": \"홍길동\"\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 도메인 공유 정책은 어떤 값이 있을까요?", "answer": "현재 사용자의 도메인 공유 정책(domainSharingPolicy)은 다음과 같은 값이 있습니다: allowed, allowedWithWarning, incomingOnly, disallowed.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 총 할당량 바이트 수는 어떻게 확인하나요?", "answer": "사용자의 총 할당량 바이트 수는 quotaBytesTotal 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자가 공유 드라이브를 만들 수 있는지 여부는 어떻게 확인하나요?", "answer": "사용자가 공유 드라이브를 만들 수 있는지 여부는 canCreateDrives 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자의 언어 코드는 어떻게 확인하나요?", "answer": "사용자의 언어 또는 언어 코드는 languageCode 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "Google Drive에서 사용자가 인증된 앱을 설치했는지 여부는 어떻게 확인하나요?", "answer": "사용자가 인증된 앱이 인증된 사용자에 의해 설치되었는지 여부는 isCurrentAppInstalled 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about.txt"}
{"question": "about.get 메서드를 사용하여 어떤 정보를 가져올 수 있나요?", "answer": "about.get 메서드는 Drive API 설정과 함께 현재 사용자에 대한 정보를 가져옵니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about_get.txt"}
{"question": "about.get 메서드의 HTTP 요청 형식은 어떻게 되나요?", "answer": "HTTP 요청 형식은 다음과 같습니다:\n```\nGET https://www.googleapis.com/drive/v2/about\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about_get.txt"}
{"question": "about.get 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "about.get 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- includeSubscribed: boolean\n- maxChangeIdCount: string (int64 format)\n- startChangeId: string (int64 format)", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about_get.txt"}
{"question": "about.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "about.get 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about_get.txt"}
{"question": "about.get 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "about.get 메서드를 호출하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_about_get.txt"}
{"question": "어떻게 사용자의 설치된 앱 목록을 가져올 수 있나요?", "answer": "사용자의 설치된 앱 목록을 가져오려면 `apps.list` 메서드를 사용합니다. 이 메서드는 사용자가 설치한 앱의 ID와 기타 세부정보를 포함한 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps.txt"}
{"question": "특정 앱의 세부정보를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "특정 앱의 세부정보를 가져오려면 `apps.get` 메서드를 사용해야 합니다. 이 메서드를 호출할 때는 `appId`가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps.txt"}
{"question": "앱 리소스의 JSON 표현에서 'primaryMimeTypes' 필드는 무엇을 의미하나요?", "answer": "'primaryMimeTypes' 필드는 앱이 지원하는 기본 MIME 유형의 목록을 포함합니다. 이 목록은 문자열 배열로 표현됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps.txt"}
{"question": "앱이 새 객체 생성을 지원하는지 여부는 어떤 필드에서 확인할 수 있나요?", "answer": "앱이 새 객체 생성을 지원하는지 여부는 `supportsCreate` 필드에서 확인할 수 있습니다. 이 필드는 boolean 값으로, 앱이 새 객체 생성을 지원하면 true, 그렇지 않으면 false입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps.txt"}
{"question": "앱의 아이콘 정보는 어떻게 구성되어 있나요?", "answer": "앱의 아이콘 정보는 `icons` 필드에 포함되어 있으며, 이 필드는 아이콘의 크기(`size`), 카테고리(`category`), 아이콘 URL(`iconUrl`)을 포함하는 객체 배열로 구성됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps.txt"}
{"question": "특정 앱의 정보를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 앱을 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/drive/v2/apps/{appId}\n```\n여기서 `{appId}`는 가져오고자 하는 앱의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_get.txt"}
{"question": "앱 정보를 요청할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "앱 정보를 요청할 때 요청 본문은 비어 있어야 합니다. 즉, 요청 본문을 포함하지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_get.txt"}
{"question": "앱 정보를 가져오기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "앱 정보를 가져오기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.apps.readonly\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_get.txt"}
{"question": "성공적인 요청 후 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공적인 요청 후 응답 본문에는 App의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_get.txt"}
{"question": "gRPC 트랜스코딩 문법이란 무엇인가요?", "answer": "gRPC 트랜스코딩 문법은 HTTP 요청을 gRPC 호출로 변환하는 방법을 정의하는 문법입니다. 이 문서에서는 특정 앱을 가져오기 위한 HTTP 요청을 gRPC 트랜스코딩 문법을 사용하여 설명하고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_get.txt"}
{"question": "사용자의 설치된 앱을 나열하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "사용자의 설치된 앱을 나열하기 위해 다음의 HTTP 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/drive/v2/apps\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_list.txt"}
{"question": "앱 필터링을 위해 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "앱 필터링을 위해 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `appFilterExtensions`: 열기 필터링을 위한 파일 확장자의 쉼표로 구분된 목록입니다.\n- `appFilterMimeTypes`: 열기 필터링을 위한 MIME 유형의 쉼표로 구분된 목록입니다.\n- `languageCode`: BCP 47에 정의된 언어 또는 언어 코드입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_list.txt"}
{"question": "응답 본문에서 'items' 필드는 어떤 정보를 포함하나요?", "answer": "'items' 필드는 사용자가 설치했거나 Google Drive에 액세스 권한을 부여한 서드 파티 애플리케이션 목록을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_list.txt"}
{"question": "성공적인 응답 본문의 구조는 어떻게 되나요?", "answer": "성공적인 응답 본문의 구조는 다음과 같습니다:\n\n```json\n{\n  \"defaultAppIds\": [\n    string\n  ],\n  \"items\": [\n    {\n      object (App)\n    }\n  ],\n  \"etag\": string,\n  \"kind\": string,\n  \"selfLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_list.txt"}
{"question": "이 API를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "이 API를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n```\nhttps://www.googleapis.com/auth/drive.apps.readonly\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_apps_list.txt"}
{"question": "changes.list 메서드를 사용하여 사용자 또는 공유 드라이브의 변경사항을 나열하는 방법은 무엇인가요?", "answer": "changes.list 메서드를 사용하여 사용자 또는 공유 드라이브의 변경사항을 나열할 수 있습니다. 이 메서드는 변경사항 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes.txt"}
{"question": "changes.getStartPageToken 메서드는 어떤 용도로 사용되나요?", "answer": "changes.getStartPageToken 메서드는 향후 변경사항을 나열하기 위한 시작 pageToken을 가져오는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes.txt"}
{"question": "변경사항의 JSON 표현에서 'file' 필드는 어떤 정보를 포함하나요?", "answer": "변경사항의 JSON 표현에서 'file' 필드는 업데이트된 파일 상태를 포함합니다. 이 필드는 유형이 파일이고 이 변경사항 목록에서 파일이 삭제되지 않은 경우에 표시됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes.txt"}
{"question": "변경사항의 'changeType' 필드는 어떤 값을 가질 수 있나요?", "answer": "'changeType' 필드는 변경 유형을 나타내며, 가능한 값은 'file' 및 'drive'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes.txt"}
{"question": "changes.get 메서드는 현재 어떤 상태인가요?", "answer": "changes.get 메서드는 지원 중단되었습니다. 대신 changes.getStartPageToken 및 changes.list를 사용하여 최근 변경사항을 가져와야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes.txt"}
{"question": "changes.get 메서드를 호출할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "changes.get 메서드를 호출할 때 필요한 경로 매개변수는 changeId입니다. 이는 변경의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_get.txt"}
{"question": "changes.get 메서드의 요청 본문은 어떤 형식이어야 하나요?", "answer": "changes.get 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_get.txt"}
{"question": "changes.get 메서드를 호출할 때 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "changes.get 메서드를 호출할 때 사용할 수 있는 쿼리 매개변수는 driveId, supportsAllDrives, supportsTeamDrives입니다. 단, supportsTeamDrives는 지원 중단되었으므로 대신 supportsAllDrives를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_get.txt"}
{"question": "changes.get 메서드의 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "changes.get 메서드의 성공적인 응답 본문에는 Change의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_get.txt"}
{"question": "changes.get 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "changes.get 메서드를 사용하기 위해 필요한 OAuth 범위는 다음 중 하나입니다: https://www.googleapis.com/auth/docs, https://www.googleapis.com/auth/drive, https://www.googleapis.com/auth/drive.appdata, https://www.googleapis.com/auth/drive.apps.readonly, https://www.googleapis.com/auth/drive.file, https://www.googleapis.com/auth/drive.meet.readonly, https://www.googleapis.com/auth/drive.metadata, https://www.googleapis.com/auth/drive.metadata.readonly, https://www.googleapis.com/auth/drive.photos.readonly, https://www.googleapis.com/auth/drive.readonly. 일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_get.txt"}
{"question": "changes.getStartPageToken 메서드를 호출할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "HTTP 요청 형식은 다음과 같습니다.\n\n```\nGET https://www.googleapis.com/drive/v2/changes/startPageToken\n```\nURL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "다음과 같은 쿼리 매개변수를 사용할 수 있습니다:\n- `driveId`: 해당 공유 드라이브의 ID입니다.\n- `supportsAllDrives`: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- `supportsTeamDrives`: 지원 중단됨, 대신 `supportsAllDrives`를 사용하세요.\n- `teamDriveId`: 지원 중단됨, 대신 `driveId`를 사용하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드의 성공적인 응답 본문 구조는 어떻게 되나요?", "answer": "성공한 경우 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```\n{\n  \"startPageToken\": string,\n  \"kind\": string\n}\n```\n- `startPageToken`: 등록정보 변경의 시작 페이지 토큰입니다.\n- `kind`: 리소스 종류를 식별합니다. 값: 고정 문자열 \"drive#startPageToken\".", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/docs`\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.appdata`\n- `https://www.googleapis.com/auth/drive.apps.readonly`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.metadata`\n- `https://www.googleapis.com/auth/drive.metadata.readonly`\n- `https://www.googleapis.com/auth/drive.photos.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_getStartPageToken.txt"}
{"question": "changes.list 메서드를 사용하여 변경사항을 요청할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://www.googleapis.com/drive/v2/changes\n```\nURL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드에서 'includeDeleted' 쿼리 매개변수의 역할은 무엇인가요?", "answer": "'includeDeleted' 매개변수는 삭제 또는 액세스 권한 손실과 같은 변경사항 목록에서 항목이 삭제되었음을 나타내는 변경사항을 포함할지 여부를 결정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```\n{\n  \"items\": [\n    {\n      object (Change)\n    }\n  ],\n  \"largestChangeId\": string,\n  \"nextPageToken\": string,\n  \"kind\": string,\n  \"etag\": string,\n  \"newStartPageToken\": string,\n  \"selfLink\": string,\n  \"nextLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드에서 'maxResults' 쿼리 매개변수는 어떤 용도로 사용되나요?", "answer": "'maxResults' 매개변수는 반환할 최대 변경사항 수를 지정하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.apps.readonly\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드에서 'supportsAllDrives' 필드는 어떤 역할을 하나요?", "answer": "'supportsAllDrives' 필드(필드명: supportsAllDrives)는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문에서 'largestChangeId' 필드는 무엇을 의미하나요?", "answer": "'largestChangeId' 필드(필드명: largestChangeId)는 현재 가장 큰 변경 ID를 나타내며, 응답 본문 구조에서 다음과 같이 포함됩니다: \n```json\n{\n  \"items\": [\n    {\n      object (Change)\n    }\n  ],\n  \"largestChangeId\": string,\n  \"nextPageToken\": string,\n  \"kind\": string,\n  \"etag\": string,\n  \"newStartPageToken\": string,\n  \"selfLink\": string,\n  \"nextLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문에서 'nextPageToken' 필드는 어떤 용도로 사용되나요?", "answer": "'nextPageToken' 필드(필드명: nextPageToken)는 변경사항의 다음 페이지를 위한 페이지 토큰을 나타내며, 변경사항 목록의 끝에 도달한 경우 이 값이 없습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문에서 'kind' 필드는 어떤 값을 가지나요?", "answer": "'kind' 필드(필드명: kind)는 항상 'drive#changeList'라는 값을 가지며, 응답 본문 구조에서 다음과 같이 포함됩니다: \n```json\n{\n  \"items\": [\n    {\n      object (Change)\n    }\n  ],\n  \"largestChangeId\": string,\n  \"nextPageToken\": string,\n  \"kind\": string,\n  \"etag\": string,\n  \"newStartPageToken\": string,\n  \"selfLink\": string,\n  \"nextLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.list 메서드를 사용할 때 'includePermissionsForView' 쿼리 매개변수는 어떤 값을 지원하나요?", "answer": "'includePermissionsForView' 쿼리 매개변수는 응답에 포함할 추가 뷰의 권한을 지정하며, 'published'만 지원됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_list.txt"}
{"question": "changes.watch 메서드를 사용하여 변경사항을 구독할 때 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "HTTP 요청은 다음과 같은 형식을 가집니다:\n\n```\nPOST https://www.googleapis.com/drive/v2/changes/watch\n```\nURL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_watch.txt"}
{"question": "changes.watch 메서드에서 사용할 수 있는 쿼리 매개변수 중 'includeCorpusRemovals'의 역할은 무엇인가요?", "answer": "'includeCorpusRemovals'는 파일이 변경 목록에서 삭제되었고 이 파일에 대한 추가 변경 항목이 없더라도 요청 시 사용자가 파일에 계속 액세스할 수 있는 경우 변경사항에 파일 리소스를 포함해야 하는지 여부를 나타내는 boolean 값입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_watch.txt"}
{"question": "changes.watch 메서드의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 Channel의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_watch.txt"}
{"question": "changes.watch 메서드를 호출할 때 'maxResults' 파라미터는 어떤 용도로 사용되나요?", "answer": "'maxResults'는 반환할 최대 변경사항 수를 지정하는 integer 값입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_watch.txt"}
{"question": "changes.watch 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.apps.readonly\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_changes_watch.txt"}
{"question": "라벨의 ID는 어떻게 확인하나요?", "answer": "라벨의 ID는 라벨 객체의 'id' 필드(string)에서 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Label.txt"}
{"question": "라벨의 버전 ID는 어떤 필드에서 찾을 수 있나요?", "answer": "라벨의 버전 ID는 라벨 객체의 'revisionId' 필드(string)에서 찾을 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Label.txt"}
{"question": "라벨 필드의 표현은 어떻게 구성되나요?", "answer": "라벨 필드는 'fields' 필드(map)로 구성되며, 필드의 ID를 키로 사용하여 'key': value 쌍 목록을 포함하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Label.txt"}
{"question": "라벨 필드의 유형은 어떤 값들이 있나요?", "answer": "라벨 필드의 'valueType' 필드는 현재 'dateString', 'integer', 'selection', 'text', 'user'의 값만 허용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Label.txt"}
{"question": "라벨 필드의 JSON 표현은 어떻게 되나요?", "answer": "라벨 필드의 JSON 표현은 다음과 같습니다:\n```json\n{\n  \"dateString\": [\n    string\n  ],\n  \"integer\": [\n    string\n  ],\n  \"selection\": [\n    string\n  ],\n  \"text\": [\n    string\n  ],\n  \"user\": [\n    {\n      object (User)\n    }\n  ],\n  \"kind\": string,\n  \"id\": string,\n  \"valueType\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Label.txt"}
{"question": "ModifiedDateBehavior의 'fromBody' 옵션은 어떤 기능을 제공하나요?", "answer": "'fromBody'는 modifiedDate를 요청 본문에 제공된 값으로 설정합니다. 값이 제공되지 않은 경우 변경되지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/ModifiedDateBehavior?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_ModifiedDateBehavior.txt"}
{"question": "'fromBodyIfNeeded' 옵션은 어떤 상황에서 사용되며, 그 기능은 무엇인가요?", "answer": "'fromBodyIfNeeded'는 업데이트의 다른 콘텐츠에 따라 modifiedDate를 요청 본문에 제공된 값으로 설정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/ModifiedDateBehavior?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_ModifiedDateBehavior.txt"}
{"question": "'fromBodyOrNow' 옵션을 사용하면 modifiedDate가 어떻게 설정되나요?", "answer": "'fromBodyOrNow'는 modifiedDate를 요청 본문에 제공된 값으로 설정하거나 값이 제공되지 않은 경우 현재 시간으로 설정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/ModifiedDateBehavior?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_ModifiedDateBehavior.txt"}
{"question": "'noChange' 옵션을 선택하면 modifiedDate는 어떻게 되나요?", "answer": "'noChange'는 이전 modifiedDate 값을 유지합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/ModifiedDateBehavior?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_ModifiedDateBehavior.txt"}
{"question": "'nowIfNeeded' 옵션은 어떤 조건에서 modifiedDate를 설정하나요?", "answer": "'nowIfNeeded'는 업데이트 내용에 따라 modifiedDate를 현재 시간으로 설정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/ModifiedDateBehavior?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_ModifiedDateBehavior.txt"}
{"question": "Projection 열거형의 BASIC과 FULL 값은 어떤 의미인가요?", "answer": "Projection 열거형(Projection enum)에서 BASIC은 지원 중단되었고, FULL 또한 지원 중단되었습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Projection?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Projection.txt"}
{"question": "Projection 열거형의 현재 지원 상태는 어떻게 되나요?", "answer": "현재 Projection 열거형(Projection enum)의 BASIC과 FULL 값은 모두 지원 중단되었습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Projection?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Projection.txt"}
{"question": "Projection 열거형에서 지원 중단된 값은 무엇인가요?", "answer": "Projection 열거형(Projection enum)에서 지원 중단된 값은 BASIC과 FULL입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Projection?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Projection.txt"}
{"question": "Projection 열거형의 사용 시 주의해야 할 점은 무엇인가요?", "answer": "Projection 열거형(Projection enum)의 BASIC과 FULL 값은 모두 지원 중단되었으므로, 이 값을 사용하지 않도록 주의해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Projection?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Projection.txt"}
{"question": "Projection 열거형의 지원 중단에 따른 대체 방법은 무엇인가요?", "answer": "현재 문서에서는 Projection 열거형(Projection enum)의 지원 중단에 따른 대체 방법에 대한 정보는 제공되지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Projection?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Projection.txt"}
{"question": "User 리소스의 JSON 표현에서 displayName 필드는 어떤 정보를 담고 있나요?", "answer": "displayName 필드(string)는 이 사용자의 표시 가능한 일반 텍스트 이름을 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_User.txt"}
{"question": "User 리소스의 kind 필드는 어떤 값을 가지며, 그 의미는 무엇인가요?", "answer": "kind 필드(string)는 리소스 종류를 식별하며, 고정 문자열인 'drive#user' 값을 가집니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_User.txt"}
{"question": "isAuthenticatedUser 필드는 어떤 정보를 제공하나요?", "answer": "isAuthenticatedUser 필드(boolean)는 이 사용자가 요청이 이루어진 인증된 사용자와 동일한지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_User.txt"}
{"question": "permissionId 필드는 어떤 용도로 사용되며, 어떤 정보를 포함하나요?", "answer": "permissionId 필드(string)는 권한 리소스에 표시되는 사용자의 ID를 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_User.txt"}
{"question": "User 리소스의 picture 필드는 어떤 정보를 포함하고 있나요?", "answer": "picture 필드(object)는 사용자의 프로필 사진에 대한 정보를 포함하며, picture.url(string) 필드는 이 사용자의 프로필 사진을 가리키는 URL을 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_User.txt"}
{"question": "Visibility 열거형에서 DEFAULT의 의미는 무엇인가요?", "answer": "DEFAULT는 새 파일의 공개 상태가 사용자의 기본 공개 상태/공유 정책에 따라 결정된다는 것을 의미합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Visibility?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Visibility.txt"}
{"question": "Visibility 열거형에서 PRIVATE의 의미는 무엇인가요?", "answer": "PRIVATE은 새 파일이 소유자에게만 표시된다는 것을 의미합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Visibility?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Visibility.txt"}
{"question": "Visibility 열거형의 사용 사례는 어떤 것이 있나요?", "answer": "Visibility 열거형은 파일의 공개 상태를 설정할 때 사용되며, 사용자의 기본 공개 상태에 따라 파일의 접근성을 조정할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Visibility?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Visibility.txt"}
{"question": "Visibility 열거형을 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "Visibility 열거형을 사용할 때는 사용자의 기본 공개 상태/공유 정책을 이해하고, 파일의 접근성을 적절히 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Visibility?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Visibility.txt"}
{"question": "Visibility 열거형의 값은 어떤 것이 있나요?", "answer": "Visibility 열거형의 값으로는 DEFAULT와 PRIVATE이 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v2/Visibility?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v2_Visibility.txt"}
{"question": "Google Drive API에서 사용자의 설치된 앱을 나열하려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자의 설치된 앱을 나열하려면 `list` 메서드(메서드: list)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nGET /drive/v3/apps\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "특정 앱의 정보를 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "특정 앱의 정보를 가져오려면 `get` 메서드(메서드: get)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nGET /drive/v3/apps/{appId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "파일의 댓글을 나열하는 API 요청은 어떻게 하나요?", "answer": "파일의 댓글을 나열하려면 `list` 메서드(메서드: list)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nGET /drive/v3/files/{fileId}/comments\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "댓글을 삭제하는 방법은 무엇인가요?", "answer": "댓글을 삭제하려면 `delete` 메서드(메서드: delete)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nDELETE /drive/v3/files/{fileId}/comments/{commentId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "AccessProposal을 ID로 검색하는 API 요청은 어떻게 하나요?", "answer": "AccessProposal을 ID로 검색하려면 `get` 메서드(메서드: get)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nGET /drive/v3/files/{fileId}/accessproposals/{proposalId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "AccessProposal을 ID로 검색하는 API 요청은 어떻게 하나요?", "answer": "AccessProposal을 ID로 검색하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/files/{fileId}/accessproposals/{proposalId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{proposalId}`는 검색할 AccessProposal의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "파일의 AccessProposals를 나열하는 API 요청은 어떻게 하나요?", "answer": "파일의 AccessProposals를 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/files/{fileId}/accessproposals\n```\n여기서 `{fileId}`는 AccessProposals를 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "AccessProposal을 승인하거나 거부하는 API 요청은 어떻게 하나요?", "answer": "AccessProposal을 승인하거나 거부하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v3/files/{fileId}/accessproposals/{proposalId}:resolve\n```\n여기서 `{fileId}`는 파일의 ID이고, `{proposalId}`는 승인 또는 거부할 AccessProposal의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "특정 앱의 정보를 가져오는 API 요청은 어떻게 하나요?", "answer": "특정 앱의 정보를 가져오려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/apps/{appId}\n```\n여기서 `{appId}`는 가져올 앱의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "사용자의 공유 드라이브를 나열하는 API 요청은 어떻게 하나요?", "answer": "사용자의 공유 드라이브를 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/drives\n```\n이 요청은 사용자가 소속된 모든 공유 드라이브의 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 댓글을 업데이트하려면 어떤 메서드를 사용해야 하나요?", "answer": "댓글을 업데이트하려면 PATCH 메서드인 /drive/v3/files/{fileId}/comments/{commentId}를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "특정 파일의 댓글을 가져오는 API 요청은 어떻게 하나요?", "answer": "특정 파일의 댓글을 가져오려면 GET 메서드인 /drive/v3/files/{fileId}/comments/{commentId}를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 공유 드라이브를 생성하는 방법은 무엇인가요?", "answer": "공유 드라이브를 생성하려면 POST 메서드인 /drive/v3/drives를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "사용자가 소유한 파일을 영구적으로 삭제하는 API 요청은 어떻게 하나요?", "answer": "사용자가 소유한 파일을 영구적으로 삭제하려면 DELETE 메서드인 /drive/v3/files/{fileId}를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 파일의 콘텐츠를 다운로드하는 방법은 무엇인가요?", "answer": "파일의 콘텐츠를 다운로드하려면 POST 메서드인 /drive/v3/files/{fileId}/download를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 파일의 콘텐츠를 다운로드하려면 어떤 메서드를 사용해야 하나요?", "answer": "파일의 콘텐츠를 다운로드하려면 `download` 메서드(POST /drive/v3/files/{fileId}/download)를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "사용자의 휴지통에 있는 모든 파일을 영구적으로 삭제하는 API 요청은 어떻게 하나요?", "answer": "사용자의 휴지통에 있는 모든 파일을 영구적으로 삭제하려면 `emptyTrash` 메서드(DELETE /drive/v3/files/trash)를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Workspace 문서를 요청된 MIME 유형으로 내보내는 API 요청은 어떻게 하나요?", "answer": "Google Workspace 문서를 요청된 MIME 유형으로 내보내려면 `export` 메서드(GET /drive/v3/files/{fileId}/export)를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "파일의 메타데이터 또는 콘텐츠를 업데이트하는 API 요청은 어떻게 하나요?", "answer": "파일의 메타데이터 또는 콘텐츠를 업데이트하려면 `update` 메서드(PATCH /drive/v3/files/{fileId})를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "장기 실행 작업의 최신 상태를 가져오는 API 요청은 어떻게 하나요?", "answer": "장기 실행 작업의 최신 상태를 가져오려면 `get` 메서드(GET /drive/v3/operations/{name})를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 파일의 권한을 나열하는 요청은 어떻게 하나요?", "answer": "파일 또는 공유 드라이브의 권한을 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/files/{fileId}/permissions\n```\n여기서 `{fileId}`는 권한을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 특정 권한을 삭제하는 방법은 무엇인가요?", "answer": "특정 권한을 삭제하려면 다음과 같은 DELETE 요청을 사용합니다:\n\n```\nDELETE /drive/v3/files/{fileId}/permissions/{permissionId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{permissionId}`는 삭제할 권한의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 댓글에 대한 답글을 생성하는 요청은 어떻게 하나요?", "answer": "댓글에 대한 답글을 생성하려면 다음과 같은 POST 요청을 사용합니다:\n\n```\nPOST /drive/v3/files/{fileId}/comments/{commentId}/replies\n```\n여기서 `{fileId}`는 댓글이 있는 파일의 ID이고, `{commentId}`는 답글을 추가할 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 특정 답글을 삭제하는 방법은 무엇인가요?", "answer": "특정 답글을 삭제하려면 다음과 같은 DELETE 요청을 사용합니다:\n\n```\nDELETE /drive/v3/files/{fileId}/comments/{commentId}/replies/{replyId}\n```\n여기서 `{fileId}`는 답글이 있는 파일의 ID이고, `{commentId}`는 답글이 속한 댓글의 ID이며, `{replyId}`는 삭제할 답글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive API에서 파일의 수정사항을 나열하는 요청은 어떻게 하나요?", "answer": "파일의 업데이트를 나열하려면 다음과 같은 GET 요청을 사용합니다:\n\n```\nGET /drive/v3/files/{fileId}/revisions\n```\n여기서 `{fileId}`는 수정사항을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3.txt"}
{"question": "Google Drive에서 지원되는 테마 목록을 가져오려면 어떤 메서드를 사용해야 하나요?", "answer": "Google Drive에서 지원되는 테마 목록을 가져오려면 `get` 메서드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "사용자의 스토리지 할당량 정보를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "사용자의 스토리지 할당량 정보를 확인하려면 `storageQuota` 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 최대 업로드 크기를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "Google Drive에서 최대 업로드 크기를 확인하려면 `maxUploadSize` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 지원되는 가져오기 형식은 어떻게 확인하나요?", "answer": "Google Drive에서 지원되는 가져오기 형식은 `importFormats` 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "사용자가 공유 드라이브를 만들 수 있는지 여부는 어떤 필드에서 확인하나요?", "answer": "사용자가 공유 드라이브를 만들 수 있는지 여부는 `canCreateDrives` 필드에서 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 사용자의 스토리지 할당량 정보를 가져오려면 어떤 필드를 사용해야 하나요?", "answer": "사용자의 스토리지 할당량 정보를 가져오려면 'storageQuota' 객체를 사용해야 합니다. 이 객체는 사용자의 스토리지 할당량 한도 및 사용량에 대한 정보를 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 최대 업로드 크기를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "최대 업로드 크기를 확인하려면 'maxUploadSize' 필드를 참조해야 합니다. 이 필드는 최대 업로드 크기(바이트)를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "사용자가 공유 드라이브를 만들 수 있는지 여부는 어떤 필드에서 확인하나요?", "answer": "사용자가 공유 드라이브를 만들 수 있는지 여부는 'canCreateDrives' 필드에서 확인할 수 있습니다. 이 필드는 boolean 값으로 사용자의 권한을 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 사용자의 모든 서비스의 총 사용량을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "사용자의 모든 서비스의 총 사용량을 확인하려면 'storageQuota.usage' 필드를 사용해야 합니다. 이 필드는 모든 서비스의 총 사용량을 바이트 단위로 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "Google Drive에서 사용자의 Drive에 있는 모든 파일의 사용량을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "사용자의 Drive에 있는 모든 파일의 사용량을 확인하려면 'storageQuota.usageInDrive' 필드를 참조해야 합니다. 이 필드는 Google Drive의 모든 파일의 사용량을 바이트 단위로 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about.txt"}
{"question": "about.get 메서드를 사용하여 사용자 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "GET https://www.googleapis.com/drive/v3/about", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about_get.txt"}
{"question": "about.get 메서드를 호출할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about_get.txt"}
{"question": "about.get 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다.\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about_get.txt"}
{"question": "about.get 메서드의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에 About의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about_get.txt"}
{"question": "about.get 메서드를 사용할 때 필수로 설정해야 하는 매개변수는 무엇인가요?", "answer": "필수: fields 매개변수를 설정해야 합니다. 필요한 필드를 정확하게 반환하려면 특정 필드 반환을 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/about/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_about_get.txt"}
{"question": "AccessProposal 리소스의 JSON 표현에서 'createTime' 필드는 어떤 형식으로 되어 있나요?", "answer": "'createTime' 필드는 생성 시간을 나타내며, 항상 Z-정규화되고 소수점 이하 0, 3, 6 또는 9자리인 RFC 3339 형식을 사용합니다. 예를 들면 다음과 같습니다: \"2014-10-02T15:01:23Z\", \"2014-10-02T15:01:23.045123456Z\" 또는 \"2014-10-02T15:01:23+05:30\"입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals.txt"}
{"question": "AccessProposal 리소스에서 'rolesAndViews' 필드는 어떤 정보를 포함하나요?", "answer": "'rolesAndViews' 필드는 액세스 제안서의 역할 및 뷰를 위한 래퍼로, 'role'과 'view'를 포함하는 객체 배열입니다. 'role'은 요청자가 제안한 역할을 나타내며, 현재 지원되는 값은 * writer, * commenter, * reader입니다. 'view'는 이 액세스 제안서의 뷰를 나타내며, 유일하게 지원되는 값은 published입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals.txt"}
{"question": "AccessProposal 리소스의 'requesterEmailAddress' 필드는 어떤 정보를 담고 있나요?", "answer": "'requesterEmailAddress' 필드는 요청한 사용자의 이메일 주소를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals.txt"}
{"question": "AccessProposal 리소스의 'fileId' 필드는 무엇을 나타내나요?", "answer": "'fileId' 필드는 액세스 제안이 있는 파일의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals.txt"}
{"question": "AccessProposal 리소스의 'proposalId' 필드는 어떤 역할을 하나요?", "answer": "'proposalId' 필드는 액세스 제안의 ID를 나타내며, 각 액세스 제안을 고유하게 식별하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals.txt"}
{"question": "AccessProposal을 검색하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "AccessProposal을 검색하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/accessproposals/{proposalId}\n```\n여기서 `{fileId}`는 요청이 있는 항목의 ID이고, `{proposalId}`는 해결할 액세스 제안의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_get.txt"}
{"question": "AccessProposal을 검색할 때 필요한 경로 매개변수는 무엇인가요?", "answer": "AccessProposal을 검색할 때 필요한 경로 매개변수는 다음과 같습니다:\n- `fileId`: 요청이 있는 항목의 ID (string, 필수)\n- `proposalId`: 해결할 액세스 제안의 ID (string, 필수)", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_get.txt"}
{"question": "AccessProposal을 검색할 때 요청 본문은 어떻게 구성하나요?", "answer": "AccessProposal을 검색할 때 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_get.txt"}
{"question": "AccessProposal을 성공적으로 검색했을 때 응답 본문에는 어떤 정보가 포함되나요?", "answer": "AccessProposal을 성공적으로 검색했을 경우, 응답 본문에는 AccessProposal의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_get.txt"}
{"question": "AccessProposal을 검색하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "AccessProposal을 검색하기 위해 필요한 OAuth 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/docs`\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.metadata`\n- `https://www.googleapis.com/auth/drive.metadata.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_get.txt"}
{"question": "accessproposals.list 메서드를 사용하여 특정 파일의 AccessProposals를 나열하려면 어떤 HTTP 요청을 보내야 하나요?", "answer": "다음과 같은 HTTP GET 요청을 보내야 합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/accessproposals\n```\n여기서 {fileId}는 요청이 있는 항목의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_list.txt"}
{"question": "accessproposals.list 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_list.txt"}
{"question": "accessproposals.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```\n{\n  \"accessProposals\": [\n    {\n      object (AccessProposal)\n    }\n  ],\n  \"nextPageToken\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_list.txt"}
{"question": "accessproposals.list 메서드를 호출할 때 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_list.txt"}
{"question": "accessproposals.list 메서드에서 페이지네이션을 처리하는 방법은 무엇인가요?", "answer": "응답 본문에서 `nextPageToken` 필드를 사용하여 결과의 다음 페이지에 대한 연속 토큰을 확인할 수 있습니다. 결과 목록의 끝에 도달한 경우에는 이 속성이 없습니다. 어떤 이유로든 토큰이 거부되면 토큰을 삭제하고 결과의 첫 번째 페이지에서 페이지로 나누기를 다시 시작해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_list.txt"}
{"question": "액세스 제안서를 승인하기 위해 필요한 요청 본문의 구조는 무엇인가요?", "answer": "요청 본문에는 다음과 같은 구조의 데이터가 포함됩니다.\n```json\n{\n  \"role\": [\n    string\n  ],\n  \"view\": string,\n  \"action\": enum (Action),\n  \"sendNotification\": boolean\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/resolve?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_resolve.txt"}
{"question": "액세스 제안서를 거부할 때 요청 본문에서 어떤 필드를 설정해야 하나요?", "answer": "액세스 제안서를 거부할 때는 필수로 설정해야 하는 필드는 없습니다. 그러나 요청 본문에 'action' 필드를 'DENY'로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/resolve?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_resolve.txt"}
{"question": "액세스 제안서를 승인할 때 'role' 필드는 어떤 경우에 필요하나요?", "answer": "'role' 필드는 'ACCEPT' 작업을 사용하는 경우에 필요합니다. 이 필드에는 승인자가 허용한 역할이 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/resolve?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_resolve.txt"}
{"question": "액세스 제안서를 처리하기 위한 HTTP 요청의 경로는 어떻게 되나요?", "answer": "HTTP 요청의 경로는 다음과 같습니다.\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/accessproposals/{proposalId}:resolve\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/resolve?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_resolve.txt"}
{"question": "액세스 제안서를 처리한 후 성공적인 응답 본문은 어떤 형태인가요?", "answer": "성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals/resolve?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_accessproposals_resolve.txt"}
{"question": "apps.list 메서드를 사용하여 설치된 앱의 ID를 어떻게 가져오나요?", "answer": "apps.list 메서드를 호출하면 사용자의 설치된 앱 목록과 각 앱의 ID를 포함한 정보를 가져올 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps.txt"}
{"question": "앱의 기본 MIME 유형(primaryMimeTypes)과 보조 MIME 유형(secondaryMimeTypes)은 무엇인가요?", "answer": "앱의 기본 MIME 유형(primaryMimeTypes)과 보조 MIME 유형(secondaryMimeTypes)은 해당 앱이 지원하는 파일 형식을 나타내며, 각각의 배열로 제공됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps.txt"}
{"question": "앱이 사용자의 Drive에 있는 데이터에 액세스할 수 있는지 여부는 어떻게 확인하나요?", "answer": "앱의 authorized 필드를 확인하면 해당 앱이 사용자의 Drive에 있는 데이터에 액세스할 수 있는지 여부를 알 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps.txt"}
{"question": "앱의 아이콘 정보는 어떻게 구성되어 있나요?", "answer": "앱의 아이콘 정보는 아이콘의 크기(size), 카테고리(category), 아이콘 URL(iconUrl)로 구성된 객체 배열로 제공됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps.txt"}
{"question": "앱이 두 개 이상의 파일 열기를 지원하는지 여부는 어떤 필드로 확인하나요?", "answer": "앱이 두 개 이상의 파일 열기를 지원하는지 여부는 supportsMultiOpen 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps.txt"}
{"question": "특정 앱의 정보를 가져오기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "특정 앱의 정보를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/apps/{appId}\n```\n여기서 `{appId}`는 앱의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_get.txt"}
{"question": "앱 정보를 요청할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "앱 정보를 요청할 때 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_get.txt"}
{"question": "앱 정보를 가져오기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "앱 정보를 가져오기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.apps.readonly\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_get.txt"}
{"question": "앱 정보를 요청한 후 성공적인 응답 본문에는 어떤 내용이 포함되나요?", "answer": "앱 정보를 요청한 후 성공적인 경우 응답 본문에는 App의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_get.txt"}
{"question": "앱 정보를 가져오는 메서드에 대한 자세한 내용은 어디에서 확인할 수 있나요?", "answer": "앱 정보를 가져오는 메서드에 대한 자세한 내용은 사용자 정보 반환 가이드를 참고하세요: [사용자 정보 반환](https://developers.google.com/workspace/drive/api/guides/user-info?hl=ko).", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_get.txt"}
{"question": "사용자의 설치된 앱을 나열하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "사용자의 설치된 앱을 나열하기 위해 다음의 HTTP 요청을 사용해야 합니다.\n\n```\nGET https://www.googleapis.com/drive/v3/apps\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_list.txt"}
{"question": "apps.list 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "apps.list 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `appFilterExtensions`: 반환된 결과를 제한하는 쉼표로 구분된 파일 확장자 목록입니다.\n- `appFilterMimeTypes`: 반환된 결과를 제한하는 쉼표로 구분된 MIME 유형 목록입니다.\n- `languageCode`: BCP 47에 정의된 언어 또는 언어 코드입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_list.txt"}
{"question": "apps.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "apps.list 메서드의 응답 본문 구조는 다음과 같습니다:\n\n```json\n{\n  \"defaultAppIds\": [\n    string\n  ],\n  \"items\": [\n    {\n      object (App)\n    }\n  ],\n  \"kind\": string,\n  \"selfLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_list.txt"}
{"question": "apps.list 메서드를 호출할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "apps.list 메서드를 호출할 때 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_list.txt"}
{"question": "apps.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "apps.list 메서드를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n```\nhttps://www.googleapis.com/auth/drive.apps.readonly\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/apps/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_apps_list.txt"}
{"question": "Google Drive API에서 변경사항을 나열하기 위해 어떤 메서드를 사용해야 하나요?", "answer": "변경사항을 나열하기 위해서는 `list` 메서드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes.txt"}
{"question": "변경사항 리소스에서 'removed' 필드는 어떤 정보를 제공하나요?", "answer": "'removed' 필드는 삭제 또는 액세스 권한 상실 등으로 인해 파일 또는 공유 드라이브가 이 변경사항 목록에서 삭제되었는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes.txt"}
{"question": "변경사항 리소스의 'changeType' 필드는 어떤 값을 가질 수 있나요?", "answer": "'changeType' 필드는 변경 유형을 나타내며, 가능한 값은 'file' 및 'drive'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes.txt"}
{"question": "변경사항 리소스에서 'fileId' 필드는 어떤 정보를 담고 있나요?", "answer": "'fileId' 필드는 변경된 파일의 ID를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes.txt"}
{"question": "Google Drive API에서 향후 변경사항을 나열하기 위한 시작 pageToken을 어떻게 가져오나요?", "answer": "향후 변경사항을 나열하기 위한 시작 pageToken은 `getStartPageToken` 메서드를 사용하여 가져올 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes.txt"}
{"question": "changes.getStartPageToken 메서드를 호출하기 위한 HTTP 요청 형식은 무엇인가요?", "answer": "HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://www.googleapis.com/drive/v3/changes/startPageToken\n```\nURL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `driveId`: 해당 공유 드라이브의 ID입니다.\n- `supportsAllDrives`: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- `supportsTeamDrives`: 지원 중단됨, 대신 `supportsAllDrives`를 사용하세요.\n- `teamDriveId`: 지원 중단됨, 대신 `driveId`를 사용하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "성공한 경우 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  \"startPageToken\": string,\n  \"kind\": string\n}\n```\n- `startPageToken`: 향후 변경사항을 나열하기 위한 시작 페이지 토큰입니다.\n- `kind`: 리소스 종류를 식별합니다. 값: 고정 문자열 \"drive#startPageToken\".", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.appdata`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.metadata`\n- `https://www.googleapis.com/auth/drive.metadata.readonly`\n- `https://www.googleapis.com/auth/drive.photos.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_getStartPageToken.txt"}
{"question": "changes.getStartPageToken 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/getStartPageToken?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_getStartPageToken.txt"}
{"question": "changes.list 메서드를 사용하여 변경사항을 가져올 때, 어떤 쿼리 매개변수를 사용할 수 있나요?", "answer": "changes.list 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- driveId: 변경사항이 반환될 공유 드라이브입니다.\n- includeCorpusRemovals: 파일이 변경사항 목록에서 삭제되었고 이 파일에 대한 추가 변경사항 항목이 없더라도 요청 시 사용자가 파일에 계속 액세스할 수 있는 경우 변경사항에 파일 리소스를 포함해야 하는지 여부입니다.\n- includeItemsFromAllDrives: 내 드라이브와 공유 드라이브 항목을 모두 결과에 포함할지 여부입니다.\n- includeRemoved: 삭제 또는 액세스 권한 손실과 같은 변경사항 목록에서 항목이 삭제되었음을 나타내는 변경사항을 포함할지 여부입니다.\n- pageSize: 페이지당 반환할 최대 변경사항 수입니다.\n- pageToken: 다음 페이지에서 이전 목록 요청을 계속하기 위한 토큰입니다.\n- restrictToMyDrive: 결과를 내 드라이브 계층 구조 내의 변경사항으로 제한할지 여부입니다.\n- spaces: 코퍼스 내에서 쿼리할 공백의 쉼표로 구분된 목록입니다.\n- supportsAllDrives: 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "changes.list 메서드의 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n```json\n{\n  \"changes\": [\n    {\n      object (Change [https://developers.google.com/workspace/drive/api/reference/rest/v3/changes?hl=ko#Change])\n    }\n  ],\n  \"kind\": string,\n  \"nextPageToken\": string,\n  \"newStartPageToken\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드를 호출할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "changes.list 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "changes.list 메서드를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드에서 pageToken 파라미터는 어떤 용도로 사용되나요?", "answer": "pageToken 파라미터는 다음 페이지에서 이전 목록 요청을 계속하기 위한 토큰입니다. 이 값은 이전 응답의 'nextPageToken' 값 또는 getStartPageToken 메서드의 응답으로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드를 호출할 때, spaces 파라미터는 어떤 값을 가질 수 있나요?", "answer": "spaces 파라미터는 코퍼스 내에서 쿼리할 공백의 쉼표로 구분된 목록입니다. 지원되는 값은 'drive' 및 'appDataFolder'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문에서 kind 필드는 어떤 정보를 제공하나요?", "answer": "kind 필드는 리소스 종류를 식별합니다. 이 값은 고정 문자열 'drive#changeList'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드의 응답 본문에서 nextPageToken 필드는 어떤 용도로 사용되나요?", "answer": "nextPageToken 필드는 변경사항의 다음 페이지를 위한 페이지 토큰입니다. 변경사항 목록의 끝에 도달한 경우 이 값이 없습니다. 페이지 토큰은 만료되지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드를 사용할 때 includePermissionsForView 파라미터는 어떤 값을 지원하나요?", "answer": "includePermissionsForView 파라미터는 응답에 포함할 추가 뷰의 권한을 지정합니다. 이 파라미터는 'published'만 지원됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.list 메서드의 요청 본문은 어떻게 구성해야 하나요?", "answer": "요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_list.txt"}
{"question": "changes.watch 메서드를 사용하여 변경사항을 구독할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "변경사항을 구독하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```\nPOST https://www.googleapis.com/drive/v3/changes/watch\n```\n이 URL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_watch.txt"}
{"question": "changes.watch 메서드에서 사용할 수 있는 쿼리 매개변수 중 'driveId'의 역할은 무엇인가요?", "answer": "'driveId'는 변경사항이 반환되는 공유 드라이브를 지정하는 매개변수입니다. 지정된 경우 변경 ID는 공유 드라이브를 반영합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_watch.txt"}
{"question": "changes.watch 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 Channel의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_watch.txt"}
{"question": "changes.watch 메서드를 호출할 때 'includeItemsFromAllDrives' 매개변수의 기능은 무엇인가요?", "answer": "'includeItemsFromAllDrives' 매개변수는 검색 결과에 내 드라이브 항목과 공유 드라이브 항목을 모두 포함할지 여부를 결정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_watch.txt"}
{"question": "changes.watch 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/changes/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_changes_watch.txt"}
{"question": "채널 리소스의 JSON 표현은 어떻게 되나요?", "answer": "채널 리소스의 JSON 표현은 다음과 같습니다:\n```json\n{\n  \"params\": {\n    string: string,\n    ...\n  },\n  \"payload\": boolean,\n  \"id\": string,\n  \"resourceId\": string,\n  \"resourceUri\": string,\n  \"token\": string,\n  \"expiration\": string,\n  \"type\": string,\n  \"address\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels.txt"}
{"question": "채널 리소스에서 'params' 필드는 어떤 용도로 사용되나요?", "answer": "'params' 필드는 전송 채널 동작을 제어하는 추가 매개변수입니다. 선택사항으로, 'key': value 쌍 목록을 포함하는 객체입니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n```json\n{ \"name\": \"wrench\", \"mass\": \"1.3kg\", \"count\": \"3\" }\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels.txt"}
{"question": "채널 리소스의 'expiration' 필드는 무엇을 나타내나요?", "answer": "'expiration' 필드는 알림 채널 만료 날짜 및 시간(밀리초 단위의 Unix 타임스탬프로 표현)을 나타냅니다. 이 필드는 선택사항입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels.txt"}
{"question": "채널 리소스의 'type' 필드에 유효한 값은 무엇인가요?", "answer": "'type' 필드는 이 채널에 사용된 전송 메커니즘의 유형을 나타내며, 유효한 값은 'web_hook' 또는 'webhook'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels.txt"}
{"question": "채널 리소스를 통해 리소스 모니터링을 중지하는 방법은 무엇인가요?", "answer": "채널 리소스를 통해 리소스 모니터링을 중지하려면 'stop' 메서드를 사용합니다. 이 메서드는 다음 링크에서 확인할 수 있습니다: [stop 메서드](https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko).", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels.txt"}
{"question": "channels.stop 메서드를 사용하여 리소스 시청을 중지하는 방법은 무엇인가요?", "answer": "channels.stop 메서드를 사용하여 리소스 시청을 중지하려면, 다음과 같은 HTTP POST 요청을 보내야 합니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/channels/stop\n```\n요청 본문에는 Channel의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels_stop.txt"}
{"question": "channels.stop 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "channels.stop 메서드의 요청 본문에는 Channel의 인스턴스가 포함되어야 합니다. Channel은 리소스 변경 알림을 수신하기 위한 설정을 포함하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels_stop.txt"}
{"question": "channels.stop 메서드를 호출했을 때 성공적인 응답은 어떤 형태인가요?", "answer": "channels.stop 메서드를 성공적으로 호출하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels_stop.txt"}
{"question": "channels.stop 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "channels.stop 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/docs\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.apps\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels_stop.txt"}
{"question": "channels.stop 메서드를 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "channels.stop 메서드를 사용할 때 일부 OAuth 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다. 이에 대한 자세한 내용은 승인 가이드를 참고해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/channels/stop?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_channels_stop.txt"}
{"question": "댓글을 생성하는 메서드(create)는 어떻게 사용하나요?", "answer": "댓글을 생성하기 위해서는 comments.create 메서드를 사용합니다. 이 메서드는 파일에 댓글을 추가하는 기능을 제공합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments.txt"}
{"question": "댓글의 ID를 가져오는 방법은 무엇인가요?", "answer": "댓글의 ID는 comments.list 메서드를 사용하여 파일의 댓글 목록을 나열함으로써 가져올 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments.txt"}
{"question": "댓글을 삭제하는 메서드(delete)의 사용법은 무엇인가요?", "answer": "댓글을 삭제하기 위해서는 comments.delete 메서드를 사용합니다. 이 메서드는 특정 댓글을 삭제하는 기능을 제공합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments.txt"}
{"question": "댓글의 수정 시간을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "댓글의 수정 시간을 확인하려면 modifiedTime 필드를 참조해야 합니다. 이 필드는 댓글 또는 댓글의 답글이 마지막으로 수정된 시간을 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments.txt"}
{"question": "댓글의 작성자 정보를 어떻게 확인하나요?", "answer": "댓글의 작성자 정보를 확인하려면 author 필드를 참조해야 합니다. 이 필드는 댓글 작성자의 정보를 포함하고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments.txt"}
{"question": "댓글을 생성하기 위해 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "댓글을 생성하기 위한 HTTP 요청은 다음과 같은 형식을 가집니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/comments\n```\n여기서 `{fileId}`는 댓글을 추가할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_create.txt"}
{"question": "댓글 생성 요청 시 반드시 포함해야 하는 요청 본문의 내용은 무엇인가요?", "answer": "댓글 생성 요청 시 요청 본문에는 `Comment`의 인스턴스가 포함되어야 합니다. `Comment`의 구조에 대한 자세한 내용은 [Comment](https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko#Comment) 문서를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_create.txt"}
{"question": "댓글 생성 요청에 필요한 승인 범위는 무엇인가요?", "answer": "댓글을 생성하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_create.txt"}
{"question": "댓글 생성 요청의 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공적인 댓글 생성 요청의 응답 본문에는 새로 생성된 `Comment`의 인스턴스가 포함됩니다. 이 인스턴스는 생성된 댓글에 대한 정보를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_create.txt"}
{"question": "댓글 생성 시 필수로 설정해야 하는 매개변수는 무엇인가요?", "answer": "댓글 생성 요청 시 필수로 설정해야 하는 매개변수는 `fields`입니다. 이 매개변수를 설정하여 필요한 필드를 정확하게 반환받을 수 있습니다. 자세한 내용은 [특정 필드 반환](https://developers.google.com/workspace/drive/api/guides/fields-parameter?hl=ko) 문서를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_create.txt"}
{"question": "댓글을 삭제하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "댓글을 삭제하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{commentId}`는 삭제할 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_delete.txt"}
{"question": "댓글 삭제 요청 시 필요한 경로 매개변수는 무엇인가요?", "answer": "댓글 삭제 요청 시 필요한 경로 매개변수는 다음과 같습니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_delete.txt"}
{"question": "댓글 삭제 요청의 응답 본문은 어떻게 되나요?", "answer": "댓글 삭제 요청이 성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_delete.txt"}
{"question": "댓글을 삭제하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "댓글을 삭제하기 위해 필요한 OAuth 승인 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_delete.txt"}
{"question": "댓글 삭제 요청 시 요청 본문은 어떻게 구성하나요?", "answer": "댓글 삭제 요청 시 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_delete.txt"}
{"question": "댓글을 가져오기 위해 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "댓글을 가져오기 위한 HTTP 요청은 다음과 같습니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{commentId}`는 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_get.txt"}
{"question": "댓글을 가져올 때 필수로 설정해야 하는 매개변수는 무엇인가요?", "answer": "댓글을 가져올 때 필수로 설정해야 하는 매개변수는 `fields` 매개변수입니다. 이 매개변수를 설정하여 필요한 필드를 정확하게 반환받아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_get.txt"}
{"question": "삭제된 댓글을 포함하여 가져오려면 어떤 쿼리 매개변수를 사용해야 하나요?", "answer": "삭제된 댓글을 포함하여 가져오려면 `includeDeleted` 쿼리 매개변수를 사용해야 합니다. 이 매개변수는 boolean 타입으로, 삭제된 댓글을 반환할지 여부를 설정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_get.txt"}
{"question": "댓글을 가져오는 요청의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "댓글을 가져오는 요청이 성공하면 응답 본문에 `Comment`의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_get.txt"}
{"question": "댓글을 가져오기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "댓글을 가져오기 위해 필요한 OAuth 승인 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_get.txt"}
{"question": "comments.list 메서드를 사용하여 특정 파일의 댓글을 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/comments\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_list.txt"}
{"question": "comments.list 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "다음과 같은 쿼리 매개변수를 사용할 수 있습니다:\n- `includeDeleted`: 삭제된 댓글을 포함할지 여부입니다.\n- `pageSize`: 페이지당 반환할 최대 댓글 수입니다.\n- `pageToken`: 다음 페이지에서 이전 목록 요청을 계속하기 위한 토큰입니다.\n- `startModifiedTime`: 결과 댓글의 'modifiedTime'의 최솟값입니다 (RFC 3339 날짜/시간).", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_list.txt"}
{"question": "comments.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "성공한 경우 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```\n{\n  \"comments\": [\n    {\n      object (Comment)\n    }\n  ],\n  \"kind\": string,\n  \"nextPageToken\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_list.txt"}
{"question": "comments.list 메서드를 호출할 때 필수로 설정해야 하는 매개변수는 무엇인가요?", "answer": "필수로 설정해야 하는 매개변수는 `fields` 매개변수입니다. 필요한 정확한 필드를 반환하려면 특정 필드 반환을 참고해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_list.txt"}
{"question": "comments.list 메서드의 승인 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_list.txt"}
{"question": "comments.update 메서드를 사용하여 주석을 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "주석을 업데이트하기 위해서는 다음과 같은 HTTP 요청 형식을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}\n```\n여기서 `{fileId}`는 파일의 ID, `{commentId}`는 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_update.txt"}
{"question": "comments.update 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 Comment의 인스턴스가 포함되어야 합니다. Comment는 주석의 내용을 정의하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_update.txt"}
{"question": "comments.update 메서드를 호출할 때 필수로 설정해야 하는 매개변수는 무엇인가요?", "answer": "comments.update 메서드를 호출할 때는 필수로 `fields` 매개변수를 설정해야 합니다. 이를 통해 필요한 필드를 정확하게 반환받을 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_update.txt"}
{"question": "comments.update 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "comments.update 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_update.txt"}
{"question": "comments.update 메서드의 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공적인 응답 본문에는 Comment의 인스턴스가 포함됩니다. 이는 업데이트된 주석의 내용을 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/comments/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_comments_update.txt"}
{"question": "공유 드라이브의 ID는 어떻게 확인하나요?", "answer": "공유 드라이브의 ID는 drives.list 메서드를 사용하여 가져올 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 색상(RGB 16진수 문자열)을 설정할 수 있는 경우는 언제인가요?", "answer": "공유 드라이브의 색상(colorRgb)은 themeId을 설정하지 않는 drive.drives.update 요청에서만 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "현재 사용자가 공유 드라이브에서 파일을 수정할 수 있는지 확인하려면 어떤 필드를 확인해야 하나요?", "answer": "현재 사용자가 공유 드라이브의 파일을 수정할 수 있는지 여부는 capabilities.canEdit 필드를 확인해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브를 삭제할 수 없는 경우는 어떤 상황인가요?", "answer": "현재 사용자가 공유 드라이브를 삭제할 수 없는 경우는 공유 드라이브 내에 휴지통에 없는 항목이 있는 경우입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 배경 이미지를 변경할 수 있는 권한은 어떤 필드로 확인하나요?", "answer": "공유 드라이브의 배경을 변경할 수 있는 권한은 capabilities.canChangeDriveBackground 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 배경 이미지를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "공유 드라이브의 배경 이미지를 설정할 때는 backgroundImageFile(object) 필드를 사용해야 합니다. 이 필드는 배경 이미지가 설정된 이미지 파일 및 자르기 매개변수를 포함합니다. backgroundImageFile을 설정할 때는 모든 필드를 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 테마 ID(themeId)는 어떻게 설정하나요?", "answer": "테마 ID(themeId)는 배경 이미지와 색상이 설정될 테마의 ID입니다. 가능한 driveThemes 집합은 drive.about.get 응답에서 가져올 수 있으며, drive.drives.create 요청에 지정되지 않은 경우 배경 이미지와 색상이 설정되는 테마가 무작위로 선택됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "현재 사용자가 공유 드라이브에서 파일을 삭제할 수 있는지 확인하려면 어떤 필드를 확인해야 하나요?", "answer": "현재 사용자가 공유 드라이브에서 파일을 삭제할 수 있는지 확인하려면 capabilities.canDeleteDrive(boolean) 필드를 확인해야 합니다. 이 필드는 현재 사용자가 이 공유 드라이브를 삭제할 수 있는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 배경 이미지를 변경할 수 있는 권한은 어떤 필드로 확인하나요?", "answer": "공유 드라이브의 배경 이미지를 변경할 수 있는 권한은 capabilities.canChangeDriveBackground(boolean) 필드로 확인할 수 있습니다. 이 필드는 현재 사용자가 이 공유 드라이브의 배경을 변경할 수 있는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 하위 항목을 삭제할 수 있는지 확인하려면 어떤 필드를 확인해야 하나요?", "answer": "공유 드라이브의 하위 항목을 삭제할 수 있는지 확인하려면 capabilities.canDeleteChildren(boolean) 필드를 확인해야 합니다. 이 필드는 현재 사용자가 이 공유 드라이브의 폴더에서 하위 항목을 삭제할 수 있는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 제한을 기본값으로 재설정할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "현재 사용자가 공유 드라이브 제한을 기본값으로 재설정할 수 있는지 여부는 capabilities.canResetDriveRestrictions 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브에서 하위 항목을 삭제할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "현재 사용자가 이 공유 드라이브의 폴더에서 하위 항목을 삭제할 수 있는지 여부는 capabilities.canDeleteChildren 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 배경 이미지를 설정할 때 어떤 필드를 사용해야 하나요?", "answer": "공유 드라이브의 배경 이미지를 설정할 때는 backgroundImageFile 필드를 사용해야 하며, 이 필드는 backgroundImageFile.id, backgroundImageFile.xCoordinate, backgroundImageFile.yCoordinate, backgroundImageFile.width의 모든 필드를 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 다운로드 제한을 변경할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "현재 사용자가 이 공유 드라이브의 주최자가 적용한 다운로드 제한을 변경할 수 있는지 여부는 capabilities.canChangeDownloadRestriction 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 제한 사항을 추가하려면 어떤 절차를 따라야 하나요?", "answer": "공유 드라이브를 만들 때는 제한 사항을 설정할 수 없으며, 제한을 추가하려면 먼저 공유 드라이브를 만든 다음 drives.update를 사용하여 제한을 추가해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 배경 이미지 자르기 영역의 Y 좌표는 어떻게 설정하나요?", "answer": "배경 이미지의 자르기 영역 왼쪽 상단의 Y 좌표는 `backgroundImageFile.yCoordinate` 필드를 사용하여 설정합니다. 이 값은 0~1의 닫힌 범위에 있는 값으로, 전체 이미지의 상단에서 자르기 영역의 상단까지의 세로 거리를 전체 이미지의 높이로 나눈 값을 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 잘린 이미지의 너비는 어떻게 설정하나요?", "answer": "잘린 이미지의 너비는 `backgroundImageFile.width` 필드를 사용하여 설정합니다. 이 값은 0~1 범위의 값으로, 잘린 이미지의 너비를 전체 이미지의 너비로 나눈 값을 나타냅니다. 높이는 너비에 80:9의 너비 대 높이 가로세로 비율을 적용하여 계산됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 생성 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "공유 드라이브의 생성 시간은 `createdTime` 필드를 사용하여 확인할 수 있습니다. 이 필드는 출력 전용이며, RFC 3339 날짜-시간 형식으로 표시됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 제한 사항을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "공유 드라이브의 제한 사항은 `restrictions` 필드를 통해 확인할 수 있습니다. 이 필드는 이 공유 드라이브 또는 이 공유 드라이브 내 항목에 적용되는 제한사항 집합을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브의 다운로드 제한을 설정하려면 어떤 필드를 사용해야 하나요?", "answer": "공유 드라이브의 다운로드 제한은 `restrictions.downloadRestriction` 필드를 사용하여 설정할 수 있습니다. 이 필드는 공유 드라이브 관리자가 적용한 다운로드 제한사항을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives.txt"}
{"question": "공유 드라이브를 생성하기 위한 HTTP 요청은 어떻게 하나요?", "answer": "공유 드라이브를 생성하기 위해서는 다음과 같은 HTTP POST 요청을 사용합니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/drives\n```\n이 URL은 gRPC 트랜스코딩 구문을 사용합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_create.txt"}
{"question": "공유 드라이브 생성 시 필수로 포함해야 하는 쿼리 매개변수는 무엇인가요?", "answer": "공유 드라이브를 생성할 때 필수로 포함해야 하는 쿼리 매개변수는 `requestId`입니다. 이 매개변수는 공유 드라이브의 idempotent 생성을 위한 사용자의 요청을 고유하게 식별하는 ID로, 예를 들어 임의 UUID를 사용할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_create.txt"}
{"question": "공유 드라이브 생성 요청 시 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 `Drive`의 인스턴스가 포함되어야 합니다. `Drive`에 대한 자세한 내용은 Drive API 문서를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_create.txt"}
{"question": "공유 드라이브 생성 요청이 성공했을 때 응답 본문에는 어떤 정보가 포함되나요?", "answer": "공유 드라이브 생성 요청이 성공하면 응답 본문에 새로 생성된 `Drive`의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_create.txt"}
{"question": "공유 드라이브를 생성하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "공유 드라이브를 생성하기 위해서는 다음 OAuth 범위가 필요합니다:\n\n```\nhttps://www.googleapis.com/auth/drive\n```\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_create.txt"}
{"question": "공유 드라이브를 삭제할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "공유 드라이브를 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/drives/{driveId}\n```\n여기서 `{driveId}`는 삭제할 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_delete.txt"}
{"question": "공유 드라이브를 삭제할 때 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "공유 드라이브를 삭제할 때 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n\n- `useDomainAdminAccess` (boolean): 도메인 관리자로 요청을 실행합니다. true로 설정된 경우 요청자가 공유 드라이브가 속한 도메인의 관리자이면 액세스 권한이 부여됩니다.\n- `allowItemDeletion` (boolean): 공유 드라이브 내의 항목도 삭제해야 하는지 여부입니다. 이 옵션은 `useDomainAdminAccess`도 true로 설정된 경우에만 지원됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_delete.txt"}
{"question": "공유 드라이브를 삭제할 때 요청 본문은 어떻게 구성해야 하나요?", "answer": "공유 드라이브를 삭제할 때 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_delete.txt"}
{"question": "공유 드라이브 삭제 요청이 성공했을 때 응답 본문은 어떻게 되나요?", "answer": "공유 드라이브 삭제 요청이 성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_delete.txt"}
{"question": "공유 드라이브를 삭제하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "공유 드라이브를 삭제하기 위해 필요한 OAuth 승인 범위는 다음과 같습니다:\n\n```\nhttps://www.googleapis.com/auth/drive\n```\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_delete.txt"}
{"question": "drives.get 메서드를 사용하여 공유 드라이브의 메타데이터를 가져오는 방법은 무엇인가요?", "answer": "drives.get 메서드를 사용하여 공유 드라이브의 메타데이터를 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/drives/{driveId}\n```\n여기서 `{driveId}`는 가져오려는 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_get.txt"}
{"question": "drives.get 메서드에서 사용할 수 있는 경로 매개변수는 무엇인가요?", "answer": "drives.get 메서드에서 사용할 수 있는 경로 매개변수는 `driveId`입니다. 이 매개변수는 공유 드라이브의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_get.txt"}
{"question": "drives.get 메서드의 쿼리 매개변수로는 어떤 것이 있나요?", "answer": "drives.get 메서드의 쿼리 매개변수로는 `useDomainAdminAccess`가 있습니다. 이 매개변수를 boolean 값으로 설정하여 도메인 관리자로 요청을 실행할 수 있습니다. `true`로 설정된 경우 요청자가 공유 드라이브가 속한 도메인의 관리자이면 액세스 권한이 부여됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_get.txt"}
{"question": "drives.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "drives.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문에 아무런 데이터도 포함되지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_get.txt"}
{"question": "drives.get 메서드를 호출할 때 필요한 승인 범위는 무엇인가요?", "answer": "drives.get 메서드를 호출할 때 필요한 승인 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_get.txt"}
{"question": "공유 드라이브를 숨기기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "공유 드라이브를 숨기기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/drives/{driveId}/hide\n```\n여기서 `{driveId}`는 숨기려는 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_hide.txt"}
{"question": "공유 드라이브를 숨기기 위한 요청 본문은 어떻게 되나요?", "answer": "공유 드라이브를 숨기기 위한 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_hide.txt"}
{"question": "공유 드라이브를 숨기기 위한 요청에 필요한 승인 범위는 무엇인가요?", "answer": "공유 드라이브를 숨기기 위한 요청에는 다음 OAuth 범위가 필요합니다:\n\n```\nhttps://www.googleapis.com/auth/drive\n```\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_hide.txt"}
{"question": "공유 드라이브 숨기기 요청이 성공했을 때의 응답 본문은 어떤 형식인가요?", "answer": "공유 드라이브 숨기기 요청이 성공한 경우, 응답 본문에는 Drive의 인스턴스가 포함됩니다. 이 인스턴스는 Drive 리소스에 대한 정보를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_hide.txt"}
{"question": "공유 드라이브를 숨기기 위한 API 메서드는 무엇인가요?", "answer": "공유 드라이브를 숨기기 위한 API 메서드는 `drives.hide`입니다. 이 메서드를 사용하여 기본 보기에서 공유 드라이브를 숨길 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_hide.txt"}
{"question": "drives.list 메서드를 사용하여 공유 드라이브를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "drives.list 메서드를 사용하여 공유 드라이브를 나열하기 위해서는 다음과 같은 HTTP 요청 형식을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/drives\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_list.txt"}
{"question": "drives.list 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "drives.list 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `pageSize`: 페이지당 반환할 최대 공유 드라이브 수입니다.\n- `pageToken`: 공유 드라이브의 페이지 토큰입니다.\n- `q`: 공유 드라이브 검색을 위한 쿼리 문자열입니다.\n- `useDomainAdminAccess`: 도메인 관리자로 요청을 실행합니다. true로 설정하면 요청자가 관리자인 도메인의 모든 공유 드라이브가 반환됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_list.txt"}
{"question": "drives.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "drives.list 메서드의 응답 본문 구조는 다음과 같습니다:\n\n```json\n{\n  \"drives\": [\n    {\n      object (Drive [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives?hl=ko#Drive])\n    }\n  ],\n  \"nextPageToken\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_list.txt"}
{"question": "drives.list 메서드의 응답에서 nextPageToken이 채워져 있을 때의 의미는 무엇인가요?", "answer": "응답에서 `nextPageToken`이 채워져 있으면 이 목록이 불완전할 수 있으며 결과의 추가 페이지를 가져와야 함을 의미합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_list.txt"}
{"question": "drives.list 메서드를 호출할 때 필요한 OAuth 범위는 무엇인가요?", "answer": "drives.list 메서드를 호출하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_list.txt"}
{"question": "공유 드라이브를 복원하기 위해 어떤 HTTP 요청을 사용해야 하나요?", "answer": "공유 드라이브를 복원하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다.\n\n```http\nPOST https://www.googleapis.com/drive/v3/drives/{driveId}/unhide\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/unhide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_unhide.txt"}
{"question": "drives.unhide 메서드의 경로 매개변수로 어떤 값을 제공해야 하나요?", "answer": "drives.unhide 메서드의 경로 매개변수로는 공유 드라이브의 ID인 `driveId`를 제공해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/unhide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_unhide.txt"}
{"question": "drives.unhide 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "drives.unhide 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/unhide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_unhide.txt"}
{"question": "drives.unhide 메서드 호출 시 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 Drive의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/unhide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_unhide.txt"}
{"question": "drives.unhide 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "drives.unhide 메서드를 사용하기 위해서는 다음 OAuth 범위가 필요합니다.\n\n```\nhttps://www.googleapis.com/auth/drive\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/unhide?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_unhide.txt"}
{"question": "공유 드라이브의 메타데이터를 업데이트하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "공유 드라이브의 메타데이터를 업데이트하기 위해서는 다음과 같은 HTTP 요청을 사용합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/drives/{driveId}\n```\n여기서 `{driveId}`는 업데이트할 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_update.txt"}
{"question": "공유 드라이브 업데이트 요청 시 사용할 수 있는 쿼리 매개변수는 무엇인가요?", "answer": "공유 드라이브 업데이트 요청 시 사용할 수 있는 쿼리 매개변수는 `useDomainAdminAccess`입니다. 이 매개변수는 boolean 타입으로, 도메인 관리자로 요청을 실행할지를 결정합니다. `true`로 설정된 경우 요청자가 공유 드라이브가 속한 도메인의 관리자이면 액세스 권한이 부여됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_update.txt"}
{"question": "공유 드라이브 업데이트 요청의 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "공유 드라이브 업데이트 요청의 본문에는 `Drive`의 인스턴스가 포함되어야 합니다. `Drive`는 공유 드라이브의 메타데이터를 정의하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_update.txt"}
{"question": "공유 드라이브 업데이트 요청이 성공했을 때의 응답 본문은 어떤 형식인가요?", "answer": "공유 드라이브 업데이트 요청이 성공하면 응답 본문에 `Drive`의 인스턴스가 포함됩니다. 이 인스턴스는 업데이트된 공유 드라이브의 메타데이터를 포함하고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_update.txt"}
{"question": "공유 드라이브를 업데이트하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "공유 드라이브를 업데이트하기 위해서는 다음의 OAuth 범위가 필요합니다:\n```\nhttps://www.googleapis.com/auth/drive\n```\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_drives_update.txt"}
{"question": "파일의 메타데이터를 가져오기 위해 어떤 메서드를 사용해야 하나요?", "answer": "파일의 메타데이터를 가져오기 위해서는 `files.get` 메서드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 ID는 어떻게 확인하나요?", "answer": "파일의 ID는 `files.list` 메서드를 사용하여 검색할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 소유자 정보를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 소유자 정보를 확인하려면 `owners` 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 MIME 타입을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 MIME 타입을 확인하려면 `mimeType` 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 크기를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 크기를 확인하려면 `size` 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 상위 폴더 ID는 어떤 필드를 통해 확인할 수 있나요?", "answer": "파일의 상위 폴더 ID는 'parents' 필드를 통해 확인할 수 있습니다. 이 필드는 파일이 포함된 상위 폴더의 ID를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 소유자 정보를 확인하기 위해 어떤 필드를 사용해야 하나요?", "answer": "파일의 소유자 정보를 확인하기 위해 'owners' 필드를 사용해야 합니다. 이 필드는 이 파일의 소유자를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 권한 목록을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 권한 목록을 확인하려면 'permissions' 필드를 참조해야 합니다. 이 필드는 파일의 전체 권한 목록을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일이 포함된 스페이스 목록은 어떤 필드를 통해 확인할 수 있나요?", "answer": "파일이 포함된 스페이스 목록은 'spaces' 필드를 통해 확인할 수 있습니다. 현재 지원되는 값은 'drive', 'appDataFolder', 'photos'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 임의의 키-값 쌍 모음은 어떤 필드를 통해 확인할 수 있나요?", "answer": "'properties' 필드를 통해 파일의 임의의 키-값 쌍 모음을 확인할 수 있습니다. 이 필드는 모든 앱에 표시되는 임의의 키-값 쌍을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 SHA-1 체크섬을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 SHA-1 체크섬은 'sha1Checksum' 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 다운로드 제한 정보를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 다운로드 제한 정보는 'downloadRestrictions' 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠 액세스 제한을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 콘텐츠 액세스 제한은 'contentRestrictions' 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 전체 권한 목록을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 전체 권한 목록은 'permissions' 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 MIME 타입을 확인하기 위해 어떤 필드를 사용해야 하나요?", "answer": "파일의 MIME 타입은 'fileExtension' 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠 액세스 제한 정보를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 콘텐츠 액세스 제한 정보를 확인하려면 'contentRestrictions' 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 MD5 체크섬을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 MD5 체크섬을 확인하려면 'md5Checksum' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 썸네일 정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 썸네일 정보를 확인하려면 'contentHints.thumbnail' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 마지막 수정자를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 마지막 수정자를 확인하려면 'lastModifyingUser' 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 웹 뷰 링크를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 웹 뷰 링크를 확인하려면 'webViewLink' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 썸네일 데이터는 어떤 필드를 통해 확인할 수 있나요?", "answer": "파일의 썸네일 데이터는 `contentHints.thumbnail.image` 필드를 통해 확인할 수 있습니다. 이 필드는 URL 안전 Base64 (RFC 4648 섹션 5)로 인코딩된 썸네일 데이터입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 MIME 유형을 확인하기 위해 어떤 필드를 사용해야 하나요?", "answer": "파일의 MIME 유형은 `mimeType` 필드를 사용하여 확인할 수 있습니다. 값이 제공되지 않으면 Google Drive에서 업로드된 콘텐츠에서 적절한 값을 자동으로 감지하려고 시도합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 마지막 수정자를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 마지막 수정자는 `lastModifyingUser` 필드를 참조하여 확인할 수 있습니다. 이 필드는 파일을 마지막으로 수정한 사용자 정보를 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 웹 뷰 링크는 어떤 필드를 통해 확인할 수 있나요?", "answer": "파일의 웹 뷰 링크는 `webViewLink` 필드를 통해 확인할 수 있습니다. 이 필드는 브라우저에서 관련 Google 편집기 또는 뷰어로 파일을 여는 링크입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 크기를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 크기는 `size` 필드를 사용하여 확인할 수 있습니다. 이 필드는 blob 및 퍼스트 파티 편집기 파일의 크기를 바이트 단위로 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 생성 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 생성 시간을 확인하려면 createdTime 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 마지막 수정 시간을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 마지막 수정 시간을 확인하려면 modifiedTime 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "사용자가 파일을 마지막으로 수정한 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "사용자가 파일을 마지막으로 수정한 시간을 확인하려면 modifiedByMeTime 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일이 사용자와 공유된 시간을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일이 사용자와 공유된 시간을 확인하려면 sharedWithMeTime 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일에서 사용된 저장용량 할당량 바이트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일에서 사용된 저장용량 할당량 바이트 수를 확인하려면 quotaBytesUsed 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일이 마지막으로 수정된 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일이 마지막으로 수정된 시간을 확인하려면 modifiedTime 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "사용자가 파일을 마지막으로 본 시간을 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "사용자가 파일을 마지막으로 본 시간을 확인하려면 viewedByMeTime 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일이 사용자와 공유된 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일이 사용자와 공유된 시간을 확인하려면 sharedWithMeTime 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일에서 사용된 저장용량 할당량 바이트 수를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일에서 사용된 저장용량 할당량 바이트 수를 확인하려면 quotaBytesUsed 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 단조 증가 버전 번호를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "파일의 단조 증가 버전 번호를 확인하려면 version 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일을 삭제할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일을 삭제할 수 있는지 여부는 capabilities.canDelete 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일을 다운로드할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일을 다운로드할 수 있는지 여부는 capabilities.canDownload 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 이름을 변경할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 이름을 변경할 수 있는지 여부는 capabilities.canRename 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일을 휴지통으로 이동할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일을 휴지통으로 이동할 수 있는지 여부는 capabilities.canTrash 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 버전 리소스를 읽을 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 버전 리소스를 읽을 수 있는지 여부는 capabilities.canReadRevisions 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 이름을 변경할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 이름을 변경할 수 있는지 여부는 capabilities.canRename 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠를 수정할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 콘텐츠를 수정할 수 있는지 여부는 capabilities.canModifyContent 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일을 휴지통에서 복원할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일을 휴지통에서 복원할 수 있는지 여부는 capabilities.canUntrash 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 공유 설정을 수정할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 공유 설정을 수정할 수 있는지 여부는 capabilities.canShare 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "폴더의 하위 항목을 삭제할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "폴더의 하위 항목을 삭제할 수 있는지 여부는 capabilities.canDeleteChildren 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 상위 항목을 변경하여 이 드라이브 외부로 이동할 수 있는지 여부를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "현재 사용자가 상위 항목을 변경하여 이 드라이브 외부로 이 항목을 이동할 수 있는지 여부는 capabilities.canMoveItemOutOfDrive 필드를 참조하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "현재 사용자가 동일한 요청에서 기존 상위 항목을 삭제하지 않고 항목의 상위 항목을 추가할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "현재 사용자가 동일한 요청에서 기존 상위 항목을 삭제하지 않고 항목의 상위 항목을 추가할 수 있는지 여부는 capabilities.canAddMyDriveParent 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "현재 사용자가 이 드라이브 내에서 항목을 이동할 수 있는지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "현재 사용자가 이 드라이브 내에서 이 항목을 이동할 수 있는지 여부는 capabilities.canMoveItemWithinDrive 필드를 사용하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 공유 설정을 수정할 수 있는지 여부를 확인하려면 어떤 필드를 참조해야 하나요?", "answer": "현재 사용자가 이 파일의 공유 설정을 수정할 수 있는지 여부는 capabilities.canShare 필드를 참조하여 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "현재 사용자가 파일의 라벨을 수정할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "현재 사용자가 파일의 라벨을 수정할 수 있는지 여부는 capabilities.canModifyLabels 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 라벨을 읽을 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "파일의 라벨을 읽을 수 있는지 여부는 capabilities.canReadLabels 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 라벨을 수정할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "파일의 라벨을 수정할 수 있는지 여부는 capabilities.canModifyLabels 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "편집자 제한이 있는 파일에 콘텐츠 제한을 추가하거나 수정할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "편집자 제한이 있는 파일에 콘텐츠 제한을 추가하거나 수정할 수 있는지 여부는 capabilities.canModifyEditorContentRestriction 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "소유자 제한 콘텐츠 제한을 추가하거나 수정할 수 있는지 여부는 어떤 필드를 통해 확인하나요?", "answer": "소유자 제한 콘텐츠 제한을 추가하거나 수정할 수 있는지 여부는 capabilities.canModifyOwnerContentRestriction 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일이 명시적으로 휴지통으로 이동된 경우, 휴지통으로 이동한 사용자는 어떤 필드를 통해 확인할 수 있나요?", "answer": "파일이 명시적으로 휴지통으로 이동된 경우, 휴지통으로 이동한 사용자는 trashedUser 필드를 통해 확인할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "사진의 색상 공간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "사진의 색상 공간을 확인하려면 imageMediaMetadata.colorSpace 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "사진을 촬영한 날짜와 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "사진을 촬영한 날짜와 시간을 확인하려면 imageMediaMetadata.time 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "동영상의 재생 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "동영상의 재생 시간을 확인하려면 videoMediaMetadata.durationMillis 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "사진을 만드는 데 사용된 카메라의 제조사를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "사진을 만드는 데 사용된 카메라의 제조사를 확인하려면 imageMediaMetadata.cameraMake 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "바로가기 파일의 세부정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "바로가기 파일의 세부정보를 확인하려면 shortcutDetails 객체를 사용해야 하며, 이 객체 내의 targetId, targetMimeType, targetResourceKey 필드를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "동영상의 너비와 높이를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "동영상의 너비(픽셀)와 높이(픽셀)를 확인하려면 각각 videoMediaMetadata.width와 videoMediaMetadata.height 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "동영상의 재생 시간을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "동영상의 재생 시간을 확인하려면 videoMediaMetadata.durationMillis 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "바로가기 파일의 세부정보를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "바로가기 파일의 세부정보를 확인하려면 shortcutDetails 객체를 사용해야 하며, 이 객체는 mimeType 필드가 application/vnd.google-apps.shortcut로 설정된 바로가기 파일에만 채워집니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 SHA1 체크섬을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 SHA1 체크섬을 확인하려면 sha1Checksum 필드를 사용해야 합니다. 이 필드는 Google Drive에 콘텐츠가 저장된 파일에만 채워집니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠가 읽기 전용인지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 콘텐츠가 읽기 전용인지 여부를 확인하려면 downloadRestrictions.ContentRestriction.readOnly 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 SHA256 체크섬을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 SHA256 체크섬을 확인하려면 'sha256Checksum' 필드를 사용해야 합니다. 이 필드는 Google Drive에 콘텐츠가 저장된 파일에만 채워지며, Docs 편집기 또는 바로가기 파일에는 채워지지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일에 적용된 다운로드 제한사항을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일에 적용된 다운로드 제한사항을 확인하려면 'downloadRestrictions' 필드를 사용해야 합니다. 이 필드는 파일에 적용된 다운로드 제한사항을 포함하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠가 읽기 전용인지 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 콘텐츠가 읽기 전용인지 여부를 확인하려면 'readOnly' 필드를 사용해야 합니다. 이 필드가 true인 경우 파일의 새 버전이 추가되지 않고, 댓글이 추가되거나 수정되지 않으며, 파일의 제목이 수정되지 않을 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 다운로드 제한이 소유자 또는 주최자가 직접 적용한 것인지 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 다운로드 제한이 소유자 또는 주최자가 직접 적용한 것인지 확인하려면 'itemDownloadRestriction' 필드를 사용해야 합니다. 이 필드는 소유자 또는 주최자가 직접 적용한 파일의 다운로드 제한을 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 콘텐츠 제한을 설정한 사용자를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 콘텐츠 제한을 설정한 사용자를 확인하려면 'restrictingUser' 필드를 사용해야 합니다. 이 필드는 콘텐츠 제한이 설정된 경우에만 채워집니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 다운로드 제한사항을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일의 다운로드 제한사항을 확인하려면 'itemDownloadRestriction' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일에 적용된 유효한 다운로드 제한을 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "파일에 적용된 유효한 다운로드 제한을 확인하려면 'effectiveDownloadRestrictionWithContext' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "파일의 복사 및 다운로드에 대한 제한을 확인하려면 어떤 객체를 참조해야 하나요?", "answer": "파일의 복사 및 다운로드에 대한 제한을 확인하려면 'DownloadRestriction' 객체를 참조해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "작성자의 다운로드 및 복사 제한 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "작성자의 다운로드 및 복사 제한 여부를 확인하려면 'restrictedForWriters' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "독자의 다운로드 및 복사 제한 여부를 확인하려면 어떤 필드를 사용해야 하나요?", "answer": "독자의 다운로드 및 복사 제한 여부를 확인하려면 'restrictedForReaders' 필드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files.txt"}
{"question": "files.copy 메서드를 사용하여 파일을 복사할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "파일을 복사하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/copy\n```\n여기서 `{fileId}`는 복사할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_copy.txt"}
{"question": "files.copy 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "files.copy 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `enforceSingleParent`: 지원 중단됨.\n- `ignoreDefaultVisibility`: 생성된 파일에 대해 도메인의 기본 공개 상태 설정을 무시할지 여부.\n- `keepRevisionForever`: 새 헤드 버전에서 'keepForever' 필드를 설정할지 여부.\n- `ocrLanguage`: 이미지 가져오기 중에 OCR 처리를 위한 언어 힌트.\n- `supportsAllDrives`: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부.\n- `includePermissionsForView`: 응답에 포함할 추가 뷰의 권한을 지정.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_copy.txt"}
{"question": "files.copy 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "요청 본문에는 `File`의 인스턴스가 포함되어야 합니다. `File`에 대한 자세한 내용은 [File 문서](https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File)를 참조하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_copy.txt"}
{"question": "files.copy 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 `File`의 인스턴스가 포함됩니다. 이 인스턴스는 복사된 파일에 대한 정보를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_copy.txt"}
{"question": "files.copy 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "files.copy 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.appdata`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.photos.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_copy.txt"}
{"question": "files.create 메서드를 사용하여 파일을 업로드할 때 지원되는 최대 파일 크기는 얼마인가요?", "answer": "files.create 메서드를 사용하여 파일을 업로드할 때 지원되는 최대 파일 크기는 5,120GB입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드로 파일을 생성할 때, 파일의 MIME 유형을 어떻게 지정해야 하나요?", "answer": "files.create 메서드로 파일을 생성할 때, 파일의 MIME 유형은 유효한 MIME 유형을 지정해야 하며, 리터럴 */* 값은 유효한 MIME 유형을 업로드할 수 있음을 나타내는 데만 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드를 사용하여 바로가기를 만들 때 어떤 MIME 유형을 지정해야 하나요?", "answer": "files.create 메서드를 사용하여 바로가기를 만들 때는 MIME 유형 application/vnd.google-apps.shortcut을 지정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드에서 'uploadType' 파라미터의 사용 가능한 값은 무엇인가요?", "answer": "files.create 메서드에서 'uploadType' 파라미터의 사용 가능한 값은 media, multipart, resumable입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드의 'ignoreDefaultVisibility' 파라미터는 어떤 기능을 하나요?", "answer": "files.create 메서드의 'ignoreDefaultVisibility' 파라미터는 생성된 파일에 대해 도메인의 기본 공개 상태 설정을 무시할지 여부를 결정합니다. 이 매개변수는 요청에 대해 이러한 동작을 우회합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드에서 'keepRevisionForever' 파라미터는 어떤 기능을 하나요?", "answer": "'keepRevisionForever' 필드는 새 헤드 버전에서 설정할지 여부를 나타냅니다. 이 필드는 Google Drive에 바이너리 콘텐츠가 있는 파일에만 적용되며, 파일의 버전은 200개까지만 영구 보관할 수 있습니다. 한도에 도달한 경우 고정된 버전을 삭제해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드의 'ocrLanguage' 파라미터는 어떤 용도로 사용되나요?", "answer": "'ocrLanguage' 파라미터는 이미지 가져오기 중 OCR 처리를 위한 언어 힌트를 제공하는 데 사용됩니다. 이 값은 ISO 639-1 코드 형식이어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드에서 'supportsAllDrives' 파라미터는 어떤 기능을 하나요?", "answer": "'supportsAllDrives' 파라미터는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드의 'uploadType' 파라미터에서 'resumable' 값은 어떤 의미인가요?", "answer": "'uploadType' 파라미터의 'resumable' 값은 첫 번째 요청에 메타데이터가 포함된 일련의 요청(2개 이상)을 사용하여 재개 가능한 방식으로 파일을 업로드하는 것을 의미합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.create 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "요청 본문에는 File의 인스턴스가 포함되어야 합니다. 이는 파일의 메타데이터와 관련된 정보를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_create.txt"}
{"question": "files.delete 메서드를 사용하여 파일을 영구적으로 삭제할 때, 어떤 조건이 필요한가요?", "answer": "files.delete 메서드를 사용하여 파일을 영구적으로 삭제하려면 사용자가 소유한 파일이어야 하며, 파일이 공유 드라이브에 속하는 경우 사용자는 상위 폴더의 organizer여야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_delete.txt"}
{"question": "files.delete 메서드의 HTTP 요청 형식은 어떻게 되나요?", "answer": "files.delete 메서드의 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}\n```\n여기서 {fileId}는 삭제할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_delete.txt"}
{"question": "files.delete 메서드에서 supportsAllDrives 쿼리 매개변수의 역할은 무엇인가요?", "answer": "supportsAllDrives 쿼리 매개변수는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_delete.txt"}
{"question": "files.delete 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "files.delete 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_delete.txt"}
{"question": "files.delete 메서드를 호출할 때 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "files.delete 메서드를 호출할 때 필요한 OAuth 승인 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_delete.txt"}
{"question": "파일을 다운로드하기 위해 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "파일의 콘텐츠를 다운로드하기 위해 필요한 HTTP 요청은 다음과 같습니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/download\n```\n여기서 `{fileId}`는 다운로드할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_download.txt"}
{"question": "Google Workspace 문서를 다운로드할 때 MIME 유형을 설정하는 방법은 무엇인가요?", "answer": "Google Workspace 문서를 다운로드할 때 MIME 유형을 설정하려면 쿼리 매개변수로 `mimeType`을 사용해야 합니다. 이 필드는 선택사항이며, 지원되는 MIME 유형 목록은 Google Workspace 문서의 files.export MIME 유형을 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_download.txt"}
{"question": "특정 버전의 파일을 다운로드할 때 필요한 매개변수는 무엇인가요?", "answer": "특정 버전의 파일을 다운로드할 때는 쿼리 매개변수로 `revisionId`를 설정해야 합니다. 이 필드는 blob 파일, Google Docs, Google Sheets를 다운로드할 때만 설정할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_download.txt"}
{"question": "파일 다운로드 요청의 본문은 어떻게 구성되나요?", "answer": "파일 다운로드 요청의 본문은 비어 있어야 합니다. 즉, 요청 본문은 포함하지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_download.txt"}
{"question": "파일 다운로드를 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "파일 다운로드를 위해 필요한 OAuth 승인 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_download.txt"}
{"question": "Google Drive API를 사용하여 사용자의 휴지통을 비우는 방법은 무엇인가요?", "answer": "사용자의 휴지통에 있는 모든 파일을 영구적으로 삭제하려면 다음과 같은 HTTP DELETE 요청을 사용합니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/trash\n```\n이 요청의 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_emptyTrash.txt"}
{"question": "휴지통을 비울 때 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "휴지통을 비울 때 사용할 수 있는 쿼리 매개변수는 `driveId`입니다. 이 속성을 설정하면 제공된 공유 드라이브의 휴지통을 비웁니다. `enforceSingleParent` 매개변수는 지원 중단(deprecated)되었습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_emptyTrash.txt"}
{"question": "휴지통을 비운 후의 응답 본문은 어떻게 되나요?", "answer": "휴지통을 비운 후 성공하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_emptyTrash.txt"}
{"question": "휴지통을 비우기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "휴지통을 비우기 위해 필요한 OAuth 승인 범위는 `https://www.googleapis.com/auth/drive`입니다. 일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_emptyTrash.txt"}
{"question": "휴지통을 비우는 API 요청을 보낼 때 주의해야 할 점은 무엇인가요?", "answer": "휴지통을 비우는 API 요청을 보낼 때 요청 본문은 반드시 비어 있어야 하며, `driveId`를 설정하여 특정 공유 드라이브의 휴지통을 비울 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_emptyTrash.txt"}
{"question": "files.export 메서드를 사용하여 Google Workspace 문서를 내보내는 방법은 무엇인가요?", "answer": "files.export 메서드를 사용하여 Google Workspace 문서를 내보내려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/export\n```\n여기서 `{fileId}`는 내보내고자 하는 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/export?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_export.txt"}
{"question": "files.export 메서드에서 요청해야 하는 MIME 유형은 어떻게 지정하나요?", "answer": "files.export 메서드에서 요청해야 하는 MIME 유형은 쿼리 매개변수로 `mimeType`을 사용하여 지정합니다. 이 매개변수는 필수 항목입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/export?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_export.txt"}
{"question": "files.export 메서드의 응답 본문은 어떤 형식으로 반환되나요?", "answer": "files.export 메서드는 성공적으로 요청이 처리되면 파일 콘텐츠를 바이트로 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/export?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_export.txt"}
{"question": "files.export 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "files.export 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/export?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_export.txt"}
{"question": "files.export 메서드로 내보낼 수 있는 콘텐츠의 크기 제한은 어떻게 되나요?", "answer": "files.export 메서드로 내보낼 수 있는 콘텐츠의 크기는 10MB로 제한됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/export?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_export.txt"}
{"question": "files.generateIds 메서드를 사용하여 생성할 수 있는 파일 ID의 수를 지정하려면 어떤 쿼리 매개변수를 사용해야 하나요?", "answer": "files.generateIds 메서드에서 생성할 파일 ID의 수를 지정하려면 'count' 쿼리 매개변수를 사용해야 합니다. 이 매개변수는 정수형으로 반환할 ID 수를 설정합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/generateIds?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_generateIds.txt"}
{"question": "files.generateIds 메서드에서 ID를 사용할 수 있는 항목 유형을 지정하려면 어떤 쿼리 매개변수를 사용해야 하나요?", "answer": "ID를 사용할 수 있는 항목 유형을 지정하려면 'type' 쿼리 매개변수를 사용해야 합니다. 지원되는 값은 'files' 및 'shortcuts'이며, 'shortcuts'는 'drive' 스페이스에서만 지원됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/generateIds?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_generateIds.txt"}
{"question": "files.generateIds 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "files.generateIds 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문에 어떤 데이터도 포함되지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/generateIds?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_generateIds.txt"}
{"question": "files.generateIds 메서드의 성공적인 응답 본문 구조는 어떻게 되나요?", "answer": "성공적인 응답 본문은 다음과 같은 구조의 데이터를 포함합니다: \n```json\n{\n  \"ids\": [\n    string\n  ],\n  \"space\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/generateIds?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_generateIds.txt"}
{"question": "files.generateIds 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "files.generateIds 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다: \n- https://www.googleapis.com/auth/drive \n- https://www.googleapis.com/auth/drive.appdata \n- https://www.googleapis.com/auth/drive.file \n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/generateIds?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_generateIds.txt"}
{"question": "files.get 메서드를 사용하여 파일의 메타데이터를 가져오는 방법은 무엇인가요?", "answer": "files.get 메서드를 사용하여 파일의 메타데이터를 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}\n```\n여기서 {fileId}는 가져오려는 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_get.txt"}
{"question": "files.get 메서드에서 alt=media를 사용하면 어떤 결과를 얻을 수 있나요?", "answer": "alt=media를 제공하면 응답 본문에 파일 콘텐츠가 포함됩니다. 이 옵션을 사용하여 콘텐츠를 다운로드하려면 파일이 Drive에 저장되어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_get.txt"}
{"question": "files.get 메서드에서 acknowledgeAbuse 파라미터의 용도는 무엇인가요?", "answer": "acknowledgeAbuse 파라미터는 사용자가 알려진 멀웨어나 기타 악성 파일을 다운로드할 때 따르는 위험을 인정하는지 여부를 나타냅니다. 이는 alt 매개변수가 media로 설정되어 있고 사용자가 파일의 소유자이거나 파일이 있는 공유 드라이브의 주최자인 경우에만 적용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_get.txt"}
{"question": "files.get 메서드에서 supportsAllDrives 파라미터는 어떤 역할을 하나요?", "answer": "supportsAllDrives 파라미터는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_get.txt"}
{"question": "files.get 메서드의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 File의 인스턴스가 포함됩니다. File은 파일의 메타데이터와 관련된 정보를 담고 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_get.txt"}
{"question": "files.list 메서드를 사용하여 파일을 나열할 때, 휴지통에 있는 파일을 제외하려면 어떤 쿼리 매개변수를 사용해야 하나요?", "answer": "휴지통에 있는 파일이 목록에 표시되지 않도록 하려면 trashed=false 쿼리 매개변수를 사용하여 결과에서 휴지통에 있는 파일을 삭제해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드에서 사용할 수 있는 정렬 키는 무엇이 있나요?", "answer": "files.list 메서드에서 사용할 수 있는 유효한 정렬 키는 다음과 같습니다: createdTime, folder, modifiedByMeTime, modifiedTime, name, name_natural, quotaBytesUsed, recency, sharedWithMeTime, starred, viewedByMeTime.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 pageSize 매개변수는 어떤 역할을 하나요?", "answer": "pageSize 매개변수는 페이지당 반환할 최대 파일 수를 설정합니다. 파일 목록의 끝에 도달하기 전에도 부분 또는 빈 결과 페이지가 표시될 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드에서 'corpora' 매개변수의 기본값은 무엇인가요?", "answer": "기본적으로 'corpora' 매개변수는 'user'로 설정됩니다. 하지만 'q' 매개변수를 통해 설정된 필터에 따라 달라질 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "성공한 경우 응답 본문은 다음과 같은 구조의 데이터를 포함합니다: \n```json\n{\n  \"files\": [\n    {\n      object (File [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File])\n    }\n  ],\n  \"nextPageToken\": string,\n  \"kind\": string,\n  \"incompleteSearch\": boolean\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드에서 'q' 매개변수는 어떤 용도로 사용되나요?", "answer": "'q' 매개변수는 파일 결과를 필터링하기 위한 쿼리입니다. 지원되는 구문은 '파일 및 폴더 검색' 가이드를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 'spaces' 매개변수는 어떤 값을 지원하나요?", "answer": "'spaces' 매개변수는 쿼리할 공백의 쉼표로 구분된 목록을 지정합니다. 지원되는 값은 'drive' 및 'appDataFolder'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 'supportsAllDrives' 매개변수는 어떤 역할을 하나요?", "answer": "'supportsAllDrives' 매개변수는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 응답 본문에서 'incompleteSearch' 필드는 어떤 의미인가요?", "answer": "'incompleteSearch' 필드는 검색 프로세스가 불완전했는지 여부를 나타냅니다. true인 경우 모든 문서가 검색되지 않았으므로 일부 검색 결과가 누락될 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드를 사용할 때 필요한 OAuth 범위는 무엇인가요?", "answer": "files.list 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다: https://www.googleapis.com/auth/drive, https://www.googleapis.com/auth/drive.appdata, https://www.googleapis.com/auth/drive.file, https://www.googleapis.com/auth/drive.meet.readonly, https://www.googleapis.com/auth/drive.metadata, https://www.googleapis.com/auth/drive.metadata.readonly, https://www.googleapis.com/auth/drive.photos.readonly, https://www.googleapis.com/auth/drive.readonly. 일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 응답 본문에서 'nextPageToken' 필드는 어떤 역할을 하나요?", "answer": "'nextPageToken' 필드는 파일의 다음 페이지를 위한 페이지 토큰입니다. 파일 목록의 끝에 도달한 경우 이 값이 없습니다. 어떤 이유로든 토큰이 거부되면 토큰을 삭제하고 결과의 첫 번째 페이지부터 페이지로 나누기를 다시 시작해야 합니다. 페이지 토큰은 일반적으로 몇 시간 동안 유효합니다. 하지만 새 항목이 추가되거나 삭제되면 예상 결과가 달라질 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 응답 본문에서 'kind' 필드는 어떤 정보를 제공하나요?", "answer": "'kind' 필드는 리소스 종류를 식별합니다. 이 필드의 값은 고정 문자열 'drive#fileList'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 응답 본문에서 'incompleteSearch' 필드는 어떤 의미인가요?", "answer": "'incompleteSearch' 필드는 검색 프로세스가 불완전했는지 여부를 나타냅니다. true인 경우 모든 문서가 검색되지 않았으므로 일부 검색 결과가 누락될 수 있습니다. 이는 'allDrives' 말뭉치로 여러 드라이브를 검색했지만 일부 말뭉치를 검색할 수 없는 경우에 발생할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드를 사용할 때 필요한 OAuth 범위는 무엇인가요?", "answer": "files.list 메서드를 사용할 때 필요한 OAuth 범위는 다음과 같습니다: \n- https://www.googleapis.com/auth/drive \n- https://www.googleapis.com/auth/drive.appdata \n- https://www.googleapis.com/auth/drive.file \n- https://www.googleapis.com/auth/drive.meet.readonly \n- https://www.googleapis.com/auth/drive.metadata \n- https://www.googleapis.com/auth/drive.metadata.readonly \n- https://www.googleapis.com/auth/drive.photos.readonly \n- https://www.googleapis.com/auth/drive.readonly \n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.list 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "files.list 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_list.txt"}
{"question": "files.listLabels 메서드를 사용하여 특정 파일의 라벨을 나열하는 방법은 무엇인가요?", "answer": "files.listLabels 메서드를 사용하여 특정 파일의 라벨을 나열하려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/listLabels\n```\n여기서 `{fileId}`는 라벨을 나열할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/listLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_listLabels.txt"}
{"question": "files.listLabels 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "files.listLabels 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `maxResults`: 페이지당 반환할 라벨의 최대 수입니다. 설정하지 않으면 기본값은 100입니다.\n- `pageToken`: 다음 페이지에서 이전 목록 요청을 계속하는 토큰입니다. 이 값은 이전 응답의 'nextPageToken' 값으로 설정해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/listLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_listLabels.txt"}
{"question": "files.listLabels 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "files.listLabels 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문을 포함하지 않고 요청을 보내야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/listLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_listLabels.txt"}
{"question": "files.listLabels 메서드의 성공적인 응답 본문 구조는 어떻게 되나요?", "answer": "files.listLabels 메서드의 성공적인 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  \"labels\": [\n    {\n      object (Label)\n    }\n  ],\n  \"nextPageToken\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/listLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_listLabels.txt"}
{"question": "files.listLabels 메서드를 사용하기 위한 승인 범위는 무엇인가요?", "answer": "files.listLabels 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.metadata`\n- `https://www.googleapis.com/auth/drive.metadata.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/listLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_listLabels.txt"}
{"question": "files.modifyLabels 메서드를 사용하여 파일의 라벨을 수정하는 방법은 무엇인가요?", "answer": "files.modifyLabels 메서드를 사용하여 파일의 라벨을 수정하려면, POST 요청을 다음 URL로 전송해야 합니다: `https://www.googleapis.com/drive/v3/files/{fileId}/modifyLabels`. 요청 본문에는 ModifyLabelsRequest의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/modifyLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_modifyLabels.txt"}
{"question": "ModifyLabelsRequest의 JSON 표현 구조는 어떻게 되나요?", "answer": "ModifyLabelsRequest의 JSON 표현 구조는 다음과 같습니다:\n```json\n{\n  \"labelModifications\": [\n    {\n      object (LabelModification)\n    }\n  ],\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/modifyLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_modifyLabels.txt"}
{"question": "files.modifyLabels 메서드의 성공적인 응답 본문 구조는 어떻게 되나요?", "answer": "files.modifyLabels 메서드의 성공적인 응답 본문 구조는 다음과 같습니다:\n```json\n{\n  \"modifiedLabels\": [\n    {\n      object (Label)\n    }\n  ],\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/modifyLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_modifyLabels.txt"}
{"question": "LabelModification의 JSON 표현 구조는 무엇인가요?", "answer": "LabelModification의 JSON 표현 구조는 다음과 같습니다:\n```json\n{\n  \"fieldModifications\": [\n    {\n      object (FieldModification)\n    }\n  ],\n  \"labelId\": string,\n  \"removeLabel\": boolean,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/modifyLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_modifyLabels.txt"}
{"question": "files.modifyLabels 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "files.modifyLabels 메서드를 호출하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.metadata`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/modifyLabels?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_modifyLabels.txt"}
{"question": "files.update 메서드를 사용하여 파일의 메타데이터를 업데이트할 때 어떤 필드를 포함해야 하나요?", "answer": "files.update 메서드를 호출할 때는 수정하려는 요청의 필드만 채워야 합니다. 일부 필드(예: modifiedDate)는 자동으로 변경될 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 지원하는 최대 파일 크기는 얼마인가요?", "answer": "files.update 메서드는 최대 파일 크기로 5,120GB를 지원합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 사용할 수 있는 uploadType 파라미터의 값은 무엇이 있나요?", "answer": "uploadType 파라미터는 다음과 같은 값을 가질 수 있습니다: media, multipart, resumable.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 'keepRevisionForever' 필드는 어떤 경우에 사용하나요?", "answer": "'keepRevisionForever' 필드는 새 헤드 버전에서 설정할지 여부를 나타내며, Google Drive에 바이너리 콘텐츠가 있는 파일에만 적용됩니다. 파일의 버전은 200개까지만 영구 보관할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드의 요청 본문에는 어떤 형식의 데이터가 포함되어야 하나요?", "answer": "요청 본문에는 File의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 addParents 파라미터는 어떤 용도로 사용되나요?", "answer": "addParents 파라미터는 추가할 상위 ID의 쉼표로 구분된 목록을 지정하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 removeParents 파라미터는 어떤 역할을 하나요?", "answer": "removeParents 파라미터는 삭제할 상위 ID의 쉼표로 구분된 목록을 지정하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 uploadType 파라미터의 사용 가능한 값은 무엇인가요?", "answer": "uploadType 파라미터의 사용 가능한 값은 다음과 같습니다:\n- media: 메타데이터 없이 미디어만 업로드합니다.\n- multipart: 단일 요청으로 미디어와 메타데이터를 모두 업로드합니다.\n- resumable: 메타데이터가 포함된 일련의 요청을 사용하여 재개 가능한 방식으로 파일을 업로드합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드에서 includePermissionsForView 파라미터는 어떤 값을 지원하나요?", "answer": "includePermissionsForView 파라미터는 응답에 포함할 추가 뷰의 권한을 지정하며, '게시됨'만 지원됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.update 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "files.update 메서드를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.scripts", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_update.txt"}
{"question": "files.watch 메서드를 사용하여 파일 변경사항을 구독하는 방법은 무엇인가요?", "answer": "files.watch 메서드를 사용하여 파일 변경사항을 구독하려면 다음과 같은 HTTP POST 요청을 사용합니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/watch\n```\n여기서 `{fileId}`는 구독할 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_watch.txt"}
{"question": "files.watch 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "files.watch 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `supportsAllDrives`: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- `acknowledgeAbuse`: 사용자가 알려진 멀웨어나 기타 악성 파일을 다운로드할 때 따르는 위험을 인정하는지 여부입니다.\n- `includePermissionsForView`: 응답에 포함할 추가 뷰의 권한을 지정합니다. '게시됨'만 지원됩니다.\n- `includeLabels`: 응답의 labelInfo 부분에 포함할 라벨 ID의 쉼표로 구분된 목록입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_watch.txt"}
{"question": "files.watch 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "files.watch 메서드의 요청 본문에는 Channel의 인스턴스가 포함되어야 합니다. Channel에 대한 자세한 내용은 Channel 문서를 참조하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_watch.txt"}
{"question": "files.watch 메서드를 호출하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "files.watch 메서드를 호출하기 위해 필요한 OAuth 승인 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.metadata`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_watch.txt"}
{"question": "files.watch 메서드의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "files.watch 메서드의 응답 본문에는 성공한 경우 Channel의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/files/watch?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_files_watch.txt"}
{"question": "라벨의 JSON 표현에서 'fields' 필드는 어떤 구조로 되어 있나요?", "answer": "라벨의 JSON 표현에서 'fields' 필드는 다음과 같은 구조로 되어 있습니다: \n```json\n{\n  \"fields\": {\n    string: {\n      object (Field [https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko#Field])\n    },\n    ...\n  },\n  \"id\": string,\n  \"revisionId\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_Label.txt"}
{"question": "'Field' 객체의 'valueType' 필드는 어떤 값들을 가질 수 있나요?", "answer": "'Field' 객체의 'valueType' 필드는 현재 다음 값만 허용됩니다: \n- dateString\n- integer\n- selection\n- text\n- user", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_Label.txt"}
{"question": "라벨의 'id' 필드는 어떤 정보를 담고 있나요?", "answer": "'id' 필드는 라벨의 ID를 나타내며, 이는 문자열(string) 형식입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_Label.txt"}
{"question": "'fields' 필드의 구조에서 'key'와 'value'는 어떤 형태로 이루어져 있나요?", "answer": "'fields' 필드는 필드의 ID를 키로 사용하며, 'key': 'value' 쌍 목록을 포함하는 객체입니다. 예를 들어, 다음과 같은 형태입니다: \n```json\n{ \"name\": \"wrench\", \"mass\": \"1.3kg\", \"count\": \"3\" }\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_Label.txt"}
{"question": "'Field' 객체의 'user' 필드는 어떤 정보를 포함하나요?", "answer": "'Field' 객체의 'user' 필드는 'valueType'이 user인 경우에만 포함되며, 이는 다음과 같은 구조를 가집니다: \n```json\n\"user\": [\n  {\n    object (User [https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko])\n  }\n]\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_Label.txt"}
{"question": "장기 실행 작업의 상태를 확인하기 위해 어떤 메서드를 사용해야 하나요?", "answer": "장기 실행 작업의 최신 상태를 확인하기 위해서는 `get` 메서드를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "작업 리소스의 JSON 표현에서 'done' 필드는 어떤 의미인가요?", "answer": "'done' 필드는 작업이 완료되었는지를 나타내며, 값이 false이면 작업이 아직 진행 중이라는 의미이고, true이면 작업이 완료된 것입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "작업 결과를 나타내는 'result' 필드는 어떤 값을 가질 수 있나요?", "answer": "'result' 필드는 'error' 또는 'response' 중 하나의 값을 가질 수 있으며, 'done'이 true일 때만 설정됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "작업 리소스의 'metadata' 필드는 어떤 정보를 포함하나요?", "answer": "'metadata' 필드는 작업과 관련된 서비스별 메타데이터를 포함하며, 일반적으로 진행률 정보 및 생성 시간과 같은 정보를 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "Status 유형의 JSON 표현에서 'details' 필드는 어떤 정보를 담고 있나요?", "answer": "'details' 필드는 오류 세부정보를 설명하는 메시지 목록을 포함하며, API에서 사용할 일반적인 메시지 유형 집합이 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "장기 실행 작업의 상태를 가져오기 위해 어떤 메서드를 사용해야 하나요?", "answer": "장기 실행 작업의 최신 상태를 가져오기 위해서는 `get` 메서드(https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko)를 사용해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "'result' 필드가 'error'일 때 어떤 정보를 포함하나요?", "answer": "'result' 필드가 'error'일 때는 실패하거나 취소된 작업의 오류 결과를 포함하는 객체(Status)입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "'result' 필드가 'response'일 때 어떤 정보를 포함하나요?", "answer": "'result' 필드가 'response'일 때는 정상적인 성공한 작업 응답을 포함하며, Delete와 같이 원래 메서드가 성공 시 데이터를 반환하지 않는 경우 응답은 `google.protobuf.Empty`입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "Status 유형의 JSON 표현에서 'code' 필드는 어떤 값을 가져야 하나요?", "answer": "'code' 필드는 상태 코드로, `google.rpc.Code`의 열거형 값이어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "Status 메시지의 'details' 필드는 어떤 정보를 담고 있나요?", "answer": "'details' 필드는 오류 세부정보를 설명하는 메시지 목록을 포함하며, API에서 사용할 일반적인 메시지 유형 집합이 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations.txt"}
{"question": "operations.get 메서드를 사용하여 어떤 정보를 얻을 수 있나요?", "answer": "operations.get 메서드는 장기 실행 작업의 최신 상태를 가져오는 데 사용됩니다. 클라이언트는 이 메서드를 사용하여 API 서비스가 권장하는 간격으로 작업 결과를 폴링할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations_get.txt"}
{"question": "operations.get 메서드의 HTTP 요청 형식은 어떻게 되나요?", "answer": "operations.get 메서드는 다음과 같은 HTTP 요청 형식을 사용합니다:\n```\nGET https://www.googleapis.com/drive/v3/operations/{name}\n```\n여기서 {name}은 작업 리소스의 이름입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations_get.txt"}
{"question": "operations.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "operations.get 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations_get.txt"}
{"question": "operations.get 메서드의 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 Operation의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations_get.txt"}
{"question": "operations.get 메서드를 사용하기 위한 승인 범위는 무엇인가요?", "answer": "operations.get 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/operations/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_operations_get.txt"}
{"question": "permissions.create 메서드를 사용하여 파일에 권한을 추가하는 방법은 무엇인가요?", "answer": "permissions.create 메서드를 사용하여 파일에 권한을 추가할 수 있습니다. 요청 본문에 권한 정보를 포함해야 하며, 예를 들어 다음과 같은 JSON 형식을 사용할 수 있습니다.\n\n```json\n{\n  \"type\": \"user\",\n  \"role\": \"writer\",\n  \"emailAddress\": \"example@example.com\"\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.list 메서드를 사용하여 특정 파일의 권한을 조회하는 방법은 무엇인가요?", "answer": "permissions.list 메서드를 사용하여 특정 파일의 권한을 조회할 수 있습니다. 요청 URL에 파일 ID를 포함하여 다음과 같이 요청을 보낼 수 있습니다.\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/permissions\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.get 메서드를 사용하여 특정 권한의 세부정보를 가져오는 방법은 무엇인가요?", "answer": "permissions.get 메서드를 사용하여 특정 권한의 세부정보를 가져올 수 있습니다. 요청 URL에 파일 ID와 permissionId를 포함하여 다음과 같이 요청을 보낼 수 있습니다.\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/permissions/{permissionId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.update 메서드를 사용하여 기존 권한을 수정하는 방법은 무엇인가요?", "answer": "permissions.update 메서드를 사용하여 기존 권한을 수정할 수 있습니다. 요청 본문에 수정할 권한 정보를 포함해야 하며, 예를 들어 다음과 같은 JSON 형식을 사용할 수 있습니다.\n\n```json\n{\n  \"role\": \"reader\"\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.delete 메서드를 사용하여 특정 권한을 삭제하는 방법은 무엇인가요?", "answer": "permissions.delete 메서드를 사용하여 특정 권한을 삭제할 수 있습니다. 요청 URL에 파일 ID와 permissionId를 포함하여 다음과 같이 요청을 보낼 수 있습니다.\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}/permissions/{permissionId}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissionDetails 배열에서 permissionType 필드는 어떤 정보를 제공하나요?", "answer": "permissionDetails[].permissionType 필드는 이 사용자의 권한 유형을 나타냅니다. 현재는 'file'과 'member' 두 가지 값이 사용되고 있으며, 향후 새로운 값이 추가될 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissionDetails 배열의 role 필드는 어떤 역할을 나타내나요?", "answer": "permissionDetails[].role 필드는 이 사용자의 기본 역할을 나타냅니다. 현재 지원되는 역할은 'owner', 'organizer', 'fileOrganizer', 'writer', 'commenter', 'reader'입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissionDetails 배열의 inherited 필드는 어떤 의미인가요?", "answer": "permissionDetails[].inherited 필드는 이 권한이 상속되는지 여부를 나타냅니다. 이 필드는 항상 채워지며, 출력 전용입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissionDetails 배열의 id 필드는 무엇을 나타내나요?", "answer": "permissionDetails[].id 필드는 이 권한의 ID를 나타냅니다. 이는 수혜자의 고유 식별자이며, 사용자 리소스에 permissionId로 게시됩니다. ID는 불투명 값으로 취급해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissionDetails 배열의 emailAddress 필드는 어떤 정보를 포함하나요?", "answer": "permissionDetails[].emailAddress 필드는 이 권한이 참조하는 사용자 또는 그룹의 이메일 주소를 포함합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드를 사용하여 파일에 권한을 추가할 때 필요한 emailAddress 필드는 어떤 정보를 포함해야 하나요?", "answer": "permissions.create 메서드를 사용하여 파일에 권한을 추가할 때, emailAddress 필드는 이 권한이 참조하는 사용자 또는 그룹의 이메일 주소를 포함해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드를 사용할 때 role 필드는 어떤 역할을 정의하나요?", "answer": "permissions.create 메서드를 사용할 때, role 필드는 이 권한이 부여하는 역할을 정의합니다. 현재 허용되는 값은 owner, organizer, fileOrganizer, writer, commenter, reader입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드에서 expirationTime 필드는 어떤 제한사항이 있나요?", "answer": "permissions.create 메서드에서 expirationTime 필드는 사용자 및 그룹 권한에만 설정할 수 있으며, 시간은 미래여야 하고 1년 이후의 시간은 사용할 수 없습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드를 사용할 때 allowFileDiscovery 필드는 어떤 기능을 제공하나요?", "answer": "permissions.create 메서드를 사용할 때 allowFileDiscovery 필드는 권한에서 검색을 통해 파일을 검색할 수 있도록 허용할지 여부를 설정합니다. 이 필드는 domain 또는 anyone 유형의 권한에만 적용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드에서 inheritedPermissionsDisabled 필드는 어떤 의미인가요?", "answer": "permissions.create 메서드에서 inheritedPermissionsDisabled 필드는 이 속성이 true이면 항목에 직접 추가된 권한이 있는 주최자, 소유자, 사용자만 항목에 액세스할 수 있음을 나타냅니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions.txt"}
{"question": "permissions.create 메서드를 사용하여 파일에 권한을 추가할 때 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "HTTP 요청은 다음과 같은 형식을 가집니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/permissions\n```\n여기서 {fileId}는 파일 또는 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_create.txt"}
{"question": "permissions.create 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "permissions.create 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- emailMessage: 알림 이메일에 포함할 일반 텍스트 맞춤 메시지입니다.\n- moveToNewOwnersRoot: 항목이 공유 드라이브에 없고 요청에서 항목의 소유권을 이전하려는 경우에만 적용됩니다.\n- sendNotificationEmail: 사용자 또는 그룹에 공유할 때 알림 이메일을 전송할지 여부입니다.\n- supportsAllDrives: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- transferOwnership: 지정된 사용자에게 소유권을 이전하고 현재 소유자를 작성자로 다운그레이드할지 여부입니다.\n- useDomainAdminAccess: 도메인 관리자로 요청을 제출합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_create.txt"}
{"question": "permissions.create 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "요청 본문에는 Permission의 인스턴스가 포함되어야 합니다. Permission의 구조에 대한 자세한 내용은 [Permission 문서](https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions?hl=ko#Permission)를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_create.txt"}
{"question": "permissions.create 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에는 새로 생성된 Permission의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_create.txt"}
{"question": "permissions.create 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "permissions.create 메서드를 사용하기 위해 필요한 OAuth 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_create.txt"}
{"question": "permissions.delete 메서드를 사용하여 권한을 삭제할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}/permissions/{permissionId}\n```\n여기서 `{fileId}`는 파일 또는 공유 드라이브의 ID이고, `{permissionId}`는 삭제할 권한의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_delete.txt"}
{"question": "permissions.delete 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "permissions.delete 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `supportsAllDrives`: 요청하는 애플리케이션에서 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- `useDomainAdminAccess`: 도메인 관리자로 요청을 제출합니다. true로 설정하면 파일 ID 매개변수가 공유 드라이브를 참조하고 요청자가 공유 드라이브가 속한 도메인의 관리자인 경우 요청자에게 액세스 권한이 부여됩니다.\n- `enforceExpansiveAccess`: 요청에 확장된 액세스 규칙을 적용해야 하는지 여부입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_delete.txt"}
{"question": "permissions.delete 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "permissions.delete 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_delete.txt"}
{"question": "permissions.delete 메서드가 성공적으로 실행되었을 때의 응답 본문은 어떻게 되나요?", "answer": "permissions.delete 메서드가 성공적으로 실행되면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_delete.txt"}
{"question": "permissions.delete 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "permissions.delete 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_delete.txt"}
{"question": "permissions.get 메서드를 사용하여 특정 파일의 권한을 가져오는 방법은 무엇인가요?", "answer": "permissions.get 메서드를 사용하여 특정 파일의 권한을 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/permissions/{permissionId}\n```\n여기서 {fileId}는 파일의 ID, {permissionId}는 권한의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_get.txt"}
{"question": "permissions.get 메서드에서 supportsAllDrives 쿼리 매개변수의 역할은 무엇인가요?", "answer": "supportsAllDrives 쿼리 매개변수는 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부를 나타냅니다. 이 매개변수를 사용하여 요청의 범위를 조정할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_get.txt"}
{"question": "permissions.get 메서드에서 useDomainAdminAccess 매개변수는 어떻게 사용하나요?", "answer": "useDomainAdminAccess 매개변수는 도메인 관리자로 요청을 제출할 때 사용합니다. 이 매개변수를 true로 설정하면 파일 ID 매개변수가 공유 드라이브를 참조하고 요청자가 해당 공유 드라이브가 속한 도메인의 관리자인 경우 요청자에게 액세스 권한이 부여됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_get.txt"}
{"question": "permissions.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "permissions.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청을 보낼 때 본문에 아무런 데이터를 포함하지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_get.txt"}
{"question": "permissions.get 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "permissions.get 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_get.txt"}
{"question": "permissions.list 메서드를 사용하여 파일의 권한을 나열하는 방법은 무엇인가요?", "answer": "permissions.list 메서드를 사용하여 파일 또는 공유 드라이브의 권한을 나열하려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/permissions\n```\n여기서 `{fileId}`는 권한을 나열할 파일 또는 공유 드라이브의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_list.txt"}
{"question": "permissions.list 메서드에서 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?", "answer": "permissions.list 메서드에서 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `pageSize`: 페이지당 반환할 최대 권한 수입니다. 공유 드라이브의 파일에 설정되지 않은 경우 최대 100개의 결과가 반환됩니다.\n- `pageToken`: 다음 페이지에서 이전 목록 요청을 계속하기 위한 토큰입니다.\n- `supportsAllDrives`: 요청하는 애플리케이션이 내 드라이브와 공유 드라이브를 모두 지원하는지 여부입니다.\n- `useDomainAdminAccess`: 도메인 관리자로 요청을 실행합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_list.txt"}
{"question": "permissions.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "permissions.list 메서드의 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  \"permissions\": [\n    {\n      object (Permission)\n    }\n  ],\n  \"nextPageToken\": string,\n  \"kind\": string\n}\n```\n여기서 `permissions`는 권한 목록이며, `nextPageToken`은 다음 페이지를 위한 페이지 토큰입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_list.txt"}
{"question": "permissions.list 메서드에서 `nextPageToken`이 채워져 있는 경우 어떻게 처리해야 하나요?", "answer": "`nextPageToken`이 채워져 있는 경우 이 목록이 불완전할 수 있으며 결과의 추가 페이지를 가져와야 합니다. 페이지 토큰이 거부되면 토큰을 삭제하고 결과의 첫 번째 페이지부터 페이지로 나누기를 다시 시작해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_list.txt"}
{"question": "permissions.list 메서드를 사용하기 위한 승인 범위는 무엇인가요?", "answer": "permissions.list 메서드를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.metadata`\n- `https://www.googleapis.com/auth/drive.metadata.readonly`\n- `https://www.googleapis.com/auth/drive.photos.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_list.txt"}
{"question": "permissions.update 메서드를 사용하여 권한을 업데이트할 때 어떤 HTTP 요청을 사용해야 하나요?", "answer": "PATCH https://www.googleapis.com/drive/v3/files/{fileId}/permissions/{permissionId}를 사용하여 권한을 업데이트합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_update.txt"}
{"question": "permissions.update 메서드에서 사용되는 경로 매개변수는 무엇인가요?", "answer": "경로 매개변수로는 fileId(파일 또는 공유 드라이브의 ID)와 permissionId(권한의 ID)가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_update.txt"}
{"question": "permissions.update 메서드의 쿼리 매개변수 중 removeExpiration의 역할은 무엇인가요?", "answer": "removeExpiration은 만료일을 삭제할지 여부를 나타내는 boolean 값입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_update.txt"}
{"question": "permissions.update 메서드를 호출할 때 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 Permission의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_update.txt"}
{"question": "permissions.update 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "다음 OAuth 범위 중 하나가 필요합니다: https://www.googleapis.com/auth/drive 또는 https://www.googleapis.com/auth/drive.file.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/permissions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_permissions_update.txt"}
{"question": "replies.create 메서드를 사용하여 댓글에 대한 답글을 생성하는 방법은 무엇인가요?", "answer": "replies.create 메서드를 사용하여 댓글에 대한 답글을 생성할 수 있습니다. 이 메서드는 댓글에 대한 답글을 만들기 위해 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies.txt"}
{"question": "replies.delete 메서드를 사용하여 답글을 삭제할 때 필요한 정보는 무엇인가요?", "answer": "replies.delete 메서드를 사용하여 답글을 삭제할 때는 삭제할 답글의 ID가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies.txt"}
{"question": "replies.get 메서드를 사용하여 특정 답글을 가져오는 방법은 무엇인가요?", "answer": "replies.get 메서드를 사용하여 ID로 특정 답글을 가져올 수 있습니다. 이 메서드는 답글의 ID를 입력받아 해당 답글의 정보를 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies.txt"}
{"question": "replies.list 메서드를 사용하여 댓글의 답글을 나열하는 방법은 무엇인가요?", "answer": "replies.list 메서드를 사용하여 특정 댓글에 대한 모든 답글을 나열할 수 있습니다. 이 메서드는 댓글의 ID를 기반으로 답글 목록을 반환합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies.txt"}
{"question": "replies.update 메서드를 사용하여 답글을 업데이트할 때 어떤 방식으로 업데이트하나요?", "answer": "replies.update 메서드는 패치 시맨틱스를 사용하여 답글을 업데이트합니다. 이 메서드는 기존 답글의 내용을 수정하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies.txt"}
{"question": "댓글에 대한 답글을 생성하기 위한 HTTP 요청은 어떻게 구성하나요?", "answer": "댓글에 대한 답글을 생성하기 위해서는 다음과 같은 HTTP 요청을 사용합니다:\n\n```\nPOST https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies\n```\n여기서 `{fileId}`는 파일의 ID, `{commentId}`는 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_create.txt"}
{"question": "댓글에 대한 답글을 생성할 때 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 `Reply`의 인스턴스가 포함되어야 합니다. `Reply`의 구조에 대한 자세한 내용은 [Reply](https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko#Reply) 문서를 참조하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_create.txt"}
{"question": "댓글에 대한 답글을 생성한 후의 응답 본문에는 어떤 정보가 포함되나요?", "answer": "댓글에 대한 답글을 성공적으로 생성한 경우, 응답 본문에는 새로 생성된 `Reply`의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_create.txt"}
{"question": "댓글에 대한 답글을 생성하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "댓글에 대한 답글을 생성하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_create.txt"}
{"question": "댓글에 대한 답글을 생성할 때 주의해야 할 점은 무엇인가요?", "answer": "댓글에 대한 답글을 생성할 때는 사용하려는 OAuth 범위가 제한되어 있을 수 있으며, 이 경우 보안 평가가 필요합니다. 자세한 내용은 승인 가이드를 참고하세요.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/create?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_create.txt"}
{"question": "replies.delete 메서드를 사용하여 댓글의 답글을 삭제하는 방법은 무엇인가요?", "answer": "replies.delete 메서드를 사용하여 답글을 삭제하려면 다음과 같은 HTTP 요청을 사용합니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies/{replyId}\n```\n여기서 `{fileId}`는 파일의 ID, `{commentId}`는 댓글의 ID, `{replyId}`는 답장의 ID로 대체해야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_delete.txt"}
{"question": "replies.delete 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "replies.delete 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문에는 아무런 데이터도 포함되지 않아야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_delete.txt"}
{"question": "replies.delete 메서드를 호출했을 때 성공적인 응답은 어떤 형태인가요?", "answer": "replies.delete 메서드를 성공적으로 호출하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_delete.txt"}
{"question": "replies.delete 메서드를 사용하기 위한 승인 범위는 무엇인가요?", "answer": "replies.delete 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_delete.txt"}
{"question": "replies.delete 메서드의 경로 매개변수에 대해 설명해 주세요.", "answer": "replies.delete 메서드의 경로 매개변수는 다음과 같습니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.\n- `replyId`: 답장의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_delete.txt"}
{"question": "replies.get 메서드를 사용하여 특정 답장을 가져오는 방법은 무엇인가요?", "answer": "replies.get 메서드를 사용하여 특정 답장을 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies/{replyId}\n```\n여기서 {fileId}, {commentId}, {replyId}는 각각 파일, 댓글, 답장의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_get.txt"}
{"question": "replies.get 메서드에서 사용할 수 있는 경로 매개변수는 무엇인가요?", "answer": "replies.get 메서드에서 사용할 수 있는 경로 매개변수는 다음과 같습니다:\n- fileId: 파일의 ID입니다.\n- commentId: 댓글의 ID입니다.\n- replyId: 답장의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_get.txt"}
{"question": "replies.get 메서드의 쿼리 매개변수 includeDeleted의 역할은 무엇인가요?", "answer": "replies.get 메서드의 쿼리 매개변수 includeDeleted는 삭제된 답글을 반환할지 여부를 결정합니다. 삭제된 답글에는 원본 콘텐츠가 포함되지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_get.txt"}
{"question": "replies.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "replies.get 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_get.txt"}
{"question": "replies.get 메서드를 호출할 때 필요한 OAuth 범위는 무엇인가요?", "answer": "replies.get 메서드를 호출할 때 필요한 OAuth 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_get.txt"}
{"question": "replies.list 메서드를 사용하여 댓글의 답글을 나열할 때 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "replies.list 메서드를 사용하여 댓글의 답글을 나열할 때 필요한 HTTP 요청의 형식은 다음과 같습니다.\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_list.txt"}
{"question": "replies.list 메서드에서 사용할 수 있는 경로 매개변수는 무엇이며, 각각의 역할은 무엇인가요?", "answer": "replies.list 메서드에서 사용할 수 있는 경로 매개변수는 다음과 같습니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_list.txt"}
{"question": "replies.list 메서드의 쿼리 매개변수 중 'includeDeleted'의 역할은 무엇인가요?", "answer": "'includeDeleted' 쿼리 매개변수는 삭제된 답글을 포함할지 여부를 결정합니다. 삭제된 답글에는 원본 콘텐츠가 포함되지 않습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_list.txt"}
{"question": "replies.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "replies.list 메서드의 응답 본문 구조는 다음과 같습니다:\n\n```json\n{\n  \"replies\": [\n    {\n      object (Reply [https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko#Reply])\n    }\n  ],\n  \"kind\": string,\n  \"nextPageToken\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_list.txt"}
{"question": "replies.list 메서드를 호출하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "replies.list 메서드를 호출하기 위해 필요한 OAuth 범위는 다음 중 하나입니다:\n- `https://www.googleapis.com/auth/drive`\n- `https://www.googleapis.com/auth/drive.file`\n- `https://www.googleapis.com/auth/drive.meet.readonly`\n- `https://www.googleapis.com/auth/drive.readonly`", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_list.txt"}
{"question": "replies.update 메서드를 사용하여 답글을 업데이트할 때 필요한 HTTP 요청의 형식은 무엇인가요?", "answer": "답글을 업데이트하기 위해서는 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies/{replyId}\n```\n여기서 `{fileId}`, `{commentId}`, `{replyId}`는 각각 파일, 댓글, 답글의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_update.txt"}
{"question": "replies.update 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?", "answer": "요청 본문에는 Reply의 인스턴스가 포함되어야 합니다. Reply는 답글의 내용을 정의하는 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_update.txt"}
{"question": "replies.update 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공적인 경우 응답 본문에는 Reply의 인스턴스가 포함됩니다. 이는 업데이트된 답글의 정보를 제공합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_update.txt"}
{"question": "replies.update 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "replies.update 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며, 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_update.txt"}
{"question": "replies.update 메서드의 경로 매개변수로 사용되는 fileId, commentId, replyId의 역할은 무엇인가요?", "answer": "경로 매개변수는 다음과 같은 역할을 합니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.\n- `replyId`: 답장의 ID입니다.\n이 매개변수들은 특정 파일의 특정 댓글에 대한 특정 답글을 식별하는 데 사용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/replies/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_replies_update.txt"}
{"question": "revisions.get 메서드를 사용하여 수정사항의 메타데이터를 가져오는 방법은 무엇인가요?", "answer": "revisions.get 메서드를 사용하여 ID로 수정사항의 메타데이터 또는 콘텐츠를 가져올 수 있습니다. 요청은 다음과 같이 구성됩니다:\n\n```\nGET https://www.googleapis.com/drive/v3/revisions/{revisionId}\n```\n여기서 `{revisionId}`는 가져오고자 하는 수정사항의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions.txt"}
{"question": "revisions.list 메서드를 사용하여 파일의 버전을 나열하는 방법은 무엇인가요?", "answer": "revisions.list 메서드를 사용하여 특정 파일의 버전을 나열할 수 있습니다. 요청은 다음과 같이 구성됩니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/revisions\n```\n여기서 `{fileId}`는 버전을 나열하고자 하는 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions.txt"}
{"question": "revisions.update 메서드를 사용하여 버전을 업데이트할 때 필요한 요청 형식은 무엇인가요?", "answer": "revisions.update 메서드를 사용하여 패치 시맨틱스를 사용하여 버전을 업데이트할 수 있습니다. 요청은 다음과 같이 구성됩니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/revisions/{revisionId}\n```\n여기서 `{revisionId}`는 업데이트할 수정사항의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions.txt"}
{"question": "revisions.delete 메서드를 사용하여 파일 버전을 삭제하는 방법은 무엇인가요?", "answer": "revisions.delete 메서드를 사용하여 파일 버전을 영구적으로 삭제할 수 있습니다. 요청은 다음과 같이 구성됩니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/revisions/{revisionId}\n```\n여기서 `{revisionId}`는 삭제할 수정사항의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions.txt"}
{"question": "revisions 리소스의 'keepForever' 필드는 어떤 의미인가요?", "answer": "'keepForever' 필드는 이 버전이 더 이상 헤드 버전이 아니더라도 영구적으로 보관할지 여부를 나타냅니다. 설정하지 않으면 최신 콘텐츠가 업로드된 후 30일이 지나면 버전이 자동으로 삭제됩니다. 이 필드는 Drive의 바이너리 콘텐츠가 있는 파일에만 적용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions.txt"}
{"question": "Google Drive에서 파일 버전을 삭제할 때 어떤 파일 형식이 지원되나요?", "answer": "Google Drive에서 이미지나 동영상과 같은 바이너리 콘텐츠가 포함된 파일의 버전만 삭제할 수 있습니다. Google Docs 또는 Sheets와 같은 다른 파일의 버전 및 마지막으로 남은 파일 버전은 삭제할 수 없습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_delete.txt"}
{"question": "revisions.delete 메서드를 호출할 때 필요한 HTTP 요청 형식은 무엇인가요?", "answer": "revisions.delete 메서드는 다음과 같은 HTTP 요청 형식을 사용합니다:\n\n```\nDELETE https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\n```\n여기서 {fileId}는 파일의 ID, {revisionId}는 버전의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_delete.txt"}
{"question": "revisions.delete 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "revisions.delete 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_delete.txt"}
{"question": "revisions.delete 메서드 호출 시 성공적인 응답은 어떤 형태인가요?", "answer": "revisions.delete 메서드를 성공적으로 호출하면 응답 본문은 빈 JSON 객체입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_delete.txt"}
{"question": "revisions.delete 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "revisions.delete 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/delete?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_delete.txt"}
{"question": "revisions.get 메서드를 사용하여 특정 파일의 버전 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\n```\n여기서 {fileId}는 파일의 ID이고, {revisionId}는 버전의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_get.txt"}
{"question": "revisions.get 메서드에서 acknowledgeAbuse 쿼리 매개변수의 역할은 무엇인가요?", "answer": "acknowledgeAbuse 쿼리 매개변수는 사용자가 알려진 멀웨어나 기타 악성 파일을 다운로드할 때 따르는 위험을 인정하는지 여부를 나타냅니다. 이는 alt 매개변수가 media로 설정되어 있고 사용자가 파일의 소유자이거나 파일이 있는 공유 드라이브의 주최자인 경우에만 적용됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_get.txt"}
{"question": "revisions.get 메서드의 요청 본문은 어떻게 구성되나요?", "answer": "revisions.get 메서드의 요청 본문은 비어 있어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_get.txt"}
{"question": "revisions.get 메서드를 호출했을 때 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "성공한 경우 응답 본문에 Revision의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_get.txt"}
{"question": "revisions.get 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "revisions.get 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/get?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_get.txt"}
{"question": "revisions.list 메서드를 사용하여 특정 파일의 버전을 나열하는 방법은 무엇인가요?", "answer": "revisions.list 메서드를 사용하여 특정 파일의 버전을 나열하려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/revisions\n```\n여기서 {fileId}는 파일의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_list.txt"}
{"question": "revisions.list 메서드의 pageSize 쿼리 매개변수는 어떤 역할을 하나요?", "answer": "pageSize 쿼리 매개변수는 페이지당 반환할 최대 버전 수를 설정하는 데 사용됩니다. 이 매개변수를 통해 한 번에 가져올 수 있는 버전의 수를 조절할 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_list.txt"}
{"question": "revisions.list 메서드의 응답 본문 구조는 어떻게 되나요?", "answer": "revisions.list 메서드의 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  \"revisions\": [\n    {\n      object (Revision)\n    }\n  ],\n  \"nextPageToken\": string,\n  \"kind\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_list.txt"}
{"question": "revisions.list 메서드에서 nextPageToken의 역할은 무엇인가요?", "answer": "nextPageToken은 다음 버전의 페이지 토큰으로, 버전 목록의 끝에 도달한 경우 이 값이 없습니다. 이 값이 채워져 있으면 결과의 추가 페이지를 가져와야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_list.txt"}
{"question": "revisions.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?", "answer": "revisions.list 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/list?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_list.txt"}
{"question": "revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 어떤 HTTP 요청을 사용해야 하나요?", "answer": "revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{revisionId}`는 업데이트할 버전의 ID입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_update.txt"}
{"question": "revisions.update 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?", "answer": "revisions.update 메서드의 요청 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함되어야 합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_update.txt"}
{"question": "revisions.update 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?", "answer": "revisions.update 메서드를 호출한 후 성공적인 경우 응답 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함됩니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_update.txt"}
{"question": "revisions.update 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?", "answer": "revisions.update 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_update.txt"}
{"question": "revisions.update 메서드의 경로 매개변수로 사용되는 fileId와 revisionId는 무엇을 의미하나요?", "answer": "revisions.update 메서드의 경로 매개변수로 사용되는 `fileId`는 파일의 ID를 의미하며, `revisionId`는 업데이트할 버전의 ID를 의미합니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_revisions_update.txt"}
{"question": "Drive API에서 사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 어떻게 되나요?", "answer": "사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 다음과 같습니다:\n```json\n{\n  \"displayName\": string,\n  \"kind\": string,\n  \"me\": boolean,\n  \"permissionId\": string,\n  \"emailAddress\": string,\n  \"photoLink\": string\n}\n```", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_User.txt"}
{"question": "User 리소스에서 'displayName' 필드는 어떤 정보를 담고 있나요?", "answer": "'displayName' 필드는 사용자의 표시 가능한 일반 텍스트 이름을 담고 있습니다. 이 필드는 출력 전용입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_User.txt"}
{"question": "User 리소스의 'kind' 필드는 어떤 값을 가지며, 그 의미는 무엇인가요?", "answer": "'kind' 필드는 리소스 종류를 식별하며, 고정 문자열 'drive#user' 값을 가집니다. 이 필드는 출력 전용입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_User.txt"}
{"question": "'me' 필드는 어떤 정보를 나타내며, 그 데이터 타입은 무엇인가요?", "answer": "'me' 필드는 이 사용자가 요청하는 사용자인지 여부를 나타내며, 데이터 타입은 boolean입니다. 이 필드는 출력 전용입니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_User.txt"}
{"question": "사용자의 이메일 주소는 어떤 필드에서 확인할 수 있으며, 이 필드의 특성은 무엇인가요?", "answer": "사용자의 이메일 주소는 'emailAddress' 필드에서 확인할 수 있습니다. 이 필드는 출력 전용이며, 사용자가 요청자에게 이메일 주소를 표시하지 않은 경우 특정 컨텍스트에 표시되지 않을 수 있습니다.", "source": ["https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko"], "tags": "drive", "last_verified": "2025-08-19", "source_file": "workspace_drive_api_reference_rest_v3_User.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들기 위해 필요한 사전 준비 사항은 무엇인가요?", "answer": "커스텀 토큰을 만들기 위해서는 서비스 계정 JSON 파일을 사용하거나, Admin SDK의 서비스 계정 탐색을 허용하거나, 서비스 계정 ID를 사용해야 합니다. 각 방법에 대한 자세한 내용은 문서에서 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "서드 파티 JWT 라이브러리를 사용하여 커스텀 토큰을 만드는 방법은 무엇인가요?", "answer": "Firebase Admin SDK로 커스텀 토큰을 만들 수 없는 경우, 서드 파티 JWT 라이브러리를 사용하여 커스텀 토큰을 생성할 수 있습니다. 이 방법은 Firebase가 지원하지 않는 언어로 서버가 작성된 경우에 유용합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "서비스 계정 JSON 파일을 사용하여 Admin SDK를 초기화하는 방법은 무엇인가요?", "answer": "서비스 계정 JSON 파일을 통해 Admin SDK를 초기화하는 방법은 Admin SDK 설정 안내를 참조해야 합니다. 이 파일에는 서비스 계정과 관련된 모든 정보가 포함되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "커스텀 토큰을 사용하여 클라이언트에서 인증하는 방법은 무엇인가요?", "answer": "클라이언트 기기는 서버에서 반환된 커스텀 JWT를 사용하여 Firebase에 인증할 수 있습니다. 인증이 완료되면 이 ID는 Firebase Realtime Database, Cloud Storage 등의 다른 Firebase 서비스에 액세스하는 데 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "서비스 계정 JSON 파일을 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "서비스 계정 JSON 파일은 외부에 공개되지 않도록 각별히 주의해야 합니다. 이 파일에는 RSA 비공개 키가 포함되어 있어 보안에 매우 중요합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들기 위해 서비스 계정 JSON 파일을 사용하는 방법은 무엇인가요?", "answer": "서비스 계정 JSON 파일을 사용하여 Admin SDK를 초기화하는 방법은 Admin SDK 설정 안내를 참조하세요. 이 초기화 방법은 광범위한 Admin SDK 배포에 적합하며, Admin SDK로 원격 API 호출 없이 로컬에서 커스텀 토큰을 만들고 서명할 수 있습니다. 다음은 Python에서의 초기화 예시입니다:\n\n```python\ndefault_app = firebase_admin.initialize_app()\n```", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Google Cloud Functions에서 Firebase Admin SDK가 커스텀 토큰에 서명하는 방법은 무엇인가요?", "answer": "코드가 Google Cloud Functions와 같은 Google에서 관리하는 환경에 배포되면 Firebase Admin SDK가 로컬 메타데이터 서버에서 서비스 계정 ID 문자열을 자동으로 탐색하여 커스텀 토큰에 서명할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "서비스 계정 JSON 파일을 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "서비스 계정 JSON 파일은 외부에 공개되지 않도록 각별히 주의해야 하며, 공개 버전 제어에 추가하지 말아야 합니다. 또한, 이 파일에는 비공개 키가 포함되어 있으므로 기밀 유지를 위해 주의해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Admin SDK의 서비스 계정 탐색 허용을 사용하는 경우 어떤 환경에서 사용할 수 있나요?", "answer": "Admin SDK의 서비스 계정 탐색 허용은 Google Cloud Functions 및 App Engine과 같은 Google에서 관리하는 환경에서 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 초기화할 때 서비스 계정 ID 문자열을 지정하지 않아야 하는 이유는 무엇인가요?", "answer": "서비스 계정 ID 문자열을 지정하지 않으면 Google 애플리케이션 기본 사용자 인증 정보를 통해 SDK가 자동으로 서비스 계정 ID를 탐색하여 커스텀 토큰에 서명할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 서비스 계정 ID를 명시적으로 지정하는 방법은 무엇인가요?", "answer": "--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko#node.js] ---\n```\ninitializeApp({\nserviceAccountId: 'my-client-id@my-project-id.iam.gserviceaccount.com',\n```\n\n--- 탭: Java [https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko#java] ---\n```\nFirebaseOptions options = FirebaseOptions.builder()\n.setCredentials(GoogleCredentials.getApplicationDefault())\n.setServiceAccountId(\"my-client-id@my-project-id.iam.gserviceaccount.com\")\n.build();\nFirebaseApp.initializeApp(options);\n```\n\n--- 탭: Python [https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko#python] ---\n```\noptions = {\n'serviceAccountId': 'my-client-id@my-project-id.iam.gservice\n```", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 서비스 계정 ID를 사용하는 이유는 무엇인가요?", "answer": "서비스 계정 ID를 사용하면 애플리케이션의 다양한 부분에서 일관성을 유지할 수 있으며, Google이 관리하는 환경에서 실행할 때 이 ID의 키가 토큰 서명에 사용됩니다. 이렇게 하면 IAM 정책을 보다 간단하고 안전하게 만들 수 있으며 코드에 서비스 계정 JSON 파일을 포함할 필요가 없습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK가 자동으로 서비스 계정 ID를 탐색하는 경우 어떤 환경에서 가능한가요?", "answer": "코드가 Java, Python 또는 Go용 App Engine 표준 환경에서 배포되는 경우 Admin SDK는 해당 환경에 있는 앱 ID 서비스를 사용하여 커스텀 토큰에 서명할 수 있습니다. 기타 관리형 환경에서 배포되는 경우(예: Google Cloud Functions, Google Compute Engine) Firebase Admin SDK가 로컬 메타데이터 서버에서 서비스 계정 ID 문자열을 자동으로 탐색할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 필요한 iam.serviceAccounts.signBlob 권한은 무엇인가요?", "answer": "명시적으로 지정된 서비스 계정 ID와 마찬가지로 자동 탐색된 서비스 계정 ID에서 커스텀 토큰 만들기가 작동하려면 iam.serviceAccounts.signBlob 권한이 필요합니다. 기본 서비스 계정에 필수 권한을 부여하기 위해 Google Cloud 콘솔의 IAM 및 관리 섹션을 사용해야 할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 초기화할 때 서비스 계정 JSON 파일을 사용하지 않고 Google 애플리케이션 기본 사용자 인증 정보를 사용하는 방법은 무엇인가요?", "answer": "이 서명 방식을 사용하려면 Google 애플리케이션 기본 사용자 인증 정보를 통해 SDK를 초기화하고, 서비스 계정 ID 문자열은 지정하지 마세요.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 uid는 무엇인가요?", "answer": "uid는 인증하는 사용자 또는 기기를 고유하게 식별하는 임의의 문자열입니다. 커스텀 토큰을 만들기 위해서는 이 uid를 제공해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 토큰을 만들 때 추가 클레임을 어떻게 지정하나요?", "answer": "추가 클레임은 Map<String, Object> 형태로 지정할 수 있습니다. 예를 들어, 다음과 같이 추가 클레임을 설정할 수 있습니다:\n```java\nMap<String, Object> additionalClaims = new HashMap<String, Object>();\nadditionalClaims.put(\"premiumAccount\", true);\nString customToken = FirebaseAuth.getInstance().createCustomToken(uid, additionalClaims);\n```", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 예약된 클레임은 무엇인가요?", "answer": "Firebase 토큰은 OpenID Connect JWT 사양을 준수하므로 다음과 같은 클레임은 예약되어 있으며 추가 클레임 내에 지정할 수 없습니다: acr, amr, at_hash, aud, auth_time, azp, cnf, c_hash, exp, iat, iss, jti, nbf, nonce, sub. 또한 Firebase에는 firebase와 user_id라는 예약된 클레임이 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 토큰을 만들기 위해 필요한 권한은 무엇인가요?", "answer": "커스텀 토큰 만들기가 작동하려면 iam.serviceAccounts.signBlob 권한이 필요합니다. 이 권한은 Google Cloud 콘솔의 IAM 및 관리 섹션을 통해 부여할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 서비스 계정 ID를 명시적으로 지정하는 방법은 무엇인가요?", "answer": "서비스 계정 ID를 명시적으로 지정하려면 SDK를 다음과 같이 초기화합니다:\n```javascript\ninitializeApp({\n  serviceAccountId: 'my-client-id@my-project-id.iam.gserviceaccount.com',\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 uid는 어떻게 설정하나요?", "answer": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 uid는 인증하는 사용자 또는 기기를 고유하게 식별하는 임의의 문자열입니다. 다음과 같이 설정할 수 있습니다.\n\n```javascript\nString uid = \"some-uid\";\nString customToken = FirebaseAuth.getInstance().createCustomToken(uid);\n```\n위 코드에서 uid는 사용자의 고유 식별자로 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 토큰을 만들 때 추가 클레임을 어떻게 지정하나요?", "answer": "Firebase Admin SDK에서 커스텀 토큰을 만들 때 추가 클레임은 다음과 같이 지정할 수 있습니다. 추가 클레임은 Map 형태로 전달됩니다.\n\n```java\nMap<String, Object> additionalClaims = new HashMap<String, Object>();\nadditionalClaims.put(\"premiumAccount\", true);\nString customToken = FirebaseAuth.getInstance().createCustomToken(uid, additionalClaims);\n```\n위 코드에서 'premiumAccount'는 추가 클레임의 예시입니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 예약된 클레임은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 예약된 클레임은 다음과 같습니다:\n\n| acr | amr | at_hash | aud |\n| --- | --- | --- | --- |\n| auth_time | azp | cnf | c_hash |\n| exp | iat | iss | jti |\n| nbf | nonce | sub |  |\n\n또한 Firebase에는 다음과 같은 예약된 클레임이 있습니다:\n\n| firebase | user_id |\n| --- | --- |", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 토큰의 만료 시간은 어떻게 설정하나요?", "answer": "Firebase Admin SDK에서 커스텀 토큰은 기본적으로 1시간 후에 만료됩니다. 만료 시간을 변경하려면 추가 클레임을 사용하여 'exp' 클레임을 설정해야 합니다. 그러나 기본적으로는 1시간으로 설정되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "클라이언트에서 커스텀 토큰으로 로그인하는 방법은 무엇인가요?", "answer": "클라이언트에서 커스텀 토큰으로 로그인하려면, 커스텀 토큰을 생성한 후 클라이언트 앱에서 다음과 같이 `signInWithCustomToken()` 메서드를 호출하여 인증을 진행합니다.\n\n```javascript\nfirebase.auth().signInWithCustomToken(token)\n.then((userCredential) => {\n  // 로그인 성공 시 처리\n})\n.catch((error) => {\n  // 로그인 실패 시 처리\n});\n```\n위 코드에서 'token'은 생성한 커스텀 토큰입니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "클라이언트 앱에서 커스텀 토큰으로 인증하기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "클라이언트 앱은 `signInWithCustomToken()` 메서드를 호출하여 커스텀 토큰으로 인증을 진행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 생성한 후 클라이언트 앱으로 전송하는 방법은 무엇인가요?", "answer": "커스텀 토큰을 생성한 후에는 이 토큰을 Firebase 인증에 사용할 수 있도록 클라이언트 앱으로 전송합니다. 방법은 아래 코드 샘플을 참조하세요.\n\n```javascript\nfirebase.auth().signInWithCustomToken(token)\n.then((userCredential) => {\n  // Handle successful sign-in\n})\n.catch((error) => {\n  // Handle error\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "커스텀 토큰을 사용하여 클라이언트에서 인증할 때 발생할 수 있는 일반적인 문제는 무엇인가요?", "answer": "커스텀 토큰을 사용하여 인증할 때 발생할 수 있는 일반적인 문제는 IAM API가 사용 설정되지 않았거나 서비스 계정에 필수 권한이 없는 경우입니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "IAM API가 사용 설정되지 않았을 때 발생하는 오류 메시지는 무엇인가요?", "answer": "IAM API가 사용 설정되지 않았을 때 발생하는 오류 메시지는 다음과 같습니다: `Identity and Access Management (IAM) API has not been used in project 1234567890 before or it is disabled.`", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK가 커스텀 토큰을 만들 때 필요한 서비스 계정 권한은 무엇인가요?", "answer": "Firebase Admin SDK가 커스텀 토큰을 만들 때 필요한 서비스 계정 권한은 `iam.serviceAccounts.signBlob`입니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 IAM API가 사용 설정되지 않았을 때 발생하는 오류 메시지는 무엇인가요?", "answer": "IAM API가 사용 설정되지 않았을 때 발생하는 오류 메시지는 다음과 같습니다: \n\nIdentity and Access Management (IAM) API has not been used in project 1234567890 before or it is disabled. Enable it by visiting https://console.developers.google.com/apis/api/iam.googleapis.com/overview?project=1234567890 then retry. If you enabled this API recently, wait a few minutes for the action to propagate to our systems and retry.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 서비스 계정에 필수 권한이 없을 때 발생하는 오류 메시지는 무엇인가요?", "answer": "서비스 계정에 필수 권한이 없을 때 발생하는 오류 메시지는 다음과 같습니다: \n\nPermission iam.serviceAccounts.signBlob is required to perform this operation on service account projects/-/serviceAccounts/{your-service-account-id}.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 만들 때 서비스 계정에 '서비스 계정 토큰 생성자' IAM 역할을 부여하는 방법은 무엇인가요?", "answer": "서비스 계정에 '서비스 계정 토큰 생성자' IAM 역할을 부여하는 방법은 다음과 같습니다: \n1. Google Cloud 콘솔에서 IAM 및 관리 페이지를 엽니다. \n2. 프로젝트를 선택하고 '계속'을 클릭합니다. \n3. 업데이트할 서비스 계정에 해당하는 수정 아이콘을 클릭합니다. \n4. '다른 역할 추가'를 클릭합니다. \n5. 검색 필터에 '서비스 계정 토큰 생성자'를 입력하고 결과에서 이를 선택합니다. \n6. '저장'을 클릭하여 역할 부여를 확인합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK가 올바르게 초기화되지 않았을 때 발생하는 오류 메시지는 무엇인가요?", "answer": "Firebase Admin SDK가 올바르게 초기화되지 않았을 때 발생하는 오류 메시지는 다음과 같습니다: \n\nFailed to determine service account ID. Initialize the SDK with service account credentials or specify a service account ID with iam.serviceAccounts.signBlob permission.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 통해 서비스 계정 ID를 자동 탐색할 때 주의해야 할 점은 무엇인가요?", "answer": "서비스 계정 ID를 자동 탐색할 때는 코드가 메타데이터 서버를 통해 관리형 Google 환경에 배포되는지 확인해야 합니다. 그렇지 않은 경우 SDK 초기화 시 서비스 계정 JSON 파일 또는 서비스 계정 ID를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_create-custom-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자에게 커스텀 클레임을 설정하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 커스텀 클레임을 설정하려면 다음과 같은 코드를 사용할 수 있습니다. \n```javascript\n.setCustomUserClaims(uid, { admin: true })\n.then(() => {\n  Map<String, Object> claims = new HashMap<>();\n  claims.put(\"admin\", true);\n  FirebaseAuth.getInstance().setCustomUserClaims(uid, claims);\n  if err != nil {\n    log.Fatalf(\"error setting custom claims %v\\n\", err)\n  }\n```\n이 코드는 특정 사용자(uid)에게 'admin'이라는 커스텀 클레임을 설정합니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "클라이언트에서 커스텀 클레임에 접근하는 방법은 무엇인가요?", "answer": "클라이언트에서 커스텀 클레임에 접근하려면, 사용자 레코드에서 클레임을 가져올 수 있습니다. 예를 들어, Python에서는 다음과 같이 사용할 수 있습니다. \n```python\n# Lookup the user associated with the specified uid.\nuser = auth.get_user(uid)\n# The claims can be accessed on the user record.\nprint(user.custom_claims.get('admin'))\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 클라이언트에 전파하는 방법은 무엇인가요?", "answer": "Admin SDK를 통해 사용자의 새 클레임을 수정하면, 클레임은 클라이언트 측의 인증된 사용자에게 ID 토큰을 통해 전파됩니다. 사용자가 로그인하거나 다시 인증할 때 발급되는 ID 토큰에 최신 클레임이 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 클레임을 설정할 때 주의해야 할 점은 무엇인가요?", "answer": "커스텀 클레임은 민감한 정보를 포함할 수 있으므로, 관리자 권한 서버 환경에서 Firebase Admin SDK를 통해서만 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 사용하여 데이터베이스 접근을 제한하는 방법은 무엇인가요?", "answer": "예를 들어, 'adminContent'라는 데이터베이스 노드에 대한 접근을 제한하려면 다음과 같은 Realtime Database 규칙을 사용할 수 있습니다. \n```json\n\"rules\": {\n  \"adminContent\": {\n    \".read\": \"auth.token.admin === true\",\n    \".write\": \"auth.token.admin === true\"\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 클레임을 설정한 후, 클라이언트에서 해당 클레임을 어떻게 가져올 수 있나요?", "answer": "커스텀 클레임은 사용자의 ID 토큰을 통해서만 검색할 수 있습니다. 사용자의 역할이나 액세스 수준에 따라 클라이언트 UI를 수정하려면 이러한 클레임에 액세스해야 할 수 있습니다. ID 토큰을 가져오는 방법으로 해당 클레임을 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 클레임을 설정한 후, 클라이언트에서 ID 토큰을 갱신하는 방법은 무엇인가요?", "answer": "ID 토큰을 갱신하려면 `currentUser.getIdToken(true)`을 호출하여 강제로 ID 토큰을 새로고칠 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 사용하여 데이터베이스 접근을 제한할 때, 어떤 Realtime Database 규칙을 사용할 수 있나요?", "answer": "다음과 같은 Realtime Database 규칙을 사용할 수 있습니다: \n```json\n\"rules\": {\n  \"adminContent\": {\n    \".read\": \"auth.token.admin === true\",\n    \".write\": \"auth.token.admin === true\"\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 클레임을 설정할 때, 어떤 환경에서 설정해야 하나요?", "answer": "커스텀 클레임은 민감한 정보를 포함할 수 있으므로 관리자 권한 서버 환경에서 Firebase Admin SDK를 통해서만 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "클라이언트에서 커스텀 클레임을 전파하기 위해 사용자가 어떤 작업을 해야 하나요?", "answer": "커스텀 클레임이 수정된 후 사용자가 로그인하거나 다시 인증해야 하며, 그 결과로 발급되는 ID 토큰에 최신 클레임이 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 클레임을 설정한 후, 클라이언트에서 ID 토큰을 강제로 새로 고치는 방법은 무엇인가요?", "answer": "ID 토큰을 강제로 새로 고치려면, 클라이언트에서 다음 메서드를 호출합니다: `currentUser.getIdToken(true)`.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 클라이언트에서 가져오는 방법은 무엇인가요?", "answer": "커스텀 클레임은 사용자의 ID 토큰을 통해 검색할 수 있습니다. 다음과 같이 ID 토큰 결과를 가져올 수 있습니다: \n```javascript\nfirebase.auth().currentUser.getIdTokenResult()\n.then((idTokenResult) => {\n  // 클레임에 접근\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 클레임을 설정할 때, 기존 클레임을 덮어쓰지 않고 추가하는 방법은 무엇인가요?", "answer": "기존 클레임을 덮어쓰지 않고 추가하려면, 현재 클레임을 가져온 후 수정하여 설정합니다. 예를 들어: \n```javascript\ngetAuth()\n  .getUserByEmail('user@admin.example.com')\n  .then((user) => {\n    Map<String, Object> currentClaims = user.getCustomClaims();\n    currentClaims['accessLevel'] = 10; // 추가 클레임\n    FirebaseAuth.getInstance().setCustomUserClaims(user.getUid(), currentClaims);\n  });\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 설정한 후, 클라이언트에서 해당 클레임을 사용하여 UI를 수정하는 방법은 무엇인가요?", "answer": "클라이언트에서 ID 토큰을 검증하고 클레임을 파싱한 후, 해당 클레임을 사용하여 UI를 수정할 수 있습니다. 예를 들어: \n```javascript\nfirebase.auth().currentUser.getIdTokenResult()\n.then((idTokenResult) => {\n  if (idTokenResult.claims.admin) {\n    // 관리자 UI 수정\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "커스텀 클레임을 설정한 후, 클라이언트에서 해당 클레임을 전파하기 위해 사용자가 어떤 작업을 해야 하나요?", "answer": "사용자는 로그인하거나 다시 인증하여 커스텀 클레임이 포함된 ID 토큰을 발급받아야 합니다. 이 과정에서 ID 토큰이 갱신됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_custom-claims_hl=ko.txt"}
{"question": "ActionCodeSettings 인스턴스를 초기화할 때 어떤 매개변수를 제공해야 하나요?", "answer": "| 매개변수 | 유형 | 설명 |\n| --- | --- | --- |\n| url | 문자열 | 컨텍스트에 따라 다른 의미를 가지는 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다. 앱에서 링크가 직접 처리되는 경우 Hosting 링크의 딥 링크에 있는 continueUrl 쿼리 파라미터입니다. |\n| iOS | ({bundleId: string}\\|undefined) | Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| android | ({packageName: string, installApp:boolean\\|undefined, minimumVersion: string\\|undefined}\\|undefined) | Firebase Authentication이 Android 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| handleCodeInApp | (boolean\\|undefined) | 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다. true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성하기 위해 Firebase Admin SDK를 사용하는 이유는 무엇인가요?", "answer": "Firebase Admin SDK를 사용하면 비밀번호 재설정, 이메일 주소 확인, 이메일 기반 로그인에 사용할 수 있는 링크를 프로그래매틱 방식으로 생성할 수 있습니다. 이를 통해 자체 이메일 템플릿과 이메일 전송 서비스를 이용하여 사용자에게 맞춤형 이메일을 보낼 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 구성할 때 어떤 기능을 맞춤설정할 수 있나요?", "answer": "이메일 작업 링크를 구성할 때 다음과 같은 기능을 맞춤설정할 수 있습니다:\n- 이메일 템플릿 맞춤설정\n- 컨텍스트별로 템플릿 적용\n- 맞춤설정된 이메일 템플릿 현지화\n- 안전한 서버 환경에서 링크 생성\n- 링크를 여는 방법(모바일 앱과 브라우저 중 선택) 및 추가 상태 정보 전달", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 모바일 앱에서 처리하기 위해 어떤 작업을 수행해야 하나요?", "answer": "이메일 작업 링크를 모바일 앱에서 처리하기 위해서는 모바일 앱이 이러한 링크를 감지하도록 몇 가지 작업을 수행해야 합니다. 이메일 작업에 모바일 링크를 구성하는 방법에 대한 안내를 참조해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "Firebase 클라이언트 SDK를 사용하여 이메일 작업 링크를 생성할 수 있는 작업은 무엇인가요?", "answer": "Firebase 클라이언트 SDK를 사용하여 비밀번호 재설정, 이메일 주소 확인, 이메일 기반 로그인에 사용할 수 있는 링크가 포함된 이메일을 사용자에게 보낼 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 ActionCodeSettings 인스턴스를 초기화하는 방법은 무엇인가요?", "answer": "ActionCodeSettings 인스턴스를 초기화하려면 다음 데이터를 제공합니다.\n\n| 매개변수 | 유형 | 설명 |\n| --- | --- | --- |\n| url | 문자열 | 컨텍스트에 따라 다른 의미를 가지는 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다. 앱에서 링크가 직접 처리되는 경우 Hosting 링크의 딥 링크에 있는 continueUrl 쿼리 파라미터입니다. |\n| iOS | ({bundleId: string}\\|undefined) | Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| android | ({packageName: string, installApp:boolean\\|undefined, minimumVersion: string\\|undefined}\\|undefined) | Firebase Authentication이 Android 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| handleCodeInApp | (boolean\\|undefined) | 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다. true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다. |\n| linkDomain | (string\\|undefined) | 프로젝트에 커스텀 호스팅 링크 도메인이 정의된 경우 지정된 모바일 앱에서 링크를 열 때 사용할 도메인을 지정합니다. 그렇지 않으면 기본 도메인이 자동으로 선택됩니다(예: PROJECT_ID.firebaseapp.com). |\n| dynamicLinkDomain | (string\\|undefined) | 지원 중단되었습니다. 이 파라미터를 지정하지 마세요.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 모바일 앱에서 처리하기 위해 어떤 작업을 수행해야 하나요?", "answer": "모바일 앱을 통해 열어야 하는 링크의 경우 모바일 앱에서 이러한 링크를 감지하도록 몇 가지 작업을 수행해야 합니다. 이메일 작업에 모바일 링크를 구성하는 방법에 대한 안내를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "ActionCodeSettings의 handleCodeInApp 매개변수는 어떤 역할을 하나요?", "answer": "handleCodeInApp 매개변수는 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다. true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 사용할 수 있는 Android 관련 매개변수는 무엇인가요?", "answer": "ActionCodeSettings에서 사용할 수 있는 Android 관련 매개변수는 다음과 같습니다:\n- android: ({packageName: string, installApp:boolean\\|undefined, minimumVersion: string\\|undefined}\\|undefined) - Firebase Authentication이 Android 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 사용할 수 있는 iOS 관련 매개변수는 무엇인가요?", "answer": "ActionCodeSettings에서 사용할 수 있는 iOS 관련 매개변수는 다음과 같습니다:\n- iOS: ({bundleId: string}\\|undefined) - Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 handleCodeInApp 매개변수를 true로 설정하면 어떤 결과가 발생하나요?", "answer": "handleCodeInApp 매개변수를 true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 linkDomain 매개변수는 어떤 역할을 하나요?", "answer": "linkDomain 매개변수는 프로젝트에 커스텀 호스팅 링크 도메인이 정의된 경우 지정된 모바일 앱에서 링크를 열 때 사용할 도메인을 지정합니다. 그렇지 않으면 기본 도메인이 자동으로 선택됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 dynamicLinkDomain 매개변수는 어떻게 처리해야 하나요?", "answer": "dynamicLinkDomain 매개변수는 지원 중단되었습니다. 이 파라미터를 지정하지 마세요.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 모바일 앱에서 먼저 열리도록 설정하는 방법은 무엇인가요?", "answer": "이메일 작업 링크를 모바일 앱에서 먼저 열리도록 설정하려면 ActionCodeSettings 인스턴스를 초기화할 때 handleCodeInApp 매개변수를 true로 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 작업 링크를 생성할 때 사용할 수 있는 URL 페이로드의 예시는 무엇인가요?", "answer": "이메일 작업 링크를 생성할 때 사용할 수 있는 URL 페이로드의 예시는 다음과 같습니다: https://www.example.com/checkout?cartId=1234", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성할 때 ActionCodeSettings 객체의 역할은 무엇인가요?", "answer": "ActionCodeSettings 객체는 로그인을 완료하기 위해 링크를 클릭한 후 사용자를 어디로 보낼지에 대한 정보를 제공합니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하기 위해 필요한 이메일은 어떤 것인가요?", "answer": "이메일 링크 로그인을 생성할 때 사용되는 이메일은 기존 사용자의 이메일이 아니어도 됩니다. 이메일 링크를 통해 새 사용자를 앱에 가입시키는 데 이 작업을 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하는 Node.js 코드 예시는 어떻게 되나요?", "answer": "다음은 이메일 링크 로그인을 생성하는 Node.js 코드 예시입니다:\n```javascript\n.generateSignInWithEmailLink(useremail, actionCodeSettings)\n.then((link) => {\nString email = \"user@example.com\";\ntry {\nString link = FirebaseAuth.getInstance().generateSignInWithEmailLink(\nemail, actionCodeSettings);\nSystem.out.println(\"Error generating email link: \" + e.getMessage());\nlink = auth.generate_sign_in_with_email_link(email, action_code_settings)\n# Construct email from a template embedding the link, and send\n# using a custom SMTP server.\nsend_custom_email(email, link)\n```", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하는 Go 코드 예시는 어떻게 되나요?", "answer": "다음은 이메일 링크 로그인을 생성하는 Go 코드 예시입니다:\n```go\nemail := \"user@example.com\"\nlink, err := client.EmailSignInLink(ctx, email, actionCodeSettings)\nif err != nil {\nlog.Fatalf(\"error generating email link: %v\\n\", err)\n```", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성한 후 이메일을 어떻게 보낼 수 있나요?", "answer": "링크가 생성되면 링크를 커스텀 로그인 이메일에 삽입한 다음 커스텀 SMTP 서버를 사용하여 해당 사용자에게 이메일로 보낼 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하기 위해 Firebase 프로젝트에서 어떤 설정을 해야 하나요?", "answer": "이메일 링크 로그인으로 사용자를 인증하려면 Firebase 프로젝트에서 이메일 링크 로그인을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성할 때 ActionCodeSettings 객체는 어떤 정보를 제공하나요?", "answer": "ActionCodeSettings 객체는 로그인을 완료하기 위해 링크를 클릭한 후 사용자를 어디로 보낼지에 대한 정보를 제공합니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하는 Node.js 코드 예시는 어떻게 되나요?", "answer": "Node.js에서 이메일 링크 로그인을 생성하는 코드는 다음과 같습니다:\n```javascript\n.generateSignInWithEmailLink(useremail, actionCodeSettings)\n.then((link) => {\nString email = \"user@example.com\";\ntry {\nString link = FirebaseAuth.getInstance().generateSignInWithEmailLink(\nemail, actionCodeSettings);\nSystem.out.println(\"Error generating email link: \" + e.getMessage());\nlink = auth.generate_sign_in_with_email_link(email, action_code_settings)\n# Construct email from a template embedding the link, and send\n# using a custom SMTP server.\nsend_custom_email(email, link)\n```", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크 로그인을 생성하는 Go 코드 예시는 어떻게 되나요?", "answer": "Go에서 이메일 링크 로그인을 생성하는 코드는 다음과 같습니다:\n```go\nemail := \"user@example.com\"\nlink, err := client.EmailSignInLink(ctx, email, actionCodeSettings)\nif err != nil {\nlog.Fatalf(\"error generating email link: %v\\n\", err)\n```", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "이메일 링크가 생성된 후 어떻게 사용자에게 이메일을 보낼 수 있나요?", "answer": "링크가 생성되면 링크를 커스텀 로그인 이메일에 삽입한 다음 커스텀 SMTP 서버를 사용하여 해당 사용자에게 이메일로 보낼 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/email-action-links?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_email-action-links_hl=ko.txt"}
{"question": "setCustomUserClaims() 메서드에서 발생할 수 있는 오류는 무엇인가요?", "answer": "setCustomUserClaims()에 제공된 클레임 페이로드가 최대 허용 크기인 1,000바이트를 초과하면 'auth/claims-too-large' 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "Firebase ID 토큰이 만료되었을 때 발생하는 오류는 무엇인가요?", "answer": "'auth/id-token-expired' 오류가 발생하며, 이는 제공된 Firebase ID 토큰이 만료되었음을 나타냅니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "Admin SDK 초기화에 사용된 사용자 인증 정보에 권한이 없을 때 어떤 오류가 발생하나요?", "answer": "'auth/insufficient-permission' 오류가 발생합니다. 이는 요청한 Authentication 리소스에 액세스할 권한이 없음을 의미합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "createCustomToken() 메서드를 사용할 때 어떤 인증 정보를 사용해야 하나요?", "answer": "createCustomToken() 메서드는 사용자 인증 정보 인증서로 SDK를 초기화해야 합니다. 사용자 인증 정보 인증서로 Admin SDK를 인증하는 방법은 SDK 초기화 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "이메일 주소가 잘못된 경우 어떤 오류가 발생하나요?", "answer": "'auth/invalid-email' 오류가 발생하며, 이는 email 사용자 속성에 제공된 값이 잘못되었음을 나타냅니다. 이 값은 문자열 이메일 주소여야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "disabled 사용자 속성에 잘못된 값을 제공했을 때 어떤 오류가 발생하나요?", "answer": "auth/invalid-disabled-field 오류가 발생합니다. 이 값은 부울이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "displayName 사용자 속성에 잘못된 값을 제공했을 때 어떤 오류가 발생하나요?", "answer": "auth/invalid-display-name 오류가 발생합니다. 이 값은 비어 있지 않은 문자열이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "제공된 ID 토큰이 올바르지 않을 때 어떤 오류가 발생하나요?", "answer": "auth/invalid-id-token 오류가 발생합니다. 제공된 ID 토큰이 올바른 Firebase ID 토큰이 아닙니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "password 사용자 속성에 잘못된 값을 제공했을 때 어떤 오류가 발생하나요?", "answer": "auth/invalid-password 오류가 발생합니다. 이 값은 6자 이상의 문자열이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "제공된 phoneNumber이 잘못되었을 때 어떤 오류가 발생하나요?", "answer": "auth/invalid-phone-number 오류가 발생합니다. 이 값은 E.164 표준과 호환되는 비어 있지 않은 식별자 문자열이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "providerData에 제공된 값이 잘못되었을 때 어떤 오류가 발생하나요?", "answer": "providerData가 올바른 UserInfo 객체 배열이어야 합니다. 이 경우 발생하는 오류는 auth/invalid-provider-data입니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "제공된 uid가 잘못되었을 때 어떤 오류가 발생하나요?", "answer": "제공된 uid는 128자(영문 기준) 이하의 비어 있지 않은 문자열이어야 합니다. 이 경우 발생하는 오류는 auth/invalid-uid입니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "가져올 수 있는 최대 사용자 수를 초과했을 때 어떤 오류가 발생하나요?", "answer": "가져올 수 있는 최대 사용자 수를 초과했을 때 발생하는 오류는 auth/maximum-user-count-exceeded입니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "제공된 phoneNumber이 이미 사용 중일 때 어떤 오류가 발생하나요?", "answer": "제공된 phoneNumber을 기존 사용자가 이미 사용 중일 때 발생하는 오류는 auth/phone-number-already-exists입니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "제공된 연결 URL이 허용 목록에 포함되어 있지 않을 때 어떤 오류가 발생하나요?", "answer": "연결 URL의 도메인이 허용 목록에 포함되어 있지 않을 때 발생하는 오류는 auth/unauthorized-continue-uri입니다.", "source": ["https://firebase.google.com/docs/auth/admin/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_errors_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 관리하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK는 승격된 권한으로 Firebase 사용자를 관리하는 API를 제공합니다. 이를 통해 사용자의 기존 인증 정보 없이도 클라이언트 측 비율 제한과 무관하게 프로그래매틱 방식으로 사용자를 검색, 생성, 업데이트, 삭제할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "커스텀 토큰을 생성하는 목적은 무엇인가요?", "answer": "커스텀 토큰을 생성하는 기본적인 목적은 사용자가 외부 또는 기존 인증 메커니즘을 통해 인증하는 방법을 제공하는 것입니다. 이러한 메커니즘은 LDAP 서버와 같이 개발자가 관리하는 서버일 수도 있고, Instagram, LinkedIn과 같이 Firebase가 기본적으로 지원하지 않는 타사 OAuth 제공업체일 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "ID 토큰을 확인하는 방법은 무엇인가요?", "answer": "Firebase Authentication으로 로그인한 클라이언트 애플리케이션에서 ID 토큰을 검색하고 서버로 보내는 요청에 이 토큰을 포함할 수 있습니다. 서버는 ID 토큰을 확인하고 사용자를 식별하는 클레임(사용자의 uid, 로그인에 사용한 ID 공급업체 등)을 추출합니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "커스텀 사용자 클레임을 사용하는 이유는 무엇인가요?", "answer": "커스텀 사용자 클레임은 이메일/비밀번호, Google, Facebook, 전화 등 지원되는 Firebase 인증 제공업체 중 하나를 통해 이미 로그인한 사용자의 액세스를 세밀하게 제어해야 할 때 사용됩니다. 커스텀 클레임과 애플리케이션 보안 규칙의 결합이 이러한 기능을 제공합니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 커스텀 토큰을 생성하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK에는 커스텀 토큰을 만드는 메서드가 내장되어 있습니다. 타사 JWT 라이브러리를 사용하여 어느 언어로든 프로그래매틱 방식으로 커스텀 토큰을 만들 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자의 ID 토큰을 확인하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK에는 ID 토큰을 확인하는 메서드가 내장되어 있습니다. 타사 JWT 라이브러리를 사용하여 어느 언어로든 프로그래매틱 방식으로 ID 토큰을 확인할 수도 있습니다. ID 토큰 확인 프로세스에 대한 자세한 내용과 코드 샘플은 ID 토큰 확인 [https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "커스텀 사용자 클레임을 사용하여 Firebase 인증에서 액세스를 제어하는 방법은 무엇인가요?", "answer": "커스텀 사용자 클레임과 애플리케이션 보안 규칙의 결합을 통해 이미 로그인한 사용자의 액세스를 세밀하게 제어할 수 있습니다. 예를 들어 Firebase Authentication의 이메일 및 비밀번호 제공업체를 통해 로그인한 사용자는 커스텀 클레임을 사용해 액세스 제어를 정의할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 프로그래매틱 방식으로 생성하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK는 승격된 권한으로 Firebase 사용자를 관리하는 API를 제공합니다. 관리자용 사용자 관리 API를 활용하면 사용자의 기존 인증 정보 없이도 클라이언트 측 비율 제한과 무관하게 프로그래매틱 방식으로 사용자를 검색, 생성, 업데이트, 삭제할 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/admin/manage-users?hl=ko]를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "커스텀 토큰을 생성하는 과정에서 서버가 해야 할 일은 무엇인가요?", "answer": "서버는 고유 식별자(uid)가 포함된 커스텀 토큰을 만들어 클라이언트 앱에 전달해야 하며, 클라이언트 앱은 이 토큰으로 Firebase에 로그인합니다. 커스텀 토큰 생성 프로세스에 대한 자세한 내용과 코드 샘플은 커스텀 토큰 만들기 [https://firebase.google.com/docs/auth/admin/create-custom-tokens?hl=ko]를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "ID 토큰을 사용하여 서버에서 사용자를 식별하는 이유는 무엇인가요?", "answer": "사용자가 Firebase 앱에 로그인할 때 Firebase에서 생성하는 ID 토큰으로 사용자를 안전하게 식별할 수 있습니다. ID 토큰은 OpenID Connect 사양을 준수하며 사용자를 식별하는 데이터와 함께 기타 프로필 및 인증 관련 정보를 포함합니다. 이를 통해 현재 로그인한 사용자를 안전하게 식별하고 내 백엔드 리소스에 대한 권한을 부여할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 ID 토큰을 확인하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK에는 ID 토큰을 확인하는 메서드가 내장되어 있습니다. 타사 JWT 라이브러리를 사용하여 어느 언어로든 프로그래매틱 방식으로 ID 토큰을 확인할 수도 있습니다. ID 토큰 확인 프로세스에 대한 자세한 내용과 코드 샘플은 ID 토큰 확인 [https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "ID 토큰을 사용하여 서버에서 사용자를 안전하게 식별하는 이유는 무엇인가요?", "answer": "사용자가 Firebase 앱에 로그인할 때 Firebase에서 생성하는 ID 토큰으로 사용자를 안전하게 식별할 수 있습니다. ID 토큰은 OpenID Connect 사양을 준수하며 사용자를 식별하는 데이터와 함께 기타 프로필 및 인증 관련 정보를 포함합니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "커스텀 사용자 클레임을 설정하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하면 사용자 계정에 맞춤 속성을 설정할 수 있습니다. 커스텀 사용자 클레임으로 사용자에게 다양한 수준의 액세스 권한(역할)을 부여한 후 애플리케이션 보안 규칙에 적용하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "ID 토큰의 커스텀 클레임을 클라이언트 측으로 전파하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 통해 사용자의 커스텀 클레임을 수정한 후 이를 ID 토큰으로 클라이언트 측의 인증된 사용자에 전파합니다. ID 토큰은 이러한 커스텀 클레임을 제공하는 신뢰할 수 있는 메커니즘으로서 모든 인증된 액세스에서 관련 요청을 처리하기 전에 ID 토큰의 유효성을 검사해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "서버에서 특정 사용자를 대신하여 Firebase Realtime Database 액세스를 에뮬레이션하는 방법은 무엇인가요?", "answer": "서버에서 특정 사용자를 대신하여 Firebase Realtime Database 액세스 등의 사용자 작업을 에뮬레이션하려면 우선 이 사용자의 ID 토큰을 확인하고 디코딩해야 합니다. 그런 다음 databaseAuthVariableOverride 옵션을 사용하여 서버의 권한을 제한합니다. 자세한 내용은 제한된 권한으로 인증 [https://firebase.google.com/docs/database/admin/start?hl=ko#authenticate-with-limited-privileges]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 한 번의 API 호출로 최대 몇 명의 사용자를 가져올 수 있나요?", "answer": "API 호출 한 번으로 최대 1,000명의 사용자를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "사용자 가져오기 API를 사용할 때 uid, email, phoneNumber 등의 중복 확인은 어떻게 처리되나요?", "answer": "이 작업은 속도에 맞춰 최적화되어 있으므로 uid, email, phoneNumber 및 기타 고유 식별자의 중복을 확인하지 않습니다. 기존 uid와 충돌하는 사용자를 가져오면 기존 사용자가 바뀝니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "사용자 가져오기 API를 사용할 때, 같은 email을 가진 사용자를 가져오면 어떻게 되나요?", "answer": "다른 필드가 중복된(예: email) 사용자를 가져오면 같은 값이 있는 사용자가 추가됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자별 오류가 발생했을 때, 전체 사용자 목록의 업로드는 어떻게 처리되나요?", "answer": "Firebase Authentication에서는 사용자별 오류가 발생해도 제공된 전체 사용자 목록의 업로드를 시도합니다. 이 작업으로 가져오기 성공 및 실패 요약이 포함된 결과가 반환됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "사용자 가져오기 API를 사용하여 HMAC 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "다음은 HMAC 해시 비밀번호를 사용하여 사용자를 가져오는 Node.js 코드 예시입니다:\n```javascript\ngetAuth()\n.importUsers(userImportRecords, {\nhash: {\nalgorithm: 'HMAC_SHA256',\nkey: Buffer.from('secretKey'),\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자 목록의 업로드 결과는 어떻게 확인하나요?", "answer": "사용자 가져오기 API를 사용하면 전체 사용자 목록의 업로드 시도 후 가져오기 성공 및 실패 요약이 포함된 결과가 반환됩니다. 오류 세부정보는 사용자 가져기 실패 작업별로 반환됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, HMAC 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "HMAC 해시 비밀번호를 가진 사용자를 가져오기 위해서는 UserImportOptions를 사용하여 해시 알고리즘과 키를 설정해야 합니다. 예를 들어, Node.js에서는 다음과 같이 설정할 수 있습니다:\n```javascript\ngetAuth()\n.importUsers(userImportRecords, {\nhash: {\nalgorithm: 'HMAC_SHA256',\nkey: Buffer.from('secretKey'),\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 uid가 기존 사용자와 충돌하면 어떻게 되나요?", "answer": "기존 uid와 충돌하는 사용자를 가져오면 기존 사용자가 바뀝니다. 따라서 uid는 고유해야 하며, 중복되지 않도록 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 email이 중복되면 어떻게 되나요?", "answer": "다른 필드가 중복된(예: email) 사용자를 가져오면 같은 값이 있는 사용자가 추가됩니다. 따라서 email 필드는 중복되지 않도록 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 최대 몇 명의 사용자를 가져올 수 있나요?", "answer": "API 호출 한 번으로 최대 1,000명의 사용자를 가져올 수 있습니다. 이 작업은 속도에 맞춰 최적화되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, scrypt 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "scrypt 해시 비밀번호를 가진 사용자를 가져오기 위해서는 다음과 같은 코드를 사용할 수 있습니다. 이 코드는 Firebase Admin SDK의 importUsers 메서드를 사용하여 사용자 정보를 가져옵니다.\n\n```javascript\ngetAuth()\n.importUsers(\n[\n  uid: 'some-uid',\n  email: 'user@example.com',\n  password_hash: base64.urlsafe_b64decode('password_hash'),\n  password_salt: base64.urlsafe_b64decode('salt')\n],\n)\n```\n\n여기서 `password_hash`와 `password_salt`는 각각 base64로 인코딩된 비밀번호 해시와 솔트입니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, HMAC 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "HMAC 해시 비밀번호를 가진 사용자를 가져오기 위해서는 다음과 같은 코드를 사용할 수 있습니다. 이 코드는 Firebase Admin SDK의 importUsers 메서드를 사용하여 사용자 정보를 가져옵니다.\n\n```javascript\ngetAuth()\n.importUsers(userImportRecords, {\n  hash: {\n    algorithm: 'HMAC_SHA256',\n    key: Buffer.from('secretKey'),\n  },\n});\n```\n\n여기서 `secretKey`는 HMAC 해시를 생성하는 데 사용되는 키입니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자 목록의 업로드 결과를 어떻게 확인하나요?", "answer": "가져온 사용자 목록의 업로드 결과는 `UserImportResult` 객체를 통해 확인할 수 있습니다. 다음은 결과를 확인하는 코드 예시입니다.\n\n```javascript\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nSystem.out.println(\"Successfully imported \" + result.getSuccessCount() + \" users\");\nSystem.out.println(\"Failed to import \" + result.getFailureCount() + \" users\");\nfor (ErrorInfo indexedError : result.getErrors()) {\n  System.out.println(\"Failed to import user at index: \" + indexedError.getIndex() + \" due to error: \" + indexedError.getReason());\n}\n```\n\n이 코드는 성공적으로 가져온 사용자 수와 실패한 사용자 수를 출력합니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 비밀번호 해시 매개변수는 어떻게 설정하나요?", "answer": "가져온 사용자의 비밀번호 해시 매개변수는 `UserImportOptions` 객체를 통해 설정할 수 있습니다. 다음은 scrypt 해시 매개변수를 설정하는 코드 예시입니다.\n\n```javascript\nUserImportOptions options = UserImportOptions.withHash(\n  Scrypt.builder()\n    .setKey(base64.b64decode('base64_secret'))\n    .setSaltSeparator(base64.b64decode('base64_salt_separator'))\n    .setRounds(8)\n    .setMemoryCost(14)\n);\n```\n\n여기서 각 매개변수는 Firebase 콘솔의 사용자 탭에서 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 email이 중복되면 어떻게 되나요?", "answer": "가져온 사용자의 email이 중복되는 경우, Firebase Admin SDK는 해당 email을 가진 기존 사용자와 충돌이 발생합니다. 이 경우, 충돌이 발생한 사용자에 대한 오류 정보는 `UserImportResult` 객체의 `getErrors()` 메서드를 통해 확인할 수 있습니다. 예를 들어, 다음과 같은 코드를 사용하여 오류를 출력할 수 있습니다.\n\n```javascript\nfor (ErrorInfo indexedError : result.getErrors()) {\n  System.out.println(\"Failed to import user at index: \" + indexedError.getIndex() + \" due to error: \" + indexedError.getReason());\n}\n```\n\n이 코드는 충돌이 발생한 사용자에 대한 오류 메시지를 출력합니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, scrypt 해시 알고리즘의 파라미터는 어떻게 설정하나요?", "answer": "scrypt 해시 알고리즘의 파라미터는 다음과 같이 설정할 수 있습니다:\n\n```java\nUserImportOptions options = UserImportOptions.withHash(\n    StandardScrypt.builder()\n        .setMemoryCost(1024)\n        .setParallelization(16)\n        .setBlockSize(8)\n        .setDerivedKeyLength(64)\n        .build()\n);\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, HMAC 해시 알고리즘을 사용하는 방법은 무엇인가요?", "answer": "HMAC 해시 알고리즘을 사용하는 방법은 다음과 같습니다:\n\n```java\nUserImportOptions options = UserImportOptions.withHash(\n    HmacSha256.builder()\n        .setKey(\"secret\".getBytes())\n        .build()\n);\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 비밀번호 해시를 설정하는 방법은 무엇인가요?", "answer": "가져온 사용자의 비밀번호 해시는 다음과 같이 설정할 수 있습니다:\n\n```java\nList<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()\n    .setUid(\"some-uid\")\n    .setEmail(\"user@example.com\")\n    .setPasswordHash(\"password-hash\".getBytes())\n    .setPasswordSalt(\"salt\".getBytes())\n    .build());\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자 목록의 업로드 결과를 확인하는 방법은 무엇인가요?", "answer": "가져온 사용자 목록의 업로드 결과는 다음과 같이 확인할 수 있습니다:\n\n```java\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nfor (ErrorInfo indexedError : result.getErrors()) {\n    System.out.println(\"Failed to import user: \" + indexedError.getReason());\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 email이 중복되면 어떻게 처리하나요?", "answer": "가져온 사용자의 email이 중복될 경우, Firebase Authentication에서는 중복된 email을 가진 사용자의 처리에 대한 명시적인 방법이 문서에 제공되지 않았습니다. 그러나 일반적으로 중복된 email을 가진 사용자는 기존 사용자 정보로 업데이트될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, PBKDF2_SHA256 해시 알고리즘을 사용하는 방법은 무엇인가요?", "answer": "PBKDF2_SHA256 해시 알고리즘을 사용하여 사용자를 가져오는 방법은 다음과 같습니다. \n\n```java\ngetAuth()\n.importUsers(\n[\nuid: 'some-uid',\nemail: 'user@example.com',\nList<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()\n.setUid(\"some-uid\")\n.setEmail(\"user@example.com\")\n.setPasswordHash(\"password-hash\".getBytes())\n.setPasswordSalt(\"salt\".getBytes())\n.build());\nUserImportOptions options = UserImportOptions.withHash(\nPbkdf2Sha256.builder()\n.setRounds(100000)\n.build());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nfor (ErrorInfo indexedError : result.getErrors()) {\nSystem.out.println(\"Failed to import user: \" + indexedError.getReason());\nSystem.out.println(\"Error importing users: \" + e.getMessage());\n}\n]\n)\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, HMAC_SHA256 해시 알고리즘을 사용하는 방법은 무엇인가요?", "answer": "HMAC_SHA256 해시 알고리즘을 사용하여 사용자를 가져오는 방법은 다음과 같습니다. \n\n```java\ngetAuth()\n.importUsers(\n[\nuid: 'some-uid',\nemail: 'user@example.com',\nList<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()\n.setUid(\"some-uid\")\n.setEmail(\"user@example.com\")\n.setPasswordHash(\"password-hash\".getBytes())\n.setPasswordSalt(\"salt\".getBytes())\n.build());\nUserImportOptions options = UserImportOptions.withHash(\nHmacSha256.builder()\n.setKey(\"secret\".getBytes())\n.build());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nfor (ErrorInfo indexedError : result.getErrors()) {\nSystem.out.println(\"Failed to import user: \" + indexedError.getReason());\nSystem.out.println(\"Error importing users: \" + e.getMessage());\n}\n]\n)\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, Scrypt 해시 알고리즘의 파라미터는 어떻게 설정하나요?", "answer": "Scrypt 해시 알고리즘의 파라미터를 설정하는 방법은 다음과 같습니다. \n\n```java\nUserImportOptions options = UserImportOptions.withHash(\nStandardScrypt.builder()\n.setMemoryCost(1024)\n.setParallelization(16)\n.setBlockSize(8)\n.setDerivedKeyLength(64)\n.build());\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, MD5 해시 알고리즘의 라운드 수는 어떻게 설정하나요?", "answer": "MD5 해시 알고리즘의 라운드 수를 설정하는 방법은 다음과 같습니다. \n\n```java\nUserImportOptions options = UserImportOptions.withHash(\nPbkdf2Sha256.builder()\n.setRounds(100000)\n.build());\n```\nMD5의 경우 라운드 수는 0에서 8192 사이의 값을 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, BCRYPT 해시 비밀번호의 추가 해시 매개변수는 무엇인가요?", "answer": "BCRYPT 해시 비밀번호의 경우 추가 해시 매개변수 및 사용자별 비밀번호 솔트가 필요 없습니다. BCRYPT 해시 알고리즘을 사용할 때는 별도의 설정이 필요하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, Argon2 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "Argon2 해시 비밀번호를 사용한 사용자 가져오기를 위해 Argon2 해시 객체를 구성해야 합니다. 필요한 매개변수는 다음과 같습니다:\n\n- hashLengthBytes: 원하는 해시 길이(바이트)\n- hashType: 사용할 Argon2 변형(ARGON2_D, ARGON2_ID, ARGON2_I)\n- parallelism: 동시 로드 정도(1 이상 16 이하)\n- iterations: 수행할 반복 횟수(1 이상 16 이상)\n- memoryCostKib: 이 알고리즘에 필요한 메모리 비용(키비바이트, 32,768 미만)\n- version: Argon2 알고리즘의 버전(VERSION_10 또는 VERSION_13, 선택사항)\n- associatedData: 추가 연결 데이터(바이트 배열, 선택사항)\n\n예제 코드는 다음과 같습니다:\n```java\n// Argon2 해시 객체 구성\nArgon2 argon2 = new Argon2(hashLengthBytes, hashType, parallelism, iterations, memoryCostKib, version, associatedData);\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, BCRYPT 해시 비밀번호를 가진 사용자를 가져오는 방법은 무엇인가요?", "answer": "BCRYPT 해시 비밀번호를 가진 사용자를 가져오기 위해서는 추가 해시 매개변수 및 사용자별 비밀번호 솔트가 필요하지 않습니다. BCRYPT 해시 알고리즘을 사용하여 사용자 가져오기 API를 호출할 수 있습니다. 예제 코드는 다음과 같습니다:\n```java\nUserImportOptions options = UserImportOptions.withHash(Bcrypt.getInstance());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nfor (ErrorInfo indexedError : result.getErrors()) {\n    System.out.println(\"Failed to import user: \" + indexedError.getReason());\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, PBKDF2_SHA256 해시 알고리즘을 사용하는 방법은 무엇인가요?", "answer": "PBKDF2_SHA256 해시 알고리즘을 사용하여 사용자를 가져오려면, 해시 알고리즘을 설정하고 라운드 수를 지정해야 합니다. 예제 코드는 다음과 같습니다:\n```java\nUserImportOptions options = UserImportOptions.withHash(Pbkdf2Sha256.builder().setRounds(100000).build());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\nfor (ErrorInfo indexedError : result.getErrors()) {\n    System.out.println(\"Failed to import user: \" + indexedError.getReason());\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, MD5 해시 알고리즘의 라운드 수는 어떻게 설정하나요?", "answer": "MD5 해시 알고리즘을 사용할 때, 라운드 수는 0에서 8192 사이의 정수로 설정해야 합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n```java\nUserImportOptions options = UserImportOptions.withHash(Md5.builder().setRounds(1000).build());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 해시 알고리즘의 파라미터는 어떻게 설정하나요?", "answer": "해시 알고리즘의 파라미터는 각 해시 알고리즘에 따라 다르게 설정해야 합니다. 예를 들어, PBKDF2_SHA256의 경우 라운드 수를 설정하고, BCRYPT의 경우 추가 해시 매개변수가 필요하지 않습니다. 각 해시 알고리즘에 대한 설정 방법은 다음과 같습니다:\n- PBKDF2_SHA256: `setRounds(int rounds)` 메서드를 사용하여 라운드 수를 설정합니다.\n- BCRYPT: 추가 해시 매개변수가 필요하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, Argon2 해시 알고리즘의 파라미터는 어떻게 설정하나요?", "answer": "Argon2 해시 알고리즘의 파라미터는 UserImportOptions.withHash() 메서드를 사용하여 설정할 수 있습니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```java\nUserImportOptions options = UserImportOptions.withHash(\n    Argon2.builder()\n        .setHashLengthBytes(512)\n        .setHashType(Argon2HashType.ARGON2_ID)\n        .setParallelism(8)\n        .setIterations(16)\n        .setMemoryCostKib(2048)\n        .setVersion(Argon2Version.VERSION_10)\n        .setAssociatedData(\"associated-data\".getBytes())\n        .build());\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자 정보를 가져오기 위해서는 ImportUserRecord 객체를 생성하고, 이를 FirebaseAuth.getInstance().importUsers() 메서드에 전달해야 합니다. 예를 들어:\n\n```java\nList<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()\n    .setUid(\"some-uid\")\n    .setEmail(\"user@example.com\")\n    .setPasswordHash(\"password-hash\".getBytes())\n    .setPasswordSalt(\"salt\".getBytes())\n    .build());\nUserImportResult result = FirebaseAuth.getInstance().importUsers(users);\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 사용자 프로바이더 정보를 설정하는 방법은 무엇인가요?", "answer": "사용자 프로바이더 정보를 설정하기 위해서는 UserProvider.builder()를 사용하여 프로바이더 정보를 추가할 수 있습니다. 예를 들어:\n\n```java\n.addUserProvider(UserProvider.builder() // user with Google provider\n    .setUid(\"google-uid\")\n    .setEmail(\"johndoe@gmail.com\")\n    .setDisplayName(\"John Doe\")\n    .setPhotoUrl(\"http://www.example.com/12345678/photo.png\")\n    .setProviderId(\"google.com\")\n    .build())\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 이메일이 확인되었음을 설정하는 방법은 무엇인가요?", "answer": "가져온 사용자의 이메일이 확인되었음을 설정하기 위해서는 ImportUserRecord.builder() 메서드에서 setEmailVerified(true) 메서드를 호출하면 됩니다. 예를 들어:\n\n```java\n.setEmailVerified(true)\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 가져오기 API를 사용할 때, 가져온 사용자의 비밀번호 해시와 솔트를 설정하는 방법은 무엇인가요?", "answer": "가져온 사용자의 비밀번호 해시와 솔트를 설정하기 위해서는 ImportUserRecord.builder() 메서드에서 setPasswordHash()와 setPasswordSalt() 메서드를 사용합니다. 예를 들어:\n\n```java\n.setPasswordHash(\"password-hash\".getBytes())\n.setPasswordSalt(\"salt\".getBytes())\n```", "source": ["https://firebase.google.com/docs/auth/admin/import-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_import-users_hl=ko.txt"}
{"question": "세션 쿠키를 생성할 때 어떤 옵션을 설정할 수 있나요?", "answer": "세션 쿠키를 생성할 때는 만료 시간(expiresIn)과 같은 옵션을 설정할 수 있습니다. 예를 들어, 다음과 같이 세션 쿠키를 생성할 수 있습니다:\n```python\nexpires_in = datetime.timedelta(days=5)\nsession_cookie = auth.create_session_cookie(id_token, expires_in=expires_in)\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 생성하기 전에 어떤 조건을 확인해야 하나요?", "answer": "세션 쿠키를 생성하기 전에 ID 토큰의 auth_time을 확인하여 사용자가 최근 5분 이내에 로그인했는지 확인해야 합니다. 예를 들어:\n```python\nif time.time() - decoded_claims['auth_time'] < 5 * 60:\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 생성하는 과정에서 발생할 수 있는 오류는 무엇인가요?", "answer": "세션 쿠키를 생성하는 과정에서 발생할 수 있는 오류로는 InvalidIdTokenError와 FirebaseError가 있습니다. 이 오류들은 각각 잘못된 ID 토큰과 세션 쿠키 생성 실패를 나타냅니다. 예를 들어:\n```python\nexcept auth.InvalidIdTokenError:\n    return flask.abort(401, 'Invalid ID token')\nexcept exceptions.FirebaseError:\n    return flask.abort(401, 'Failed to create a session cookie')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 생성한 후 클라이언트에 어떻게 전달하나요?", "answer": "세션 쿠키를 생성한 후, 클라이언트에 전달하기 위해 HTTP 응답에 쿠키를 설정할 수 있습니다. 예를 들어:\n```python\nresponse.set_cookie(\n    'session', session_cookie, expires=expires, httponly=True, secure=True)\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 생성하기 위한 Firebase Admin SDK의 메서드는 무엇인가요?", "answer": "Firebase Admin SDK에서 세션 쿠키를 생성하기 위해 사용하는 메서드는 createSessionCookie(idToken, options)입니다. 이 메서드는 ID 토큰과 세션 쿠키 옵션을 인자로 받습니다. 예를 들어:\n```java\nString sessionCookie = FirebaseAuth.getInstance().createSessionCookie(idToken, options);\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 인증하기 위해 어떤 메서드를 사용해야 하나요?", "answer": "세션 쿠키를 인증하기 위해 Admin SDK의 `verifySessionCookie(sessionCookie, checkRevoked)` 메서드를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키의 유효 기간은 어떻게 설정하나요?", "answer": "세션 쿠키의 유효 기간은 `SessionCookieOptions`를 사용하여 설정할 수 있으며, `setExpiresIn(expiresIn)` 메서드를 통해 설정합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키가 유효하지 않은 경우 어떻게 처리하나요?", "answer": "세션 쿠키가 유효하지 않은 경우, `InvalidSessionCookieError` 예외가 발생하며, 사용자는 다시 로그인하도록 강제해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 생성하기 전에 어떤 조건을 확인해야 하나요?", "answer": "세션 쿠키를 생성하기 전에 ID 토큰의 `auth_time`을 확인하여 사용자가 최근 5분 이내에 로그인했는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 클라이언트에 설정할 때 어떤 옵션을 사용할 수 있나요?", "answer": "세션 쿠키를 클라이언트에 설정할 때 `httponly=True` 및 `secure=True` 옵션을 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 인증할 때 어떤 메서드를 사용하나요?", "answer": "세션 쿠키를 인증하기 위해 Firebase Admin SDK의 `verifySessionCookie(sessionCookie, checkRevoked)` 메서드를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키가 유효하지 않은 경우 어떤 처리를 해야 하나요?", "answer": "세션 쿠키가 유효하지 않은 경우, 사용자가 다시 로그인하도록 요청해야 합니다. 예를 들어, `flask.redirect('/login')`을 사용하여 로그인 페이지로 리다이렉트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키의 유효 기간은 어떻게 설정하나요?", "answer": "세션 쿠키의 유효 기간은 최대 2주로 설정할 수 있으며, 이를 위해 `MaxAge`를 설정합니다. 예를 들어, `MaxAge: 0`으로 설정하면 쿠키가 삭제됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 인증할 때 추가 네트워크 요청을 방지할 수 있는 방법은 무엇인가요?", "answer": "세션 쿠키를 인증할 때 공개 인증서를 처음에 쿼리한 후 만료될 때까지 캐시하여 추가 네트워크 요청 없이 인증할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "세션 쿠키를 인증한 후 권한 확인을 어떻게 수행하나요?", "answer": "세션 쿠키를 인증한 후, 사용자 권한을 확인하기 위해 `decodedClaims`에서 특정 클레임을 확인합니다. 예를 들어, `if (Boolean.TRUE.equals(decodedToken.getClaims().get(\"admin\")))`를 사용하여 사용자가 관리자 권한을 가지고 있는지 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-cookies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-cookies_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 다단계 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자 레코드를 가져오려면 getUser() 또는 getUserByEmail()을 호출합니다. 아래는 다단계 등록 사용자를 가져오는 예시입니다.\n\n```javascript\n.then((listUsersResult) => {\nlistUsersResult.users.forEach((userRecord) => {\n// 사용자 정보 처리\n});\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-mfa-users_hl=ko.txt"}
{"question": "새 사용자를 만들 때 다단계 인증을 설정하는 방법은 무엇인가요?", "answer": "createUser()를 호출하여 새 사용자를 만들 수 있습니다. 보조 단계가 있는 신규 사용자는 확인된 이메일 주소(emailVerified를 true로 설정)와 지원되는 첫 번째 단계를 사용하여 로그인해야 합니다. 아래는 2가지 보조 단계가 있는 신규 사용자를 만드는 예시입니다.\n\n```javascript\nadmin.auth().createUser({\nuid: '123456789',\nemail: 'user@example.com',\nemailVerified: true,\npassword: 'password',\nmultiFactor: {\nenrolledFactors: [\nfunction enrollSecondFactor(userId, secondFactorPhoneNumber, secondFactorDisplayName) {\nreturn admin.auth().getUser(userId)\n.then((userRecord) => {\nupdatedList.push({\nphoneNumber: secondFactorPhoneNumber,\ndisplayName: secondFactorDisplayName,\nfactorId: 'phone',\n```\n}", "source": ["https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-mfa-users_hl=ko.txt"}
{"question": "다단계 사용자 관리에서 지원되는 보조 단계의 최대 개수는 몇 개인가요?", "answer": "사용자당 최대 5개의 보조 단계가 허용됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-mfa-users_hl=ko.txt"}
{"question": "다단계 사용자 관리에 필요한 Firebase Admin SDK의 설치 방법은 무엇인가요?", "answer": "Node.js Admin SDK를 설치해야 합니다. 다른 Admin SDK 언어는 현재 지원되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-mfa-users_hl=ko.txt"}
{"question": "다단계 사용자 관리에서 사용자 레코드의 다단계 관련 데이터를 어떻게 검색하나요?", "answer": "UserRecord 객체에서 등록된 두 번째 단계 목록과 같은 사용자의 다단계 관련 데이터를 검색할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-mfa-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 특정 사용자의 갱신 토큰을 취소하는 방법은 무엇인가요?", "answer": "다음은 Admin SDK를 사용하여 특정 사용자의 갱신 토큰을 취소하는 구현 예시입니다. Admin SDK를 초기화하려면 설정 페이지의 안내를 따르세요.\n\n```javascript\n.revokeRefreshTokens(uid)\n.then(() => {\nreturn getAuth().getUser(uid);\nFirebaseAuth.getInstance().revokeRefreshTokens(uid);\nUserRecord user = FirebaseAuth.getInstance().getUser(uid);\nSystem.out.println(\"Tokens revoked at: \" + revocationSecond);\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Python에서 Firebase Admin SDK를 사용하여 갱신 토큰을 취소하는 코드는 어떻게 되나요?", "answer": "다음은 Python에서 Firebase Admin SDK를 사용하여 갱신 토큰을 취소하는 코드 예시입니다.\n\n```python\n# Revoke tokens on the backend.\nauth.revoke_refresh_tokens(uid)\nuser = auth.get_user(uid)\n# Convert to seconds as the auth_time in the token claims is in seconds.\nrevocation_second = user.tokens_valid_after_timestamp / 1000\nprint(f'Tokens revoked at: {revocation_second}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Security Rules에서 ID 토큰 취소를 감지하기 위해 필요한 메타데이터는 무엇인가요?", "answer": "Firebase Security Rules에서 ID 토큰 취소를 감지하려면 갱신 토큰이 취소된 타임스탬프를 저장해야 합니다. 이 작업은 Firebase Security Rules을 통해 ID 토큰 취소를 추적하는 데 필요합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "사용자가 비밀번호를 재설정할 때 갱신 토큰은 어떻게 처리되나요?", "answer": "비밀번호를 재설정해도 사용자의 기존 토큰이 취소되지만, 이 경우 Firebase Authentication 백엔드에서 취소를 자동으로 처리합니다. 취소하면 사용자가 로그아웃되고 다시 인증하라는 메시지가 표시됩니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "사용자가 기기를 분실했을 때 갱신 토큰을 취소하는 방법은 무엇인가요?", "answer": "사용자가 기기 분실이나 도난을 신고하면 사용자의 기존 갱신 토큰을 취소할 수 있습니다. 일반적인 취약점이 발견되었거나 활성 토큰이 대규모로 유출된 정황이 의심되면 listUsers API를 사용하여 지정된 프로젝트의 모든 사용자를 찾아 토큰을 취소할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 특정 사용자의 갱신 토큰을 취소한 후, 해당 사용자의 메타데이터를 Firebase Realtime Database에 업데이트하는 방법은 무엇인가요?", "answer": "다음은 Firebase Admin SDK를 사용하여 특정 사용자의 갱신 토큰을 취소한 후, 해당 사용자의 메타데이터를 Firebase Realtime Database에 업데이트하는 코드 예시입니다.\n\n```python\nmetadata_ref = firebase_admin.db.reference(\"metadata/\" + uid)\nmetadata_ref.set({'revokeTime': revocation_second})\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Security Rules에서 ID 토큰 취소를 감지하기 위해 필요한 메타데이터는 무엇인가요?", "answer": "ID 토큰 취소를 감지하기 위해서는 갱신 토큰이 취소된 타임스탬프를 저장해야 합니다. 이 메타데이터는 Firebase Realtime Database에 저장되어야 하며, 이를 통해 ID 토큰 취소를 추적할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자의 ID 토큰을 검증할 때, 갱신 토큰이 취소되었는지를 확인하는 방법은 무엇인가요?", "answer": "사용자의 ID 토큰을 확인할 때는 `checkRevoked` 불리언 플래그를 `verifyIdToken` 메서드에 추가로 전달해야 합니다. 다음은 Node.js에서의 예시입니다.\n\n```javascript\n.verifyIdToken(idToken, checkRevoked)\n.then((payload) => {\n  // Token is valid and not revoked.\n})\n.catch((error) => {\n  // Handle errors\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 갱신 토큰을 취소한 후, 사용자가 로그아웃되는 이유는 무엇인가요?", "answer": "갱신 토큰이 취소되면 사용자가 로그아웃되고 다시 인증하라는 메시지가 표시됩니다. 이는 보안상의 이유로, 사용자의 기존 세션이 무효화되기 때문입니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 초기화하기 위한 설정 페이지는 어디에서 찾을 수 있나요?", "answer": "Firebase Admin SDK를 초기화하려면 설정 페이지의 안내를 따라야 합니다. 해당 페이지는 다음 링크에서 확인할 수 있습니다: [Firebase Admin SDK 설정 페이지](https://firebase.google.com/docs/admin/setup?hl=ko#initialize-sdk).", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Realtime Database에서 사용자별 메타데이터를 업데이트하는 방법은 무엇인가요?", "answer": "Firebase Realtime Database에서 사용자별 메타데이터를 업데이트하려면, 갱신 토큰이 취소된 타임스탬프를 저장해야 합니다. 아래는 Python 코드 예시입니다.\n\n```python\nmetadata_ref = firebase_admin.db.reference(\"metadata/\" + uid)\nmetadata_ref.set({'revokeTime': revocation_second})\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Security Rules에서 사용자별 취소 시간을 저장하기 위한 규칙 설정 방법은 무엇인가요?", "answer": "Firebase Security Rules에서 사용자별 취소 시간을 저장하기 위해 클라이언트 쓰기 권한 없이 규칙을 설정해야 합니다. 아래는 규칙 설정 예시입니다.\n\n```json\n\"rules\": {\n  \"metadata\": {\n    \"$user_id\": {\n      // 규칙 내용\n    }\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자의 ID 토큰을 검증할 때 갱신 토큰이 취소되었는지를 확인하는 방법은 무엇인가요?", "answer": "사용자의 ID 토큰을 검증할 때는 `checkRevoked` 불리언 플래그를 `verifyIdToken` 메서드에 추가로 전달해야 합니다. 아래는 Node.js 코드 예시입니다.\n\n```javascript\n.verifyIdToken(idToken, checkRevoked)\n.then((payload) => {\n  FirebaseToken decodedToken = FirebaseAuth.getInstance()\n  .verifyIdToken(idToken, checkRevoked);\n  String uid = decodedToken.getUid();\n  // Token is valid and not revoked.\n})\n.catch((error) => {\n  // 에러 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 갱신 토큰이 취소된 경우 클라이언트에서 사용자가 어떻게 처리되는지 설명해 주세요.", "answer": "갱신 토큰이 취소된 경우, 클라이언트는 사용자를 로그아웃 처리하거나 Firebase Authentication 클라이언트 SDK가 제공하는 재인증 API를 사용하여 재인증하도록 요청해야 합니다. 아래는 Node.js 코드 예시입니다.\n\n```javascript\n.catch((error) => {\n  if (error.code === 'auth/revoked-id-token') {\n    // Token revoked, inform the user to reauthenticate or signOut().\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 초기화하기 위한 설정 페이지는 어디에서 찾을 수 있나요?", "answer": "Firebase Admin SDK를 초기화하기 위한 설정 페이지는 [여기](https://firebase.google.com/docs/admin/setup?hl=ko#initialize-sdk)에서 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-sessions_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 특정 사용자의 uid로 사용자 데이터를 검색하는 방법은 무엇인가요?", "answer": "다음과 같이 uid를 사용하여 사용자 데이터를 검색할 수 있습니다.\n```python\nfrom firebase_admin import auth\n\nuser = auth.get_user(uid)\nprint(f'Successfully fetched user data: {user.uid}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "이메일을 사용하여 Firebase Admin SDK로 사용자 데이터를 검색하는 방법은 무엇인가요?", "answer": "이메일을 사용하여 사용자 데이터를 검색하는 방법은 다음과 같습니다.\n```python\nfrom firebase_admin import auth\n\nuser = auth.get_user_by_email(email)\nprint(f'Successfully fetched user data: {user.uid}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "전화번호를 사용하여 Firebase Admin SDK로 사용자 데이터를 검색하는 방법은 무엇인가요?", "answer": "전화번호를 사용하여 사용자 데이터를 검색하는 방법은 다음과 같습니다.\n```python\nfrom firebase_admin import auth\n\nuser = auth.get_user_by_phone_number(phone)\nprint(f'Successfully fetched user data: {user.uid}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 여러 사용자를 한 번에 검색하는 방법은 무엇인가요?", "answer": "여러 사용자를 한 번에 검색하는 방법은 다음과 같습니다.\n```javascript\ngetAuth()\n.getUsers([\n])\n.then((getUsersResult) => {\nGetUsersResult result = FirebaseAuth.getInstance().getUsersAsync(Arrays.asList(\nnew UidIdentifier(\"uid1\"),\nnew EmailIdentifier(\"user2@example.com\"),\nnew PhoneIdentifier(\"+15555550003\"),\nnew ProviderIdentifier(\"google.com\", \"google_uid4\"))).get();\n\nSystem.out.println(\"Successfully fetched user data:\");\nfor (UserRecord user : result.getUsers()) {\nSystem.out.println(user\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 초기화하기 위해 필요한 것은 무엇인가요?", "answer": "Firebase Admin SDK를 초기화하기 위해서는 서비스 계정이 필요합니다. 초기화 방법에 대한 자세한 내용은 설정 안내를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자의 데이터를 수정하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 사용자의 데이터를 수정하려면, 업데이트할 사용자 속성과 함께 해당 사용자의 uid를 지정해야 합니다. 아래는 Node.js의 예시입니다.\n```javascript\ngetAuth()\n  .updateUser(uid, {\n    email: 'modifiedUser@example.com',\n    phoneNumber: '+11234567890',\n    emailVerified: true,\n    password: 'newPassword',\n    displayName: 'Jane Doe',\n    photoURL: 'http://www.example.com/12345678/photo.png',\n    disabled: true,\n  })\n  .then((userRecord) => {\n    console.log('Successfully updated user:', userRecord.uid);\n  });\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 생성할 때 필요한 필드는 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 사용자를 생성할 때는 이메일, 비밀번호, 전화번호, 표시 이름, 사진 URL 등의 필드를 포함할 수 있습니다. 아래는 Python의 예시입니다.\n```python\nuser = auth.create_user(\n    email='user@example.com',\n    email_verified=False,\n    phone_number='+15555550100',\n    password='secretPassword',\n    display_name='John Doe',\n    photo_url='http://www.example.com/12345678/photo.png',\n    disabled=False)\nprint(f'Successfully created new user: {user.uid}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자를 생성할 때 uid를 지정하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK에서 사용자를 생성할 때 uid를 지정하려면, CreateRequest 객체를 사용하여 uid를 설정해야 합니다. 아래는 Node.js의 예시입니다.\n```javascript\ngetAuth()\n  .createUser({\n    uid: 'some-uid',\n    email: 'user@example.com',\n    phoneNumber: '+11234567890',\n  })\n  .then((userRecord) => {\n    console.log('Successfully created new user:', userRecord.uid);\n  });\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자의 이메일을 수정하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 사용자의 이메일을 수정하려면, updateUser 메서드를 사용하여 uid와 함께 수정할 이메일을 전달해야 합니다. 아래는 Python의 예시입니다.\n```python\nuser = auth.update_user(\n    uid,\n    email='user@example.com',\n    phone_number='+15555550100',\n    email_verified=True,\n    password='newPassword',\n    display_name='John Doe',\n    photo_url='http://www.example.com/12345678/photo.png',\n    disabled=True)\nprint(f'Successfully updated user: {user.uid}')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자의 프로필 정보를 수정할 때 어떤 속성을 설정할 수 있나요?", "answer": "Firebase Admin SDK에서 사용자의 프로필 정보를 수정할 때는 이메일, 전화번호, 비밀번호, 표시 이름, 사진 URL, 비활성화 상태 등의 속성을 설정할 수 있습니다. 아래는 Go의 예시입니다.\n```go\nparams := (&auth.UserToUpdate{}).\n    Email(\"user@example.com\").\n    EmailVerified(true).\n    PhoneNumber(\"+15555550100\").\n    Password(\"newPassword\").\n    DisplayName(\"John Doe\").\n    PhotoURL(\"http://www.example.com/12345678/photo.png\").\n    Disabled(true)\nu, err := client.UpdateUser(ctx, uid, params)\nif err != nil {\n    log.Fatalf(\"error updating user: %v\\n\", err)\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 삭제할 때 어떤 메서드를 사용해야 하나요?", "answer": "Firebase Admin SDK에서는 uid에 따라 기존 사용자를 삭제하는 기능을 지원합니다. 사용자를 삭제하기 위해서는 다음과 같은 메서드를 사용합니다:\n\n```go\nerr := client.DeleteUser(ctx, uid)\nif err != nil {\n    log.Fatalf(\"error deleting user: %v\\n\", err)\n}\n```\n\n또한, 여러 사용자를 한 번에 삭제할 수도 있습니다. 하지만 `deleteUsers(uids)`와 같은 메서드를 사용하여 한 번에 여러 사용자를 삭제하면 Cloud Functions for Firebase의 `onDelete()` 이벤트 핸들러가 트리거되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 여러 사용자를 한 번에 삭제할 때 주의해야 할 점은 무엇인가요?", "answer": "여러 사용자를 한 번에 삭제할 때는 `deleteUsers(uids)` 메서드를 사용하면 됩니다. 하지만 이 방법은 사용자별로 사용자 삭제 이벤트를 트리거하지 않기 때문에, 삭제된 각 사용자에 대해 사용자 삭제 이벤트를 실행하려면 한 번에 한 명씩 사용자를 삭제해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자의 데이터를 수정할 때 어떤 메서드를 사용하나요?", "answer": "Firebase Admin SDK는 기존 사용자의 데이터를 수정하는 기능을 지원합니다. 사용자의 데이터를 수정하기 위해서는 `updateUser(uid, params)` 메서드를 사용해야 합니다. 예를 들어:\n\n```go\nparams := (&auth.UserToUpdate{}).\n    Email(\"user@example.com\").\n    EmailVerified(true).\n    PhoneNumber(\"+15555550100\").\n    Password(\"newPassword\").\n    DisplayName(\"John Doe\").\n    PhotoURL(\"http://www.example.com/12345678/photo.png\").\n    Disabled(true)\nu, err := client.UpdateUser(ctx, uid, params)\nif err != nil {\n    log.Fatalf(\"error updating user: %v\\n\", err)\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자의 프로필 정보를 수정할 때 어떤 속성을 설정할 수 있나요?", "answer": "Firebase Admin SDK를 사용하여 사용자의 프로필 정보를 수정할 때 설정할 수 있는 속성은 다음과 같습니다:\n- Email\n- EmailVerified\n- PhoneNumber\n- Password\n- DisplayName\n- PhotoURL\n- Disabled\n\n이 속성들은 `UserToUpdate` 객체를 통해 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 생성할 때 어떤 필드를 설정해야 하나요?", "answer": "Firebase Admin SDK를 사용하여 사용자를 생성할 때는 다음과 같은 필드를 설정해야 합니다:\n- uid\n- Email\n- PhoneNumber\n- Password\n- DisplayName\n- PhotoURL\n- Disabled\n\n예를 들어, 사용자를 생성하는 코드는 다음과 같습니다:\n\n```go\nparams := (&auth.UserToCreate{}).\n    UID(uid).\n    Email(\"user@example.com\").\n    PhoneNumber(\"+15555550100\")\nu, err := client.CreateUser(ctx, params)\nif err != nil {\n    log.Fatalf(\"error creating user: %v\\n\", err)\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 사용자를 삭제할 때 어떤 메서드를 사용해야 하나요?", "answer": "Firebase Admin SDK에서는 uid에 따라 기존 사용자를 삭제하는 기능을 지원합니다. Python에서는 다음과 같이 사용합니다:\n```python\nauth.delete_user(uid)\nprint('Successfully deleted user')\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 여러 사용자를 한 번에 삭제할 때 주의해야 할 점은 무엇인가요?", "answer": "여러 사용자를 한 번에 삭제하면 deleteUsers(uids)와 같은 메서드를 사용하여 Cloud Functions for Firebase의 onDelete() 이벤트 핸들러가 트리거되지 않습니다. 삭제된 각 사용자에 대해 사용자 삭제 이벤트를 실행하려면 한 번에 한 명씩 사용자를 삭제해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 전체 사용자 목록을 배치별로 검색하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 전체 사용자 목록을 배치별로 검색할 수 있습니다. Node.js에서는 다음과 같이 사용합니다:\n```javascript\n.listUsers(1000, nextPageToken)\n.then((listUsersResult) => {\nlistUsersResult.users.forEach((userRecord) => {\n// 사용자 처리 로직\n});\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 비밀번호 해시를 가져오려면 어떤 권한이 필요한가요?", "answer": "비밀번호 해시의 민감한 특성으로 인해 Firebase Admin SDK 서비스 계정에는 기본적으로 firebaseauth.configs.getHashConfig 권한이 없습니다. 사용자 서비스 계정에 권한을 직접 추가할 수 없지만 커스텀 IAM 역할을 만들어 간접적으로 권한을 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 목록을 나열할 때 최대 사용자 수는 얼마인가요?", "answer": "한 번에 나열할 수 있는 최대 사용자 수는 1000명으로 제한됩니다. 최댓값보다 큰 값은 인수 오류를 발생시킵니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 여러 사용자를 삭제할 때 어떤 메서드를 사용해야 하나요?", "answer": "Firebase Admin SDK에서 여러 사용자를 삭제할 때는 `DeleteUsers` 메서드를 사용합니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n```go\ndeleteUsersResult, err := client.DeleteUsers(ctx, []string{\"uid1\", \"uid2\", \"uid3\"})\nif err != nil {\nlog.Fatalf(\"error deleting users: %v\\n\", err)\nlog.Printf(\"Failed to delete %d users\", deleteUsersResult.FailureCount)\nfor _, err := range deleteUsersResult.Errors {\nlog.Printf(\"%v\", err)\n}\n}\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 전체 사용자 목록을 배치별로 검색하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 전체 사용자 목록을 배치별로 검색하려면 `listUsers` 메서드를 사용합니다. 예를 들어, Node.js에서는 다음과 같이 사용할 수 있습니다:\n```javascript\n.listUsers(1000, nextPageToken)\n.then((listUsersResult) => {\nlistUsersResult.users.forEach((userRecord) => {\n// 사용자 처리 로직\n});\n});\n```", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 비밀번호 해시를 가져오려면 어떤 권한이 필요한가요?", "answer": "Firebase Admin SDK에서 사용자 비밀번호 해시를 가져오려면 `firebaseauth.configs.getHashConfig` 권한이 필요합니다. 이 권한이 없는 경우 비밀번호 해시 및 비밀번호 솔트는 설정되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 사용자 목록을 나열할 때 최대 사용자 수는 얼마인가요?", "answer": "Firebase Admin SDK에서 사용자 목록을 나열할 때 한 번에 나열할 수 있는 최대 사용자 수는 1000명으로 제한됩니다. 이 숫자를 초과하면 인수 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 커스텀 IAM 역할을 만들려면 어떤 단계를 따라야 하나요?", "answer": "Firebase Admin SDK에서 커스텀 IAM 역할을 만들려면 다음 단계를 따르세요:\n1. Google Cloud 콘솔의 IAM 및 관리자 패널에서 역할 페이지로 이동합니다.\n2. 페이지 상단의 드롭다운에서 프로젝트를 선택합니다.\n3. 역할 만들기를 클릭합니다.\n4. 권한 추가를 클릭합니다.\n5. `firebaseauth.configs.getHashConfig` 권한을 검색하고 해당 체크박스를 선택합니다.\n6. 추가를 클릭합니다.\n7. 만들기를 클릭하여 새 역할 만들기를 마칩니다.", "source": ["https://firebase.google.com/docs/auth/admin/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_manage-users_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 ID 토큰을 검증하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK로 ID 토큰을 검증하려면 먼저 서비스 계정으로 Admin SDK를 초기화해야 합니다. 그런 다음 verifyIdToken() 메서드를 사용하여 ID 토큰을 확인합니다. 예시는 다음과 같습니다:\n\n```javascript\n.verifyIdToken(idToken)\n.then((decodedToken) => {\n  FirebaseToken decodedToken = FirebaseAuth.getInstance().verifyIdToken(idToken);\n  String uid = decodedToken.getUid();\n```", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "클라이언트에서 ID 토큰을 검색하는 방법은 무엇인가요?", "answer": "클라이언트에서 ID 토큰을 검색하려면 사용자가 로그인한 상태인지 확인하고 로그인한 사용자의 ID 토큰을 가져와야 합니다. 예를 들어, Android에서는 다음과 같이 사용할 수 있습니다:\n\n```java\nFirebaseUser mUser = FirebaseAuth.getInstance().getCurrentUser();\nmUser.getIdToken(true)\n.addOnCompleteListener(new OnCompleteListener<GetTokenResult>() {\n  public void onComplete(@NonNull Task<GetTokenResult> task) {\n    if (task.isSuccessful()) {\n      String idToken = task.getResult().getToken();\n```", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰을 검증하기 전에 확인해야 할 사항은 무엇인가요?", "answer": "ID 토큰을 검증하기 전에 Firebase Realtime Database 및 Cloud Storage의 보안 규칙을 사용하여 다양한 방법으로 ID 토큰을 확인할 수 있는지 확인해야 합니다. 또한, Firebase Admin SDK에 포함된 ID 토큰 확인 방법은 클라이언트 SDK에서 보낸 ID 토큰을 확인하기 위한 것이며, Admin SDK로 만든 커스텀 토큰을 확인하는 용도가 아님을 유의해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰 검증 시 어떤 정보를 확인할 수 있나요?", "answer": "ID 토큰 검증 시 제공된 ID 토큰이 올바른 형식이고, 만료되지 않았으며, 정상적으로 서명된 경우, 이 메서드는 디코딩된 ID 토큰을 반환합니다. 디코딩된 토큰에서 사용자 또는 기기의 uid를 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰이 취소되었는지 여부를 확인할 수 있나요?", "answer": "ID 토큰 검증 메서드는 토큰이 취소되었는지 여부를 확인하지 않습니다. ID 토큰 취소 감지에 대한 자세한 내용은 관련 문서를 참조해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 ID 토큰을 검증하기 위해 어떤 메서드를 사용해야 하나요?", "answer": "ID 토큰을 검증하기 위해 Firebase Admin SDK의 verifyIdToken() 메서드를 사용해야 합니다. 이 메서드는 제공된 ID 토큰이 올바른 형식이고, 만료되지 않았으며, 정상적으로 서명된 경우 디코딩된 ID 토큰을 반환합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰을 검증하기 위해 필요한 프로젝트 ID는 어떻게 가져오나요?", "answer": "Firebase Admin SDK는 다음 방법 중 하나를 사용하여 프로젝트 ID를 가져오려고 시도합니다: 1) SDK가 명시적인 projectId 앱 옵션을 사용해서 초기화된 경우 해당 옵션의 값을 사용합니다. 2) SDK가 서비스 계정 사용자 인증 정보를 사용하여 초기화된 경우 서비스 계정 JSON 객체의 project_id 필드를 사용합니다. 3) GOOGLE_CLOUD_PROJECT 환경 변수가 설정된 경우 해당 값을 프로젝트 ID로 사용합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰의 헤더에서 확인해야 할 제약조건은 무엇인가요?", "answer": "ID 토큰의 헤더에서 확인해야 할 제약조건은 다음과 같습니다: 1) alg (알고리즘) - 'RS256'이어야 합니다. 2) kid (키 ID) - https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com에 나열된 공개 키 중 하나와 일치해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰의 페이로드에서 확인해야 할 제약조건은 무엇인가요?", "answer": "ID 토큰의 페이로드에서 확인해야 할 제약조건은 다음과 같습니다: 1) exp (만료 시간) - 미래 시간이어야 합니다. 2) iat (발급 시간) - 과거 시간이어야 합니다. 3) aud (대상) - Firebase 프로젝트 ID여야 합니다. 4) iss (발급자) - 'https://securetoken.google.com/<projectId>'이어야 하며, 여기서 <projectId>는 aud에 사용된 Firebase 프로젝트 ID입니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "서드 파티 JWT 라이브러리를 사용하여 ID 토큰을 검증하는 방법은 무엇인가요?", "answer": "서드 파티 JWT 라이브러리를 사용하여 ID 토큰을 검증하려면, 먼저 해당 언어의 서드 파티 JWT 라이브러리를 검색한 후, ID 토큰의 헤더, 페이로드 및 서명을 검증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "Firebase Admin SDK에서 ID 토큰을 검증할 때 Node.js에서 사용하는 코드 예시는 무엇인가요?", "answer": ".verifyIdToken(idToken)\n.then((decodedToken) => {\nFirebaseToken decodedToken = FirebaseAuth.getInstance().verifyIdToken(idToken);\nString uid = decodedToken.getUid();", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "Python에서 ID 토큰을 검증하기 위한 코드 예시는 어떻게 되나요?", "answer": "# id_token comes from the client app (shown above)\n\ndecoded_token = auth.verify_id_token(id_token)\nuid = decoded_token['uid']", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "Go 언어에서 ID 토큰을 검증하는 방법은 무엇인가요?", "answer": "client, err := app.Auth(ctx)\nif err != nil {\nlog.Fatalf(\"error getting Auth client: %v\\n\", err)\n}\nFirebaseToken decodedToken = await FirebaseAuth.DefaultInstance\n.VerifyIdTokenAsync(idToken);\nstring uid = decodedToken.Uid;", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰 검증을 위해 Firebase Admin SDK가 프로젝트 ID를 가져오는 방법은 무엇인가요?", "answer": "Firebase Admin SDK는 다음 방법 중 하나를 사용하여 프로젝트 ID를 가져오려고 시도합니다.\n\n1. SDK가 명시적인 projectId 앱 옵션을 사용해서 초기화된 경우 SDK가 해당 옵션의 값을 사용합니다.\n2. SDK가 서비스 계정 사용자 인증 정보를 사용하여 초기화된 경우 SDK가 서비스 계정 JSON 객체의 project_id 필드를 사용합니다.\n3. GOOGLE_CLOUD_PROJECT 환경 변수가 설정된 경우 SDK는 해당 값을 프로젝트 ID로 사용합니다.", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "ID 토큰의 헤더에서 확인해야 할 제약조건은 무엇인가요?", "answer": "| ID 토큰 헤더 클레임 |\n| --- |\n| alg | 알고리즘 | \"RS256\" |\n| kid | 키 ID | https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com에 나열된 공개 키 중 하나와 일치해야 합니다. |", "source": ["https://firebase.google.com/docs/auth/admin/verify-id-tokens?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_admin_verify-id-tokens_hl=ko.txt"}
{"question": "Firebase에서 Google 인증 제공업체의 사용자 인증 정보를 연결하는 방법은 무엇인가요?", "answer": "Google 인증 제공업체의 사용자 인증 정보를 연결하려면 먼저 사용자의 Google ID 토큰을 가져온 후, 다음과 같이 AuthCredential을 생성합니다:\n\n```kotlin\nval credential = GoogleAuthProvider.getCredential(googleIdToken, null)\n```\n\n그 후, 로그인한 사용자의 `linkWithCredential` 메서드에 이 `credential`을 전달하여 연결합니다.", "source": ["https://firebase.google.com/docs/auth/android/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_account-linking_hl=ko.txt"}
{"question": "Firebase에서 Facebook 인증 제공업체의 사용자 인증 정보를 연결하는 방법은 무엇인가요?", "answer": "Facebook 인증 제공업체의 사용자 인증 정보를 연결하려면 먼저 Facebook 액세스 토큰을 가져온 후, 다음과 같이 AuthCredential을 생성합니다:\n\n```kotlin\nval credential = FacebookAuthProvider.getCredential(token.token)\n```\n\n그 후, 로그인한 사용자의 `linkWithCredential` 메서드에 이 `credential`을 전달하여 연결합니다.", "source": ["https://firebase.google.com/docs/auth/android/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_account-linking_hl=ko.txt"}
{"question": "Firebase에서 이메일과 비밀번호를 사용하여 사용자 인증 정보를 연결하는 방법은 무엇인가요?", "answer": "이메일과 비밀번호를 사용하여 사용자 인증 정보를 연결하려면, 다음과 같이 AuthCredential을 생성합니다:\n\n```kotlin\nval credential = EmailAuthProvider.getCredential(email, password)\n```\n\n그 후, 로그인한 사용자의 `linkWithCredential` 메서드에 이 `credential`을 전달하여 연결합니다.", "source": ["https://firebase.google.com/docs/auth/android/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_account-linking_hl=ko.txt"}
{"question": "Firebase에서 특정 인증 제공업체와 사용자 계정의 연결을 해제하는 방법은 무엇인가요?", "answer": "특정 인증 제공업체와 사용자 계정의 연결을 해제하려면, 제공업체 ID를 `unlink` 메서드에 전달합니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```kotlin\nFirebase.auth.currentUser!!.unlink(providerId)\n```\n\n이 메서드는 비동기적으로 실행되며, 완료 후 성공 여부를 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_account-linking_hl=ko.txt"}
{"question": "Firebase에서 사용자 계정에 연결된 인증 제공업체의 ID를 가져오는 방법은 무엇인가요?", "answer": "사용자 계정에 연결된 인증 제공업체의 ID를 가져오려면 `getProviderData` 메서드를 호출합니다. 이 메서드는 현재 사용자 계정의 인증 제공업체 정보를 포함하는 리스트를 반환합니다.", "source": ["https://firebase.google.com/docs/auth/android/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_account-linking_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하여 익명으로 로그인하는 절차는 무엇인가요?", "answer": "로그아웃 상태의 사용자가 Firebase에 인증이 필요한 앱 기능을 사용할 때, 다음 절차를 밟으면 사용자를 익명으로 로그인시킬 수 있습니다. onCreate 메서드에서 FirebaseAuth 객체의 공유 인스턴스를 가져온 후, auth.signInAnonymously() 메서드를 호출하여 익명으로 로그인합니다. 예제 코드는 다음과 같습니다:\n\n```kotlin\nprivate lateinit var auth: FirebaseAuth\n\noverride fun onStart() {\n    super.onStart()\n    val currentUser = auth.currentUser\n    updateUI(currentUser)\n    auth.signInAnonymously()\n        .addOnCompleteListener(this) { task ->\n            if (task.isSuccessful) {\n                val user = auth.currentUser\n                updateUI(user)\n            } else {\n                updateUI(null)\n                Toast.makeText(baseContext, \"Authentication failed.\", Toast.LENGTH_SHORT).show()\n            }\n        }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자가 Firebase에 로그인한 후, 해당 계정을 다른 인증 방법과 연결하는 방법은 무엇인가요?", "answer": "로그인한 사용자의 linkWithCredential 메서드에 AuthCredential 객체를 전달하여 익명 계정을 다른 인증 방법과 연결할 수 있습니다. 다음은 Kotlin과 Java의 예제 코드입니다:\n\nKotlin:\n```kotlin\nauth.currentUser!!.linkWithCredential(credential)\n    .addOnCompleteListener(this) { task ->\n        if (task.isSuccessful) {\n            val user = task.result?.user\n            updateUI(user)\n        } else {\n            updateUI(null)\n            Toast.makeText(baseContext, \"Authentication failed.\", Toast.LENGTH_SHORT).show()\n        }\n    }\n```\n\nJava:\n```java\nmAuth.getCurrentUser().linkWithCredential(credential)\n    .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n        @Override\n        public void onComplete(@NonNull Task<AuthResult> task) {\n            if (task.isSuccessful()) {\n                FirebaseUser user = task.getResult().getUser();\n                updateUI(user);\n            } else {\n                updateUI(null);\n                Toast.makeText(AnonymousAuthActivity.this, \"Authentication failed.\", Toast.LENGTH_SHORT).show();\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_anonymous-auth_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하기 위해 Android 프로젝트에 추가해야 할 라이브러리는 무엇인가요?", "answer": "Android 프로젝트에 Firebase Authentication을 사용하기 위해서는 모듈(앱 수준) Gradle 파일에서 Firebase Authentication 라이브러리의 종속 항목을 추가해야 합니다. Firebase BoM을 사용하는 것이 좋으며, BoM을 사용하지 않는 경우 각 Firebase 라이브러리 버전을 명시해야 합니다. 예제는 다음과 같습니다:\n\n```groovy\ndependencies {\n    implementation platform('com.google.firebase:firebase-bom:29.0.0')\n    implementation 'com.google.firebase:firebase-auth'\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_anonymous-auth_hl=ko.txt"}
{"question": "익명 인증을 사용하기 전에 Android 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "익명 인증을 사용하기 전에 Android 프로젝트에 Firebase를 추가해야 합니다. Firebase를 추가하는 방법은 Firebase 콘솔에서 프로젝트를 생성하고, Android 앱을 등록한 후, 제공되는 google-services.json 파일을 다운로드하여 프로젝트의 app 디렉토리에 추가하는 것입니다. 이후 Gradle 파일을 수정하여 Firebase 라이브러리를 포함시켜야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_anonymous-auth_hl=ko.txt"}
{"question": "익명 인증이 성공했을 때 사용자 정보를 업데이트하는 방법은 무엇인가요?", "answer": "익명 인증이 성공했을 때, FirebaseUser 객체를 가져와서 updateUI(user) 메서드를 호출하여 사용자 정보를 업데이트할 수 있습니다. 예제 코드는 다음과 같습니다:\n\n```kotlin\nif (task.isSuccessful) {\n    val user = auth.currentUser\n    updateUI(user)\n} else {\n    updateUI(null)\n    Toast.makeText(baseContext, \"Authentication failed.\", Toast.LENGTH_SHORT).show()\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_anonymous-auth_hl=ko.txt"}
{"question": "Android 앱에서 Apple로 로그인을 구현하기 위해 Firebase Android SDK로 로그인 과정을 처리하는 방법은 무엇인가요?", "answer": "Firebase Android SDK로 로그인 과정을 처리하려면 다음 단계를 따릅니다.\n\n제공업체 ID apple.com을 사용하여 빌더로 OAuthProvider의 인스턴스를 생성합니다.\n\nKotlin\n```kotlin\nval provider = OAuthProvider.newBuilder(\"apple.com\")\n```\n\nJava\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"apple.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 추가로 요청할 수 있는 OAuth 2.0 범위는 어떻게 설정하나요?", "answer": "선택사항으로 인증 제공업체에 요청하고자 하는 기본값 범위를 넘는 OAuth 2.0 범위를 추가로 지정할 수 있습니다.\n\nKotlin\n```kotlin\nprovider.setScopes(arrayOf(\"email\", \"name\"))\n```\n\nJava\n```java\nList<String> scopes = new ArrayList<String>() {\n    {\n        add(\"email\");\n        add(\"name\");\n    }\n};\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인을 사용하기 위해 필요한 Apple ID의 조건은 무엇인가요?", "answer": "Apple로 로그인하려면 사용자는 다음을 충족해야 합니다.\n- 2단계 인증(2FA)이 사용 설정된 Apple ID가 있어야 합니다.\n- Apple 기기에서 iCloud에 로그인되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Console에서 Apple을 로그인 제공업체로 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Apple 제공업체를 사용 설정합니다. 이전 섹션에서 만든 서비스 ID를 지정하고, OAuth 코드 흐름 구성 섹션에서도 Apple 팀 ID 외에 이전 섹션에서 만든 비공개 키 및 키 ID를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 익명 처리된 데이터 요구사항을 준수하기 위해 어떤 점을 유의해야 하나요?", "answer": "Apple로 로그인에는 사용자가 로그인할 때 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션이 제공됩니다. 이 옵션을 선택한 사용자는 privaterelay.appleid.com 도메인의 이메일 주소를 갖게 됩니다. 앱에서 Apple로 로그인을 사용하는 경우 이 익명처리된 Apple ID에 대한 Apple의 관련 개발자 정책 또는 약관을 모두 준수해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK로 Apple로 로그인을 구현할 때 OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "OAuthProvider의 인스턴스를 생성하려면 제공업체 ID로 'apple.com'을 사용하여 빌더를 생성합니다. Kotlin에서는 다음과 같이 작성합니다:\n\n```kotlin\nval provider = OAuthProvider.newBuilder(\"apple.com\")\n```\nJava에서는 다음과 같이 작성합니다:\n\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"apple.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 추가로 요청할 수 있는 OAuth 2.0 범위를 설정하는 방법은 무엇인가요?", "answer": "OAuth 2.0 범위를 추가로 설정하려면 선택적으로 인증 제공업체에 요청하고자 하는 기본값 범위를 넘는 범위를 지정합니다. Kotlin에서는 다음과 같이 설정합니다:\n\n```kotlin\nprovider.setScopes(arrayOf(\"email\", \"name\"))\n```\nJava에서는 다음과 같이 설정합니다:\n\n```java\nList<String> scopes = new ArrayList<String>() {\n    {\n        add(\"email\");\n        add(\"name\");\n    }\n};\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple의 로그인 화면을 특정 언어로 표시하려면 어떻게 설정하나요?", "answer": "Apple의 로그인 화면을 영어가 아닌 다른 언어로 표시하려면 locale 매개변수를 설정해야 합니다. Kotlin에서는 다음과 같이 설정합니다:\n\n```kotlin\nprovider.addCustomParameter(\"locale\", \"fr\")\n```\nJava에서는 다음과 같이 설정합니다:\n\n```java\nprovider.addCustomParameter(\"locale\", \"fr\");\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase 인증에서 Apple로 로그인 시 대기 중인 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 `getPendingAuthResult()` 메서드를 호출합니다. Kotlin에서는 다음과 같이 작성합니다:\n\n```kotlin\nval pending = auth.pendingAuthResult\nif (pending != null) {\n    pending.addOnSuccessListener { authResult ->\n        Log.d(TAG, \"checkPending:onSuccess:\\$authResult\")\n    }\n}\n```\nJava에서는 다음과 같이 작성합니다:\n\n```java\nmAuth = FirebaseAuth.getInstance();\nTask<AuthResult> pending = mAuth.getPendingAuthResult();\nif (pending != null) {\n    pending.addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n        @Override\n        public void onSuccess(AuthResult authResult) {\n            Log.d(TAG, \"checkPending:onSuccess:\" + authResult);\n        }\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK로 Apple로 로그인 후 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "Apple로 로그인 후 사용자 정보를 가져오려면 `startActivityForSignInWithProvider()` 메서드를 사용하여 Firebase에 인증합니다. Kotlin에서는 다음과 같이 작성합니다:\n\n```kotlin\nauth.startActivityForSignInWithProvider(this, provider.build())\n```\nJava에서는 다음과 같이 작성합니다:\n\n```java\nmAuth.startActivityForSignInWithProvider(this, provider.build())\n    .addOnSuccessListener(\n        new OnSuccessListener<AuthResult>() {\n            @Override\n            public void onSuccess(AuthResult authResult) {\n                Log.d(TAG, \"activitySignIn:onSuccess:\" + authResult.getUser());\n            }\n        }\n    );\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple의 로그인 화면을 특정 언어로 표시하려면 어떻게 설정하나요?", "answer": "Apple의 로그인 화면을 영어가 아닌 다른 언어로 표시하려면 locale 매개변수를 설정하세요. 예를 들어, 프랑스어로 설정하려면 다음과 같이 코드를 작성합니다.\n\n```kotlin\n// Localize the Apple authentication screen in French.\nprovider.addCustomParameter(\"locale\", \"fr\")\n```\n\nJava에서는 다음과 같이 설정할 수 있습니다.\n\n```java\n// Localize the Apple authentication screen in French.\nprovider.addCustomParameter(\"locale\", \"fr\");\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK로 Apple로 로그인 후 대기 중인 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 다음과 같이 getPendingAuthResult()를 호출합니다. Kotlin에서는 다음과 같이 작성할 수 있습니다.\n\n```kotlin\nval pending = auth.pendingAuthResult\nif (pending != null) {\n    pending.addOnSuccessListener { authResult ->\n        Log.d(TAG, \"checkPending:onSuccess:$authResult\")\n    }\n}\n```\n\nJava에서는 다음과 같이 작성할 수 있습니다.\n\n```java\nmAuth = FirebaseAuth.getInstance();\nTask<AuthResult> pending = mAuth.getPendingAuthResult();\nif (pending != null) {\n    pending.addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n        @Override\n        public void onSuccess(AuthResult authResult) {\n            Log.d(TAG, \"checkPending:onSuccess:\" + authResult);\n        }\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK로 Apple로 로그인 후 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "Apple로 로그인 후 사용자의 정보를 가져오려면, Firebase 인증에서 제공하는 getCurrentUser() 메서드를 사용하여 사용자 정보를 가져올 수 있습니다. 예를 들어, 사용자의 표시 이름을 가져오려면 다음과 같이 작성합니다.\n\n```kotlin\nval user = auth.currentUser\nval displayName = user?.displayName\n```\n\nJava에서는 다음과 같이 작성할 수 있습니다.\n\n```java\nFirebaseUser user = mAuth.getCurrentUser();\nString displayName = user.getDisplayName();\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 시 사용자에게 제공되는 정보는 무엇인가요?", "answer": "Apple은 사용자가 처음 로그인할 때만 표시 이름 등의 사용자 정보를 앱에 공유합니다. 일반적으로 Firebase는 사용자가 Apple 계정으로 처음 로그인할 때 표시 이름을 저장하며, 이 표시 이름은 getCurrentUser().getDisplayName()를 사용하여 가져올 수 있습니다. 그러나 이전에 Firebase 대신 Apple을 사용하여 사용자를 앱에 로그인하도록 했으면 Apple은 Firebase에 사용자의 표시 이름을 제공하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK로 Apple로 로그인 시 재인증을 수행하는 방법은 무엇인가요?", "answer": "재인증을 수행하려면 startActivityForReauthenticateWithProvider() 메서드를 사용합니다. Kotlin에서는 다음과 같이 작성할 수 있습니다.\n\n```kotlin\nval firebaseUser = auth.getCurrentUser()\n\nfirebaseUser\n    .startActivityForReauthenticateWithProvider(/* activity= */ this, provider.build())\n    .addOnSuccessListener(authResult -> {\n        // 재인증 성공 시 처리\n    });\n```\n\nJava에서는 다음과 같이 작성할 수 있습니다.\n\n```java\nFirebaseUser firebaseUser = mAuth.getCurrentUser();\n\nfirebaseUser\n    .startActivityForReauthenticateWithProvider(/* activity= */ this, provider.build())\n    .addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n        @Override\n        public void onSuccess(AuthResult authResult) {\n            // 재인증 성공 시 처리\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자의 표시 이름을 가져오는 방법은 무엇인가요?", "answer": "사용자가 Apple 계정으로 처음 로그인할 때 표시 이름을 저장하며, 이 표시 이름은 다음 메서드를 사용하여 가져올 수 있습니다:\n\n```kotlin\nval displayName = auth.getCurrentUser().getDisplayName()\n```\n\n```java\nString displayName = mAuth.getCurrentUser().getDisplayName();\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 재인증을 수행하는 방법은 무엇인가요?", "answer": "재인증을 수행하기 위해서는 다음과 같은 코드를 사용할 수 있습니다:\n\n```kotlin\nval firebaseUser = auth.getCurrentUser()\n\nfirebaseUser\n    .startActivityForReauthenticateWithProvider(/* activity= */ this, provider.build())\n    .addOnSuccessListener { authResult ->\n        // 재인증 성공\n    }\n```\n\n```java\nFirebaseUser firebaseUser = mAuth.getCurrentUser();\n\nfirebaseUser\n    .startActivityForReauthenticateWithProvider(/* activity= */ this, provider.build())\n    .addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n        @Override\n        public void onSuccess(AuthResult authResult) {\n            // 재인증 성공\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자 계정을 다른 데이터에 연결하는 방법은 무엇인가요?", "answer": "사용자의 Apple 계정을 다른 데이터에 연결하기 위해서는 사용자가 Facebook에 로그인할 때 얻은 액세스 토큰을 사용하여 다음과 같이 진행합니다:\n\n```kotlin\nval credential = FacebookAuthProvider.getCredential(token.getToken())\n\n.addOnCompleteListener(this) { task ->\n    if (task.isSuccessful()) {\n        // 연결 성공\n    }\n}\n```\n\n```java\nAuthCredential credential = FacebookAuthProvider.getCredential(token.getToken());\n\n.addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n    @Override\n    public void onComplete(@NonNull Task<AuthResult> task) {\n        if (task.isSuccessful()) {\n            // 연결 성공\n        }\n    }\n});\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자 토큰을 취소하는 방법은 무엇인가요?", "answer": "사용자 토큰을 취소하기 위해서는 다음 단계를 구현해야 합니다:\n1. `startActivityForSignInWithProvider()` 메서드를 사용하여 Apple로 로그인하고 `AuthResult`를 가져옵니다.\n2. Apple 제공업체의 액세스 토큰을 가져옵니다:\n\n```kotlin\nval oauthCredential: OAuthCredential = authResult.credential\nval accessToken = oauthCredential.accessToken\n```\n\n```java\nOAuthCredential oauthCredential = (OAuthCredential) authResult.getCredential();\nString accessToken = oauthCredential.getAccessToken();\n```\n3. `revokeAccessToken` API를 사용하여 토큰을 취소합니다:\n\n```kotlin\nmAuth.revokeAccessToken(accessToken)\n    .addOnCompleteListener(this) { task ->\n        if (task.isSuccessful) {\n            // 토큰 취소 성공\n        }\n    }\n```\n\n```java\nmAuth.revokeAccessToken(accessToken)\n    .addOnCompleteListener(this, new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(@NonNull Task<Void> task) {\n            if (task.isSuccessful()) {\n                // 토큰 취소 성공\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 시 사용자에게 제공되는 정보는 무엇인가요?", "answer": "Apple은 사용자가 처음 로그인할 때만 표시 이름 등의 사용자 정보를 앱에 공유합니다. 이 정보는 `getCurrentUser().getDisplayName()` 메서드를 사용하여 가져올 수 있습니다. 그러나 이전에 Firebase 대신 Apple을 사용하여 사용자를 앱에 로그인하도록 했으면 Apple은 Firebase에 사용자의 표시 이름을 제공하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자 토큰을 취소하는 방법은 무엇인가요?", "answer": "Apple로 로그인 후 사용자 토큰을 취소하려면 다음 단계를 구현하세요.\n\n1. `startActivityForSignInWithProvider()` 메서드를 사용하여 Apple로 로그인하고 `AuthResult`를 가져옵니다.\n2. Apple 제공업체의 액세스 토큰을 가져옵니다.\n\nKotlin\n```kotlin\nval oauthCredential: OAuthCredential = authResult.credential\nval accessToken = oauthCredential.accessToken\n```\n\nJava\n```java\nOAuthCredential oauthCredential = (OAuthCredential) authResult.getCredential();\nString accessToken = oauthCredential.getAccessToken();\n```\n\n3. `revokeAccessToken` API를 사용하여 토큰을 취소합니다.\n\nKotlin\n```kotlin\nmAuth.revokeAccessToken(accessToken)\n    .addOnCompleteListener(this) { task ->\n        if (task.isSuccessful) {\n            // 성공적으로 토큰이 취소됨\n        }\n    }\n```\n\nJava\n```java\nmAuth.revokeAccessToken(accessToken)\n    .addOnCompleteListener(this, new OnCompleteListener<Void>() {\n        @Override\n        public void onComplete(@NonNull Task<Void> task) {\n            if (task.isSuccessful()) {\n                // 성공적으로 토큰이 취소됨\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자 인증 정보를 Firebase에 인증하는 방법은 무엇인가요?", "answer": "Firebase Android SDK에서 Apple로 로그인 후 사용자 인증 정보를 Firebase에 인증하려면 다음과 같이 진행하세요.\n\nKotlin\n```kotlin\nauth.signInWithCredential(credential)\n    .addOnCompleteListener(this) { task ->\n        if (task.isSuccessful) {\n            // 인증 성공\n        }\n    }\n```\n\nJava\n```java\nmAuth.signInWithCredential(credential)\n    .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n        @Override\n        public void onComplete(@NonNull Task<AuthResult> task) {\n            if (task.isSuccessful()) {\n                // 인증 성공\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 해시된 nonce를 포함해야 하는 이유는 무엇인가요?", "answer": "Apple로 로그인 시 요청에 해시된 nonce를 파라미터로 포함시켜야 하는 것은 보안상의 이유 때문입니다. 해시된 nonce는 요청의 무결성을 보장하고, 재사용 공격을 방지하는 데 도움을 줍니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Apple로 로그인 후 사용자 계정을 다른 데이터에 연결하는 방법은 무엇인가요?", "answer": "Firebase Android SDK에서 Apple로 로그인 후 사용자 계정을 다른 데이터에 연결하려면, 사용자의 UID를 사용하여 해당 데이터를 Firebase 데이터베이스에 저장하거나 업데이트할 수 있습니다. 예를 들어, 사용자의 UID를 키로 사용하여 데이터베이스에 사용자 정보를 저장할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자에게 제공되는 정보는 무엇인가요?", "answer": "Apple로 로그인 시 사용자에게 제공되는 정보는 사용자의 이름, 이메일 주소, 그리고 Apple ID에 대한 고유 식별자입니다. 이 정보는 사용자가 로그인할 때 요청할 수 있으며, 사용자가 제공한 정보에 따라 다를 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_apple_hl=ko.txt"}
{"question": "Android 프로젝트에 Firebase Authentication 라이브러리를 추가하는 방법은 무엇인가요?", "answer": "모듈(앱 수준) Gradle 파일(일반적으로 <project>/<app-module>/build.gradle.kts 또는 <project>/<app-module>/build.gradle)에서 Android용 Firebase Authentication 라이브러리의 종속 항목을 추가합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_custom-auth_hl=ko.txt"}
{"question": "FirebaseAuth 객체의 공유 인스턴스를 가져오는 방법은 무엇인가요?", "answer": "로그인 작업의 onCreate 메서드에서 FirebaseAuth 객체의 공유 인스턴스를 가져옵니다. 예를 들어, Kotlin에서는 다음과 같이 작성할 수 있습니다:\n\n```kotlin\nprivate lateinit var auth: FirebaseAuth\n```", "source": ["https://firebase.google.com/docs/auth/android/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_custom-auth_hl=ko.txt"}
{"question": "커스텀 토큰으로 Firebase에 로그인하는 방법은 무엇인가요?", "answer": "커스텀 토큰을 사용하여 Firebase에 로그인하려면 다음과 같이 작성합니다:\n\n```java\nmAuth.signInWithCustomToken(mCustomToken)\n    .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n        @Override\n        public void onComplete(@NonNull Task<AuthResult> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"signInWithCustomToken:success\");\n                FirebaseUser user = mAuth.getCurrentUser();\n                updateUI(user);\n            } else {\n                Log.w(TAG, \"signInWithCustomToken:failure\", task.getException());\n                Toast.makeText(CustomAuthActivity.this, \"Authentication failed.\",\n                        Toast.LENGTH_SHORT).show();\n                updateUI(null);\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_custom-auth_hl=ko.txt"}
{"question": "Firebase에서 로그아웃하는 방법은 무엇인가요?", "answer": "Firebase에서 로그아웃하려면 다음과 같이 작성합니다:\n\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_custom-auth_hl=ko.txt"}
{"question": "Firebase 인증에 실패했을 때의 처리 방법은 무엇인가요?", "answer": "Firebase 인증에 실패했을 때는 다음과 같이 Toast 메시지를 표시하고 UI를 업데이트합니다:\n\n```java\nToast.makeText(\n    baseContext,\n    \"Authentication failed.\",\n    Toast.LENGTH_SHORT,\n).show();\nupdateUI(null);\n```", "source": ["https://firebase.google.com/docs/auth/android/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_custom-auth_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하여 이메일 링크로 사용자를 로그인 처리하기 위해 어떤 설정을 해야 하나요?", "answer": "Firebase 프로젝트에서 이메일 제공업체 및 이메일 링크 로그인 방법을 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정합니다. 이메일 링크 로그인을 사용하려면 이메일/비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인을 사용 설정한 후 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증을 시작하기 위해 사용자가 제공해야 하는 정보는 무엇인가요?", "answer": "사용자에게 이메일 주소를 제공하도록 요청하는 인터페이스를 제시해야 합니다. 이후 sendSignInLinkToEmail을 호출하여 Firebase가 사용자의 이메일에 인증 링크를 전송하도록 요청합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크를 생성하기 위해 ActionCodeSettings 객체에서 설정해야 하는 필드는 무엇인가요?", "answer": "ActionCodeSettings 객체에서 설정해야 하는 필드는 다음과 같습니다: url: 삽입할 딥 링크 및 함께 전달할 추가 상태입니다. 승인된 도메인의 Firebase Console 목록에서 링크의 도메인을 허용 목록에 추가해야 하며, 사용자 기기에 앱이 설치되어 있지 않고 앱을 설치할 수 없는 경우 인증 링크는 사용자를 이 URL로 리디렉션합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 localhost를 승인된 도메인으로 사용하는 것에 대한 주의사항은 무엇인가요?", "answer": "2025년 4월 28일 이후에 생성된 프로젝트에서는 Firebase Authentication에 더 이상 기본적으로 localhost가 승인된 도메인으로 포함되지 않습니다. 프로덕션 프로젝트에서는 localhost를 사용하지 않는 것이 좋으며, localhost를 승인하는 경우 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication을 설정할 때 Gradle 파일에 추가해야 하는 종속 항목은 무엇인가요?", "answer": "모듈(앱 수준) Gradle 파일(<project>/<app-module>/build.gradle.kts 또는 <project>/<app-module>/build.gradle)에서 Android용 Firebase Authentication 라이브러리의 종속 항목을 추가해야 합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 사용하기 위해 Firebase Console에서 어떤 단계를 거쳐야 하나요?", "answer": "Firebase 프로젝트에서 이메일 링크 로그인 사용을 설정하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정해야 합니다. 이메일 링크 로그인을 사용하려면 이메일/비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인을 사용 설정한 후 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증을 위해 ActionCodeSettings 객체에서 설정해야 하는 필드에는 어떤 것들이 있나요?", "answer": "ActionCodeSettings 객체에서 설정해야 하는 필드는 다음과 같습니다: \n- url: 삽입할 딥 링크 및 함께 전달할 추가 상태입니다. \n- androidPackageName: Firebase Authentication이 Android 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. \n- iOSBundleId: Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. \n- handleCodeInApp: true로 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크를 전송하기 위해 Firebase Authentication에서 사용하는 메서드는 무엇인가요?", "answer": "이메일 링크를 전송하기 위해 Firebase Authentication에서는 `sendSignInLinkToEmail` 메서드를 사용합니다. 예를 들어, Kotlin에서는 다음과 같이 사용할 수 있습니다:\n```kotlin\nFirebase.auth.sendSignInLinkToEmail(email, actionCodeSettings)\nLog.d(TAG, \"Email sent.\")\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 완료하기 위해 앱에서 어떤 작업을 수행해야 하나요?", "answer": "Firebase Authentication에서는 Firebase Hosting을 사용하여 모바일 기기로 이메일 링크를 보냅니다. 모바일 애플리케이션을 통해 로그인을 완료하는 경우 애플리케이션에서 수신 애플리케이션 링크를 감지하고 이 링크에 포함된 딥 링크를 파싱한 다음 로그인을 완료하도록 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 localhost를 승인된 도메인으로 추가하는 방법은 무엇인가요?", "answer": "localhost를 승인된 도메인으로 추가하려면 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가해야 합니다. 그러나 2025년 4월 28일 이후에 생성된 프로젝트에서는 Firebase Authentication에 더 이상 기본적으로 localhost가 승인된 도메인으로 포함되지 않으므로 프로덕션 프로젝트에서는 localhost를 사용하지 않는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 보내기 위해 ActionCodeSettings 객체를 설정할 때, Android 및 iOS의 패키지 이름을 어떻게 지정하나요?", "answer": "ActionCodeSettings 객체를 설정할 때, Android 및 iOS의 패키지 이름은 다음과 같이 지정할 수 있습니다:\n\n```kotlin\nval actionCodeSettings = actionCodeSettings {\n    setIOSBundleId(\"com.example.ios\")\n    setAndroidPackageName(\n        \"com.example.android\",\n        true, // installIfNotAvailable\n        \"12\" // minimumVersion\n    )\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 완료하기 위해 AndroidManifest.xml 파일에 어떤 인텐트 필터를 추가해야 하나요?", "answer": "AndroidManifest.xml 파일에 추가해야 할 인텐트 필터는 다음과 같습니다:\n\n```xml\n<intent-filter android:autoVerify=\"true\">\n    <action android:name=\"android.intent.action.VIEW\" />\n    <category android:name=\"android.intent.category.BROWSABLE\" />\n    <category android:name=\"android.intent.category.DEFAULT\" />\n    <data\n        android:scheme=\"https\"\n        android:host=\"<PROJECT_ID>.firebaseapp.com or your custom domain\"\n        android:pathPrefix=\"/__/auth/links\" />\n</intent-filter>\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 통해 사용자가 로그인할 때, 앱에서 어떤 작업을 수행해야 하나요?", "answer": "앱에서 사용자가 이메일 링크를 통해 로그인할 때, 수신한 링크가 이메일 링크 인증을 위한 것인지 확인하고 로그인을 완료해야 합니다. 예를 들어, 다음과 같이 코드를 작성할 수 있습니다:\n\n```kotlin\nval auth = Firebase.auth\nval intent = intent\nval emailLink = intent.data.toString()\n\nLog.d(TAG, emailLink)\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 보내기 위해 사용자가 입력해야 하는 정보는 무엇인가요?", "answer": "사용자는 이메일 주소를 입력해야 하며, 이 이메일 주소로 인증 링크가 전송됩니다. 예를 들어, 다음과 같이 이메일 링크를 보낼 수 있습니다:\n\n```kotlin\nFirebase.auth.sendSignInLinkToEmail(email, actionCodeSettings)\nLog.d(TAG, \"Email sent.\")\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 커스텀 도메인을 사용하는 방법은 무엇인가요?", "answer": "이메일 링크에 커스텀 도메인을 사용하려면 Firebase Hosting에 도메인을 등록하여 링크의 도메인으로 사용할 수 있습니다. 기본 도메인은 PROJECT_ID.firebaseapp.com 형식입니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 통해 로그인을 완료하기 위해 AndroidManifest.xml 파일에 어떤 인텐트 필터를 추가해야 하나요?", "answer": "AndroidManifest.xml 파일에 다음과 같은 인텐트 필터를 추가해야 합니다:\n```xml\n<intent-filter android:autoVerify=\"true\">\n<action android:name=\"android.intent.action.VIEW\" />\n<category android:name=\"android.intent.category.BROWSABLE\" />\n<category android:name=\"android.intent.category.DEFAULT\" />\n<data\nandroid:scheme=\"https\"\nandroid:host=\"<PROJECT_ID>.firebaseapp.com or your custom domain\"\nandroid:pathPrefix=\"/__/auth/links\" />\n</intent-filter>\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Hosting 도메인을 구성하기 위해 Firebase Console에서 어떤 단계를 거쳐야 하나요?", "answer": "Firebase Console에서 호스팅 섹션을 열고, 기본 사이트로 이동하여 기본 Hosting 도메인을 기록해야 합니다. 기본 Hosting 도메인의 형식은 일반적으로 다음과 같습니다: PROJECT_ID.firebaseapp.com.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위한 링크를 수신한 후 앱에서 어떤 작업을 수행해야 하나요?", "answer": "앱에서 수신한 링크가 이메일 링크 인증을 위한 링크인지 확인하고 로그인을 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 통해 사용자가 로그인할 때, 어떤 Kotlin 코드를 사용해야 하나요?", "answer": "다음과 같은 Kotlin 코드를 사용하여 이메일 링크로 로그인을 처리할 수 있습니다:\n```kotlin\nval auth = Firebase.auth\nval intent = intent\nval emailLink = intent.data.toString()\n\nLog.d(TAG, \"Successfully signed in with email link!\")\nval result = task.result\nLog.e(TAG, \"Error signing in with email link\", task.exception)\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 Android 애플리케이션에서 어떤 정보를 제공해야 하나요?", "answer": "Android 애플리케이션에서 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정하고, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크로 로그인을 완료하기 위해 Kotlin에서 어떤 코드를 사용해야 하나요?", "answer": "Kotlin에서 이메일 링크로 로그인을 완료하기 위해 다음 코드를 사용할 수 있습니다:\n\n```kotlin\nval auth = Firebase.auth\nval intent = intent\nval emailLink = intent.data.toString()\n\nLog.d(TAG, \"Successfully signed in with email link!\")\nval result = task.result\nLog.e(TAG, \"Error signing in with email link\", task.exception)\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 Java에서 어떤 코드를 사용해야 하나요?", "answer": "Java에서 이메일 링크 인증을 위해 다음 코드를 사용할 수 있습니다:\n\n```java\nFirebaseAuth auth = FirebaseAuth.getInstance();\nIntent intent = getIntent();\nString emailLink = intent.getData().toString();\n\nString email = \"someemail@domain.com\";\n\n.addOnCompleteListener(new OnCompleteListener<AuthResult>() {\n@Override\npublic void onComplete(@NonNull Task<AuthResult> task) {\nif (task.isSuccessful()) {\nLog.d(TAG, \"Successfully signed in with email link!\");\nAuthResult result = task.getResult();\nLog.e(TAG, \"Error signing in with email link\", task.getException());\n}\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 사용자가 로그인을 시도할 때 어떤 작업을 수행해야 하나요?", "answer": "사용자가 이메일 링크 인증을 위해 로그인을 시도할 때, 다음과 같은 작업을 수행해야 합니다:\n\n```kotlin\nFirebase.auth.currentUser!!.linkWithCredential(credential)\nLog.d(TAG, \"Successfully linked emailLink credential!\")\nval result = task.result\nLog.e(TAG, \"Error linking emailLink credential\", task.exception)\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 사용자가 로그아웃할 때 어떤 코드를 사용해야 하나요?", "answer": "사용자가 로그아웃할 때, Kotlin에서는 다음 코드를 사용할 수 있습니다:\n\n```kotlin\nFirebase.auth.signOut()\n```\nJava에서는 다음 코드를 사용할 수 있습니다:\n\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 인증을 위해 사용자가 제공해야 하는 이메일 주소를 어떻게 처리하나요?", "answer": "이메일 링크 인증을 위해 사용자가 제공한 이메일 주소는 다음과 같이 처리할 수 있습니다:\n\n```java\nAuthCredential credential = EmailAuthProvider.getCredentialWithLink(email, emailLink);\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-auth_hl=ko.txt"}
{"question": "Firebase Dynamic Links 도메인을 Firebase Hosting 도메인으로 마이그레이션하려면 어떤 단계를 따라야 하나요?", "answer": "Firebase Authentication은 Firebase Dynamic Links 도메인을 사용하는 대신 프로젝트의 Firebase Hosting 기본 도메인을 사용하여 모바일 앱에서 이메일 링크 및 기타 대역 외 링크 작업의 링크를 만듭니다. 앱을 업데이트하여 자동으로 프로비저닝된 새 Firebase Hosting 기본 도메인을 사용할 수 있도록 하려면 Android에서 이메일 링크를 사용하여 Firebase에 인증을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "AndroidManifest.xml 파일에서 Firebase Hosting 링크를 처리하기 위해 어떤 인텐트 필터를 구성해야 하나요?", "answer": "AndroidManifest.xml 파일에 다음과 같은 인텐트 필터를 추가해야 합니다:\n```xml\n<intent-filter android:autoVerify=\"true\">\n<action android:name=\"android.intent.action.VIEW\" />\n<category android:name=\"android.intent.category.BROWSABLE\" />\n<category android:name=\"android.intent.category.DEFAULT\" />\n<data\nandroid:scheme=\"https\"\nandroid:host=\"PROJECT_ID.firebaseapp.com or a custom hosting domain\"\nandroid:pathPrefix=\"/__/auth/links\" />\n</intent-filter>\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 링크를 처리하기 위해 Android 애플리케이션에서 제공해야 하는 정보는 무엇인가요?", "answer": "Android 애플리케이션에서 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정해야 하며, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Dynamic Links 도메인을 커스텀 도메인으로 재사용할 수 있나요?", "answer": "Firebase Dynamic Links 도메인을 커스텀 도메인으로 재사용할 수 있지만, Firebase Dynamic Links 기능은 더 이상 지원되지 않습니다. 예를 들어 앱이 기기에 설치되어 있지 않으면 사용자를 앱 스토어로 리디렉션할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 링크 솔루션을 사용하면서 기존 Firebase Dynamic Links 인텐트 필터를 유지해야 하는 이유는 무엇인가요?", "answer": "원활한 롤백을 위해 Firebase Hosting 링크 솔루션을 사용해 보는 동안 Firebase Dynamic Links를 처리하는 기존 인텐트 필터를 유지하는 것이 좋습니다. Firebase Dynamic Links 솔루션은 2025년 8월 25일까지 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 링크를 처리하기 위해 Android 애플리케이션에서 제공해야 하는 패키지 이름은 어떻게 설정하나요?", "answer": "Android 애플리케이션에서 Firebase Hosting 링크를 처리하려면 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 링크를 특정 활동으로 리디렉션하기 위해 AndroidManifest.xml 파일에 어떤 인텐트 필터를 추가해야 하나요?", "answer": "AndroidManifest.xml 파일에 다음과 같은 인텐트 필터를 추가해야 합니다:\n```xml\n<intent-filter android:autoVerify=\"true\">\n<action android:name=\"android.intent.action.VIEW\" />\n<category android:name=\"android.intent.category.BROWSABLE\" />\n<category android:name=\"android.intent.category.DEFAULT\" />\n<data\nandroid:scheme=\"https\"\nandroid:host=\"PROJECT_ID.firebaseapp.com or a custom hosting domain\"\nandroid:pathPrefix=\"/__/auth/links\" />\n</intent-filter>\n```", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 링크 솔루션을 사용하면서 기존 Firebase Dynamic Links 인텐트 필터를 유지해야 하는 이유는 무엇인가요?", "answer": "원활한 롤백을 위해 Firebase Hosting 링크 솔루션을 사용해 보는 동안 Firebase Dynamic Links를 처리하는 기존 인텐트 필터를 유지하는 것이 좋습니다. Firebase Dynamic Links 솔루션은 2025년 8월 25일까지 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Admin SDK를 사용하여 이메일 링크 생성 방식을 업데이트하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 이메일 링크 생성 방식을 업데이트하고 백엔드에 새 Firebase Hosting 도메인을 사용하여 링크 생성을 시작하도록 지시할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Firebase Dynamic Links 도메인을 커스텀 도메인으로 재사용할 때 주의해야 할 점은 무엇인가요?", "answer": "Firebase Dynamic Links 도메인을 커스텀 도메인으로 재사용할 수 있지만, Firebase Dynamic Links 기능은 더 이상 지원되지 않으며, 예를 들어 앱이 기기에 설치되어 있지 않으면 사용자를 앱 스토어로 리디렉션할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/android/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_email-link-migration_hl=ko.txt"}
{"question": "Android에서 Facebook 로그인을 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "Android 프로젝트에 Firebase를 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "Firebase Console에서 Facebook 로그인을 사용 설정할 때 어떤 정보를 입력해야 하나요?", "answer": "Facebook에서 받은 앱 ID와 앱 비밀번호를 입력해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인을 통합할 때 요청해야 하는 권한은 무엇인가요?", "answer": "public_profile 및 email 권한을 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "사용자가 Facebook 로그인을 통해 인증할 때, 성공적으로 인증된 후 어떤 메서드를 호출해야 하나요?", "answer": "handleFacebookAccessToken(loginResult.accessToken) 메서드를 호출해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "사용자를 로그아웃시키기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "signOut 메서드를 호출해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인을 통해 사용자가 인증된 후, 어떤 정보를 사용하여 FirebaseUser 객체에서 기본 프로필 정보를 가져올 수 있나요?", "answer": "앱의 FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "사용자가 Facebook 로그인을 통해 인증할 때, 인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 어떻게 연결하나요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다. 계정 연결 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃시키기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut 메서드를 호출해야 합니다. 예제 코드는 다음과 같습니다:\n\nKotlin\n```kotlin\nFirebase.auth.signOut()\n```\n\nJava\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인을 통해 인증할 때, 인증이 실패했을 경우 어떤 메시지를 사용자에게 표시하나요?", "answer": "인증이 실패했을 경우, 'Authentication failed.'라는 메시지를 사용자에게 표시합니다. 예제 코드는 다음과 같습니다:\n\n```java\nToast.makeText(FacebookLoginActivity.this, \"Authentication failed.\", Toast.LENGTH_SHORT).show();\n```", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "사용자가 Facebook 로그인을 통해 인증할 때, 인증 성공 후 어떤 UI 업데이트를 수행해야 하나요?", "answer": "인증 성공 후 updateUI(user) 메서드를 호출하여 UI를 업데이트해야 합니다. 예제 코드는 다음과 같습니다:\n\n```java\nupdateUI(user);\n```", "source": ["https://firebase.google.com/docs/auth/android/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_facebook-login_hl=ko.txt"}
{"question": "FirebaseUI에서 여러 로그인 제공업체를 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 여러 로그인 제공업체를 설정하려면, 로그인 인텐트를 만들 때 사용 가능한 제공업체 목록을 설정해야 합니다. 예를 들어, Kotlin에서는 다음과 같이 설정할 수 있습니다:\n\n```kotlin\nval providers = arrayListOf(\n    AuthUI.IdpConfig.EmailBuilder().build(),\n    AuthUI.IdpConfig.PhoneBuilder().build(),\n    AuthUI.IdpConfig.GoogleBuilder().build(),\n    AuthUI.IdpConfig.FacebookBuilder().build(),\n    AuthUI.IdpConfig.TwitterBuilder().build()\n)\nval signInIntent = AuthUI.getInstance()\n    .createSignInIntentBuilder()\n    .setAvailableProviders(providers)\n    .build()\nsignInLauncher.launch(signInIntent)\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 결과를 처리하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 로그인 결과를 처리하려면, `onSignInResult` 메서드를 구현해야 합니다. Kotlin 예시는 다음과 같습니다:\n\n```kotlin\nprivate fun onSignInResult(result: FirebaseAuthUIAuthenticationResult) {\n    val response = result.idpResponse\n    if (result.resultCode == RESULT_OK) {\n        // 로그인 성공 처리\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI를 사용하기 위해 Android 프로젝트에 추가해야 할 종속 항목은 무엇인가요?", "answer": "Android 프로젝트에 FirebaseUI를 추가하기 위해서는 `build.gradle(.kts)` 파일에 FirebaseUI의 종속 항목을 추가해야 합니다. 예를 들어:\n\n```groovy\ndependencies {\n    implementation 'com.firebaseui:firebase-ui-auth:7.2.0'\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Facebook 로그인을 설정하기 위해 필요한 문자열 리소스는 무엇인가요?", "answer": "FirebaseUI에서 Facebook 로그인을 설정하기 위해서는 `strings.xml` 파일에 다음과 같은 문자열 리소스를 추가해야 합니다:\n\n```xml\n<resources>\n    <string name=\"facebook_application_id\" translatable=\"false\">YOUR_APP_ID</string>\n    <string name=\"facebook_login_protocol_scheme\" translatable=\"false\">fbYOUR_APP_ID</string>\n</resources>\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Google 로그인을 사용하기 위해 필요한 구성 파일은 무엇인가요?", "answer": "FirebaseUI에서 Google 로그인을 사용하기 위해서는 업데이트된 Firebase 구성 파일인 `google-services.json`을 다운로드하고, 이를 Android 스튜디오 프로젝트에 추가해야 합니다. 이 파일에는 Google 로그인에 필요한 OAuth 클라이언트 정보가 포함되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 SHA-1 디지털 지문을 지정하는 방법은 무엇인가요?", "answer": "Firebase Console의 설정 페이지에서 SHA-1 디지털 지문을 지정할 수 있습니다. 설정 페이지는 다음 링크에서 확인할 수 있습니다: [Firebase Console 설정 페이지](https://console.firebase.google.com/project/_/settings/general/?hl=ko).", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Facebook 로그인을 설정하기 위해 strings.xml에 추가해야 하는 문자열 리소스는 무엇인가요?", "answer": "<resources>\n<!-- Facebook application ID and custom URL scheme (app ID prefixed by 'fb'). -->\n<string name=\"facebook_application_id\" translatable=\"false\">YOUR_APP_ID</string>\n<string name=\"facebook_login_protocol_scheme\" translatable=\"false\">fbYOUR_APP_ID</string>\n</resources>", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 인텐트를 생성하는 방법은 무엇인가요?", "answer": "로그인 인텐트를 생성하려면 다음과 같이 코드를 작성합니다:\n\nKotlin\nval signInIntent = AuthUI.getInstance()\n.createSignInIntentBuilder()\n.setAvailableProviders(providers)\n.build();\nsignInLauncher.launch(signInIntent);", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 결과를 처리하는 방법은 무엇인가요?", "answer": "로그인 결과는 onSignInResult 메서드에서 처리할 수 있습니다. 다음은 Kotlin 코드 예시입니다:\n\nKotlin\nprivate fun onSignInResult(result: FirebaseAuthUIAuthenticationResult) {\nval response = result.idpResponse\nif (result.resultCode == RESULT_OK) {\n// 로그인 성공 처리\n}", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크 인증을 처리하는 방법은 무엇인가요?", "answer": "이메일 링크 인증을 처리하려면 다음과 같은 코드를 사용합니다:\n\nKotlin\nif (AuthUI.canHandleIntent(intent)) {\nval extras = intent.extras ?: return\nval link = extras.getString(\"email_link_sign_in\")\nif (link != null) {\nval signInIntent = AuthUI.getInstance()\n.createSignInIntentBuilder()\n.setEmailLink(link)\n.setAvailableProviders(providers)\n.build()\nsignInLauncher.launch(signInIntent)\n}", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크 인증을 위한 ActionCodeSettings를 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 이메일 링크 인증을 위한 ActionCodeSettings는 다음과 같이 설정할 수 있습니다. \n\n```kotlin\nval actionCodeSettings = ActionCodeSettings.newBuilder()\n    .setAndroidPackageName( // yourPackageName=\n        \"...\", // installIfNotAvailable=\n        true, // minimumVersion=\n        null)\n    .setHandleCodeInApp(true) // This must be set to true\n    .setUrl(\"https://google.com\") // This URL needs to be whitelisted\n    .build()\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크을 사용하여 로그인하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 이메일 링크을 사용하여 로그인하려면 다음과 같은 코드를 사용할 수 있습니다. \n\n```kotlin\nif (AuthUI.canHandleIntent(intent)) {\n    val extras = intent.extras ?: return\n    val link = extras.getString(\"email_link_sign_in\")\n    if (link != null) {\n        val signInIntent = AuthUI.getInstance()\n            .createSignInIntentBuilder()\n            .setEmailLink(link)\n            .setAvailableProviders(providers)\n            .build()\n        signInLauncher.launch(signInIntent)\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그아웃을 처리하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 로그아웃을 처리하는 방법은 다음과 같습니다. \n\n```kotlin\nAuthUI.getInstance()\n    .signOut(this)\n    .addOnCompleteListener { task ->\n        // 로그아웃 완료 후 처리\n    }\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 사용자 정의 개인정보처리방침 및 서비스 약관을 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 사용자 정의 개인정보처리방침 및 서비스 약관을 설정하려면 다음과 같은 코드를 사용할 수 있습니다. \n\n```kotlin\nval signInIntent = AuthUI.getInstance()\n    .createSignInIntentBuilder()\n    .setAvailableProviders(providers)\n    .setTosAndPrivacyPolicyUrls(\n        \"https://example.com/terms.html\",\n        \"https://example.com/privacy.html\")\n    .build()\nsignInLauncher.launch(signInIntent)\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 인텐트를 생성할 때 로고와 테마를 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 로그인 인텐트를 생성할 때 로고와 테마를 설정하는 방법은 다음과 같습니다. \n\n```java\nIntent signInIntent = AuthUI.getInstance()\n    .createSignInIntentBuilder()\n    .setAvailableProviders(providers)\n    .setLogo(R.drawable.my_great_logo) // Set logo drawable\n    .setTheme(R.style.MySuperAppTheme) // Set theme\n    .build();\nsignInLauncher.launch(signInIntent);\n```", "source": ["https://firebase.google.com/docs/auth/android/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_firebaseui_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 GitHub 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 GitHub 로그인을 사용 설정하려면 다음 단계를 따르세요:\n1. Firebase Console에서 인증 섹션을 엽니다.\n2. 로그인 방법 탭에서 GitHub 제공업체를 사용 설정합니다.\n3. GitHub 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "Android 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "Android 프로젝트에 Firebase를 추가하려면 Firebase 공식 문서의 지침을 따르세요. 일반적으로 Firebase Console에서 프로젝트를 생성하고, Firebase SDK를 Android 프로젝트에 통합하는 과정을 포함합니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "OAuthProvider의 인스턴스를 생성하려면 제공업체 ID로 'github.com'을 사용하여 빌더를 생성합니다. Kotlin과 Java의 예시는 다음과 같습니다:\n\nKotlin\n```kotlin\nval provider = OAuthProvider.newBuilder(\"github.com\")\n```\n\nJava\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"github.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수를 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "GitHub API의 비공식 사용자 데이터에 대한 액세스를 요청하는 방법은 무엇인가요?", "answer": "애플리케이션에서 GitHub API의 비공식 사용자 데이터에 대한 액세스가 필요한 경우 GitHub 개발자 콘솔의 API 권한에서 GitHub API에 대한 액세스 권한을 요청해야 합니다. 요청받은 OAuth 범위는 앱의 API 권한으로 사전 구성된 범위와 정확하게 일치해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "Firebase Android SDK를 사용하여 GitHub 로그인을 처리하는 방법은 무엇인가요?", "answer": "Firebase Android SDK로 로그인 과정을 처리하려면 다음 단계를 따릅니다.\n\n제공업체 ID github.com을 사용하여 빌더로 OAuthProvider의 인스턴스를 생성합니다.\n\nKotlin\n```kotlin\nval provider = OAuthProvider.newBuilder(\"github.com\")\n```\n\nJava\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"github.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 커스텀 OAuth 매개변수를 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없으며, 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "GitHub API의 비공식 사용자 데이터에 대한 액세스를 요청하기 위해 추가해야 하는 OAuth 2.0 범위는 무엇인가요?", "answer": "애플리케이션에서 GitHub API의 비공식 사용자 데이터에 대한 액세스가 필요한 경우 GitHub 개발자 콘솔의 API 권한에서 GitHub API에 대한 액세스 권한을 요청해야 합니다. 요청받은 OAuth 범위는 앱의 API 권한으로 사전 구성된 범위와 정확하게 일치해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스를 사용하여 사용자를 로그아웃하는 방법은 무엇인가요?", "answer": "Kotlin\n```kotlin\nFirebase.auth.signOut()\n```\n\nJava\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "Firebase에서 현재 사용자를 가져오는 방법은 무엇인가요?", "answer": "Kotlin\n```kotlin\nval firebaseUser = Firebase.auth.currentUser\n```\n\nJava\n```java\nFirebaseUser firebaseUser = FirebaseAuth.getInstance().getCurrentUser();\n```", "source": ["https://firebase.google.com/docs/auth/android/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_github-auth_hl=ko.txt"}
{"question": "Firebase Authentication을 설정하기 위해 Android 프로젝트에 추가해야 하는 라이브러리는 무엇인가요?", "answer": "Android 프로젝트에 Firebase Authentication 라이브러리의 종속 항목을 추가해야 합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "Google 로그인 방법을 Firebase Console에서 어떻게 활성화하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Google 로그인 방법을 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "Google 계정으로 로그인을 통합하기 위해 어떤 요청을 만들어야 하나요?", "answer": "GetGoogleIdOption을 사용하여 Google 로그인 요청을 인스턴스화한 후, GetCredentialRequest를 사용하여 인증 관리자 요청을 만듭니다. 예시는 다음과 같습니다.\n\n```java\nGetGoogleIdOption googleIdOption = new GetGoogleIdOption.Builder()\n.setFilterByAuthorizedAccounts(true)\n.setServerClientId(getString(R.string.default_web_client_id))\n.build();\n\nGetCredentialRequest request = new GetCredentialRequest.Builder()\n.addCredentialOption(googleIdOption)\n.build();\n```", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "OAuth 2.0 클라이언트 ID를 확인하는 방법은 무엇인가요?", "answer": "Google Cloud 콘솔에서 사용자 인증 정보 페이지를 열고 웹 애플리케이션 유형의 클라이언트 ID가 백엔드 서버의 OAuth 2.0 클라이언트 ID입니다.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "GoogleSignInActivity.kt에서 Google ID 옵션을 설정하는 방법은 무엇인가요?", "answer": "Google ID 옵션을 설정하기 위해서는 다음과 같은 코드를 사용합니다:\n\n```kotlin\nGetGoogleIdOption googleIdOption = new GetGoogleIdOption.Builder()\n.setFilterByAuthorizedAccounts(true)\n.setServerClientId(getString(R.string.default_web_client_id))\n.build();\n```", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "Java에서 GetCredentialRequest를 생성하는 방법은 무엇인가요?", "answer": "Java에서 GetCredentialRequest를 생성하기 위해서는 다음과 같은 코드를 사용합니다:\n\n```java\nGetCredentialRequest request = new GetCredentialRequest.Builder()\n.addCredentialOption(googleIdOption)\n.build();\n```", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "앱의 FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져오려면 FirebaseUser 객체를 사용하여 관련 정보를 조회하면 됩니다. 자세한 내용은 사용자 관리 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키기 위해서는 다음과 같은 코드를 사용합니다:\n\n```kotlin\nprivate fun signOut() {\n    credentialManager.clearCredentialState(clearRequest)\n    updateUI(null)\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_google-signin_hl=ko.txt"}
{"question": "Firebase에서 신규 사용자를 생성하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 신규 사용자를 생성할 때는 createUserWithEmailAndPassword 메서드를 호출하거나 Google 로그인 또는 Facebook 로그인과 같은 제휴 ID 공급업체를 이용해 사용자의 최초 로그인을 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_manage-users_hl=ko.txt"}
{"question": "현재 로그인한 사용자를 가져오는 방법은 무엇인가요?", "answer": "현재 사용자를 가져올 때 권장하는 방법은 getCurrentUser 메서드를 호출하는 것입니다. 로그인한 사용자가 없으면 getCurrentUser는 null을 반환합니다.", "source": ["https://firebase.google.com/docs/auth/android/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_manage-users_hl=ko.txt"}
{"question": "사용자의 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자의 프로필 정보를 가져오려면 FirebaseUser 인스턴스의 접근자 메서드를 사용합니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n\n```kotlin\nval user = Firebase.auth.currentUser\nuser?.let {\n    val email = it.email\n    val photoUrl = it.photoUrl\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_manage-users_hl=ko.txt"}
{"question": "사용자의 이메일 주소를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소를 업데이트하려면 다음과 같이 updateEmail 메서드를 사용할 수 있습니다: \n\n```kotlin\nval user = Firebase.auth.currentUser\nuser!!.updateEmail(\"user@example.com\")\n    .addOnCompleteListener { task ->\n        if (task.isSuccessful()) {\n            Log.d(TAG, \"User email address updated.\");\n        }\n    }\n```", "source": ["https://firebase.google.com/docs/auth/android/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_manage-users_hl=ko.txt"}
{"question": "사용자 계정을 삭제하는 방법은 무엇인가요?", "answer": "사용자 계정을 삭제하려면 delete 메서드를 사용할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n\n```kotlin\nval user = Firebase.auth.currentUser!!\nuser.delete()\n    .addOnCompleteListener { task ->\n        if (task.isSuccessful()) {\n            Log.d(TAG, \"User account deleted.\");\n        }\n    }\n```", "source": ["https://firebase.google.com/docs/auth/android/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_manage-users_hl=ko.txt"}
{"question": "Firebase Android SDK를 사용하여 Microsoft 계정으로 로그인하는 과정은 어떻게 되나요?", "answer": "Firebase Android SDK로 로그인 과정을 처리하려면 다음 단계를 따릅니다.\n\n1. 제공업체 ID microsoft.com을 사용하여 빌더로 OAuthProvider의 인스턴스를 생성합니다.\n   ```kotlin\n   val provider = OAuthProvider.newBuilder(\"microsoft.com\")\n   ```\n   ```java\n   OAuthProvider.Builder provider = OAuthProvider.newBuilder(\"microsoft.com\");\n   ```\n2. 선택사항: OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 클라이언트를 등록하기 위한 절차는 무엇인가요?", "answer": "Microsoft OAuth 클라이언트를 등록하려면 빠른 시작: Azure Active Directory v2.0 엔드포인트를 사용하여 앱 등록의 안내를 따릅니다. 이 엔드포인트는 Microsoft 개인 계정과 Azure Active Directory 계정을 사용하는 로그인을 지원합니다. 앱을 등록할 때 프로젝트의 *.firebaseapp.com 도메인을 앱의 리디렉션 도메인으로 등록해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase Console에서 Microsoft 제공업체를 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Microsoft 제공업체를 사용 설정합니다. 또한 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?", "answer": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용해야 합니다. 이렇게 하려면 커스텀 매개변수 객체의 '테넌트' 필드를 지정합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase SDK로 로그인 과정 처리 시 커스텀 매개변수는 어떻게 전달하나요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Microsoft 계정으로 로그인하기 위해 OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko#kotlin-android] ---\nval provider = OAuthProvider.newBuilder(\"microsoft.com\")\n\n--- 탭: Java [https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko#java-android] ---\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"microsoft.com\");", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 커스텀 OAuth 매개변수를 추가하는 방법은 무엇인가요?", "answer": "선택사항: OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하는 방법은 무엇인가요?", "answer": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용하면 됩니다. 이렇게 하려면 커스텀 매개변수 객체의 '테넌트' 필드를 지정합니다.", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Microsoft 제공업체를 기존 사용자에 연결하는 방법은 무엇인가요?", "answer": "위의 예시는 로그인 과정에 중점을 두고 있지만 startActivityForLinkWithProvider를 사용하여 Microsoft 제공업체를 기존 사용자에 연결할 수도 있습니다. 예를 들어 여러 제공업체를 동일한 사용자에 연결하여 그 중 하나로 로그인하도록 허용할 수 있습니다.\n--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko#kotlin-android] ---\nfirebaseUser\n.startActivityForLinkWithProvider(activity, provider.build())\n\nFirebaseUser firebaseUser = firebaseAuth.getCurrentUser();", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Microsoft 제공업체로 재인증하는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko#kotlin-android] ---\nfirebaseUser\n.startActivityForReauthenticateWithProvider(activity, provider.build())\n\nFirebaseUser firebaseUser = firebaseAuth.getCurrentUser();", "source": ["https://firebase.google.com/docs/auth/android/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_microsoft-oauth_hl=ko.txt"}
{"question": "Android 앱에서 다중 인증(MFA)을 사용하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "다중 인증(MFA)을 사용하기 위해서는 앱이 사용자 이메일을 확인하고 있는지 확인해야 합니다. MFA를 사용하려면 이메일 인증이 필요합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Firebase Console에서 SMS 다중 인증(MFA)을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console의 인증 > 로그인 방법 페이지를 열고, 고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "사용자가 다중 인증(MFA)의 두 번째 단계를 등록하기 위해 따라야 할 단계는 무엇인가요?", "answer": "사용자의 새로운 두 번째 단계를 등록하려면 다음 단계를 따르세요: 사용자를 다시 인증합니다. 사용자에게 전화번호를 입력하도록 요청합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "Kotlin에서 다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용하세요:\n\n```kotlin\nuser.multiFactor.session.addOnCompleteListener { task ->\n    if (task.isSuccessful) {\n        val multiFactorSession: MultiFactorSession? = task.result\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 사용자 전화로 인증 코드를 보내는 방법은 무엇인가요?", "answer": "Java에서 사용자 전화로 인증 코드를 보내려면 다음 코드를 사용하세요:\n\n```java\nPhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions);\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 사용자의 두 번째 단계를 등록하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "사용자의 새로운 두 번째 단계를 등록하려면 다음 단계를 따르세요.\n\n1. 사용자를 다시 인증합니다.\n2. 사용자에게 전화번호를 입력하도록 요청합니다.\n   참고: Google은 모든 Google 서비스의 스팸 및 악용 방지를 위해 전화번호를 저장하고 사용합니다. 전화번호를 Firebase로 보내기 전에 사용자에게 적절한 동의를 얻어야 합니다.\n3. 사용자를 위한 다중 세션을 가져옵니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용하세요:\n\n```kotlin\nuser.multiFactor.session.addOnCompleteListener { task ->\n    if (task.isSuccessful) {\n        val multiFactorSession: MultiFactorSession? = task.result\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용하세요:\n\n```java\nuser.getMultiFactor().getSession()\n    .addOnCompleteListener(\n        new OnCompleteListener<MultiFactorSession>() {\n            @Override\n            public void onComplete(@NonNull Task<MultiFactorSession> task) {\n                if (task.isSuccessful()) {\n                    MultiFactorSession multiFactorSession = task.getResult();\n                }\n            }\n        }\n    );\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 사용자의 전화로 인증 코드를 보내는 방법은 무엇인가요?", "answer": "사용자 전화로 인증 코드를 보내려면 다음 코드를 사용하세요:\n\nKotlin:\n```kotlin\nPhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions)\n```\n\nJava:\n```java\nPhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions);\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 등록을 완료하려면 다음 코드를 사용하세요:\n\nKotlin:\n```kotlin\nFirebaseAuth.getInstance()\n    .currentUser\n    ?.multiFactor\n    ?.enroll(multiFactorAssertion, \"My personal phone number\")\n    ?.addOnCompleteListener {\n```\n\nJava:\n```java\nFirebaseAuth.getInstance()\n    .getCurrentUser()\n    .getMultiFactor()\n    .enroll(multiFactorAssertion, \"My personal phone number\")\n    .addOnCompleteListener(\n        new OnCompleteListener<Void>() {\n            @Override\n            public void onComplete(@NonNull Task<Void> task) {\n            }\n        }\n    );\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "Kotlin에서 다중 인증(MFA) 등록을 완료하려면 다음 코드를 사용합니다:\n\n```kotlin\n// Complete enrollment. This will update the underlying tokens\nFirebaseAuth.getInstance()\n.currentUser\n?.multiFactor\n?.enroll(multiFactorAssertion, \"My personal phone number\")\n?.addOnCompleteListener {\n```\n이 코드는 MultiFactorAssertion 객체를 사용하여 현재 사용자의 다중 인증을 등록합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "Java에서 다중 인증(MFA) 등록을 완료하려면 다음 코드를 사용합니다:\n\n```java\n// Complete enrollment. This will update the underlying tokens\nFirebaseAuth.getInstance()\n.getCurrentUser()\n.getMultiFactor()\n.enroll(multiFactorAssertion, \"My personal phone number\")\n.addOnCompleteListener(\nnew OnCompleteListener<Void>() {\n@Override\npublic void onComplete(@NonNull Task<Void> task) {\n```\n이 코드는 MultiFactorAssertion 객체를 사용하여 현재 사용자의 다중 인증을 등록합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하는 방법은 무엇인가요?", "answer": "Kotlin에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하려면 다음 코드를 사용합니다:\n\n```kotlin\nval phoneAuthOptions = PhoneAuthOptions.newBuilder()\n.setPhoneNumber(phoneNumber)\n.setTimeout(30L, TimeUnit.SECONDS)\n.setMultiFactorSession(multiFactorSession)\n.setCallbacks(callbacks)\n.build()\n```\n이 코드는 전화번호, 타임아웃, 다중 인증 세션 및 콜백을 설정하여 PhoneAuthOptions 객체를 생성합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하는 방법은 무엇인가요?", "answer": "Java에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하려면 다음 코드를 사용합니다:\n\n```java\nPhoneAuthOptions phoneAuthOptions = PhoneAuthOptions.newBuilder()\n.setPhoneNumber(phoneNumber)\n.setTimeout(30L, TimeUnit.SECONDS)\n.setMultiFactorSession(multiFactorSession)\n.setCallbacks(callbacks)\n.build();\n```\n이 코드는 전화번호, 타임아웃, 다중 인증 세션 및 콜백을 설정하여 PhoneAuthOptions 객체를 생성합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 사용자가 인증 코드를 확인하도록 요청하는 방법은 무엇인가요?", "answer": "다중 인증(MFA)에서 사용자가 인증 코드를 확인하도록 요청하려면 다음 코드를 사용합니다:\n\n```kotlin\n// Ask user for the verification code.\nval credential = PhoneAuthProvider.getCredential(verificationId, verificationCode)\n```\n이 코드는 사용자가 입력한 인증 코드로 PhoneAuthCredential 객체를 생성합니다.", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 다중 인증(MFA) 세션을 사용하여 인증을 완료하는 방법은 무엇인가요?", "answer": "Kotlin에서 다중 인증(MFA) 세션을 사용하여 인증을 완료하려면, 다음과 같은 코드를 사용합니다:\n\n```kotlin\nmultiFactorResolver\n    .resolveSignIn(multiFactorAssertion)\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 다중 인증(MFA) 세션을 사용하여 인증을 완료하는 방법은 무엇인가요?", "answer": "Java에서 다중 인증(MFA) 세션을 사용하여 인증을 완료하려면, 다음과 같은 코드를 사용합니다:\n\n```java\nmultiFactorResolver\n    .resolveSignIn(multiFactorAssertion)\n    .addOnCompleteListener(\n        new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete(@NonNull Task<AuthResult> task) {\n                if (task.isSuccessful()) {\n                    AuthResult authResult = task.getResult();\n                }\n            }\n        }\n    );\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Kotlin에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하는 방법은 무엇인가요?", "answer": "Kotlin에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하려면, 다음과 같은 코드를 사용합니다:\n\n```kotlin\nval phoneAuthOptions = PhoneAuthOptions.newBuilder()\n    .setMultiFactorHint(selectedHint)\n    .setTimeout(30L, TimeUnit.SECONDS)\n    .setMultiFactorSession(multiFactorResolver.session)\n    .setCallbacks(callbacks)\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "Java에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하는 방법은 무엇인가요?", "answer": "Java에서 인증 코드 전송을 위한 PhoneAuthOptions를 설정하려면, 다음과 같은 코드를 사용합니다:\n\n```java\nPhoneAuthOptions phoneAuthOptions = PhoneAuthOptions.newBuilder()\n    .setMultiFactorHint(selectedHint)\n    .setTimeout(30L, TimeUnit.SECONDS)\n    .setMultiFactorSession(multiFactorResolver.getSession())\n    .setCallbacks(callbacks)\n    .build();\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "SMS 인증 코드가 전송된 후 사용자가 해야 할 작업은 무엇인가요?", "answer": "SMS 인증 코드가 전송된 후, 사용자는 인증 코드를 확인하도록 요청받습니다. Kotlin에서는 다음과 같은 코드를 사용하여 인증 코드를 처리합니다:\n\n```kotlin\nval credential =\n    PhoneAuthProvider.getCredential(verificationId, verificationCode)\n```", "source": ["https://firebase.google.com/docs/auth/android/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_multi-factor_hl=ko.txt"}
{"question": "OpenID Connect(OIDC) 제공업체를 사용하여 Firebase에 사용자를 인증하기 위해 필요한 정보는 무엇인가요?", "answer": "OIDC 제공업체를 사용하여 사용자를 로그인하도록 하려면 다음 정보를 수집해야 합니다:\n1. 클라이언트 ID: 앱을 식별하는 제공업체의 고유한 문자열입니다. 이 값은 제공업체에서 발급한 ID 토큰의 aud 클레임 값 중 하나입니다.\n2. 클라이언트 보안 비밀번호: 제공업체가 클라이언트 ID의 소유권을 확인하는 데 사용하는 보안 비밀 문자열입니다. 인증 코드 흐름을 사용하는 경우에만 필요합니다.\n3. 발급기관: 제공업체를 식별하는 문자열로, 이 값은 /.well-known/openid-configuration이 추가될 때 제공업체의 OIDC 탐색 문서가 위치하는 URL이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase Console에서 OpenID Connect 제공업체를 추가하는 방법은 무엇인가요?", "answer": "Firebase Console의 로그인 제공업체 페이지에서 새 제공업체 추가를 클릭한 다음 OpenID Connect를 클릭합니다. 이후 승인 코드 흐름을 사용할지 또는 암시적 권한 부여 흐름을 사용할지 선택하고, 제공업체에 이름을 지정한 후 생성된 제공업체 ID를 기록해 둡니다. 클라이언트 ID와 클라이언트 보안 비밀번호, 제공업체의 발급기관 문자열을 지정하고 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase Android SDK로 로그인 과정을 처리하는 방법은 무엇인가요?", "answer": "Firebase Android SDK로 로그인 과정을 처리하려면 다음 단계를 따릅니다:\n1. 제공업체 ID를 사용하여 OAuthProvider로 OAuthProvider의 인스턴스를 생성합니다:\n```java\nOAuthProvider.Builder providerBuilder = OAuthProvider.newBuilder(\"oidc.example-provider\");\n```\n2. 선택사항으로 OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다. Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇이며, 어떻게 처리하나요?", "answer": "Firebase에서 요구하는 매개변수는 client_id, response_type, redirect_uri, state, scope, response_mode입니다. 이러한 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "OAuth 제공업체 객체를 사용해 Firebase로 인증하는 방법은 무엇인가요?", "answer": "OAuth 제공업체 객체를 사용해 Firebase로 인증하려면, OAuthProvider 객체를 생성한 후 FirebaseAuth 객체를 사용하여 인증을 수행합니다. 예를 들어, 다음과 같이 FirebaseAuth를 사용하여 인증을 진행할 수 있습니다:\n```java\nFirebaseAuth.getInstance().startActivityForSignInWithProvider(this, providerBuilder.build());\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "OpenID Connect 제공업체를 추가할 때 어떤 흐름을 선택해야 하나요?", "answer": "제공업체가 지원하는 경우 항상 코드 흐름을 사용해야 합니다. 암시적 흐름은 보안 수준이 낮으므로 사용하지 않는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase Android SDK로 OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "제공업체 ID를 사용하여 OAuthProvider로 OAuthProvider의 인스턴스를 생성합니다. 예를 들어, Kotlin에서는 다음과 같이 작성합니다:\n```kotlin\nval providerBuilder = OAuthProvider.newBuilder(\"oidc.example-provider\")\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 어떻게 처리하나요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "OAuth 제공업체 객체를 사용해 Firebase로 인증하는 과정은 어떻게 되나요?", "answer": "OAuth 제공업체 객체를 사용해 Firebase로 인증하는 과정은 다음과 같습니다. 먼저, OAuthCredential을 생성한 후 FirebaseAuth의 signInWithCredential 메서드를 호출합니다. 예를 들어, Java에서는 다음과 같이 작성합니다:\n```java\nAuthCredential credential = OAuthProvider\n.newCredentialBuilder(\"oidc.example-provider\")  // As registered in Firebase console.\n.setIdToken(idToken)  // ID token from OpenID Connect flow.\n.build();\nFirebaseAuth.getInstance()\n.signInWithCredential(credential)\n.addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n@Override\npublic void onSuccess(AuthResult authResult) {\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "로그인 과정 중 대기 중인 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 다음과 같이 getPendingAuthResult를 호출합니다. 예를 들어, Kotlin에서는 다음과 같이 작성합니다:\n```kotlin\nval pendingResultTask = firebaseAuth.pendingAuthResult\nif (pendingResultTask != null) {\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OpenID Connect(OIDC) 제공업체를 사용하여 인증할 때 필요한 매개변수는 무엇인가요?", "answer": "필요한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase Android SDK에서 대기 중인 인증 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 다음과 같이 getPendingAuthResult를 호출합니다.\n\n```kotlin\nval pendingResultTask = firebaseAuth.pendingAuthResult\nif (pendingResultTask != null) {\n    Task<AuthResult> pendingResultTask = firebaseAuth.getPendingAuthResult();\n    if (pendingResultTask != null) {\n        // Handle pending result\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OpenID Connect(OIDC) 제공업체로 인증할 때 UI를 제어하는 방법은 무엇인가요?", "answer": "OAuth 제공업체 객체를 사용해 Firebase로 인증할 때, 커스텀 Chrome 탭을 팝업으로 표시하여 UI를 제어합니다.", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 인증 후 사용자의 ID 토큰을 설정하는 방법은 무엇인가요?", "answer": "ID 토큰을 설정하려면 다음과 같이 OAuthCredential을 생성합니다.\n\n```java\nAuthCredential credential = OAuthProvider\n    .newCredentialBuilder(\"oidc.example-provider\")  // As registered in Firebase console.\n    .setIdToken(idToken)  // ID token from OpenID Connect flow.\n    .build();\nFirebaseAuth.getInstance()\n    .signInWithCredential(credential)\n    .addOnSuccessListener(new OnSuccessListener<AuthResult>() {\n        @Override\n        public void onSuccess(AuthResult authResult) {\n            // Handle successful sign-in\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 현재 사용자를 가져오는 방법은 무엇인가요?", "answer": "현재 사용자를 가져오려면 다음과 같이 firebaseAuth.getCurrentUser()를 호출합니다.\n\n```java\nFirebaseUser firebaseUser = firebaseAuth.getCurrentUser();\n```", "source": ["https://firebase.google.com/docs/auth/android/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_openid-connect_hl=ko.txt"}
{"question": "Firebase Console에서 연결 URL을 안전하게 전달하기 위해 어떤 단계를 따라야 하나요?", "answer": "Firebase Console에서 이 URL의 도메인을 허용해야 합니다. 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업을 위해 ActionCodeSettings 인스턴스를 어떻게 생성하나요?", "answer": "ActionCodeSettings 인스턴스는 ActionCodeSettings.Builder 클래스를 사용하여 생성할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "setHandleCodeInApp 메서드는 어떤 역할을 하나요?", "answer": "setHandleCodeInApp(boolean status) 메서드는 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 인증 링크를 모바일 앱에서 먼저 열도록 설정하는 방법은 무엇인가요?", "answer": "다음 예시에서는 모바일 앱에서 먼저 열리는 이메일 인증 링크를 보내는 방법을 보여줍니다. 딥 링크에는 연결 URL 페이로드(http://www.example.com/verify?uid=1234)가 포함됩니다.\n\nKotlin\nval auth = Firebase.auth", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "setUrl 메서드는 어떤 용도로 사용되나요?", "answer": "setUrl(String url) 메서드는 컨텍스트에 따라 의미가 다른 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Console에서 이메일 작업을 위한 도메인을 허용 목록에 추가하는 방법은 무엇인가요?", "answer": "Firebase Console에서 연결 URL의 도메인을 허용하려면 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "ActionCodeSettings.Builder 클래스의 setIOSBundleId 메서드는 어떤 역할을 하나요?", "answer": "setIOSBundleId(String iOSBundleId) 메서드는 Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 Android 애플리케이션을 구성할 때 필요한 설정은 무엇인가요?", "answer": "Android 애플리케이션을 구성하려면 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정하고, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다. 또한 AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터도 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 코드 링크를 웹 애플리케이션에서 처리하는 방법은 무엇인가요?", "answer": "웹 애플리케이션에서 작업 코드 링크를 처리하려면 setHandleCodeInApp(false)을 ActionCodeSettings.Builder 객체에서 호출하여 정상적으로 완료된 후 다른 웹페이지로 리디렉션할지 또는 모바일 애플리케이션으로 리디렉션할지 지정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 인증 링크를 보내는 Kotlin 코드 예시는 어떻게 되나요?", "answer": "다음은 모바일 앱에서 먼저 열리는 이메일 인증 링크를 보내는 Kotlin 코드 예시입니다.\n\n```kotlin\nval auth = Firebase.auth\nval user = auth.currentUser!!\n\nval url = \"http://www.example.com/verify?uid=\" + user.uid\nval actionCodeSettings = ActionCodeSettings.newBuilder()\n    .setUrl(url)\n    .setIOSBundleId(\"com.example.ios\")\nLog.d(TAG, \"Email sent.\")\n```", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 코드 링크를 모바일 애플리케이션에서 처리하도록 설정하는 방법은 무엇인가요?", "answer": "모바일 애플리케이션에서 이메일 작업 코드 링크를 처리하도록 설정하려면 ActionCodeSettings.Builder 객체에서 setHandleCodeInApp(true)을 호출해야 합니다. 이때 모바일 애플리케이션의 Android 패키지 이름 또는 iOS 번들 ID도 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 코드 링크를 웹 애플리케이션에서 처리할 때 리디렉션을 설정하는 방법은 무엇인가요?", "answer": "웹 애플리케이션에서 이메일 작업 코드 링크를 처리할 때 리디렉션을 설정하려면 ActionCodeSettings.Builder 객체에서 setHandleCodeInApp(false)을 호출하면 됩니다. 이 설정을 통해 작업 코드 링크 처리 후 웹페이지로 리디렉션할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 인증과 같은 이메일 작업을 처리할 때 필요한 쿼리 매개변수는 무엇인가요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Console에서 모바일 애플리케이션의 패키지 이름을 지정하는 이유는 무엇인가요?", "answer": "Firebase Console에서 모바일 애플리케이션의 패키지 이름을 지정하는 이유는 Android 애플리케이션에서 이메일 작업 코드 링크를 처리하기 위해 필요하기 때문입니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용을 어디에서 확인할 수 있나요?", "answer": "이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용은 이메일 핸들러 맞춤설정 [https://firebase.google.com/docs/auth/custom-email-handler?hl=ko]을 참조하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "모바일 애플리케이션에서 이메일 작업 코드 링크를 처리하도록 설정하는 방법은 무엇인가요?", "answer": "모바일 애플리케이션에서 이메일 작업 코드 링크를 처리하도록 설정하려면, ActionCodeSettings.Builder 객체에서 setHandleCodeInApp(true)을 호출해야 합니다. 이때 모바일 애플리케이션의 Android 패키지 이름 또는 iOS 번들 ID도 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업을 처리할 때 사용되는 쿼리 매개변수는 무엇인가요?", "answer": "이메일 작업을 처리할 때 사용되는 쿼리 매개변수는 oobCode, mode, apiKey, continueUrl입니다. 이 매개변수들은 작업 코드 URL을 구성하는 데 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 코드 링크를 클릭했을 때 모바일 애플리케이션이 설치되어 있지 않은 경우 어떻게 되나요?", "answer": "모바일 애플리케이션이 설치되어 있지 않은 경우, 링크를 클릭하면 대신 웹페이지에서 링크가 열립니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용을 어디에서 확인할 수 있나요?", "answer": "이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용은 이메일 핸들러 맞춤설정 [https://firebase.google.com/docs/auth/custom-email-handler?hl=ko]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 인증과 같은 이메일 작업을 처리할 때 어떤 과정을 거치나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다.", "source": ["https://firebase.google.com/docs/auth/android/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 설정할 때 어떤 요구사항이 있나요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다.\n\n- 소문자 필요\n- 대문자 필요\n- 숫자 필요\n- 영숫자가 아닌 문자 필요\n\n다음 문자는 영숫자가 아닌 문자 요구사항을 충족합니다.\n^ $ * . [ ] { } ( ) ? \" ! @ # % & / \\ , > < ' : ; | _ ~\n비밀번호 최소 길이(6~30자, 기본값은 6)\n비밀번호 최대 길이(최대 4,096자)", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책을 적용할 때 어떤 모드를 사용할 수 있나요?", "answer": "다음 두 가지 모드로 비밀번호 정책 적용을 사용 설정할 수 있습니다.\n\n- 필수: 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다.\n- 알림: 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있습니다. 이 모드를 사용할 때는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 어떤 방식으로든 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 열거 보호를 설정하는 것이 왜 중요한가요?", "answer": "이메일 열거 보호는 이메일 주소가 등록되어 있어야 하는데(예: 이메일 주소와 비밀번호로 로그인할 때) 등록되지 않은 경우 또는 이메일 주소를 사용해서는 안 되는데(예: 사용자의 이메일 주소를 변경할 때) 등록된 경우, 이메일 주소를 파라미터로 사용하는 일부 Firebase Authentication 메서드에서 특정 오류가 발생합니다. 이는 사용자에게 특정 조치를 제안하는 데 유용할 수 있지만 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 데 도움이 될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호를 업데이트할 때 사용자에게 어떤 방식으로 알림을 제공해야 하나요?", "answer": "알림 모드를 사용할 때는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 어떤 방식으로든 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "활성 사용자가 있는 경우 비밀번호 정책을 어떻게 설정하는 것이 좋나요?", "answer": "활성 사용자가 있는 경우 비밀번호가 정책을 준수하지 않는 사용자의 액세스를 차단하려는 경우가 아니면 로그인 강제 업그레이드를 사용 설정하지 않는 것이 좋습니다. 대신 사용자가 현재 비밀번호로 로그인할 수 있게 해주고 비밀번호에 부족한 요구사항을 알리는 알림 모드를 사용하세요.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 설정할 때 영숫자가 아닌 문자로 어떤 문자를 사용할 수 있나요?", "answer": "다음 문자는 영숫자가 아닌 문자 요구사항을 충족합니다.\n^ $ * . [ ] { } ( ) ? \" ! @ # % & / \\ , > < ' : ; | _ ~", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 필수 모드로 설정하면 사용자는 어떤 상황에서 가입 시도가 실패하나요?", "answer": "필수 모드에서는 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 알림 모드로 설정할 경우 클라이언트 측에서 어떤 작업을 수행해야 하나요?", "answer": "알림 모드에서는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고, 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 어떤 방식으로든 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 활성 사용자가 있는 경우 비밀번호 정책을 설정할 때 어떤 점을 고려해야 하나요?", "answer": "활성 사용자가 있는 경우 비밀번호가 정책을 준수하지 않는 사용자의 액세스를 차단하려는 경우가 아니면 로그인 강제 업그레이드를 사용 설정하지 않는 것이 좋습니다. 대신 사용자가 현재 비밀번호로 로그인할 수 있게 해주고 비밀번호에 부족한 요구사항을 알리는 알림 모드를 사용하세요.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트의 일부로 저장되며 사용자의 로그인 방법에 관계없이 프로젝트 내 모든 앱에서 사용자를 식별하는 데 사용될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자의 기본 프로필 정보를 어떻게 가져올 수 있나요?", "answer": "앱의 FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리(User Management) 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 어떻게 가져오나요?", "answer": "Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자를 로그아웃시키려면 어떤 메서드를 호출해야 하나요?", "answer": "사용자를 로그아웃시키려면 signOut() 메서드를 호출합니다. 예제 코드는 다음과 같습니다:\n\nKotlin\n```kotlin\nFirebase.auth.signOut()\n```\n\nJava\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 어떻게 연결하나요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다. 자세한 내용은 계정 연결(Account Linking) 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화번호 로그인을 구현하기 위해 필요한 Gradle 설정은 무엇인가요?", "answer": "모듈(앱 수준) Gradle 파일(일반적으로 <project>/<app-module>/build.gradle.kts 또는 <project>/<app-module>/build.gradle)에서 Android용 Firebase Authentication 라이브러리의 종속 항목을 추가해야 합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 사용하기 위해 Firebase 프로젝트에서 어떤 설정을 해야 하나요?", "answer": "Firebase 프로젝트에서 전화번호 로그인 방법을 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Play Integrity API를 사용하여 전화번호 로그인을 진행하기 위한 조건은 무엇인가요?", "answer": "사용자가 Google Play services가 설치된 기기를 보유하고 있고 Firebase Authentication에서 Play Integrity API로 기기가 합법적임을 확인할 수 있어야 합니다. Play Integrity 지원은 Authentication SDK v21.2.0 이상에서 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증이 필요한 경우 어떤 조건이 있나요?", "answer": "사용자의 기기에 Google Play services가 설치되지 않았거나 앱이 Google Play Store를 통해 배포되지 않은 경우, 또는 획득한 SafetyNet 토큰이 유효하지 않은 경우 reCAPTCHA 인증이 필요합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 SHA-256 디지털 지문을 지정하는 방법은 무엇인가요?", "answer": "Firebase Console의 프로젝트 설정에서 앱의 SHA-256 디지털 지문을 지정해야 합니다. 앱의 SHA-256 디지털 지문을 얻는 방법에 대한 자세한 내용은 클라이언트 인증을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 Play Integrity API를 사용하려면 어떤 조건이 필요한가요?", "answer": "Play Integrity API를 사용하려면 사용자가 Google Play services가 설치된 기기를 보유하고 있어야 하며, Firebase Authentication에서 Play Integrity API로 기기가 합법적임을 확인할 수 있어야 합니다. 또한, Play Integrity 지원은 Authentication SDK v21.2.0 이상에서 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증이 필요한 경우 어떤 상황에서 발생하나요?", "answer": "reCAPTCHA 인증은 사용자의 기기에 Google Play services가 설치되지 않았거나, 앱이 Google Play Store를 통해 배포되지 않은 경우, 또는 획득한 SafetyNet 토큰이 유효하지 않은 경우에 발생합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 reCAPTCHA 인증을 사용할 때 발생할 수 있는 오류는 무엇인가요?", "answer": "reCAPTCHA 인증을 사용할 때 'FirebaseAuthMissingActivityForRecaptchaException' 오류가 발생할 수 있습니다. 이는 활동을 설정하지 않고 reCAPTCHA 인증을 시도할 때 발생하며, onVerificationFailed 콜백에서 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자가 해야 할 첫 번째 단계는 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자에게 전화번호 입력을 요청하는 인터페이스를 제시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 사용자가 알아야 할 사항은 무엇인가요?", "answer": "사용자는 전화 로그인을 사용하면 인증용 SMS 메시지가 발송되고 일반 요금이 부과될 수 있다는 점을 미리 알 수 있도록 안내받아야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 사용자가 입력해야 할 정보는 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자에게 전화번호 입력을 요청하는 인터페이스를 제시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 Firebase에서 사용하는 메서드는 무엇인가요?", "answer": "전화번호 인증을 위해 PhoneAuthProvider.verifyPhoneNumber 메서드를 사용하여 Firebase가 사용자의 전화번호를 확인하도록 요청합니다. 예를 들면 다음과 같습니다.\n\nKotlin\nval options = PhoneAuthOptions.newBuilder(auth)\n.setPhoneNumber(phoneNumber) // Phone number to verify\n.setTimeout(60L, TimeUnit.SECONDS) // Timeout and unit\n.setActivity(this) // Activity (for callback binding)\n.setCallbacks(callbacks) // OnVerificationStateChangedCallbacks\n.build()\nPhoneAuthProvider.verifyPhoneNumber(options)\n\nJava\nPhoneAuthOptions options =\nPhoneAuthOptions.newBuilder(mAuth)\n.setPhoneNumber(phoneNumber)       // Phone number to verify\n.setTimeout(60L, TimeUnit.SECONDS) // Timeout and unit\n.setActivity(this)                 // (optional) Activity for callback binding\nPhoneAuthProvider.verifyPhoneNumber(options);", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위한 SMS 메시지 발송 시 사용자가 알아야 할 사항은 무엇인가요?", "answer": "일반적으로는 사용자가 제반 상황을 미리 알 수 있도록 전화 로그인을 사용하면 인증용 SMS 메시지가 발송되고 일반 요금이 부과될 수 있다는 점을 알려야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 중 사용자가 앱을 종료했을 때 어떻게 처리하나요?", "answer": "사용자가 로그인하기 전에 앱이 종료되면 verifyPhoneNumber를 호출한 후 인증이 진행 중임을 나타내는 플래그를 설정합니다. 그런 다음 액티비티의 onSaveInstanceState 메서드에서 플래그를 저장하고 onRestoreInstanceState에서 플래그를 복원합니다. 마지막으로 액티비티의 onStart 메서드에서 인증이 진행 중인지 확인하고 진행 중이라면 verifyPhoneNumber를 다시 호출합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "verifyPhoneNumber 메서드의 재진입 가능성에 대해 설명해 주세요.", "answer": "verifyPhoneNumber 메서드는 재진입이 가능합니다. 즉, 액티비티의 onStart 메서드와 같은 위치에서 verifyPhoneNumber 메서드를 여러 번 호출해도 원래 요청이 시간 초과되지 않았다면 SMS를 재차 보내지 않습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 SMS 메시지를 현지화하는 방법은 무엇인가요?", "answer": "Auth 인스턴스의 setLanguageCode 메서드를 통해 auth 언어를 지정하여 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\n```kotlin\nauth.setLanguageCode(\"fr\")\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위한 OnVerificationStateChangedCallbacks의 역할은 무엇인가요?", "answer": "OnVerificationStateChangedCallbacks는 verifyPhoneNumber 메서드를 호출할 때 요청 결과를 처리하는 콜백 함수의 구현을 포함하는 인스턴스입니다. 이 콜백을 통해 인증이 완료되었는지, 실패했는지, 인증 코드가 전송되었는지를 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 중 자동 인증이 가능한 경우는 어떤 경우인가요?", "answer": "자동 인증은 일부 기기에서 수신되는 인증 SMS를 Google Play 서비스가 자동으로 감지하여 사용자의 개입 없이 인증을 수행할 수 있는 경우입니다. 이 기능은 일부 이동통신사에서 제공하지 않을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 잘못된 경우 어떤 메서드가 호출되나요?", "answer": "onVerificationFailed(FirebaseException) 메서드는 요청에 잘못된 전화번호 또는 인증 코드가 지정된 경우와 같은 잘못된 인증 요청에 대한 응답으로 호출됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "인증 코드가 SMS를 통해 전송된 후 어떤 메서드가 호출되나요?", "answer": "onCodeSent(String verificationId, PhoneAuthProvider.ForceResendingToken) 메서드는 제공된 전화번호로 인증 코드가 SMS를 통해 전송된 후에 호출됩니다. 이 메서드가 호출되면 대부분의 앱은 사용자에게 SMS 메시지로 받은 인증 코드를 입력하라는 UI를 표시합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 SMS 메시지를 현지화하는 방법은 무엇인가요?", "answer": "Auth 인스턴스의 setLanguageCode 메서드를 통해 auth 언어를 지정하여 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\nKotlin\n```kotlin\nauth.setLanguageCode(\"fr\")\n```\n\nJava\n```java\nauth.setLanguageCode(\"fr\");\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 잘못된 경우 어떤 메서드가 호출되나요?", "answer": "잘못된 인증 요청에 대한 응답으로 onVerificationFailed(FirebaseException) 메서드가 호출됩니다. 이 메서드는 요청에 잘못된 전화번호 또는 인증 코드가 지정된 경우에 호출됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "인증 코드가 SMS를 통해 전송된 후 어떤 메서드가 호출되나요?", "answer": "제공된 전화번호로 인증 코드가 SMS를 통해 전송된 후 onCodeSent(String verificationId, PhoneAuthProvider.ForceResendingToken) 메서드가 호출됩니다. 이 메서드가 호출되면 대부분의 앱은 사용자에게 SMS 메시지로 받은 인증 코드를 입력하라는 UI를 표시합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "자동 인증이 가능한 경우는 어떤 경우인가요?", "answer": "자동 인증은 두 가지 경우에 가능합니다. 첫째, 즉시 인증이 이루어지는 경우로, 인증 코드를 보내거나 입력하지 않고 전화번호를 즉시 인증할 수 있습니다. 둘째, 일부 기기에서는 수신되는 인증 SMS를 Google Play 서비스가 자동으로 감지하여 사용자의 개입 없이 인증을 수행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "PhoneAuthCredential 객체를 만드는 방법은 무엇인가요?", "answer": "사용자가 Firebase에서 보낸 인증 코드를 입력하면 인증 코드 및 onCodeSent 또는 onCodeAutoRetrievalTimeOut 콜백에 전달된 인증 ID를 사용하여 PhoneAuthCredential 객체를 만듭니다. 이를 위해 다음과 같이 PhoneAuthProvider.getCredential을 호출합니다.\n\nKotlin\n```kotlin\nval credential = PhoneAuthProvider.getCredential(verificationId!!, code)\n```\n\nJava\n```java\nPhoneAuthCredential credential = PhoneAuthProvider.getCredential(verificationId, code);\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위해 PhoneAuthCredential 객체를 만드는 방법은 무엇인가요?", "answer": "사용자가 Firebase에서 사용자의 전화로 보낸 인증 코드를 입력하면 인증 코드 및 onCodeSent 또는 onCodeAutoRetrievalTimeOut 콜백에 전달된 인증 ID를 사용하여 PhoneAuthCredential 객체를 만듭니다. PhoneAuthCredential 객체를 만들려면 다음과 같이 PhoneAuthProvider.getCredential을 호출합니다.\n\nKotlin\nval credential = PhoneAuthProvider.getCredential(verificationId!!, code)\n\nJava\nPhoneAuthCredential credential = PhoneAuthProvider.getCredential(verificationId, code);", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자가 전화번호로 인증 코드를 입력한 후 어떤 과정을 거치나요?", "answer": "사용자가 인증 코드를 입력하면 인증 코드와 onCodeSent 또는 onCodeAutoRetrievalTimeOut 콜백에 전달된 인증 ID를 사용하여 PhoneAuthCredential 객체를 만들고 이 객체로 사용자를 로그인 처리할 수 있습니다. 이후 FirebaseAuth.signInWithCredential에 PhoneAuthCredential 객체를 전달하여 로그인 과정을 완료합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한될 수 있는 경우는 어떤 경우인가요?", "answer": "Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트용으로 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 가상 전화번호를 설정하는 방법은 무엇인가요?", "answer": "Firebase Console을 통해 개발용 가상 전화번호를 설정할 수 있습니다. 가상 전화번호로 테스트하면 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있으며, 실제 SMS 메시지를 보내지 않고 전화번호 인증을 테스트할 수 있습니다. 가상 전화번호는 실제로 존재하지 않는 가상의 전화번호여야 하며, 555로 시작하는 번호(예: +1 650-555-3434)를 미국 테스트 전화번호로 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위한 가상 전화번호의 조건은 무엇인가요?", "answer": "가상 전화번호는 실제로 존재하지 않는 가상의 전화번호여야 하며, Firebase Authentication에서는 실제 사용자가 사용하는 기존 전화번호를 테스트 전화번호로 설정할 수 없습니다. 개발용으로 최대 10개의 전화번호를 추가할 수 있으며, 다른 사람이 추측하기 어려운 테스트 전화번호와 코드를 사용하고 자주 변경해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화번호 인증 요청이 제한될 수 있는 경우는 어떤 경우인가요?", "answer": "단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트용으로 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화번호로 로그인을 완료하는 방법은 무엇인가요?", "answer": "onVerificationCompleted 콜백 또는 PhoneAuthProvider.getCredential 호출을 통해 PhoneAuthCredential 객체를 가져온 후 FirebaseAuth.signInWithCredential에 PhoneAuthCredential 객체를 전달하여 로그인 과정을 완료합니다. 예제 코드는 다음과 같습니다. \n\nKotlin\nprivate fun signInWithPhoneAuthCredential(credential: PhoneAuthCredential) {\n    auth.signInWithCredential(credential)\n        .addOnCompleteListener(this) { task ->\n            if (task.isSuccessful) {\n                // 로그인 성공\n            }\n        }\n}\n\nJava\nprivate void signInWithPhoneAuthCredential(PhoneAuthCredential credential) {\n    mAuth.signInWithCredential(credential)\n        .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n            @Override\n            public void onComplete(@NonNull Task<AuthResult> task) {\n                if (task.isSuccessful()) {\n                    // 로그인 성공\n                }\n            }\n        });\n}", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Console에서 가상 전화번호를 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고, 전화 제공업체를 사용 설정한 후 로그인 방법 탭에서 테스트용 전화번호 아코디언 메뉴를 엽니다. 테스트할 전화번호(예: +1 650-555-3434)를 입력하고, 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력한 후 번호를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 테스트할 때의 장점은 무엇인가요?", "answer": "가상 전화번호로 테스트하면 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있으며, 실제 SMS 메시지를 보내지 않고도 인증을 테스트할 수 있습니다. 또한 제한 없이 동일한 전화번호로 연속 테스트를 실행할 수 있어, 앱 스토어 검토 절차 중에 검토자가 동일한 전화번호를 테스트에 사용하게 될 경우 번호가 거부될 위험이 최소화됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 가상 전화번호의 ID 토큰은 어떻게 처리되나요?", "answer": "로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다. 사용자는 실제 전화번호 사용자와 동일한 행동과 속성을 가지며, 동일한 방식으로 Realtime Database/Cloud Firestore 및 기타 서비스에 액세스할 수 있습니다. 이 절차 중에 발급된 ID 토큰에는 실제 전화번호 사용자와 같은 서명이 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Console에서 가상 전화번호를 추가하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 전화 제공업체를 사용 설정한 후, 테스트용 전화번호 아코디언 메뉴를 열어 테스트할 전화번호(예: +1 650-555-3434)와 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력한 후 번호를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 테스트할 때 어떤 점을 유의해야 하나요?", "answer": "가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않으며, 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다. 또한, 로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 테스트용 reCAPTCHA 흐름을 수동으로 트리거하는 방법은 무엇인가요?", "answer": "테스트용 reCAPTCHA 흐름을 수동으로 트리거하려면 다음 메서드를 사용하세요: \n```java\nFirebaseAuth.getInstance().getFirebaseAuthSettings().forceRecaptchaFlowForTesting();\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Android에서 가상 전화번호를 사용하여 인증을 테스트할 때 어떤 메서드를 호출해야 하나요?", "answer": "Android에서는 `signInWithPhoneNumber` 호출 전에 `setAppVerificationDisabledForTesting()`을 호출해야 합니다. 이렇게 하면 앱 인증이 자동으로 사용 중지되어 수동으로 해결하지 않아도 전화번호를 전달할 수 있습니다. 코드 예시는 다음과 같습니다: \n```java\nFirebaseAuth.getInstance().getFirebaseAuthSettings()\n.setAppVerificationDisabledForTesting();\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 통합 테스트를 작성하는 방법은 무엇인가요?", "answer": "Firebase Authentication은 전화 인증 테스트용 통합 테스트를 작성할 수 있는 API를 제공합니다. 이러한 API는 웹에서 reCAPTCHA 요구사항을, iOS에서 백그라운드 푸시 알림을 중지하여 앱 인증을 사용 중지합니다. 이를 통해 테스트를 자동화하고 더 쉽게 구현할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "테스트용 reCAPTCHA 흐름을 수동으로 트리거하는 방법은 무엇인가요?", "answer": "테스트용 reCAPTCHA 흐름을 수동으로 트리거하려면 `forceRecaptchaFlowForTesting()` 메서드를 사용하세요.\n\n```java\nFirebaseAuth.getInstance().getFirebaseAuthSettings().forceRecaptchaFlowForTesting();\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Android에서 전화번호 인증을 테스트할 때 앱 인증을 사용 중지하는 방법은 무엇인가요?", "answer": "Android에서는 `signInWithPhoneNumber` 호출 전에 `setAppVerificationDisabledForTesting()`을 호출합니다. 이렇게 하면 앱 인증이 자동으로 사용 중지되어 수동으로 해결하지 않아도 전화번호를 전달할 수 있습니다.\n\n```java\nFirebaseAuth.getInstance().getFirebaseAuthSettings()\n.setAppVerificationDisabledForTesting();\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호로 인증을 테스트할 때 어떤 과정을 거치나요?", "answer": "가상 번호로 `verifyPhoneNumber`를 호출하여 `onCodeSent` 콜백이 트리거되면 해당 인증 코드를 입력해야 합니다. 그러면 Android 에뮬레이터에서 테스트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위한 Java 코드 예시는 어떻게 되나요?", "answer": "다음은 전화번호 인증을 위한 Java 코드 예시입니다.\n\n```java\nString phoneNum = \"+16505554567\";\nString testVerificationCode = \"123456\";\n\nFirebaseAuth auth = FirebaseAuth.getInstance();\nPhoneAuthOptions options = PhoneAuthOptions.newBuilder(auth)\n.setPhoneNumber(phoneNum)\n.setTimeout(60L, TimeUnit.SECONDS)\n.setActivity(this)\n.setCallbacks(new PhoneAuthProvider.OnVerificationStateChangedCallbacks() {\n@Override\npublic void onCodeSent(@NonNull String verificationId,\n@NonNull PhoneAuthProvider.ForceResendingToken forceResendingToken) {\nMainActivity.this.enableUserManuallyInputCode();\nPhoneAuthProvider.verifyPhoneNumber(options);\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 위한 Kotlin 코드 예시는 어떻게 되나요?", "answer": "다음은 전화번호 인증을 위한 Kotlin 코드 예시입니다.\n\n```kotlin\nval phoneNum = \"+16505554567\"\nval testVerificationCode = \"123456\"\n\n.setPhoneNumber(phoneNum)\n.setTimeout(30L, TimeUnit.SECONDS)\n.setActivity(this)\n.setCallbacks(object : PhoneAuthProvider.OnVerificationStateChangedCallbacks() {\noverride fun onCodeSent(\nverificationId: String,\nforceResendingToken: PhoneAuthProvider.ForceResendingToken,\n) {\n// 인증 코드 전송 후 처리\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/android/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_phone-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에 Google Play 게임즈 서비스를 통합하기 위해 필요한 Gradle 설정은 무엇인가요?", "answer": "모듈(앱 수준) Gradle 파일(일반적으로 <project>/<app-module>/build.gradle.kts 또는 <project>/<app-module>/build.gradle)에서 Android용 Firebase Authentication 라이브러리의 종속 항목을 추가해야 합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Google Play 게임즈 로그인 제공업체를 사용 설정하기 위해 필요한 정보는 무엇인가요?", "answer": "프로젝트의 웹 서버 클라이언트 ID와 클라이언트 보안 비밀번호를 찾아야 합니다. Google API 콘솔의 사용자 인증 정보 페이지에서 Firebase 프로젝트를 열고 OAuth 2.0 클라이언트 ID 섹션에서 웹 클라이언트 세부정보 페이지를 확인하여 이 값을 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase 콘솔에서 Play 게임즈 로그인 제공업체를 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 콘솔에서 인증 섹션을 열고 로그인 방법 탭에서 Play 게임즈 로그인 제공업체를 사용 설정합니다. 이때 API 콘솔에서 가져온 프로젝트의 웹 서버 클라이언트 ID와 클라이언트 보안 비밀번호를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Google Play Console에서 Play Games services를 구성하는 절차는 어떻게 되나요?", "answer": "Google Play Console에서 Google Play 앱을 열거나 만들고, 성장 섹션에서 Play Games services > 설정 및 관리 > 구성을 클릭합니다. 이후 '예, 게임에서 이미 Google API를 사용하고 있습니다'를 클릭하고 목록에서 Firebase 프로젝트를 선택한 후 사용을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Android 클라이언트 ID가 표시되지 않을 경우 어떻게 해야 하나요?", "answer": "Android 클라이언트 ID가 표시되지 않는 경우 Firebase Console에서 게임의 SHA-1 디지털 지문을 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 SHA-1 디지털 지문을 설정하는 방법은 무엇인가요?", "answer": "Firebase 콘솔의 설정 페이지에서 게임의 SHA-1 디지털 지문을 설정합니다. Gradle signingReport 명령어를 사용하여 서명 인증서의 SHA 해시를 가져올 수 있습니다. 명령어는 다음과 같습니다.\n```\n./gradlew signingReport\n```", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Google Play Console에서 Play Games services를 구성할 때 필요한 단계는 무엇인가요?", "answer": "Google Play Console에서 Google Play 앱을 열거나 만듭니다. 성장 섹션에서 Play Games services > 설정 및 관리 > 구성을 클릭합니다. '예, 게임에서 이미 Google API를 사용하고 있습니다'를 클릭하고 목록에서 Firebase 프로젝트를 선택한 후 사용을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Play Games services 구성 페이지에서 Android 클라이언트 ID를 추가하는 방법은 무엇인가요?", "answer": "Play Games services 구성 페이지에서 사용자 인증 정보 추가를 클릭한 후 Android 유형을 선택합니다. OAuth 클라이언트 입력란에서 프로젝트의 Android 클라이언트 ID를 선택하고 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 설정하기 위해 필요한 GoogleSignInOptions 객체의 구성은 어떻게 되나요?", "answer": "GoogleSignInOptions 객체를 작성할 때 DEFAULT_GAMES_SIGN_IN 구성을 사용하고 requestServerAuthCode를 호출합니다. Kotlin 코드 예시는 다음과 같습니다.\n```kotlin\nval gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_GAMES_SIGN_IN)\n.requestServerAuthCode(getString(R.string.default_web_client_id))\n.build()\n```", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase로 인증하기 위해 Play 게임즈 로그인 후 수행해야 할 작업은 무엇인가요?", "answer": "플레이어가 Play 게임즈로 로그인할 때 확인되는 Google 계정 사용자 인증 정보를 사용하도록 Firebase를 설정해야 합니다. FirebaseAuth 객체의 공유 인스턴스를 가져오고, GoogleSignInAccount 객체에서 인증 코드를 가져와 Firebase 사용자 인증 정보로 교환합니다. Kotlin 코드 예시는 다음과 같습니다.\n```kotlin\nval credential = PlayGamesAuthProvider.getCredential(acct.serverAuthCode!!)\nauth.signInWithCredential(credential)\n.addOnCompleteListener(this) { task ->\nif (task.isSuccessful) {\nupdateUI(user)\nToast.makeText(\nbaseContext,\n\"Authentication failed.\",\nToast.LENGTH_SHORT,\n).show()\nupdateUI(null)\nLog.d(TAG, \"firebaseAuthWithPlayGames:\" + acct.getId());\n}\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 설정한 후, FirebaseAuth 객체의 공유 인스턴스를 가져오는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/play-games?hl=ko#kotlin-android] ---\nprivate lateinit var auth: FirebaseAuth\nauth = FirebaseAuth.getInstance()", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Play 게임즈 로그인 후 Firebase로 인증하기 위해 필요한 GoogleSignInAccount 객체에서 인증 코드를 가져오는 방법은 무엇인가요?", "answer": "플레이어가 자동 또는 대화형으로 Play 게임즈에 로그인하면 GoogleSignInAccount 객체에서 인증 코드를 가져와 Firebase 사용자 인증 정보로 교환합니다.", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase로 인증하기 위해 Play 게임즈 로그인 후 FirebaseAuth.signInWithCredential() 메서드를 사용하는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/play-games?hl=ko#kotlin-android] ---\nval credential = PlayGamesAuthProvider.getCredential(acct.serverAuthCode!!)\nauth.signInWithCredential(credential)\n.addOnCompleteListener(this) { task ->\nif (task.isSuccessful) {\nupdateUI(user)\n}", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "사용자가 Firebase에 로그인한 후, FirebaseUser 객체로부터 사용자의 Firebase UID를 가져오는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/play-games?hl=ko#kotlin-android] ---\nval user = auth.currentUser\nuser?.let {\nval playerName = it.displayName\n}", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "사용자를 로그아웃시키기 위해 FirebaseAuth.signOut() 메서드를 호출하는 방법은 무엇인가요?", "answer": "--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/play-games?hl=ko#kotlin-android] ---\nFirebase.auth.signOut()", "source": ["https://firebase.google.com/docs/auth/android/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_play-games_hl=ko.txt"}
{"question": "Firebase Authentication을 Android 프로젝트에 추가하는 방법은 무엇인가요?", "answer": "모듈(앱 수준) Gradle 파일(일반적으로 <project>/<app-module>/build.gradle.kts 또는 <project>/<app-module>/build.gradle)에서 Android용 Firebase Authentication 라이브러리의 종속 항목을 추가합니다. 라이브러리 버전 관리 제어에는 Firebase Android BoM을 사용하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "Firebase Authentication 에뮬레이터를 사용하는 방법은 무엇인가요?", "answer": "Authentication 에뮬레이터를 사용하려면 다음 몇 단계만 거치면 됩니다. 1. 에뮬레이터에 연결하려면 앱의 테스트 구성에 코드 줄을 추가합니다. 2. 로컬 프로젝트 디렉터리의 루트에서 firebase emulators:start를 실행합니다. 3. 대화형 프로토타입 제작에는 Local Emulator Suite UI를, 비대화형 테스트에는 Authentication 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스를 초기화하는 방법은 무엇인가요?", "answer": "Kotlin에서는 다음과 같이 FirebaseAuth 인스턴스를 선언하고 초기화합니다: \n```kotlin\nprivate lateinit var auth: FirebaseAuth\n// Initialize Firebase Auth\nauth = Firebase.auth\n``` \nJava에서는 다음과 같이 선언하고 초기화합니다: \n```java\nprivate FirebaseAuth mAuth;\n// Initialize Firebase Auth\nmAuth = FirebaseAuth.getInstance();\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "사용자가 현재 로그인되어 있는지 확인하는 방법은 무엇인가요?", "answer": "Kotlin에서는 onStart() 메서드에서 다음과 같이 확인합니다: \n```kotlin\npublic override fun onStart() {\n    super.onStart()\n    if (currentUser != null) {\n        reload()\n    }\n}\n``` \nJava에서는 다음과 같이 확인합니다: \n```java\n@Override\npublic void onStart() {\n    super.onStart();\n    FirebaseUser currentUser = mAuth.getCurrentUser();\n    if(currentUser != null){\n        reload();\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "이메일과 비밀번호로 사용자를 생성하는 방법은 무엇인가요?", "answer": "Kotlin에서는 다음과 같이 사용자를 생성합니다: \n```kotlin\nauth.createUserWithEmailAndPassword(email, password)\n    .addOnCompleteListener(this) { task ->\n        if (task.isSuccessful) {\n            updateUI(user)\n        } else {\n            Toast.makeText(\n                baseContext,\n                \"Authentication failed.\",\n                Toast.LENGTH_SHORT,\n            ).show()\n            updateUI(null)\n        }\n    }\n``` \nJava에서는 다음과 같이 사용자를 생성합니다: \n```java\nmAuth.createUserWithEmailAndPassword(email, password)\n    .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n        @Override\n        public void onComplete(@NonNull Task<AuthResult> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"createUserWithEmail:success\");\n                FirebaseUser user = mAuth.getCurrentUser();\n                updateUI(user);\n            } else {\n                Log.w(TAG, \"createUserWithEmail:failure\", task.getException());\n                Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                        Toast.LENGTH_SHORT).show();\n                updateUI(null);\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "Kotlin에서 FirebaseAuth 인스턴스를 초기화하는 방법은 무엇인가요?", "answer": "Kotlin에서 FirebaseAuth 인스턴스를 초기화하려면 onCreate() 메서드에서 다음 코드를 사용합니다:\n\n```kotlin\n// Initialize Firebase Auth\nauth = Firebase.auth\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "Java에서 FirebaseAuth 인스턴스를 초기화하는 방법은 무엇인가요?", "answer": "Java에서 FirebaseAuth 인스턴스를 초기화하려면 onCreate() 메서드에서 다음 코드를 사용합니다:\n\n```java\n// Initialize Firebase Auth\nmAuth = FirebaseAuth.getInstance();\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "사용자가 현재 로그인되어 있는지 확인하는 Kotlin 코드 예시는 무엇인가요?", "answer": "Kotlin에서 사용자가 현재 로그인되어 있는지 확인하려면 onStart() 메서드에서 다음 코드를 사용합니다:\n\n```kotlin\npublic override fun onStart() {\n    super.onStart()\n    if (currentUser != null) {\n        reload()\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "사용자가 현재 로그인되어 있는지 확인하는 Java 코드 예시는 무엇인가요?", "answer": "Java에서 사용자가 현재 로그인되어 있는지 확인하려면 onStart() 메서드에서 다음 코드를 사용합니다:\n\n```java\n@Override\npublic void onStart() {\n    super.onStart();\n    FirebaseUser currentUser = mAuth.getCurrentUser();\n    if(currentUser != null){\n        reload();\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "이메일과 비밀번호로 사용자를 로그인시키는 Java 코드 예시는 무엇인가요?", "answer": "Java에서 이메일과 비밀번호로 사용자를 로그인시키려면 다음 코드를 사용합니다:\n\n```java\nmAuth.signInWithEmailAndPassword(email, password)\n    .addOnCompleteListener(this, new OnCompleteListener<AuthResult>() {\n        @Override\n        public void onComplete(@NonNull Task<AuthResult> task) {\n            if (task.isSuccessful()) {\n                Log.d(TAG, \"signInWithEmail:success\");\n                FirebaseUser user = mAuth.getCurrentUser();\n                updateUI(user);\n            } else {\n                Log.w(TAG, \"signInWithEmail:failure\", task.getException());\n                Toast.makeText(EmailPasswordActivity.this, \"Authentication failed.\",\n                        Toast.LENGTH_SHORT).show();\n                updateUI(null);\n            }\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/android/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_start_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정하기 위해 Admin SDK에서 어떤 코드를 실행해야 하나요?", "answer": "다음 코드를 실행하여 TOTP MFA를 사용 설정할 수 있습니다.\n\n```javascript\nimport { getAuth } from 'firebase-admin/auth';\n\ngetAuth().projectConfigManager().updateProjectConfig(\n  multiFactorConfig: {\n    providerConfigs: [{\n      state: \"ENABLED\",\n      totpProviderConfig: {\n        adjacentIntervals: NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n);\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "REST API를 사용하여 TOTP MFA를 사용 설정하는 방법은 무엇인가요?", "answer": "다음 curl 명령어를 사용하여 TOTP MFA를 사용 설정할 수 있습니다.\n\n```bash\ncurl -X PATCH \"https://identitytoolkit.googleapis.com/admin/v2/projects/PROJECT_ID/config?updateMask=mfa\" \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\" \\\n-d \\\n'{\n  \"mfa\": {\n    \"providerConfigs\": [{\n      \"state\": \"ENABLED\",\n      \"totpProviderConfig\": {\n        \"adjacentIntervals\": NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n}'\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "사용자가 TOTP MFA에 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "사용자를 TOTP MFA에 등록하기 위해 다음과 같은 클라이언트 측 로직을 구현해야 합니다.\n\n```javascript\n// 사용자를 다시 인증합니다.\n// 인증된 사용자의 TOTP 보안 비밀을 생성합니다.\nFirebase.auth.currentUser.multiFactor.session\nTotpMultiFactorGenerator.generateSecret(multiFactorSession);\n\n// 보안 비밀 키를 표시하고 OTP 앱에 추가합니다.\nval qrCodeUri = totpSecret.generateQrCodeUrl(\n  currentUser.email ?: \"default account\",\n  \"Your App Name\"\n);\ntotpSecret.openInOtpApp(qrCodeUri);\n\n// 사용자가 OTP 앱에 보안 비밀을 추가하면 TOTP가 생성됩니다.\n// 사용자에게 OTP 앱에 표시된 TOTP를 입력하라고 요청합니다.\n.getAssertionForEnrollment(totpSecret, verificationCode);\nFirebase.auth.currentUser.multiFactor.enroll(multiFactorAssertion, \"TOTP\");\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "MFA를 사용하지 않을 때와 동일하게 로그인하려면 어떤 메서드를 호출해야 하나요?", "answer": "MFA를 사용하지 않을 때와 마찬가지로 `signInWith-` 메서드 중 하나를 호출해야 합니다. 예를 들어, `signInWithEmailAndPassword()` 메서드를 사용할 수 있습니다.\n\n```javascript\nFirebase.auth.signInWithEmailAndPassword(email, password);\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용하기 위해 어떤 사전 조건이 필요한가요?", "answer": "TOTP MFA를 사용하기 위해서는 다음과 같은 사전 조건이 필요합니다:\n1. MFA를 지원하는 하나 이상의 제공업체를 사용 설정해야 합니다.\n2. 앱에서 사용자 이메일 주소를 인증해야 합니다.\n3. Firebase Android SDK를 설치해야 하며, TOTP MFA는 Android SDK 버전 v22.1.0 이상에서만 지원됩니다.", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현합니다. 다음 코드를 사용하여 사용자를 다시 인증하고 TOTP 보안 비밀을 생성합니다.\n\n```javascript\n// 사용자를 다시 인증합니다.\nFirebase.auth.currentUser.multiFactor.session\nTotpMultiFactorGenerator.generateSecret(multiFactorSession)\n```\n보안 비밀 키를 표시하는 것 외에도 기기의 기본 OTP 앱에 보안 비밀 키를 자동으로 추가하도록 시도할 수 있습니다. 이렇게 하려면 Google OTP 호환 키 URI를 생성하여 `openInOtpApp()`에 전달합니다.\n\n```kotlin\nval qrCodeUri = totpSecret.generateQrCodeUrl(\ncurrentUser.email ?: \"default account\",\n\"Your App Name\")\ntotpSecret.openInOtpApp(qrCodeUri)\n```\n사용자가 OTP 앱에 보안 비밀을 추가하면 TOTP가 생성되기 시작합니다. 사용자에게 OTP 앱에 표시된 TOTP를 입력하고 이를 사용하여 MFA 등록을 완료하라는 메시지를 표시합니다.\n\n```javascript\n.getAssertionForEnrollment(totpSecret, verificationCode)\nFirebase.auth.currentUser.multiFactor.enroll(multiFactorAssertion, \"TOTP\")\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정할 때 어떤 등록 패턴을 선택할 수 있나요?", "answer": "앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 몇몇 일반적인 패턴은 다음과 같습니다:\n1. 등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n2. 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 앱에서 다중 인증(MFA)을 권장하지만 필수가 아니라면 이 방법을 사용할 수 있습니다.\n3. 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.\n4. 사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA에서 사용자가 등록 해제할 때 어떤 오류를 처리해야 하나요?", "answer": "사용자가 여러 MFA 옵션에 가입했고, 가장 최근에 사용 설정된 옵션에서 등록 해제한 경우 `auth/user-token-expired`를 수신하고 로그아웃됩니다. 사용자는 다시 로그인하여 기존 사용자 인증 정보(예: 이메일 주소와 비밀번호)를 확인해야 합니다. 사용자를 등록 해제하고 오류를 처리하고 재인증을 트리거하려면 다음 코드를 사용하세요.\n\n```javascript\nFirebase.auth.currentUser.multiFactor.unenroll(mfaEnrollmentId)\ncurrentUser.reauthenticate(credential)\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정하기 위해 필요한 API 요청의 형식은 어떻게 되나요?", "answer": "TOTP MFA를 사용 설정하려면 다음과 같은 API 요청을 실행해야 합니다.\n\n```bash\ncurl -X PATCH \"https://identitytoolkit.googleapis.com/admin/v2/projects/PROJECT_ID/config?updateMask=mfa\" \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\" \\\n-d \\\n'{\n\"mfa\": {\n\"providerConfigs\": [{\n\"state\": \"ENABLED\",\n\"totpProviderConfig\": {\n\"adjacentIntervals\": NUM_ADJ_INTERVALS\n}\n}\n]}\n}'\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정한 후 사용자가 MFA 등록을 완료하기 위해 어떤 단계를 거쳐야 하나요?", "answer": "사용자가 OTP 앱에 보안 비밀을 추가하면 TOTP가 생성되기 시작합니다. 사용자에게 OTP 앱에 표시된 TOTP를 입력하고 이를 사용하여 MFA 등록을 완료하라는 메시지를 표시합니다. 다음 코드를 사용하여 MFA 등록을 완료합니다.\n\n```javascript\n.getAssertionForEnrollment(totpSecret, verificationCode)\nFirebase.auth.currentUser.multiFactor.enroll(multiFactorAssertion, \"TOTP\")\n```", "source": ["https://firebase.google.com/docs/auth/android/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_totp-mfa_hl=ko.txt"}
{"question": "Firebase에서 Twitter 로그인을 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "Firebase 프로젝트에서 Twitter를 로그인 제공업체로 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Android 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "아직 추가하지 않았다면 Android 프로젝트에 Firebase를 추가하려면 Firebase 공식 문서의 지침을 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Twitter 계정을 사용하여 Firebase에 인증하기 위해 OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "제공업체 ID Twitter.com을 사용하여 빌더로 OAuthProvider의 인스턴스를 생성합니다. Kotlin 예시는 다음과 같습니다:\n```kotlin\nval provider = OAuthProvider.newBuilder(\"twitter.com\")\n```\nJava 예시는 다음과 같습니다:\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"twitter.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수를 OAuth 요청과 함께 전송할 수 있나요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "로그인 과정 중에 대기 중인 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 다음과 같이 getPendingAuthResult를 호출합니다:\n```kotlin\nval pendingResultTask = firebaseAuth.pendingAuthResult\nif (pendingResultTask != null) {\n    // 처리 로직\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 Twitter 로그인을 위해 OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "Firebase Android SDK로 Twitter 로그인을 처리하기 위해서는 다음과 같이 OAuthProvider의 인스턴스를 생성합니다.\n\nKotlin\n```kotlin\nval provider = OAuthProvider.newBuilder(\"twitter.com\")\n```\n\nJava\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"twitter.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 OAuth 요청과 함께 커스텀 OAuth 매개변수를 추가하는 방법은 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 로그인 과정 중 대기 중인 결과가 있는지 확인하는 방법은 무엇인가요?", "answer": "대기 중인 결과가 있는지 확인하려면 다음과 같이 getPendingAuthResult를 호출합니다.\n\nKotlin\n```kotlin\nval pendingResultTask = firebaseAuth.pendingAuthResult\nif (pendingResultTask != null) {\n    // 대기 중인 결과가 존재함\n}\n```\n\nJava\n```java\nTask<AuthResult> pendingResultTask = firebaseAuth.getPendingAuthResult();\nif (pendingResultTask != null) {\n    // 대기 중인 결과가 존재함\n}\n```", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 Twitter 로그인을 위한 UI를 제어하는 방법은 무엇인가요?", "answer": "OAuth 제공업체 객체를 사용해 Firebase에 인증할 때, UI를 제어하기 위해 커스텀 Chrome 탭을 팝업으로 표시합니다. 이로 인해 작업에서 UI를 시작할 때, 연결한 OnSuccessListener 및 OnFailureListener가 즉각 분리되므로 이들 리스너에서 활동을 참조하면 안 됩니다.", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 현재 사용자를 로그아웃하는 방법은 무엇인가요?", "answer": "Firebase에서 현재 사용자를 로그아웃하려면 다음과 같이 signOut() 메서드를 호출합니다.\n\nKotlin\n```kotlin\nFirebase.auth.signOut()\n```\n\nJava\n```java\nFirebaseAuth.getInstance().signOut();\n```", "source": ["https://firebase.google.com/docs/auth/android/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_twitter-login_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 Yahoo를 로그인 제공업체로 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 Yahoo를 로그인 제공업체로 사용 설정하려면 다음 단계를 따르세요:\n1. Firebase Console에서 인증 섹션을 엽니다.\n2. 로그인 방법 탭에서 Yahoo 제공업체를 사용 설정합니다.\n3. 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase Android SDK로 Yahoo 계정을 통해 인증하는 방법은 무엇인가요?", "answer": "Firebase Android SDK로 Yahoo 계정을 통해 인증하려면 다음 단계를 따르세요:\n1. 제공업체 ID yahoo.com을 사용하여 빌더로 OAuthProvider의 인스턴스를 생성합니다.\n   ```\n   val provider = OAuthProvider.newBuilder(\"yahoo.com\")\n   ```\n2. 선택적으로 OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo OAuth 클라이언트를 등록하기 위해 필요한 권한은 무엇인가요?", "answer": "Yahoo OAuth 클라이언트를 등록하기 위해 OpenID Connect API 권한 2개(profile 및 email)를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase Console에서 앱의 SHA-1 디지털 지문을 지정하는 방법은 무엇인가요?", "answer": "Firebase Console의 설정 페이지에서 앱의 SHA-1 디지털 지문을 지정할 수 있습니다. 앱의 SHA-256 디지털 지문을 얻는 방법에 대한 자세한 내용은 클라이언트 인증 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "OAuth 요청 시 추가로 지정해야 하는 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, redirect_uri, response_type, scope, state가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase Android SDK에서 Yahoo 계정을 통해 인증하기 위해 OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "Firebase Android SDK에서 Yahoo 계정을 통해 인증하기 위해 OAuthProvider의 인스턴스를 생성하려면 다음 코드를 사용합니다.\n\n```kotlin\nval provider = OAuthProvider.newBuilder(\"yahoo.com\")\n```\n\nJava에서는 다음과 같이 작성합니다.\n\n```java\nOAuthProvider.Builder provider = OAuthProvider.newBuilder(\"yahoo.com\");\n```", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇이며, 어떻게 전달하나요?", "answer": "Firebase에서 요구하는 매개변수는 client_id, redirect_uri, response_type, scope, state입니다. 이러한 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo API의 비공개 사용자 데이터에 대한 액세스를 요청하기 위해 필요한 OAuth 범위는 어떻게 지정하나요?", "answer": "Yahoo API의 비공식 사용자 데이터에 대한 액세스가 필요한 경우, Yahoo 개발자 콘솔의 API 권한에서 Yahoo API에 대한 권한을 요청해야 합니다. 요청받은 OAuth 범위는 앱의 API 권한에서 사전 구성된 범위와 정확하게 일치해야 합니다.", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 계정으로 인증 후 사용자의 프로필 및 이메일 범위를 요청하는 방법은 무엇인가요?", "answer": "인증 제공업체에서 요청하고자 하는 profile 및 email 범위를 넘는 OAuth 2.0 범위를 추가로 지정하려면, 다음과 같이 List<String>을 사용하여 범위를 설정합니다.\n\n```kotlin\nList<String> scopes =\nnew ArrayList<String>() {\n// 범위 추가\n};\n```", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 인증 후 사용자를 재인증하는 방법은 무엇인가요?", "answer": "Firebase에서 사용자를 재인증하려면 다음 코드를 사용합니다.\n\n```kotlin\nfirebaseUser\n.startActivityForReauthenticateWithProvider(activity, provider.build());\n```", "source": ["https://firebase.google.com/docs/auth/android/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_android_yahoo-oauth_hl=ko.txt"}
{"question": "Fabulous 앱은 Firebase 인증을 구현하는 데 얼마나 걸렸나요?", "answer": "Fabulous는 불과 반나절 만에 Firebase 인증을 구현하였습니다.", "source": ["https://firebase.google.com/docs/auth/case-studies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_case-studies_hl=ko.txt"}
{"question": "Rave 앱의 클라이언트와 서버에서 Firebase 인증을 구현하는 데 걸린 시간은 각각 얼마인가요?", "answer": "Rave의 경우 클라이언트는 1~2일, 서버는 단 1시간이 걸렸습니다.", "source": ["https://firebase.google.com/docs/auth/case-studies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_case-studies_hl=ko.txt"}
{"question": "Kwaver Music 앱의 엔지니어링 담당 부사장은 Firebase 인증의 어떤 점을 강조했나요?", "answer": "Kwaver Music의 제임스 자밋은 '새 인증 버전으로 간편하게 여러 소셜 제공업체를 처리할 수 있었습니다.'라고 강조했습니다.", "source": ["https://firebase.google.com/docs/auth/case-studies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_case-studies_hl=ko.txt"}
{"question": "reebee 앱의 공동 창립자는 Firebase 인증을 통해 어떤 점이 마음에 들었나요?", "answer": "reebee의 마이클 마티니악은 '사용자 인증을 기반으로 차세대 기능을 구현하는 데에만 집중할 수 있다는 점이 가장 마음에 들었습니다.'라고 말했습니다.", "source": ["https://firebase.google.com/docs/auth/case-studies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_case-studies_hl=ko.txt"}
{"question": "Rave 앱은 Firebase 인증을 통해 어떤 시스템을 신속하게 가동할 수 있었나요?", "answer": "Rave는 Firebase 인증을 통해 다중 플랫폼 로그인 시스템을 신속하게 가동할 수 있었습니다.", "source": ["https://firebase.google.com/docs/auth/case-studies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_case-studies_hl=ko.txt"}
{"question": "C++에서 Google 인증 제공업체의 사용자 인증 정보를 가져오는 방법은 무엇인가요?", "answer": "Google 로그인 시 사용자 인증 정보를 가져오려면 다음과 같이 firebase::auth::Credential을 생성합니다.\n\n```cpp\nfirebase::auth::Credential credential =\nfirebase::auth::GoogleAuthProvider::GetCredential(google_id_token,\nnullptr);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_account-linking_hl=ko.txt"}
{"question": "사용자 계정에 인증 제공업체의 사용자 인증 정보를 연결하는 과정은 어떻게 되나요?", "answer": "사용자 계정에 인증 제공업체의 사용자 인증 정보를 연결하려면 다음 단계를 따릅니다:\n1. 인증 제공업체 또는 인증 방법을 사용해 사용자를 로그인 처리합니다.\n2. 새로운 인증 제공업체의 로그인 과정을 진행하되 firebase::auth::Auth::SignInWithCredential 메서드 호출 전까지만 진행합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_account-linking_hl=ko.txt"}
{"question": "LinkWithCredential 호출이 실패하는 경우는 어떤 상황인가요?", "answer": "LinkWithCredential 호출이 실패하는 경우는 사용자의 인증 정보가 다른 사용자 계정에 이미 연결되어 있을 때 발생합니다. 이 경우에는 앱에 맞게 계정과 관련 데이터를 병합하는 과정을 처리해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_account-linking_hl=ko.txt"}
{"question": "특정 인증 제공업체와 사용자 계정의 연결을 해제하는 방법은 무엇인가요?", "answer": "특정 인증 제공업체와 사용자 계정의 연결을 해제하려면 제공업체 ID를 Unlink 메서드에 전달해야 합니다. 사용자 계정에 연결된 인증 제공업체의 ID를 가져오려면 ProviderData를 호출합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_account-linking_hl=ko.txt"}
{"question": "사용자가 여러 인증 제공업체를 통해 로그인할 수 있는 이유는 무엇인가요?", "answer": "사용자가 여러 인증 제공업체를 통해 로그인할 수 있는 이유는 인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하기 때문입니다. 이를 통해 사용자는 동일한 Firebase 사용자 ID로 본인 확인이 가능합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_account-linking_hl=ko.txt"}
{"question": "C++에서 Firebase에 익명으로 인증하기 위해 필요한 초기화 코드는 무엇인가요?", "answer": "#include \"firebase/app.h\"\n#include \"firebase/auth.h\"\n\n#if defined(__ANDROID__)\nfirebase::App* app =", "source": ["https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자가 Firebase에 인증할 때 어떤 메서드를 사용하여 결과를 확인하나요?", "answer": "firebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAnonymouslyLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        auth_result.user.display_name().c_str());\n    }\n}", "source": ["https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_anonymous-auth_hl=ko.txt"}
{"question": "Firebase Console에서 익명 인증을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 페이지에서 익명 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_anonymous-auth_hl=ko.txt"}
{"question": "자동 정리를 사용 설정하면 익명 계정은 어떻게 관리되나요?", "answer": "자동 정리를 사용 설정하면 30일이 지난 익명 계정은 자동으로 삭제됩니다. 자동 정리가 사용 설정된 프로젝트에서는 익명 인증이 사용량 한도 또는 결제 할당량에 포함되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_anonymous-auth_hl=ko.txt"}
{"question": "익명 계정을 로그인 방법에 연결하면 어떤 결과가 발생하나요?", "answer": "익명 계정을 로그인 방법에 연결하여 '업그레이드'할 경우 계정이 자동으로 삭제되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_anonymous-auth_hl=ko.txt"}
{"question": "Apple로 로그인 기능을 사용하기 위해 사용자가 충족해야 하는 조건은 무엇인가요?", "answer": "Apple로 로그인하려면 사용자는 다음을 충족해야 합니다.\n\n- 2단계 인증(2FA)이 사용 설정된 Apple ID가 있어야 합니다.\n- Apple 기기에서 iCloud에 로그인되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 Apple 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 Apple 로그인을 사용 설정하려면 Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Apple 제공업체를 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 익명 처리된 데이터 요구사항을 준수하기 위해 어떤 점을 유의해야 하나요?", "answer": "Apple로 로그인에는 사용자가 로그인할 때 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션이 제공됩니다. 이 익명처리된 Apple ID에 대한 Apple의 관련 개발자 정책 또는 약관을 모두 준수해야 하며, 개인 식별 정보를 익명처리된 Apple ID와 연결하려면 먼저 사용자 동의를 받아야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Firebase SDK를 사용하여 Apple로 로그인하는 절차는 어떻게 되나요?", "answer": "C++ 코드에서 호출된 Apple Sign in Objective-C SDK를 통해 Firebase에 사용자를 인증합니다. 로그인 요청마다 임의의 문자열인 'nonce'가 생성되며, 이 nonce는 앱의 인증 요청에 대한 응답으로 ID 토큰이 명시적으로 부여되었는지 확인하는 데 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Apple 로그인을 구성하기 위해 필요한 Apple Developer Program의 조건은 무엇인가요?", "answer": "Apple로 로그인은 Apple Developer Program의 멤버만 구성할 수 있습니다. 따라서 Apple Developer Program에 가입해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple로 로그인하기 위해 nonce를 생성하는 방법은 무엇인가요?", "answer": "C++에서 nonce를 생성하는 방법은 다음과 같습니다. 이 코드는 임의의 문자열인 'nonce'를 생성하여 인증 요청에 사용합니다.\n\n```objc\n- (NSString *)randomNonce:(NSInteger)length {\n    NSAssert(length > 0, @\"Expected nonce to have positive length\");\n    NSString *characterSet = @\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\";\n    NSMutableString *result = [NSMutableString string];\n    NSInteger remainingLength = length;\n\n    while (remainingLength > 0) {\n        NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];\n        for (NSInteger i = 0; i < 16; i++) {\n            uint8_t random = 0;\n            int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);\n            NSAssert(errorCode == errSecSuccess, @\"Unable to generate nonce: OSStatus %i\", errorCode);\n\n            [randoms addObject:@(random)];\n            [result appendFormat:@\"%C\", character];\n            remainingLength--;\n        }\n    }\n    return result;\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Apple 로그인 요청을 시작하는 방법은 무엇인가요?", "answer": "Apple 로그인 요청을 시작하는 방법은 다음과 같습니다. 이 코드는 nonce의 SHA256 해시를 요청에 포함하여 Apple의 로그인 과정을 시작합니다.\n\n```objc\n- (void)startSignInWithAppleFlow {\n    NSString *nonce = [self randomNonce:32];\n    self.currentNonce = nonce;\n    ASAuthorizationAppleIDProvider *appleIDProvider = [[ASAuthorizationAppleIDProvider alloc] init];\n    ASAuthorizationAppleIDRequest *request = [appleIDProvider createRequest];\n    request.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n    request.nonce = [self stringBySha256HashingString:nonce];\n\n    ASAuthorizationController *authorizationController =\n    [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[request]];\n    authorizationController.delegate = self;\n    authorizationController.presentationContextProvider = self;\n    [authorizationController performRequests];\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Apple 로그인 후 응답을 처리하는 방법은 무엇인가요?", "answer": "Apple 로그인 후 응답을 처리하는 방법은 다음과 같습니다. 이 코드는 로그인에 성공했을 때 Apple의 응답에서 ID 토큰을 사용하여 Firebase에 인증합니다.\n\n```objc\n- (void)authorizationController:(ASAuthorizationController *)controller\n    didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0)) {\n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *rawNonce = self.currentNonce;\n        NSAssert(rawNonce != nil, @\"Invalid state: A login callback was received, but no login request was sent.\");\n\n        if (appleIDCredential.identityToken == nil) {\n            NSLog(@\"Unable to fetch identity token.\");\n            return;\n        }\n        NSLog(@\"Unable to serialize id token from data: %@\", appleIDCredential.identityToken);\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 계정을 연결하는 방법은 무엇인가요?", "answer": "Firebase에서 Apple 계정을 연결하는 방법은 다음과 같습니다. 이 코드는 기존 Firebase 계정에 Apple 계정을 연결하는 과정을 보여줍니다.\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> link_result =\n    auth->current_user().LinkWithCredential(credential);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "Apple 로그인 시 발생할 수 있는 오류는 무엇인가요?", "answer": "Apple 로그인 시 발생할 수 있는 오류는 'kAuthErrorCredentialAlreadyInUse' 상태입니다. 이 오류는 연결하려는 Apple 계정에 기존 Firebase 계정이 이미 연결되어 있을 때 발생합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 요청을 시작하기 위해 필요한 nonce를 생성하는 방법은 무엇인가요?", "answer": "C++에서 nonce를 생성하기 위해 다음과 같은 메서드를 사용할 수 있습니다:\n\n```objc\n- (NSString *)randomNonce:(NSInteger)length {\n    NSAssert(length > 0, @\"Expected nonce to have positive length\");\n    NSString *characterSet = @\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\";\n    NSMutableString *result = [NSMutableString string];\n    NSInteger remainingLength = length;\n\n    while (remainingLength > 0) {\n        NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];\n        for (NSInteger i = 0; i < 16; i++) {\n            uint8_t random = 0;\n            int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);\n            NSAssert(errorCode == errSecSuccess, @\"Unable to generate nonce: OSStatus %i\", errorCode);\n\n            [randoms addObject:@(random)];\n            [result appendFormat:@\"%C\", character];\n            remainingLength--;\n        }\n    }\n    return result;\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 후 응답을 처리하는 방법은 무엇인가요?", "answer": "C++에서 Apple 로그인 후 응답을 처리하기 위해 다음과 같은 메서드를 구현해야 합니다:\n\n```objc\n- (void)authorizationController:(ASAuthorizationController *)controller\n    didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0)) {\n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *rawNonce = self.currentNonce;\n        NSAssert(rawNonce != nil, @\"Invalid state: A login callback was received, but no login request was sent.\");\n\n        if (appleIDCredential.identityToken == nil) {\n            NSLog(@\"Unable to fetch identity token.\");\n            return;\n        }\n        NSLog(@\"Unable to serialize id token from data: %@\", appleIDCredential.identityToken);\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 계정을 Firebase에 연결하는 방법은 무엇인가요?", "answer": "C++에서 Apple 계정을 Firebase에 연결하기 위해 다음과 같은 코드를 사용할 수 있습니다:\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> link_result =\n    auth->current_user().LinkWithCredential(credential);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 시 발생할 수 있는 오류는 무엇인가요?", "answer": "C++에서 Apple 로그인 시 발생할 수 있는 오류 중 하나는 kAuthErrorCredentialAlreadyInUse 상태입니다. 이 오류는 연결하려는 Apple 계정에 기존 Firebase 계정이 이미 연결되어 있을 때 발생합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 요청 시 요청에 포함해야 하는 nonce의 해시를 생성하는 방법은 무엇인가요?", "answer": "C++에서 nonce의 SHA256 해시를 생성하기 위해 다음과 같은 코드를 사용할 수 있습니다:\n\n```objc\nCC_SHA256(string, (CC_LONG)strlen(string), result);\nNSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2];\nfor (NSInteger i = 0; i < CC_SHA256_DIGEST_LENGTH; i++) {\n    [hashed appendFormat:@\"%02x\", result[i]];\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 후 사용자의 표시 이름을 가져오는 방법은 무엇인가요?", "answer": "사용자가 Apple 계정으로 처음 로그인할 때 표시 이름을 저장하며, 이 표시 이름은 다음과 같이 가져올 수 있습니다:\n\n```cpp\ncurrent_user().display_name();\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 시 사용자의 이메일을 공유하지 않을 경우 어떤 이메일 주소가 제공되나요?", "answer": "사용자가 자신의 이메일을 앱에 공유하지 않으면 Apple은 이 사용자의 고유 이메일 주소(xyz@privaterelay.appleid.com 형식)를 프로비저닝하여 개발자 앱으로 공유합니다. 비공개 이메일 릴레이 서비스를 구성한 경우 Apple은 익명처리된 주소로 전송된 이메일을 사용자의 실제 이메일 주소로 전달합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 후 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 요청 시 FederatedOAuthProviderData를 구성하는 방법은 무엇인가요?", "answer": "Apple에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 만들고, 다음과 같이 scopes를 추가합니다:\n\n```cpp\nprovider_data.scopes.push_back(\"name\");\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++에서 Apple 로그인 후 사용자 인증 정보를 검색하는 방법은 무엇인가요?", "answer": "Firebase SDK를 통해 사용자 인증 정보를 검색하려면 다음과 같이 ReauthenticateWithProvider를 사용합니다:\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nuser.ReauthenticateWithProvider(provider_data);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_apple_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase C++ SDK 설정 문서](https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform)를 참조하여 필요한 단계를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_custom-auth_hl=ko.txt"}
{"question": "Firebase 인증을 위해 서비스 계정의 비공개 키를 생성하는 방법은 무엇인가요?", "answer": "서비스 계정의 비공개 키를 생성하려면 다음 단계를 따르세요: 1. 프로젝트 설정의 서비스 계정 페이지로 이동합니다. 2. Firebase Admin SDK 섹션 하단에서 '새 비공개 키 생성'을 클릭합니다. 3. 새 서비스 계정의 공개 키/비공개 키 쌍이 자동으로 컴퓨터에 저장됩니다. 이 파일을 인증 서버에 복사합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_custom-auth_hl=ko.txt"}
{"question": "Firebase 인증을 위한 초기화 코드는 어떻게 작성하나요?", "answer": "#include \"firebase/app.h\"\n#include \"firebase/auth.h\"\n\nfirebase::App* app = ...; // firebase::App 클래스를 초기화합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_custom-auth_hl=ko.txt"}
{"question": "C++에서 커스텀 서명 토큰으로 로그인한 결과를 확인하는 방법은 무엇인가요?", "answer": "다음과 같이 Auth::SignInWithCustomTokenLastResult를 사용하여 결과를 확인할 수 있습니다:\n\nfirebase::Future<firebase::auth::AuthResult> result = auth->SignInWithCustomTokenLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        auth_result.user.display_name().c_str());\n    }\n}", "source": ["https://firebase.google.com/docs/auth/cpp/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_custom-auth_hl=ko.txt"}
{"question": "Firebase 인증에서 Auth와 App의 관계는 무엇인가요?", "answer": "Auth 클래스는 모든 API 호출에 대한 게이트웨이이며, Auth와 App은 일대일 매핑 관계입니다.", "source": ["https://firebase.google.com/docs/auth/cpp/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_custom-auth_hl=ko.txt"}
{"question": "C++ 프로젝트에서 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase 설정 문서](https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform)를 참조하여 필요한 단계를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_facebook-login_hl=ko.txt"}
{"question": "Firebase Console에서 Facebook 로그인을 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Facebook 로그인 방법을 사용 설정한 후, Facebook에서 받은 앱 ID와 앱 비밀번호를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 사용자의 액세스 토큰을 가져오는 방법은 무엇인가요?", "answer": "Android 및 iOS 관련 안내에 따라 로그인한 Facebook 사용자의 액세스 토큰을 가져와야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_facebook-login_hl=ko.txt"}
{"question": "C++에서 Firebase 사용자 인증 정보를 사용해 인증하는 방법은 무엇인가요?", "answer": "Firebase 사용자 인증 정보를 사용해 Firebase에 인증하려면 다음과 같이 코드를 작성합니다:\n```cpp\nfirebase::auth::Credential credential = ...;\n```", "source": ["https://firebase.google.com/docs/auth/cpp/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_facebook-login_hl=ko.txt"}
{"question": "C++에서 비동기 호출을 폴링하는 방법은 무엇인가요?", "answer": "비정기적으로 실행되는 업데이트 루프가 있는 경우, 다음과 같이 Auth::SignInAndRetrieveDataWithCredentialLastResult를 사용하여 결과를 확인할 수 있습니다:\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        auth_result.user.display_name().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_facebook-login_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase C++ SDK 설정 가이드](https://firebase.google.com/docs/cpp/setup?hl=ko)를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_github-auth_hl=ko.txt"}
{"question": "GitHub 인증을 사용하기 위해 Firebase Console에서 어떤 설정을 해야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 GitHub 제공업체를 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub 사용자의 토큰을 가져오는 방법은 무엇인가요?", "answer": "Android 및 iOS 안내에 따라 로그인한 GitHub 사용자의 토큰을 가져온 후, 해당 토큰을 Firebase 사용자 인증 정보로 교환하여 Firebase에 인증합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_github-auth_hl=ko.txt"}
{"question": "C++에서 Firebase 인증을 사용하여 사용자를 인증하는 코드는 어떻게 작성하나요?", "answer": "다음 코드를 사용하여 Firebase 인증을 통해 사용자를 인증할 수 있습니다:\n```cpp\nfirebase::auth::Credential credential = ...;\nfirebase::Future<firebase::auth::AuthResult> result = auth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        printf(\"User display name: %s\", auth_result.user.display_name().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_github-auth_hl=ko.txt"}
{"question": "비동기 호출을 폴링하는 방법은 무엇인가요?", "answer": "비동기 호출을 폴링하려면 다음과 같이 LastResult 함수를 호출하여 결과를 확인할 수 있습니다:\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result = auth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        printf(\"User display name: %s\", auth_result.user.display_name().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_github-auth_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase 설정 문서](https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform)를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_google-signin_hl=ko.txt"}
{"question": "Firebase Console에서 Google 로그인을 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 Google 로그인을 설정하려면 인증 섹션을 열고 로그인 방법 탭에서 Google 로그인 방법을 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_google-signin_hl=ko.txt"}
{"question": "Firebase 인증을 위해 Google ID 토큰을 가져오는 방법은 무엇인가요?", "answer": "Google ID 토큰을 가져오는 방법은 Android 및 iOS+ 안내에 따라 진행해야 합니다. 관련 문서는 [Android](https://firebase.google.com/docs/auth/android/google-signin?hl=ko#authenticate_with_firebase)와 [iOS+](https://firebase.google.com/docs/auth/ios/google-signin?hl=ko#2_implement_google_sign-in)를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_google-signin_hl=ko.txt"}
{"question": "C++에서 Firebase 사용자 인증 정보를 얻기 위한 코드 예시는 무엇인가요?", "answer": "Firebase 사용자 인증 정보를 얻기 위해 다음과 같은 코드를 사용할 수 있습니다:\n```cpp\nfirebase::auth::Credential credential =\nfirebase::auth::GoogleAuthProvider::GetCredential(google_id_token,\nnullptr);\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredential(credential);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_google-signin_hl=ko.txt"}
{"question": "C++에서 Firebase 인증 결과를 주기적으로 확인하는 방법은 무엇인가요?", "answer": "Firebase 인증 결과를 주기적으로 확인하려면 다음과 같은 코드를 사용할 수 있습니다:\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\nif (result.error() == firebase::auth::kAuthErrorNone) {\nprintf(\"User display name: %s\", auth_result.user.display_name().c_str());\n}\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_google-signin_hl=ko.txt"}
{"question": "Firebase에서 신규 사용자를 생성하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 신규 사용자를 생성할 때는 CreateUserWithEmailAndPassword 메서드를 호출하거나 Google 로그인 또는 Facebook 로그인과 같은 제휴 ID 공급업체를 이용해 사용자의 최초 로그인을 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_manage-users_hl=ko.txt"}
{"question": "현재 로그인한 사용자를 가져오는 권장 방법은 무엇인가요?", "answer": "현재 사용자를 가져올 때 권장하는 방법은 Auth 객체에 리스너를 설정하는 것입니다. 예를 들어, 다음과 같이 구현할 수 있습니다.\n\n```cpp\nclass MyAuthStateListener : public firebase::auth::AuthStateListener {\npublic:\nvoid OnAuthStateChanged(firebase::auth::Auth* auth) override {\nMyAuthStateListener state_change_listener;\nauth->AddAuthStateListener(&state_change_listener);\n}\n};\n```", "source": ["https://firebase.google.com/docs/auth/cpp/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_manage-users_hl=ko.txt"}
{"question": "사용자 인증 정보를 유지하는 방법은 무엇인가요?", "answer": "사용자 인증 정보는 사용자가 로그인한 후에 로컬 키 저장소에 저장됩니다. 사용자 인증 정보의 로컬 캐시는 사용자가 로그아웃하면 삭제됩니다. 플랫폼에 따라 키 저장소는 다릅니다: Apple 플랫폼은 Keychain Services, Android는 Android Keystore, Windows는 Credential Management API, OS X는 Keychain Services, Linux는 libsecret을 사용합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_manage-users_hl=ko.txt"}
{"question": "사용자의 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자의 프로필 정보를 가져오려면 firebase::auth::User 인스턴스의 접근자 메서드를 사용합니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\n```cpp\nit != user.provider_data().end(); ++it) {\nprofile.photo_url = \"https://example.com/jane-q-user/profile.jpg\";\nuser.UpdateUserProfile(profile).OnCompletion(\n[](const firebase::Future<void>& completed_future, void* user_data) {\n// 프로필 업데이트 완료 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/cpp/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_manage-users_hl=ko.txt"}
{"question": "사용자 계정을 삭제하는 방법은 무엇인가요?", "answer": "Delete 메서드를 사용하여 사용자 계정을 삭제할 수 있습니다. 예를 들어, 다음과 같이 구현할 수 있습니다.\n\n```cpp\nuser.Delete().OnCompletion(\n[](const firebase::Future<void>& completed_future, void* user_data) {\nif (completed_future.error() == 0) {\n// 사용자 계정 삭제 성공\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/cpp/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_manage-users_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase C++ SDK 설정 가이드](https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform)를 참조하여 필요한 단계를 따르세요.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 클라이언트를 등록하기 위한 절차는 무엇인가요?", "answer": "Microsoft OAuth 클라이언트를 등록하려면 '빠른 시작: Azure Active Directory v2.0 엔드포인트를 사용하여 앱 등록'의 안내를 따르세요. 이 엔드포인트는 Microsoft 개인 계정과 Azure Active Directory 계정을 사용하는 로그인을 지원합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase SDK로 Microsoft OAuth 로그인을 처리하기 위한 첫 번째 단계는 무엇인가요?", "answer": "Firebase SDK로 Microsoft OAuth 로그인을 처리하기 위해서는 먼저 Microsoft에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 생성해야 합니다. 예시는 다음과 같습니다:\n```cpp\nfirebase::auth::FederatedOAuthProviderData provider_data(firebase::auth::MicrosoftAuthProvider::kProviderId);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 요청에 추가할 수 있는 커스텀 매개변수는 무엇인가요?", "answer": "Microsoft OAuth 요청에 추가할 수 있는 커스텀 매개변수는 'user@firstadd.onmicrosoft.com'과 같은 형식으로 지정할 수 있습니다. Microsoft가 지원하는 매개변수 정보는 Microsoft OAuth 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?", "answer": "Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용하여 커스텀 매개변수 객체의 '테넌트' 필드를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 요청에 추가할 수 있는 기본 프로필 범위는 어떻게 지정하나요?", "answer": "기본 프로필 범위를 넘는 OAuth 2.0 범위를 추가로 지정하려면, `provider_data.scopes.push_back()` 메서드를 사용하여 범위를 추가할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```cpp\nprovider_data.scopes.push_back(\"mail.read\");\nprovider_data.scopes.push_back(\"calendars.read\");\n```", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?", "answer": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면, 커스텀 매개변수 객체의 '테넌트' 필드를 지정해야 합니다. 이 필드에는 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft Graph API를 호출하기 위해 OAuth 액세스 토큰을 어떻게 사용하나요?", "answer": "OAuth 액세스 토큰을 사용하면 Microsoft Graph API를 호출할 수 있습니다. 이를 통해 Microsoft Graph API의 다양한 기능을 활용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase 인증에서 Microsoft OAuth 액세스 토큰을 사용하여 직접 로그인할 수 있나요?", "answer": "Firebase 인증 서버에서 Microsoft OAuth 액세스 토큰의 사용자를 인증할 수 없으므로, Firebase 인증은 Microsoft와 같은 제공업체에 대해 동일한 인증 기능을 지원하지 않습니다. 이는 보안 요구사항으로, 다른 프로젝트에서 확보한 Microsoft OAuth 액세스 토큰을 사용할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft OAuth 로그인을 처리하기 위한 후속 단계는 무엇인가요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성됩니다. 이 계정은 사용자가 로그인할 때 사용한 사용자 인증 정보에 연결되며, Firebase 프로젝트에 저장됩니다. 이후, 앱의 `firebase::auth::User` 객체를 통해 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_microsoft-oauth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication을 사용하여 비밀번호 기반 계정을 생성하는 방법은 무엇인가요?", "answer": "C++에서 Firebase Authentication을 사용하여 비밀번호 기반 계정을 생성하려면, 다음과 같이 `Auth::CreateUserWithEmailAndPasswordLastResult` 메서드를 사용하여 결과를 확인할 수 있습니다.\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\n    auth->CreateUserWithEmailAndPasswordLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        printf(\"User created: %s\\n\", auth_result.user.email().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication을 사용하여 사용자가 로그인할 때의 처리 방법은 무엇인가요?", "answer": "C++에서 Firebase Authentication을 사용하여 사용자가 로그인할 때는 `Auth::SignInWithEmailAndPasswordLastResult` 메서드를 사용하여 결과를 확인할 수 있습니다.\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\n    auth->SignInWithEmailAndPasswordLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        printf(\"User signed in: %s\\n\", auth_result.user.email().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication의 비밀번호 정책에서 요구하는 최소 및 최대 비밀번호 길이는 얼마인가요?", "answer": "Firebase Authentication의 비밀번호 정책에서는 비밀번호의 최소 길이는 6자, 최대 길이는 4,096자입니다. 기본값은 6자입니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 필수로 설정할 경우의 동작은 어떻게 되나요?", "answer": "비밀번호 정책을 필수로 설정하면 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. 즉, 사용자는 정책을 준수하지 않는 비밀번호로는 가입할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 열거 보호를 사용하는 이유는 무엇인가요?", "answer": "이메일 열거 보호를 사용하면 등록되지 않은 이메일 주소로 로그인 시도할 때 특정 오류가 발생하여 사용자에게 조치를 제안할 수 있습니다. 이는 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 것을 방지하는 데 유용합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication의 비밀번호 정책을 설정하는 방법은 무엇인가요?", "answer": "Firebase Authentication의 비밀번호 정책은 두 가지 모드로 설정할 수 있습니다. 필수 모드에서는 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. 알림 모드에서는 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있으며, 클라이언트 측에서 비밀번호가 정책을 준수하는지 확인하고 부족한 요구사항을 알리는 메시지를 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication의 비밀번호 요구사항에는 어떤 것들이 있나요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다. 소문자 필요, 대문자 필요, 숫자 필요, 영숫자가 아닌 문자 필요. 비밀번호 최소 길이는 6자에서 30자이며, 기본값은 6자입니다. 비밀번호 최대 길이는 4,096자입니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication을 사용할 때 비밀번호 정책을 필수로 설정하면 어떤 결과가 발생하나요?", "answer": "비밀번호 정책을 필수로 설정하면 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. 따라서 신규 사용자는 항상 해당 정책에 따라 비밀번호를 선택해야 하며, 기존 사용자는 비밀번호를 업데이트해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication의 이메일 열거 보호 기능을 사용 설정하는 방법은 무엇인가요?", "answer": "이메일 열거 보호 기능을 사용 설정하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 해당 기능을 활성화해야 합니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경되어, 앱이 더 구체적인 오류에 의존하지 않도록 해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication을 사용할 때 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "앱의 firebase::auth::User 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보에 연결됩니다.", "source": ["https://firebase.google.com/docs/auth/cpp/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_password-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 로그인을 사용하기 위해 어떤 설정을 해야 하나요?", "answer": "Firebase 프로젝트에서 전화번호 로그인 방법을 사용 설정해야 합니다. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 구현하기 위해 사용자가 전화번호를 입력한 후 어떤 메서드를 호출해야 하나요?", "answer": "사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 표시한 후 PhoneAuthProvider::VerifyPhoneNumber를 호출하여 Firebase에서 사용자의 휴대전화에 SMS 메시지로 인증 코드를 전송하도록 요청합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 사용할 때 보안 문제는 무엇인가요?", "answer": "전화번호만 사용하는 인증은 편리하지만, 전화번호 소유권은 사용자 간에 쉽게 이전될 수 있어 보안성이 떨어집니다. 기기에 여러 사용자 프로필이 있는 경우 SMS 메시지를 받을 수 있는 사람이라면 누구든지 기기의 전화번호로 계정에 로그인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "Apple 플랫폼에서 전화번호 인증을 사용하기 위해 어떤 추가 설정이 필요한가요?", "answer": "Apple 플랫폼에서 전화번호 인증을 사용하려면 앱이 Firebase의 APN 알림을 수신할 수 있어야 합니다. 기기에서 처음으로 전화번호를 통해 사용자를 로그인시키면 Firebase Authentication에서 기기로 자동 푸시 알림을 전송합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 구현할 때 사용자가 알아야 할 법적 사항은 무엇인가요?", "answer": "지역에 따라 현지 법규가 다르지만, 일반적으로 사용자가 제반 상황을 미리 알 수 있도록 전화 로그인을 사용하면 인증용 SMS 메시지가 발송되고 일반 요금이 부과될 수 있다는 점을 알려야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 구현할 때 APN 알림을 설정하는 방법은 무엇인가요?", "answer": "Apple 플랫폼에서 전화번호 인증을 사용하려면 앱이 Firebase의 APN 알림을 수신할 수 있어야 합니다. APN 알림을 사용 설정하는 방법은 다음과 같습니다:\n\n1. Xcode에서 프로젝트에 푸시 알림을 사용 설정합니다.\n2. Firebase에 APN 인증서를 업로드합니다. 인증서가 없다면 Apple Developer Member Center에서 만드세요.\n3. Firebase Console 프로젝트 내에서 톱니바퀴 아이콘을 선택하고 프로젝트 설정을 선택한 다음 클라우드 메시징 탭을 선택합니다.\n4. 인증서 업로드 버튼을 선택하고 .p12 파일을 선택한 후 비밀번호를 입력합니다. 이 인증서의 번들 ID가 앱의 번들 ID와 일치해야 합니다. 저장을 선택합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자가 전화번호를 입력한 후 어떤 메서드를 호출해야 하나요?", "answer": "전화번호 로그인을 시작하려면 사용자의 전화번호를 제공하도록 요청하는 인터페이스를 표시하고 PhoneAuthProvider::VerifyPhoneNumber를 호출하여 Firebase에서 사용자의 휴대전화에 SMS 메시지로 인증 코드를 전송하도록 요청합니다. 다음과 같이 호출합니다:\n\n```cpp\nPhoneAuthProvider::VerifyPhoneNumber(options, &phone_listener);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한될 수 있는 이유는 무엇인가요?", "answer": "Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 SMS 메시지의 인증 코드를 앱에 제공하면 인증 코드와 인증 ID를 사용하여 PhoneAuthCredential 객체를 만들고 이 객체를 Auth::SignInWithCredential에 전달합니다. 다음과 같이 처리합니다:\n\n```cpp\nPhoneAuthCredential credential = phone_auth_provider->GetCredential(\n    verification_id_.c_str(), verification_code.c_str());\nFuture<User> future = auth_->SignInWithCredential(credential);\nfuture.OnCompletion(\n    [](const Future<User*>& result, void*) {\n        if (result.error() == kAuthErrorNone) {\n            User user = *result.result();\n        }\n    });\n```", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 통해 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자를 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청 후 SMS 메시지를 보내는 과정은 어떻게 되나요?", "answer": "PhoneAuthProvider::VerifyPhoneNumber를 호출하면 Firebase가 다음을 수행합니다.\n\n- iOS의 경우 앱에 사용자 모르게 푸시 알림을 보냅니다.\n- 지정된 전화번호로 인증 코드가 포함된 SMS 메시지를 보냅니다.\n- 완료 함수에 인증 ID를 전달합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "인증 ID를 저장하고 복원하는 방법은 무엇인가요?", "answer": "인증 ID를 저장한 후 앱이 로드되면 이를 복원합니다. 이렇게 하면 사용자가 로그인 과정을 완료하기 전에 앱이 종료되더라도(예: SMS 앱으로 전환) 올바른 인증 ID를 유지할 수 있습니다. 인증 ID를 유지하는 방법에는 제한이 없습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "SMS 메시지의 인증 코드를 사용하여 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 SMS 메시지의 인증 코드를 앱에 제공하면 인증 코드와 인증 ID를 사용하여 PhoneAuthCredential 객체를 만들고 이 객체를 Auth::SignInWithCredential에 전달합니다.\n\n```cpp\nPhoneAuthCredential credential = phone_auth_provider->GetCredential(\nverification_id_.c_str(), verification_code.c_str());\nFuture<User> future = auth_->SignInWithCredential(credential);\nfuture.OnCompletion(\n[](const Future<User*>& result, void*) {\nif (result.error() == kAuthErrorNone) {\nUser user = *result.result();\n```", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한될 수 있는 이유는 무엇인가요?", "answer": "Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자를 식별하는 데 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_phone-auth_hl=ko.txt"}
{"question": "C++ 프로젝트에서 Firebase를 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "C++ 프로젝트에서 Firebase를 사용하기 위해서는 먼저 C++ 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. 또한, C++ 프로젝트에 Firebase C++ SDK를 추가해야 합니다. 초기 설정 작업에 대한 자세한 안내는 C++ 프로젝트에 Firebase 추가를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase Console에서 Google Play 게임즈 서비스 로그인을 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 Google Play 게임즈 서비스 로그인을 설정하려면, Authentication 섹션을 열고 로그인 방법 탭에서 Google 로그인 제공업체와 Play Games 로그인 제공업체를 사용 설정해야 합니다. 이때, 프로젝트의 웹 서버 클라이언트 ID와 클라이언트 보안 비밀번호를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Google Play Console에서 Play Games services를 구성하는 절차는 어떻게 되나요?", "answer": "Google Play Console에서 Play Games services를 구성하려면, Google Play 앱을 열거나 만들고, 성장 섹션에서 Play Games services > 설정 및 관리 > 구성을 클릭합니다. 이후 사용자 인증 정보를 추가하고, 게임 서버 유형과 OAuth 클라이언트를 선택하여 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "C++ Android 프로젝트에 Google 로그인 C++ SDK를 통합하는 방법은 무엇인가요?", "answer": "C++ Android 프로젝트에 Google 로그인 C++ SDK를 통합하려면, Google 로그인 C++ SDK를 포함한 Unity 플러그인 저장소를 클론하거나 다운로드한 후, Android 스튜디오나 gradlew build를 사용하여 staging/native/ 디렉터리에 포함된 프로젝트를 빌드합니다. 빌드가 완료되면, 게임의 네이티브 코드 작성 파일에 Google 로그인 C++ SDK를 포함해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase Console에서 게임의 SHA-1 디지털 지문을 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 게임의 SHA-1 디지털 지문을 설정하려면, 설정 페이지에서 Gradle signingReport 명령어를 사용하여 서명 인증서의 SHA 해시를 가져와야 합니다. 이 해시를 Firebase Console의 설정 페이지에 입력하여 설정합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "C++ Android 프로젝트에서 Google 로그인 C++ SDK를 사용하여 Play 게임즈 로그인을 추가하는 방법은 무엇인가요?", "answer": "Google 로그인 C++ SDK를 사용하여 게임에 Play 게임즈 로그인을 추가하려면 다음을 진행합니다.\n\n1. C++ SDK도 포함된 Google 로그인 Unity 플러그인 저장소를 클론하거나 다운로드합니다: [https://github.com/googlesamples/google-signin-unity](https://github.com/googlesamples/google-signin-unity).\n2. Android 스튜디오나 gradlew build를 사용하여 staging/native/ 디렉터리에 포함된 프로젝트를 빌드합니다.\n3. 빌드가 google-signin-cpp라는 디렉터리에 출력을 복사합니다.\n4. 게임의 네이티브 코드 작성 파일에 Google 로그인 C++ SDK를 포함합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "CMake를 사용하여 Google 로그인 C++ SDK를 포함하는 방법은 무엇인가요?", "answer": "최상위 CMakeLists.txt 파일에서 다음과 같이 설정합니다:\n```cmake\nset(GSI_PACKAGE_DIR \"/path/to/google-signin-cpp\")\nadd_library(lib-google-signin-cpp STATIC IMPORTED)\nset_target_properties(lib-google-signin-cpp PROPERTIES IMPORTED_LOCATION\n${GSI_PACKAGE_DIR}/lib/${ANDROID_ABI}/libgoogle-signin-cpp.a )\n...\ntarget_link_libraries(\n...\nlib-google-signin-cpp)\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "ndk-build를 사용하여 Google 로그인 C++ SDK를 포함하는 방법은 무엇인가요?", "answer": "Android.mk 파일에서 다음과 같이 설정합니다:\n```makefile\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := google-signin-cpp\nGSI_SDK_DIR := /path/to/google-signin-cpp\nLOCAL_SRC_FILES := $(GSI_SDK_DIR)/lib/$(TARGET_ARCH_ABI)/libgoogle-signin-cpp.a\nLOCAL_EXPORT_C_INCLUDES := $(GSI_SDK_DIR)/include\ninclude $(PREBUILT_STATIC_LIBRARY)\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 처리하기 위해 인증 코드를 가져오는 방법은 무엇인가요?", "answer": "플레이어가 Play 게임즈로 로그인하면 플레이어 계정의 인증 코드를 가져옵니다. 그런 다음 Play 게임즈 서비스의 인증 코드를 Firebase 사용자 인증 정보로 교환하고, Firebase 사용자 인증 정보를 사용하여 플레이어를 인증합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase에서 인증 결과를 확인하는 방법은 무엇인가요?", "answer": "프로그램에 정기적으로 실행되는 업데이트 루프가 있는 경우 다음과 같이 Auth::SignInAndRetrieveDataWithCredentialLastResult를 사용해 업데이트 시마다 한 번씩 결과를 확인할 수 있습니다:\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        auth_result.user.display_name().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "CMake를 사용하여 Google 로그인 C++ SDK를 포함하는 방법은 무엇인가요?", "answer": "최상위 CMakeLists.txt 파일에서 다음과 같이 설정합니다.\n\n```cmake\nset(GSI_PACKAGE_DIR \"/path/to/google-signin-cpp\")\nadd_library(lib-google-signin-cpp STATIC IMPORTED)\nset_target_properties(lib-google-signin-cpp PROPERTIES IMPORTED_LOCATION\n${GSI_PACKAGE_DIR}/lib/${ANDROID_ABI}/libgoogle-signin-cpp.a )\n...\ntarget_link_libraries(\n...\nlib-google-signin-cpp)\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "ndk-build를 사용하여 Google 로그인 C++ SDK를 포함하는 방법은 무엇인가요?", "answer": "Android.mk 파일에서 다음과 같이 설정합니다.\n\n```makefile\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := google-signin-cpp\nGSI_SDK_DIR := /path/to/google-signin-cpp\nLOCAL_SRC_FILES := $(GSI_SDK_DIR)/lib/$(TARGET_ARCH_ABI)/libgoogle-signin-cpp.a\nLOCAL_EXPORT_C_INCLUDES := $(GSI_SDK_DIR)/include\ninclude $(PREBUILT_STATIC_LIBRARY)\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 처리하기 위해 인증 코드를 가져오는 방법은 무엇인가요?", "answer": "다음과 같이 SignIn()을 호출하여 Play 게임즈에서 사용자를 로그인 처리합니다.\n\n```cpp\nGoogleSignIn gsi = GoogleSignIn(GetActivity(), GetJavaVM());\ngsi.Configure(config);\nFuture<GoogleSignIn::SignInResult> &future = gsi.SignIn();\nif (!future.Pending()) {\n    if (status == GoogleSignIn::kStatusCodeSuccess) {\n        // Firebase 인증\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase에서 인증 결과를 확인하는 방법은 무엇인가요?", "answer": "프로그램에 정기적으로 실행되는 업데이트 루프가 있는 경우 다음과 같이 Auth::SignInAndRetrieveDataWithCredentialLastResult를 사용해 결과를 확인할 수 있습니다.\n\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        // 인증 성공\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?", "answer": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 사용해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_play-games_hl=ko.txt"}
{"question": "C++에서 Firebase Authentication을 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "C++ 프로젝트에서 Firebase Authentication을 사용하려면 먼저 C++ 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. 또한 C++ 프로젝트에 Firebase C++ SDK를 추가해야 합니다. 초기 설정 작업에 대한 자세한 안내는 C++ 프로젝트에 Firebase 추가를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_start_hl=ko.txt"}
{"question": "사용자가 이메일 주소와 비밀번호로 가입할 때 사용하는 메서드는 무엇인가요?", "answer": "사용자가 이메일 주소와 비밀번호로 가입할 때는 CreateUserWithEmailAndPassword 메서드를 사용합니다. 예시는 다음과 같습니다.\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->CreateUserWithEmailAndPassword(email, password);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_start_hl=ko.txt"}
{"question": "가입 작업의 상태를 확인하는 방법은 무엇인가요?", "answer": "가입 작업의 상태를 확인하려면 CreateUserWithEmailAndPasswordLastResult Future 객체에 콜백을 등록하거나, 주기적인 업데이트 루프에서 상태를 폴링할 수 있습니다. 예시는 다음과 같습니다.\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->CreateUserWithEmailAndPasswordLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        // 가입 성공\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_start_hl=ko.txt"}
{"question": "로그인 상태 변경에 대한 리스너를 설정하는 방법은 무엇인가요?", "answer": "로그인 상태 변경에 대한 리스너를 설정하려면 firebase::auth::AuthStateListener 추상 클래스를 구현하여 리스너를 만들어야 합니다. 예시는 다음과 같습니다.\n```cpp\nclass MyAuthStateListener : public firebase::auth::AuthStateListener {\npublic:\n    void OnAuthStateChanged(firebase::auth::Auth* auth) override {\n        // 로그인 상태 변경 시 처리\n    }\n};\n```", "source": ["https://firebase.google.com/docs/auth/cpp/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_start_hl=ko.txt"}
{"question": "Firebase Authentication에서 다른 ID 공급업체를 추가하는 방법은 무엇인가요?", "answer": "Firebase Authentication에서 다른 ID 공급업체를 추가하는 방법은 각 공급업체에 대한 문서를 참조하면 됩니다. 예를 들어 Google 로그인은 [Google 로그인 문서](https://firebase.google.com/docs/auth/cpp/google-signin?hl=ko)를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/cpp/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_start_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [Firebase C++ SDK 설정 가이드](https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform)를 참조하여 필요한 단계를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_twitter-login_hl=ko.txt"}
{"question": "Twitter 인증을 사용하기 위해 Firebase Console에서 어떤 설정을 해야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Twitter 제공업체를 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 Twitter 인증을 위해 필요한 API 키와 비밀번호는 어디서 가져오나요?", "answer": "Twitter에서 개발자 애플리케이션으로 앱을 등록한 후, 앱의 OAuth API 키와 API 비밀번호를 가져와 제공업체 구성에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_twitter-login_hl=ko.txt"}
{"question": "Firebase 인증을 위해 사용자가 정상적으로 로그인한 후 어떤 과정을 거쳐야 하나요?", "answer": "사용자가 정상적으로 로그인한 후에 OAuth 액세스 토큰과 비밀번호를 Firebase 사용자 인증 정보로 교체하고, 이를 사용해 Firebase에 인증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_twitter-login_hl=ko.txt"}
{"question": "C++에서 Firebase 인증 결과를 확인하는 방법은 무엇인가요?", "answer": "Auth::SignInAndRetrieveDataWithCredentialLastResult를 사용하여 업데이트 시마다 결과를 확인할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n```cpp\nfirebase::Future<firebase::auth::AuthResult> result =\nauth->SignInAndRetrieveDataWithCredentialLastResult();\nif (result.status() == firebase::kFutureStatusComplete) {\n    if (result.error() == firebase::auth::kAuthErrorNone) {\n        auth_result.user.display_name().c_str());\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/cpp/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_twitter-login_hl=ko.txt"}
{"question": "C++ 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "C++ 프로젝트에 Firebase를 추가하려면 [https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform]를 참조하여 설정을 진행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo OAuth 클라이언트를 등록하기 위해 필요한 단계는 무엇인가요?", "answer": "Yahoo OAuth 클라이언트를 등록하려면 Yahoo에 웹 애플리케이션을 등록하는 방법 [https://developer.yahoo.com/oauth2/guide/openid_connect/getting_started.html]에 대한 Yahoo 개발자 문서를 따라야 하며, OpenID Connect API 권한 2개(profile 및 email)를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK로 로그인 과정을 처리하기 위한 첫 번째 단계는 무엇인가요?", "answer": "Firebase SDK로 로그인 과정을 처리하기 위해서는 Yahoo에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 생성해야 합니다. 예시는 다음과 같습니다:\n\n```cpp\nfirebase::auth::FederatedOAuthProviderData provider_data(firebase::auth::YahooAuthProvider::kProviderId);\n```", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 요구하는 OAuth 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 custom_parameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, redirect_uri, response_type, scope, state가 포함됩니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase 인증 서버에서 Yahoo OAuth 액세스 토큰을 어떻게 처리하나요?", "answer": "Firebase 인증 서버에서 Yahoo OAuth 액세스 토큰의 사용자를 인증할 수 없으므로, Firebase 인증은 Yahoo와 같은 제공업체에 대해 동일한 인증 기능을 지원하지 않습니다. 이는 보안 요구사항으로, 한 프로젝트에서 확보한 Yahoo OAuth 액세스 토큰을 사용하여 다른 프로젝트에 로그인할 수 있는 재전송 공격에 노출될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo OAuth를 사용할 때, custom_parameters()와 함께 전달할 수 없는 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 custom_parameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, redirect_uri, response_type, scope, state가 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo API의 비공개 사용자 데이터에 대한 액세스를 요청하려면 어떻게 해야 하나요?", "answer": "애플리케이션에서 Yahoo API의 비공개 사용자 데이터에 대한 액세스가 필요한 경우 Yahoo 개발자 콘솔의 API 권한에서 Yahoo API에 대한 권한을 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo OAuth를 사용하여 여러 제공업체를 동일한 사용자에 연결하는 방법은 무엇인가요?", "answer": "LinkWithProvider를 사용하여 Yahoo 제공업체를 기존 사용자에 연결할 수 있습니다. 예를 들어 여러 제공업체를 동일한 사용자에 연결하여 그 중 하나로 로그인하도록 허용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase 인증 서버에서 Yahoo OAuth 액세스 토큰을 사용하여 사용자를 인증할 수 없는 이유는 무엇인가요?", "answer": "Firebase 인증 서버에서 Yahoo OAuth 액세스 토큰의 사용자를 인증할 수 없으므로 Firebase 인증은 Yahoo와 같은 제공업체에 대해 동일한 인증 기능을 지원하지 못합니다. 이는 중요한 보안 요구사항으로, 한 프로젝트에서 확보한 Yahoo OAuth 액세스 토큰을 사용하여 다른 프로젝트에 로그인할 수 있는 재전송 공격에 노출될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "서드 파티 OAuth 라이브러리와 Firebase 커스텀 인증을 사용하는 이유는 무엇인가요?", "answer": "지원되지 않는 환경에서 이러한 제공업체를 사용해야 하는 경우 서드 파티 OAuth 라이브러리 및 Firebase 커스텀 인증을 사용해야 합니다. 서드 파티 라이브러리는 제공업체 인증에 필요하고 Firebase 커스텀 인증은 제공업체의 사용자 인증 정보를 커스텀 토큰으로 교환할 때 필요합니다.", "source": ["https://firebase.google.com/docs/auth/cpp/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_cpp_yahoo-oauth_hl=ko.txt"}
{"question": "이메일 작업 핸들러 페이지에서 처리해야 하는 쿼리 매개변수는 무엇인가요?", "answer": "| 매개변수 |\n| --- |\n| 모드 | 완료할 사용자 관리 작업입니다. 다음 값 중 하나일 수 있습니다. resetPassword recoverEmail verifyEmail |\n| oobCode | 요청을 식별하고 확인하는 데 사용되는 일회용 코드입니다. |\n| apiKey | Firebase 프로젝트의 API 키로서 편의를 위해 제공됩니다. |\n| continueUrl | URL을 통해 상태를 앱으로 다시 전달할 수 있는 선택적 URL로, 비밀번호 재설정 및 이메일 확인 모드에 사용됩니다. |\n| lang | 선택사항인 BCP47 언어 태그이며 사용자의 언어를 나타냅니다(예: fr). |", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "Firebase에서 이메일 작업 핸들러를 맞춤설정하려면 어떤 SDK를 사용해야 하나요?", "answer": "Firebase JavaScript SDK를 사용하여 요청의 유효성을 확인하고 요청을 완료하는 웹페이지를 만들어 호스팅해야 합니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러 페이지의 URL 예시는 어떻게 되나요?", "answer": "예를 들면 다음과 같습니다.\nhttps://example.com/usermgmt?mode=resetPassword&oobCode=ABC123&apiKey=AIzaSy...&lang=fr", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러에서 사용자가 완료해야 하는 작업은 무엇인가요?", "answer": "다음 사용자 관리 작업에서는 사용자가 이메일 작업 핸들러를 사용하여 작업을 완료해야 합니다.\n\n- 비밀번호 재설정\n- 이메일 주소 변경 취소\n- 이메일 주소 확인", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러의 continueUrl 매개변수는 어떤 용도로 사용되나요?", "answer": "continueUrl은 비밀번호 재설정 및 이메일 확인 모드에 사용되는 선택적 URL로, 사용자가 이메일 작업을 마친 지점에서 계속 진행할 수 있게 됩니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러 페이지에서 사용할 수 있는 모드 매개변수는 무엇이 있나요?", "answer": "이메일 작업 핸들러 페이지에서 사용할 수 있는 모드 매개변수는 다음과 같습니다: resetPassword, recoverEmail, verifyEmail.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러에서 oobCode 매개변수는 어떤 역할을 하나요?", "answer": "oobCode 매개변수는 요청을 식별하고 확인하는 데 사용되는 일회용 코드입니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "continueUrl 매개변수를 사용하여 이메일 작업 핸들러에서 어떤 기능을 구현할 수 있나요?", "answer": "continueUrl 매개변수는 URL을 통해 상태를 앱으로 다시 전달할 수 있는 선택적 URL로, 비밀번호 재설정 및 이메일 확인 모드에 사용됩니다. 이를 통해 사용자가 이메일 작업을 마친 지점에서 계속 진행할 수 있게 됩니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러에서 lang 매개변수는 어떤 용도로 사용되나요?", "answer": "lang 매개변수는 선택사항인 BCP47 언어 태그로, 사용자의 언어를 나타냅니다. 이 값을 사용해 현지화된 이메일 작업 핸들러 페이지를 사용자에게 제공할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "이메일 작업 핸들러에서 Firebase 프로젝트의 API 키(apiKey)는 어떤 용도로 사용되나요?", "answer": "apiKey는 Firebase 프로젝트의 API 키로서 편의를 위해 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/custom-email-handler?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_custom-email-handler_hl=ko.txt"}
{"question": "Firebase 콘솔에서 이메일 템플릿에 커스텀 도메인을 추가하는 방법은 무엇인가요?", "answer": "Firebase 콘솔에서 Authentication 섹션의 템플릿 페이지를 엽니다. 각 이메일 템플릿에 대해 다음을 수행합니다:\n\n1. 수정 아이콘(edit)을 클릭합니다.\n2. 도메인 직접 입력을 클릭합니다.\n3. 사용할 도메인을 입력합니다.\n\n그러면 도메인 소유권을 확인하기 위해 도메인 등록기관에 추가할 DNS 레코드 표가 표시됩니다.", "source": ["https://firebase.google.com/docs/auth/email-custom-domain?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_email-custom-domain_hl=ko.txt"}
{"question": "도메인 확인을 위해 DNS 레코드를 추가하는 절차는 어떻게 되나요?", "answer": "Firebase 콘솔에서 제공된 TXT 및 CNAME DNS 레코드를 추가하거나 업데이트합니다. 작업 절차는 등록기관에 따라 다릅니다. 특정 도메인에 v=spf1... TXT 레코드는 하나만 있을 수 있으며, 여러 이메일 주소를 지정해야 하는 경우 레코드 하나로 결합해야 합니다.", "source": ["https://firebase.google.com/docs/auth/email-custom-domain?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_email-custom-domain_hl=ko.txt"}
{"question": "GoDaddy를 등록기관으로 사용할 때 주의해야 할 점은 무엇인가요?", "answer": "GoDaddy를 등록기관으로 사용한 경우 고객이 보고한 바에 따르면 최상위 도메인만 포함하는 레코드를 추가할 수 없으며 대신 최상위 도메인에 @를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/email-custom-domain?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_email-custom-domain_hl=ko.txt"}
{"question": "도메인 확인이 완료되면 Firebase 콘솔에서 어떤 메시지가 표시되나요?", "answer": "도메인을 확인하는 데 최대 24시간이 걸릴 수 있습니다. 확인이 완료되면 Firebase 콘솔의 템플릿 페이지에 초록색으로 '확인 완료' 메시지가 표시됩니다. 그런 다음 커스텀 도메인 적용 버튼을 클릭하여 변경사항을 적용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/email-custom-domain?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_email-custom-domain_hl=ko.txt"}
{"question": "멀티 테넌트 프로젝트에서 커스텀 도메인을 상속하도록 설정하는 방법은 무엇인가요?", "answer": "Firebase Authentication with Identity Platform으로 업그레이드하고 멀티테넌시를 사용 설정한 경우, 테넌트에서 커스텀 도메인, 이메일 템플릿, 커스텀 SMTP 설정을 상속하도록 허용하려면 테넌트 메타데이터를 업데이트해야 합니다. 이를 위해 다음 명령어를 실행합니다:\n\n```bash\ncurl -X PATCH -d \"{'inheritance':{'emailSendingConfig': true}}\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\"                          \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\"  \\\n-H 'Content-Type:application/json'                            \\\nhttps://identitytoolkit.googleapis.com/v2/projects/PROJECT_ID/tenants/TENANT_ID?updateMask=inheritance.emailSendingConfig\n```", "source": ["https://firebase.google.com/docs/auth/email-custom-domain?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_email-custom-domain_hl=ko.txt"}
{"question": "차단 함수(blocking function)를 사용하여 사용자가 앱에 등록하거나 로그인할 때 어떤 커스텀 코드를 실행할 수 있나요?", "answer": "차단 함수를 사용하면 사용자가 특정 기준을 충족하지 않는 경우 인증하지 못하도록 하거나 클라이언트 앱으로 반환하기 전에 사용자 정보를 업데이트하는 커스텀 코드를 실행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수를 사용하기 위해 Firebase 프로젝트에서 어떤 업그레이드가 필요한가요?", "answer": "차단 함수를 사용하려면 Firebase 프로젝트를 Firebase Authentication with Identity Platform으로 업그레이드해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수가 트리거되는 이벤트에는 어떤 것들이 있나요?", "answer": "차단 함수는 다음과 같은 이벤트에 등록할 수 있습니다: 사용자가 생성되기 전, 사용자가 로그인하기 전, 이메일 전송 전(Node.js만 해당), SMS 메시지 전송 전(Node.js만 해당).", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수의 응답 시간 제한은 어떻게 되나요?", "answer": "차단 함수는 7초 이내에 응답해야 하며, 7초 후에 Firebase Authentication이 오류를 반환하고 클라이언트 작업이 실패합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 반환할 수 있는 HTTP 응답 코드에 대한 주의사항은 무엇인가요?", "answer": "차단 함수는 200 이외의 HTTP 응답 코드를 클라이언트 앱으로 전달하며, 함수가 반환할 수 있는 오류를 클라이언트 코드가 처리하는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수(blocking function)를 배포하기 위해 어떤 명령어를 사용해야 하나요?", "answer": "차단 함수를 배포하기 위해 Firebase CLI를 사용하여 다음 명령어를 실행합니다:\n```\nfirebase deploy --only functions\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 로그인 정보는 어떤 객체를 통해 제공되나요?", "answer": "차단 이벤트는 사용자의 로그인 정보가 포함된 AuthBlockingEvent 객체를 제공합니다. 이 객체를 통해 작업 진행을 허용할지 여부를 결정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 IP 주소는 어떤 속성으로 접근할 수 있나요?", "answer": "차단 함수에서 사용자의 IP 주소는 AuthBlockingEvent 객체의 ipAddress 속성을 통해 접근할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 애플리케이션 언어는 어떻게 설정하나요?", "answer": "차단 함수에서 사용자의 애플리케이션 언어는 AuthBlockingEvent 객체의 locale 속성을 통해 확인할 수 있으며, 클라이언트 SDK를 사용하거나 REST API에서 언어 헤더를 전달하여 언어를 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수가 반환할 수 있는 HTTP 응답 코드에 대한 주의사항은 무엇인가요?", "answer": "차단 함수는 200 이외의 HTTP 응답 코드가 클라이언트 앱으로 전달됩니다. 따라서 함수가 반환할 수 있는 오류를 클라이언트 코드가 처리하는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 로그인 정보는 어떤 객체를 통해 제공되나요?", "answer": "차단 이벤트는 사용자의 로그인 정보가 포함된 AuthBlockingEvent 객체를 제공합니다. 이 객체를 통해 사용자의 로그인 정보를 확인하고, 작업 진행을 허용할지 여부를 결정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 IP 주소는 어떤 속성으로 접근할 수 있나요?", "answer": "차단 함수에서 사용자의 IP 주소는 AuthBlockingEvent 객체의 ipAddress 속성으로 접근할 수 있습니다. 예를 들어, 사용자가 등록하거나 로그인한 기기의 IP 주소는 다음과 같이 확인할 수 있습니다.\n\n```javascript\nconst ipAddress = event.data.ipAddress;\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 애플리케이션 언어는 어떻게 설정하나요?", "answer": "차단 함수에서 사용자의 애플리케이션 언어는 AuthBlockingEvent 객체의 locale 속성을 통해 설정할 수 있습니다. 클라이언트 SDK를 사용하거나 REST API에서 언어 헤더를 전달하여 언어를 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 특정 도메인 내에 있지 않은 사용자가 앱에 등록하는 것을 차단하는 방법은 무엇인가요?", "answer": "특정 도메인 내에 있지 않은 사용자가 앱에 등록하는 것을 차단하려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n  const user = event.data;\n  // 도메인 확인 로직 추가\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 커스텀 오류 메시지를 지정하는 방법은 무엇인가요?", "answer": "차단 함수에서 커스텀 오류 메시지를 지정하려면 HttpsError를 발생시키면서 메시지를 함께 전달하면 됩니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\n```javascript\nthrow new HttpsError('permission-denied', 'Unauthorized request origin!');\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 애플리케이션 언어(locale)는 어떻게 설정하나요?", "answer": "애플리케이션 언어(locale)는 클라이언트 SDK를 사용하거나 REST API에서 언어 헤더를 전달하여 설정할 수 있습니다. 예를 들어, 언어 코드는 'fr' 또는 'sv-SE'와 같이 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 IP 주소(ipAddress)는 어떻게 접근하나요?", "answer": "사용자의 IP 주소(ipAddress)는 이벤트 객체의 속성으로 제공됩니다. 예를 들어, 'event.data.ipAddress'를 통해 접근할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 특정 도메인 내에 있지 않은 사용자가 앱에 등록하는 것을 차단하는 방법은 무엇인가요?", "answer": "특정 도메인 내에 있지 않은 사용자가 앱에 등록하는 것을 차단하려면, 다음과 같은 코드를 사용할 수 있습니다. \n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n  const user = event.data;\n  if (user.email === null || !user.email.includes('@acme.com')) {\n    throw new HttpsError('invalid-argument', 'Unauthorized email');\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 커스텀 오류 메시지를 지정하는 방법은 무엇인가요?", "answer": "커스텀 오류 메시지를 지정하려면 HttpsError를 발생시킬 때 메시지를 추가하면 됩니다. 예를 들어, 다음과 같은 코드를 사용할 수 있습니다. \n```javascript\nthrow new HttpsError('permission-denied', 'Unauthorized request origin!');\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 이벤트의 고유 식별자(eventId)는 어떻게 사용하나요?", "answer": "이벤트의 고유 식별자(eventId)는 이벤트 객체의 속성으로 제공됩니다. 이를 통해 특정 이벤트를 추적하거나 로깅할 수 있습니다. 예를 들어, 'event.eventId'를 통해 접근할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 기본 표시 이름을 설정하는 방법은 무엇인가요?", "answer": "다음 예시에서는 기본 표시 이름을 설정하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nreturn {\n# If no display name is provided, set it to \"Guest\".\ndisplay_name=event.data.display_name if event.data.display_name is not None else \"Guest\"\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "beforeUserCreated와 beforeUserSignedIn 이벤트 핸들러의 실행 순서는 어떻게 되나요?", "answer": "beforeUserCreated와 beforeUserSignedIn 모두에 이벤트 핸들러를 등록하면 beforeUserCreated가 실행된 후 beforeUserSignedIn이 실행됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 세션 클레임(sessionClaims)은 어떻게 처리되나요?", "answer": "sessionClaims의 경우에만 현재 세션의 토큰 클레임에 전파되지만 데이터베이스에 유지되거나 저장되지는 않습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "OAuth 사용자 인증 정보를 차단 함수에서 사용하기 위해 어떤 설정이 필요한가요?", "answer": "차단 함수에서 ID 토큰, 액세스 토큰 또는 갱신 토큰을 사용하려면 먼저 Firebase 콘솔의 차단 함수 페이지에서 체크박스를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 지원되는 OAuth 사용자 인증 정보는 어떤 것들이 있나요?", "answer": "다음 표에서는 각 ID 공급업체에서 지원되는 사용자 인증 정보와 데이터를 보여줍니다.\n\n| ID 공급업체 | ID 토큰 | 액세스 토큰 | 만료 시간 | 토큰 보안 비밀 | 갱신 토큰 | 로그인 클레임 |\n| --- | --- | --- | --- | --- | --- | --- |\n| Google | 예 | 예 | 예 | 아니요 | 예 | 아니요 |\n| Facebook | 아니요 | 예 | 예 | 아니요 | 아니요 | 아니요 |\n| Twitter | 아니요 | 예 | 아니요 | 예 | 아니요 | 아니요 |\n| GitHub | 아니요 | 예 | 아니요 | 아니요 | 아니요 | 아니요 |\n| Microsoft | 예 | 예 | 예 | 아니요 | 예 | 아니요 |\n| LinkedIn | 아니요 | 예 | 예 | 아니요 | 아니요 | 아니요 |\n| Yahoo | 예 | 예 | 예 | 아니요 | 예 | 아니요 |\n| Apple | 예 | 예 | 예 | 아니요 | 예 | 아니요 |\n| SAML | 아니요 | 아니요 | 아니요 | 아니요 | 아니요 | 예 |\n| OIDC | 예 | 예 | 예 | 아니요 | 예 | 예 |", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 sessionClaims를 설정하는 방법은 무엇인가요?", "answer": "차단 함수(blocking function)에서 sessionClaims는 beforeUserCreated 이벤트 핸들러에서 설정할 수 있습니다. 이 경우 beforeUserSignedIn 이벤트 핸들러에서 sessionClaims가 전파되지만 데이터베이스에 저장되지는 않습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 OAuth 사용자 인증 정보를 사용하기 위해 어떤 설정이 필요한가요?", "answer": "차단 함수(blocking function)에서 ID 토큰, 액세스 토큰 또는 갱신 토큰을 사용하려면 먼저 Firebase 콘솔의 차단 함수 페이지에서 체크박스를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Google 계정으로 로그인할 때 전달되는 사용자 인증 정보는 무엇인가요?", "answer": "사용자가 Google 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다: ID 토큰, 액세스 토큰, 갱신 토큰(다음 커스텀 매개변수가 요청된 경우에만 제공됨: access_type=offline, prompt=consent).", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Facebook 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Facebook 계정으로 로그인하면 액세스 토큰이 전달됩니다. 이 액세스 토큰은 다른 액세스 토큰으로 교환할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Microsoft 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Microsoft 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다: ID 토큰, 액세스 토큰, 갱신 토큰(offline_access 범위가 선택된 경우에 제공됨).", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Google 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Google 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰: 다음 커스텀 매개변수가 요청된 경우에만 제공됩니다.\n  - access_type=offline\n  - prompt=consent - 사용자가 이전에 동의하고 새 범위를 요청하지 않은 경우\n\n예를 들면 다음과 같습니다.\n```javascript\nimport { getAuth, signInWithPopup, GoogleAuthProvider } from 'firebase/auth';\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Facebook 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Facebook 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- 액세스 토큰: 다른 액세스 토큰으로 교환할 수 있는 액세스 토큰이 반환됩니다. Facebook에서 지원되는 여러 유형의 액세스 토큰과 장기 토큰으로 교환하는 방법에 대해 자세히 알아보세요.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Microsoft 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Microsoft 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰: offline_access 범위가 선택된 경우 차단 함수에 전달됩니다.\n\n예를 들면 다음과 같습니다.\n```javascript\nimport { getAuth, signInWithPopup, OAuthProvider } from 'firebase/auth';\nsignInWithPopup(auth, provider);\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Yahoo 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Yahoo 계정으로 로그인하면 커스텀 매개변수 또는 범위 없이 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 LinkedIn 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 LinkedIn 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- 액세스 토큰", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 세션 클레임(sessionClaims)을 설정하는 방법은 무엇인가요?", "answer": "차단 함수에서 사용자의 세션 클레임(sessionClaims)을 설정하려면, 사용자가 로그인할 때 IP 주소를 추적하고 이를 세션 클레임으로 설정할 수 있습니다. 예를 들어, 다음과 같이 구현할 수 있습니다.\n```javascript\nexport const beforesignedin = beforeUserSignedIn((event) => {\n    return {\n        sessionClaims: {\n            signInIpAddress: event.ipAddress,\n        }\n    };\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하는 방법은 무엇인가요?", "answer": "특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하려면, 다음과 같이 차단 함수를 구현할 수 있습니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    if (event.credential &&\n        event.credential.claims &&\n        event.credential.providerId === \"saml.my-provider-id\") {\n        return identity_fn.BeforeCreateResponse(\n            custom_claims={\"eid\": event.credential.claims[\"employeeid\"]}\n        );\n    }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 이메일이 확인되지 않은 사용자의 등록을 차단하는 방법은 무엇인가요?", "answer": "이메일이 확인되지 않은 사용자의 등록을 차단하려면, 다음과 같이 차단 함수를 구현할 수 있습니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    if (event.data.email is not None and not event.data.email_verified) {\n        raise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n            message=\"You must register using a trusted provider.\");\n    }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 로그인 IP 주소를 추적하는 방법은 무엇인가요?", "answer": "사용자의 로그인 IP 주소를 추적하려면, 세션 클레임(sessionClaims)을 사용하여 IP 주소를 저장할 수 있습니다. 다음은 그 예시입니다.\n```javascript\nexport const beforesignedin = beforeUserSignedIn((event) => {\n    return {\n        sessionClaims: {\n            signInIpAddress: event.ipAddress,\n        }\n    };\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 특정 도메인에 속하지 않는 사용자의 등록을 차단하는 방법은 무엇인가요?", "answer": "특정 도메인에 속하지 않는 사용자의 등록을 차단하려면, 다음과 같이 차단 함수를 구현할 수 있습니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    user = event.data;\n    if (user.email is None or \"@example.com\" not in user.email) {\n        raise https_fn.HttpsError(\n            code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n            message=\"Unauthorized email\",\n        );\n    }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하는 방법은 무엇인가요?", "answer": "다음 예시에서는 특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.data.email is not None and not event.data.email_verified) {\nraise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\nmessage=\"You must register using a trusted provider.\")\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 커스텀 및 세션 클레임을 설정하는 방법은 무엇인가요?", "answer": "다음 예시에서는 커스텀 및 세션 클레임을 설정하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential &&\nevent.credential.claims &&\nevent.credential.providerId === \"saml.my-provider-id\") {\nreturn identity_fn.BeforeCreateResponse(\ncustom_claims={\"eid\": event.credential.claims[\"employeeid\"]})\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "사용자가 로그인한 IP 주소를 추적하는 방법은 무엇인가요?", "answer": "세션 클레임을 사용하여 사용자가 로그인하는 IP 주소를 추적합니다. 다음은 그 예시입니다.\n```javascript\nexport const beforesignedin = beforeUserSignedIn((event) => {\nreturn {\nsessionClaims: {\nsignInIpAddress: event.ipAddress,\n}\n};\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 프로필 사진을 정리하는 방법은 무엇인가요?", "answer": "다음 예시는 사용자의 프로필 사진을 정리하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.data.photo_url is not None) {\nscore = analyze_photo_with_ml(event.data.photo_url)\nif score > THRESHOLD:\nreturn identity_fn.BeforeCreateResponse(photo_url=PLACEHOLDER_URL)\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "Google 계정으로 로그인한 사용자의 갱신 토큰을 가져오는 방법은 무엇인가요?", "answer": "다음 예시에서는 Google 계정으로 로그인한 사용자의 갱신 토큰을 가져오는 방법을 보여줍니다.\n```javascript\nconst {OAuth2Client} = require('google-auth-library');\nconst {google} = require('googleapis');\n\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential is not None and event.credential.provider_id == \"google.com\") {\n// Save the Google OAuth2 access token\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 프로필 사진을 정리하는 방법은 무엇인가요?", "answer": "다음 예시는 사용자의 프로필 사진을 정리하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n.then((status) => {\nif (!status) {\n    event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeCreateResponse | None:\n    if event.data.photo_url is not None:\n        score = analyze_photo_with_ml(event.data.photo_url)\n        if score > THRESHOLD:\n            return identity_fn.BeforeCreateResponse(photo_url=PLACEHOLDER_URL)\n```\n이미지 감지 및 정리 방법에 대한 자세한 내용은 Cloud Vision 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 Google 계정으로 로그인한 사용자의 갱신 토큰을 가져오는 방법은 무엇인가요?", "answer": "다음 예시에서는 Google 계정으로 로그인한 사용자의 갱신 토큰을 가져와서 Google Calendar API를 호출하는 방법을 보여줍니다.\n```javascript\nconst {OAuth2Client} = require('google-auth-library');\nconst {google} = require('googleapis');\nkeys.web.client_secret\n\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential.providerId === 'google.com') {\n    user.uid,\n    event.credential.refreshToken,\n    'google.com'\n    .then(() => {\n        event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeCreateResponse | None:\n        \"\"\"During sign-up, save the Google OAuth2 access token and queue up a task\n        to schedule an onboarding session on the user's Google Calendar.\n\n        You will only get an access token if you enabled it in your project's blocking\n        functions settings in the Firebase console:\n        https://console.firebase.google.com/project/_/authentication/settings\n        \"\"\"\n        if event.credential is not None and event.credential.provider_id == \"google.com\":\n            print(f\"Signed in with {event.credential.provider_id}. Saving access token.\")\n\n            firestore_client: google.cloud.firestore.Client = firestore.client()\n            doc_ref = firestore_client.collection(\"user_info\").document(event.data.uid)\n            doc_ref.set({\"calendar_access_token\": event.credential.access_token}, merge=True)\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 reCAPTCHA Enterprise 결과를 재정의하는 방법은 무엇인가요?", "answer": "다음 예에서는 지원되는 사용자 흐름에 대해 reCAPTCHA Enterprise 결과를 재정의하는 방법을 보여줍니다.\n```javascript\nconst { beforeSmsSent } = require(\"firebase-functions/v2/identity\");\nexports.beforesmssentv2 = beforeSmsSent((event) => {\nif (\n    event.smsType === \"SIGN_IN_OR_SIGN_UP\" &&\n    event.additionalUserInfo.phoneNumber.includes('+91')\n) {\n    return {\n        recaptchaActionOverride: \"ALLOW\",\n    };\n}\n});\n```\nreCAPTCHA Enterprise를 Firebase 인증과 통합하는 방법에 대한 자세한 내용은 reCAPTCHA Enterprise 사용 설정 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 요청 IP 주소를 확인하는 방법은 무엇인가요?", "answer": "차단 함수에서 사용자의 요청 IP 주소를 확인하는 방법은 다음과 같습니다. 요청의 IP 주소는 `req.remote_addr`를 통해 접근할 수 있습니다. 예시는 다음과 같습니다.\n```python\nrequest_ip = req.remote_addr\n```\n이렇게 하면 현재 요청의 IP 주소를 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수에서 사용자의 세션 IP 주소를 확인하는 방법은 무엇인가요?", "answer": "차단 함수에서 사용자의 세션 IP 주소는 ID 토큰의 클레임에서 확인할 수 있습니다. 예시는 다음과 같습니다.\n```python\nsignin_ip = claims[\"signInIpAddress\"]\n```\n이렇게 하면 사용자의 세션 IP 주소를 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko.txt"}
{"question": "차단 함수를 사용하기 위해 Firebase 프로젝트를 어떻게 업그레이드하나요?", "answer": "차단 함수를 사용하려면 Firebase 프로젝트를 Firebase Authentication with Identity Platform으로 업그레이드해야 합니다. 아직 업그레이드하지 않았다면 먼저 업그레이드하세요.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수가 트리거되는 이벤트는 어떤 것들이 있나요?", "answer": "차단 함수는 다음과 같은 이벤트에 등록할 수 있습니다:\n\n1. 사용자가 생성되기 전: 신규 사용자가 Firebase Authentication 데이터베이스에 저장되기 전 그리고 클라이언트 앱에 토큰이 반환되기 전에 트리거됩니다.\n2. 사용자가 로그인하기 전: 사용자 인증 정보 확인 후 Firebase Authentication에서 클라이언트 앱에 ID 토큰을 반환하기 전에 트리거됩니다. 앱에서 다중 인증(MFA)을 사용하는 경우 사용자가 2단계 인증을 완료하면 함수가 트리거됩니다. 신규 사용자를 만들면 이 두 이벤트가 모두 트리거됩니다.\n3. 이메일 전송 전(Node.js만 해당): 사용자에게 이메일(예: 로그인 또는 비밀번호 재설정 이메일)이 전송되기 전에 트리거됩니다.\n4. SMS 메시지 전송 전(Node.js만 해당): 다중 인증(MFA)과 같은 경우에 SMS 메시지가 사용자에게 전송되기 전에 트리거됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수의 응답 시간 제한은 어떻게 되나요?", "answer": "차단 함수를 사용할 때는 함수가 7초 이내에 응답해야 합니다. 7초 후에 Firebase Authentication이 오류를 반환하고 클라이언트 작업이 실패합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 반환할 수 있는 HTTP 응답 코드에 대한 주의사항은 무엇인가요?", "answer": "차단 함수는 200 이외의 HTTP 응답 코드를 클라이언트 앱으로 전달합니다. 함수가 반환할 수 있는 오류를 클라이언트 코드가 처리하는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수는 어떤 사용자에게 적용되나요?", "answer": "차단 함수는 테넌트에 포함된 사용자를 포함하여 프로젝트의 모든 사용자에게 적용됩니다. Firebase Authentication은 사용자가 속한 테넌트를 비롯하여 사용자에 대한 정보를 함수에 제공하므로 그에 따라 처리해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 로그인 정보는 어떻게 가져오나요?", "answer": "차단 이벤트는 사용자의 로그인 정보가 포함된 AuthBlockingEvent 객체를 제공합니다. 이 객체를 사용하여 작업 진행을 허용할지 여부를 결정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수를 배포하는 방법은 무엇인가요?", "answer": "차단 함수를 배포하려면 Firebase CLI를 사용하여 다음 명령어를 실행합니다: \n```\nfirebase deploy --only functions\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수의 응답 시간 제한은 어떻게 되나요?", "answer": "차단 함수는 7초 이내에 응답해야 합니다. 7초 후에 Firebase Authentication이 오류를 반환하고 클라이언트 작업이 실패합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수가 트리거되는 이벤트는 어떤 것들이 있나요?", "answer": "차단 함수는 다음과 같은 이벤트에 등록할 수 있습니다: \n- 사용자가 생성되기 전 \n- 사용자가 로그인하기 전 \n- 이메일 전송 전 (Node.js만 해당) \n- SMS 메시지 전송 전 (Node.js만 해당)", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수가 삭제되면 어떤 문제가 발생할 수 있나요?", "answer": "함수를 삭제하는 경우 Firebase Authentication에서 트리거를 등록 취소해야 합니다. 그렇지 않으면 모든 사용자가 앱에서 인증할 수 없게 됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 로그인 정보는 어떤 객체를 통해 제공되나요?", "answer": "차단 이벤트는 사용자의 로그인 정보가 포함된 AuthBlockingEvent 객체를 제공합니다. 이 객체를 통해 사용자의 로그인 정보와 관련된 다양한 속성에 접근할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 HttpsError를 발생시키는 방법은 무엇인가요?", "answer": "등록 또는 로그인 시도를 차단하려면 함수에 HttpsError를 발생시킵니다. 예를 들면 다음과 같습니다.\n```javascript\nimport { HttpsError } from \"firebase-functions/v2/identity\";\n\nthrow new HttpsError('invalid-argument');\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 커스텀 오류 메시지를 지정하는 방법은 무엇인가요?", "answer": "커스텀 오류 메시지를 지정할 수도 있습니다. 예를 들면 다음과 같습니다.\n```javascript\nthrow new HttpsError('permission-denied', 'Unauthorized request origin!');\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 특정 도메인 내에 있지 않은 사용자를 차단하는 방법은 무엇인가요?", "answer": "다음 예시에서는 특정 도메인 내에 있지 않은 사용자가 앱에 등록하는 것을 차단하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n  event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeCreateResponse | None:\n  # User data passed in from the CloudEvent.\n  user = event.data\n\n  # Only users of\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수 배포 시 어떤 명령어를 사용하나요?", "answer": "차단 함수를 배포할 때는 Firebase CLI를 사용하여 다음 명령어를 입력합니다.\n```bash\nfirebase deploy --only functions\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 IP 주소는 어떤 속성으로 제공되나요?", "answer": "사용자의 IP 주소는 객체의 ipAddress 속성으로 제공됩니다. 예를 들어, ipAddress는 최종 사용자가 등록하거나 로그인한 기기의 IP 주소입니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 이벤트의 고유 식별자는 어떤 속성으로 확인할 수 있나요?", "answer": "이벤트의 고유 식별자는 객체의 eventId 속성으로 확인할 수 있습니다. eventId는 이벤트의 고유 식별자를 나타냅니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 사용자 인증 정보는 어떤 속성으로 제공되나요?", "answer": "사용자의 사용자 인증 정보는 객체의 credential 속성으로 제공됩니다. credential은 사용자의 사용자 인증 정보에 대한 정보를 포함하는 객체입니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 특정 도메인 내에 있지 않은 사용자를 차단하는 방법은 무엇인가요?", "answer": "특정 도메인 내에 있지 않은 사용자를 차단하려면 다음과 같은 코드를 사용할 수 있습니다. \n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n  user = event.data;\n  if (user.email === null || !user.email.includes('@acme.com')) {\n    throw new HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n    message='Unauthorized email');\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 커스텀 오류 메시지를 지정하는 방법은 무엇인가요?", "answer": "커스텀 오류 메시지를 지정하려면 HttpsError를 발생시킬 때 메시지를 추가하면 됩니다. 예를 들어, 다음과 같은 코드를 사용할 수 있습니다. \n```javascript\nthrow new HttpsError('permission-denied', 'Unauthorized request origin!');\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 이메일 주소를 검증하는 방법은 무엇인가요?", "answer": "차단 함수에서 사용자의 이메일 주소를 검증하려면, 사용자의 이메일이 특정 도메인에 포함되어 있는지 확인해야 합니다. 예를 들어, '@acme.com' 도메인에 포함되지 않은 경우, 다음과 같이 HttpsError를 발생시켜 계정 생성을 거부할 수 있습니다.\n\n```python\n# Only users of a specific domain can sign up.\nif user.email is None or \"@acme.com\" not in user.email:\n    # Return None so that Firebase Auth rejects the account creation.\n    raise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n                               message=\"Unauthorized email\")\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 오류를 발생시키는 방법은 무엇인가요?", "answer": "차단 함수에서 오류를 발생시키려면 HttpsError를 사용하여 오류 코드를 지정하고 메시지를 포함해야 합니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\n```javascript\nthrow new HttpsError('invalid-argument', \"Unauthorized email\");\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 표시 이름을 설정하는 방법은 무엇인가요?", "answer": "차단 함수에서 사용자의 표시 이름을 설정하려면, 이벤트 데이터에서 표시 이름을 가져오고, 제공되지 않은 경우 기본값으로 'Guest'를 설정할 수 있습니다. 다음은 그 예시입니다.\n\n```python\nreturn {\n    # If no display name is provided, set it to \"Guest\".\n    display_name=event.data.display_name if event.data.display_name is not None else \"Guest\"\n}\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "beforeUserCreated와 beforeUserSignedIn 이벤트 핸들러의 실행 순서는 어떻게 되나요?", "answer": "beforeUserCreated와 beforeUserSignedIn 모두에 이벤트 핸들러를 등록하면, beforeUserCreated가 실행된 후에 beforeUserSignedIn이 실행됩니다. 이때 beforeUserCreated에서 업데이트된 사용자 필드는 beforeUserSignedIn에 표시됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "OAuth 사용자 인증 정보를 차단 함수에서 사용하려면 어떻게 해야 하나요?", "answer": "차단 함수에서 OAuth 사용자 인증 정보를 사용하려면, 먼저 Firebase 콘솔의 차단 함수 페이지에서 해당 체크박스를 선택해야 합니다. 이를 통해 ID 토큰, 액세스 토큰 또는 갱신 토큰을 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "beforeUserCreated와 beforeUserSignedIn 이벤트 핸들러의 실행 순서는 어떻게 되나요?", "answer": "beforeUserCreated와 beforeUserSignedIn 모두에 이벤트 핸들러를 등록하면 beforeUserCreated가 실행된 후 beforeUserSignedIn이 실행됩니다. beforeUserCreated에서 업데이트된 사용자 필드는 beforeUserSignedIn에 표시됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "sessionClaims의 경우 beforeUserSignedIn에서 어떻게 처리되나요?", "answer": "sessionClaims의 경우에만 현재 세션의 토큰 클레임에 전파되지만 데이터베이스에 유지되거나 저장되지는 않습니다. 예를 들어 sessionClaims가 설정된 경우 beforeUserSignedIn은 beforeUserCreated 클레임과 함께 이를 반환하고 병합합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "OAuth 사용자 인증 정보를 차단 함수에서 사용하려면 어떤 설정이 필요한가요?", "answer": "차단 함수에서 ID 토큰, 액세스 토큰 또는 갱신 토큰을 사용하려면 먼저 Firebase 콘솔의 차단 함수 페이지에서 체크박스를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "일반 OIDC 제공업체로 로그인할 때 전달되는 사용자 인증 정보는 무엇인가요?", "answer": "사용자가 일반 OIDC 제공업체로 로그인하면 다음 사용자 인증 정보가 전달됩니다: ID 토큰은 id_token 흐름이 선택된 경우 제공되며, 액세스 토큰은 코드 흐름이 선택된 경우 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Google 계정으로 로그인할 때 전달되는 사용자 인증 정보는 무엇인가요?", "answer": "사용자가 Google 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다: ID 토큰, 액세스 토큰, 갱신 토큰은 access_type=offline 및 prompt=consent 커스텀 매개변수가 요청된 경우에만 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 OAuth 토큰을 사용하려면 어떤 설정이 필요한가요?", "answer": "차단 함수에서 ID 토큰, 액세스 토큰 또는 갱신 토큰을 사용하려면 먼저 Firebase 콘솔의 차단 함수 페이지에서 체크박스를 선택해야 합니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "일반 OIDC 제공업체로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 일반 OIDC 제공업체로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰: id_token 흐름이 선택된 경우 제공됩니다.\n- 액세스 토큰: 코드 흐름이 선택된 경우 제공됩니다. 코드 흐름은 현재 REST API를 통해서만 지원됩니다.\n- 갱신 토큰: offline_access 범위가 선택된 경우에 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Google 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Google 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰: 다음 커스텀 매개변수가 요청된 경우에만 제공됩니다.\n  - access_type=offline\n  - prompt=consent - 사용자가 이전에 동의하고 새 범위를 요청하지 않은 경우", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Facebook 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Facebook 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- 액세스 토큰: 다른 액세스 토큰으로 교환할 수 있는 액세스 토큰이 반환됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Microsoft 계정으로 로그인할 때 어떤 사용자 인증 정보가 전달되나요?", "answer": "사용자가 Microsoft 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰: offline_access 범위가 선택된 경우 차단 함수에 전달됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "사용자가 Microsoft 계정으로 로그인할 때 전달되는 사용자 인증 정보는 무엇인가요?", "answer": "사용자가 Microsoft 계정으로 로그인하면 다음 사용자 인증 정보가 전달됩니다.\n\n- ID 토큰\n- 액세스 토큰\n- 갱신 토큰: offline_access 범위가 선택된 경우 차단 함수에 전달됩니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 특정 도메인에 속하지 않는 사용자를 차단하는 방법은 무엇인가요?", "answer": "다음 예시는 특정 도메인의 등록만 허용하는 방법을 보여줍니다.\n\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    raise https_fn.HttpsError(\n        code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n        message=\"Unauthorized email\",\n    )\n    user = event.data\n\n    if user.email is None or \"@example.com\" not in user.email:\n        raise https_fn.HttpsError(\n            code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n            message=\"Unauthorized email\",\n        )\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 이메일이 확인되지 않은 사용자를 차단하는 방법은 무엇인가요?", "answer": "다음 예시는 이메일이 확인되지 않은 사용자가 앱에 등록하는 것을 방지하는 방법을 보여줍니다.\n\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    if event.data.email is not None and not event.data.email_verified:\n        raise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\n        message=\"You must register using a trusted provider.\")\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 커스텀 및 세션 클레임을 설정하는 방법은 무엇인가요?", "answer": "다음 예시에서는 커스텀 및 세션 클레임을 설정하는 방법을 보여줍니다.\n\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n    if (event.credential &&\n        event.credential.claims &&\n        event.credential.providerId === \"saml.my-provider-id\") {\n        return identity_fn.BeforeCreateResponse(\n            custom_claims={\"eid\": event.credential.claims[\"employeeid\"]}\n        )\n    }\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자가 로그인한 IP 주소를 추적하는 방법은 무엇인가요?", "answer": "다음 예시에서는 사용자가 로그인한 IP 주소를 추적하는 방법을 보여줍니다.\n\n```javascript\nexport const beforesignedin = beforeUserSignedIn((event) => {\n    return {\n        sessionClaims: {\n            signInIpAddress: event.ipAddress,\n        }\n    };\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하는 방법은 무엇인가요?", "answer": "다음 예시에서는 특정 ID 공급업체의 사용자 이메일을 확인된 것으로 처리하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.data.email is not None and not event.data.email_verified):\nraise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.INVALID_ARGUMENT,\nmessage=\"You must register using a trusted provider.\")\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 커스텀 및 세션 클레임을 설정하는 방법은 무엇인가요?", "answer": "다음 예시에서는 커스텀 및 세션 클레임을 설정하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential &&\nevent.credential.claims &&\nevent.credential.providerId === \"saml.my-provider-id\") {\nreturn {\nevent.credential.claims &&\nevent.credential.providerId === \"saml.my-provider-id\") {\nreturn {\nevent.credential.provider_id == \"saml.my-provider-id\"):\nreturn identity_fn.BeforeCreateResponse(\ncustom_claims={\"eid\": event.credential.claims[\"employeeid\"]})\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "사용자가 로그인한 IP 주소를 추적하는 방법은 무엇인가요?", "answer": "세션 클레임을 사용하여 사용자가 로그인하는 IP 주소를 추적합니다. 다음 예시를 참고하세요.\n```javascript\nexport const beforesignedin = beforeUserSignedIn((event) => {\nreturn {\nsessionClaims: {\nsignInIpAddress: event.ipAddress,\n}\n};\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 요청의 IP 주소와 로그인한 IP 주소를 비교하여 토큰 도난을 방지하는 방법은 무엇인가요?", "answer": "다음 예시에서는 요청의 IP 주소와 로그인한 IP 주소를 비교하여 토큰 도난을 방지하는 방법을 보여줍니다.\n```python\nimport flask\n\n@flask_app.post()\ndef get_restricted_data(req: flask.Request):\n# Get the ID token passed.\nid_token = req.json().get(\"idToken\")\n\n# Verify the ID token, check if revoked, and decode its payload.\ntry:\nclaims = auth.verify_id_token(id_token, check_revoked=True)\nexcept:\nreturn flask.Response(status=500)\n\n# Get request IP address.\nrequest_ip = req.remote_addr\n\n# Get sign-in IP address.\nsignin_ip = claims[\"signInIpAddress\"]\n\n# Check if the request IP address origin is suspicious relative to\n# the session IP addresses.\nif is_suspicious_change(signin_ip, request_ip):\n# Suspicious IP address change. Require re-authentication.\nreturn flask.Response(status=401,\nresponse=\"Unauthorized access. Sign in again!\")\nelse:\n# Access is valid. Try to return data.\nreturn data_from_claims(claims)\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "사용자의 프로필 사진을 정리하는 방법은 무엇인가요?", "answer": "다음 예시에서는 사용자의 프로필 사진을 정리하는 방법을 보여줍니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.data.photo_url is not None):\nscore = analyze_photo_with_ml(event.data.photo_url)\nif score > THRESHOLD:\nreturn identity_fn.BeforeCreateResponse(photo_url=PLACEHOLDER_URL)\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "차단 함수에서 사용자의 프로필 사진을 정리하는 방법은 무엇인가요?", "answer": "사용자의 프로필 사진을 정리하는 방법은 다음과 같습니다. `beforeUserCreated` 이벤트 핸들러를 사용하여 사용자의 사진 URL을 분석하고, 특정 기준을 초과하는 경우 대체 URL로 변경할 수 있습니다. 예시는 다음과 같습니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\n.then((status) => {\nif (!status) {\n    event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeCreateResponse | None:\n    if event.data.photo_url is not None:\n        score = analyze_photo_with_ml(event.data.photo_url)\n        if score > THRESHOLD:\n            return identity_fn.BeforeCreateResponse(photo_url=PLACEHOLDER_URL)\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Google 계정으로 로그인한 사용자의 갱신 토큰을 가져오는 방법은 무엇인가요?", "answer": "Google 계정으로 로그인한 사용자의 갱신 토큰을 가져오는 방법은 다음과 같습니다. `beforeUserCreated` 이벤트 핸들러 내에서 사용자의 인증 정보를 확인하고, 갱신 토큰을 Firestore에 저장하는 예시는 다음과 같습니다.\n```javascript\nconst {OAuth2Client} = require('google-auth-library');\nconst {google} = require('googleapis');\n\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential.providerId === 'google.com') {\n    firestore_client: google.cloud.firestore.Client = firestore.client();\n    doc_ref = firestore_client.collection(\"user_info\").document(event.data.uid);\n    doc_ref.set({\"calendar_access_token\": event.credential.access_token}, merge=True);\n}\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "reCAPTCHA Enterprise 결과를 재정의하는 방법은 무엇인가요?", "answer": "reCAPTCHA Enterprise 결과를 재정의하는 방법은 `beforeSmsSent` 이벤트 핸들러를 사용하여 특정 조건에 따라 흐름을 허용하거나 차단하는 것입니다. 예시는 다음과 같습니다.\n```javascript\nconst { beforeSmsSent } = require(\"firebase-functions/v2/identity\");\nexports.beforesmssentv2 = beforeSmsSent((event) => {\nif (\n    event.smsType === \"SIGN_IN_OR_SIGN_UP\" &&\n    event.additionalUserInfo.phoneNumber.includes('+91')\n) {\n    return {\n        recaptchaActionOverride: \"ALLOW\",\n    };\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "사용자의 ID 공급업체 OAuth 사용자 인증 정보에 액세스하는 방법은 무엇인가요?", "answer": "사용자의 ID 공급업체 OAuth 사용자 인증 정보에 액세스하는 방법은 `beforeUserCreated` 이벤트 핸들러를 사용하여 사용자의 인증 정보를 확인하고, 필요한 경우 해당 정보를 저장하는 것입니다. 예시는 다음과 같습니다.\n```javascript\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential is not None and event.credential.provider_id == \"google.com\") {\n    print(f\"Signed in with {event.credential.provider_id}. Saving access token.\");\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "사용자의 요청 IP 주소를 확인하는 방법은 무엇인가요?", "answer": "사용자의 요청 IP 주소를 확인하는 방법은 Flask 애플리케이션에서 `req.remote_addr`를 사용하여 요청의 IP 주소를 가져오는 것입니다. 예시는 다음과 같습니다.\n```python\nrequest_ip = req.remote_addr\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko&gen=2nd"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-blocking-functions_hl=ko_gen=2nd.txt"}
{"question": "Firebase 사용자가 생성될 때 어떤 이벤트 핸들러를 사용해야 하나요?", "answer": "Firebase 사용자가 생성될 때는 functions.auth.user().onCreate() 이벤트 핸들러를 사용하여 트리거되는 함수를 만들 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-functions_hl=ko.txt"}
{"question": "사용자가 Firebase 계정을 생성할 때 어떤 경우에 Cloud Functions의 사용자 생성 이벤트가 트리거되나요?", "answer": "Firebase 계정은 다음과 같은 경우에 Cloud Functions의 사용자 생성 이벤트를 트리거합니다:\n\n- 사용자가 이메일 계정과 비밀번호를 만들 때\n- 사용자가 제휴 ID 공급업체를 통해 처음으로 로그인할 때\n- 개발자가 Firebase Admin SDK를 사용하여 계정을 생성할 때\n- 사용자가 새 익명 인증 세션에 처음으로 로그인할 때", "source": ["https://firebase.google.com/docs/auth/extend-with-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-functions_hl=ko.txt"}
{"question": "사용자 속성에 액세스하기 위해 어떤 객체를 사용하나요?", "answer": "사용자 속성에 액세스하기 위해 새로 생성된 사용자의 UserRecord 객체를 사용합니다. 이 객체에서 제공되는 사용자 속성 목록에 액세스할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-functions_hl=ko.txt"}
{"question": "사용자의 이메일 및 표시 이름을 가져오는 방법은 무엇인가요?", "answer": "사용자의 이메일 및 표시 이름을 가져오려면 UserRecord 객체에서 해당 속성에 접근하면 됩니다. 예를 들어 다음과 같이 사용할 수 있습니다:\n\n```javascript\nexports.sendWelcomeEmail = functions.auth.user().onCreate((user) => {\n  const email = user.email;\n  const displayName = user.displayName;\n});\n```", "source": ["https://firebase.google.com/docs/auth/extend-with-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-functions_hl=ko.txt"}
{"question": "사용자가 커스텀 토큰을 사용하여 로그인할 때 Cloud Functions 이벤트는 어떻게 되나요?", "answer": "사용자가 커스텀 토큰을 사용하여 처음으로 로그인하는 경우에는 Cloud Functions 이벤트가 트리거되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/extend-with-functions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_extend-with-functions_hl=ko.txt"}
{"question": "Firebase에서 사용자가 여러 인증 제공업체를 통해 로그인할 수 있도록 하려면 어떻게 해야 하나요?", "answer": "앱에 2개 이상의 인증 제공업체(익명 인증 포함)에 대한 지원을 추가해야 합니다. 사용자가 로그인할 때 어떤 인증 제공업체를 사용하든 동일한 Firebase 사용자 ID로 본인 확인이 가능합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_account-linking_hl=ko.txt"}
{"question": "기존 사용자 계정에 인증 제공업체의 사용자 인증 정보를 연결하는 방법은 무엇인가요?", "answer": "기존 사용자 계정에 인증 제공업체의 사용자 인증 정보를 연결하려면 다음 단계를 따릅니다:\n1. 인증 제공업체 또는 인증 방법을 사용해 사용자를 로그인 처리합니다.\n2. 새로운 인증 제공업체의 로그인 과정을 진행하되 signInWith 메서드 호출 전까지만 진행합니다. 예를 들어 사용자의 Google ID 토큰, Facebook 액세스 토큰, 또는 이메일 주소와 비밀번호를 가져옵니다.\n3. 다음과 같이 새로운 인증 제공업체의 Credential 객체를 가져옵니다:\n```dart\nEmailAuthProvider.credential(email: emailAddress, password: password);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_account-linking_hl=ko.txt"}
{"question": "Firebase에서 특정 인증 제공업체와 사용자 계정의 연결을 해제하는 방법은 무엇인가요?", "answer": "특정 인증 제공업체와 계정의 연결을 해제하려면 제공업체 ID를 unlink() 메서드에 전달해야 합니다. 사용자 계정에 연결된 인증 제공업체의 제공업체 ID는 User 객체의 providerData 속성에서 가져올 수 있습니다. 예를 들어:\n```dart\ntry {\n  await FirebaseAuth.instance.currentUser?.unlink(providerId);\n} catch (e) {\n  print(\"doesn't exist.\");\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_account-linking_hl=ko.txt"}
{"question": "사용자가 인증 제공업체의 자격 증명을 사용할 수 없는 경우 어떤 오류 메시지가 발생하나요?", "answer": "사용자가 인증 제공업체의 자격 증명을 사용할 수 없는 경우 'invalid-credential' 오류가 발생하며, 이 경우 다음과 같은 메시지를 출력할 수 있습니다:\n```dart\ncase \"invalid-credential\":\n  print(\"The provider's credential is not valid.\");\n  break;\n```", "source": ["https://firebase.google.com/docs/auth/flutter/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_account-linking_hl=ko.txt"}
{"question": "Firebase에서 이미 사용 중인 자격 증명으로 연결된 계정이 있을 때 어떤 오류가 발생하나요?", "answer": "이미 사용 중인 자격 증명으로 연결된 계정이 있을 경우 'credential-already-in-use' 오류가 발생하며, 이 경우 다음과 같은 메시지를 출력할 수 있습니다:\n```dart\ncase \"credential-already-in-use\":\n  print(\"The account corresponding to the credential already exists, \"\n  \"or is already linked to a Firebase User.\");\n  break;\n```", "source": ["https://firebase.google.com/docs/auth/flutter/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_account-linking_hl=ko.txt"}
{"question": "Firebase에서 익명 로그인을 사용하기 위해 어떤 단계를 따라야 하나요?", "answer": "Firebase Console의 인증 섹션에서 로그인 방법 페이지를 열고, 익명 로그인 방법을 사용 설정한 후 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자가 Firebase 인증이 필요한 기능을 사용할 때 어떤 메서드를 호출하나요?", "answer": "로그아웃 상태의 사용자가 Firebase 인증이 필요한 앱 기능을 사용할 때 `signInAnonymously()`를 호출하여 사용자를 익명으로 로그인 처리합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_anonymous-auth_hl=ko.txt"}
{"question": "익명 계정으로 로그인한 후 사용자의 기본 프로필 정보를 어떻게 가져올 수 있나요?", "answer": "앱의 User 객체에서 사용자의 기본 프로필 정보를 가져올 수 있으며, 사용자 관리 문서를 참조하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_anonymous-auth_hl=ko.txt"}
{"question": "사용자를 로그아웃시키려면 어떤 메서드를 사용하나요?", "answer": "사용자를 로그아웃시키려면 `signOut()` 메서드를 호출해야 하며, 아래와 같이 사용할 수 있습니다:\n```dart\nawait FirebaseAuth.instance.signOut();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자가 앱에 가입하기로 결정했을 때 어떤 과정을 거치나요?", "answer": "익명 사용자가 앱에 가입하기로 결정하면, 사용자의 로그인 인증 정보를 해당 익명 계정에 연결하여 사용자가 추후 세션에서도 보호받는 데이터를 계속 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 커스텀 인증 시스템을 사용하여 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 앱에 로그인하면 사용자의 로그인 인증 정보(예: 사용자 이름과 비밀번호)를 인증 서버로 전송합니다. 서버가 사용자 인증 정보를 확인하여 정보가 유효하면 커스텀 Firebase 토큰을 생성하고 이 토큰을 앱으로 다시 보냅니다. 인증 서버에서 커스텀 토큰을 받은 후 다음과 같이 이 토큰을 signInWithCustomToken()에 전달하여 사용자를 로그인 처리합니다.\n\n```dart\ntry {\n  final userCredential =\n      await FirebaseAuth.instance.signInWithCustomToken(token);\n  print(\"Sign-in successful.\");\n} catch (e) {\n  switch (e.code) {\n    case \"custom-token-mismatch\":\n      print(\"The supplied token is for a different Firebase project.\");\n      break;\n    default:\n      print(\"Unknown error.\");\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_custom-auth_hl=ko.txt"}
{"question": "Firebase 인증에서 커스텀 토큰을 생성하는 과정은 어떻게 되나요?", "answer": "사용자가 앱에 로그인하면 사용자의 로그인 인증 정보(예: 사용자 이름과 비밀번호)를 인증 서버로 전송합니다. 서버가 사용자 인증 정보를 확인하여 정보가 유효하면 커스텀 Firebase 토큰을 생성하고 이 토큰을 앱으로 다시 보냅니다.", "source": ["https://firebase.google.com/docs/auth/flutter/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_custom-auth_hl=ko.txt"}
{"question": "사용자가 로그아웃할 때 호출해야 하는 메서드는 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut()을 호출합니다.\n\n```dart\nawait FirebaseAuth.instance.signOut();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_custom-auth_hl=ko.txt"}
{"question": "Firebase 실시간 데이터베이스와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 어떻게 가져오나요?", "answer": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 사용해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_custom-auth_hl=ko.txt"}
{"question": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하는 방법은 무엇인가요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_custom-auth_hl=ko.txt"}
{"question": "Firebase에서 이메일 링크 로그인을 사용하기 위해 어떤 설정을 해야 하나요?", "answer": "Firebase 프로젝트에서 이메일 제공업체 및 이메일 링크 로그인 방법을 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정한 후, 이메일 링크(비밀번호가 없는 로그인) 로그인 방법을 사용 설정합니다. 설정 후 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증을 시작하기 위해 어떤 메서드를 호출해야 하나요?", "answer": "이메일 링크 인증을 시작하려면 사용자의 이메일 주소를 제공하도록 요청하는 인터페이스를 제시하고 sendSignInLinkToEmail() 메서드를 호출하여 Firebase가 사용자의 이메일에 인증 링크를 전송하도록 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "ActionCodeSettings 객체를 설정할 때 어떤 필드를 포함해야 하나요?", "answer": "ActionCodeSettings 객체를 설정할 때 다음 필드를 포함해야 합니다: url, androidPackageName, IOSBundleId, handleCodeInApp, dynamicLinkDomain, linkDomain. 이 필드들은 인증 링크의 동작을 정의하는 데 필요합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "sendSignInLinkToEmail() 메서드의 사용 예시는 무엇인가요?", "answer": "sendSignInLinkToEmail() 메서드의 사용 예시는 다음과 같습니다:\n```dart\nFirebaseAuth.instance.sendSignInLinkToEmail(\n  email: emailAuth, actionCodeSettings: acs)\n  .catchError((onError) => print('Error sending email verification $onError'))\n  .then((value) => print('Successfully sent email verification'));\n```", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증에서 dynamicLinkDomain은 어떻게 설정하나요?", "answer": "dynamicLinkDomain은 지원 중단되었으며, 대신 linkDomain을 사용해야 합니다. 지정된 모바일 앱을 사용하여 링크를 열 때 사용할 선택적 커스텀 Firebase 호스팅 도메인을 설정해야 하며, 이 도메인은 Firebase 호스팅에서 구성되어야 하고 프로젝트에서 소유해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증을 완료하기 위해 애플리케이션에서 어떤 작업을 수행해야 하나요?", "answer": "모바일 애플리케이션을 통해 로그인을 완료하는 경우 애플리케이션에서 수신 애플리케이션 링크를 감지하고 기본 딥 링크를 파싱한 다음 로그인을 완료하도록 구성해야 합니다. 링크 핸들러에서 링크가 이메일 링크 인증을 위한 것인지 확인하고, 그렇다면 로그인 프로세스를 완료합니다. 예시는 다음과 같습니다:\n\n```dart\n.signInWithEmailLink(email: emailAuth, emailLink: emailLink);\nprint('Successfully signed in with email link!');\n```", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증에서 사용자의 인증 상태를 유지하기 위해 어떤 설정이 필요한가요?", "answer": "handleCodeInApp을 true로 설정해야 합니다. 다른 대역 외 이메일 작업(비밀번호 재설정 및 이메일 확인)과 달리 이 로그인 작업은 항상 앱에서 완료해야 합니다. 그 이유는 인증 과정 마지막에 사용자가 로그인하고 사용자의 인증 상태를 앱에서 유지해야 하기 때문입니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "Firebase에서 이메일 링크를 전송할 때 사용되는 메서드는 무엇인가요?", "answer": "이메일 링크를 전송하기 위해 사용되는 메서드는 sendSignInLinkToEmail()입니다. 이 메서드를 호출하여 Firebase가 사용자의 이메일에 인증 링크를 전송하도록 요청합니다. 예시는 다음과 같습니다:\n\n```dart\nFirebaseAuth.instance.sendSignInLinkToEmail(\n  email: emailAuth, actionCodeSettings: acs)\n  .catchError((onError) => print('Error sending email verification $onError'))\n  .then((value) => print('Successfully sent email verification'));\n```", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "linkDomain 필드는 어떤 용도로 사용되나요?", "answer": "linkDomain은 지정된 모바일 앱을 사용하여 링크를 열 때 사용할 선택적 커스텀 Firebase 호스팅 도메인입니다. 도메인은 Firebase 호스팅에서 구성되어야 하며 프로젝트에서 소유해야 합니다. 기본 호스팅 도메인(web.app 또는 firebaseapp.com)이 될 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증에서 dynamicLinkDomain은 어떻게 설정하나요?", "answer": "dynamicLinkDomain은 지원 중단되었으며, linkDomain을 사용해야 합니다. 프로젝트에 여러 개의 커스텀 동적 링크 도메인이 정의된 경우 지정된 모바일 앱을 사용하여 링크를 열 때 사용할 도메인을 지정합니다. 지정하지 않으면 첫 번째 도메인이 자동으로 선택됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_email-link-auth_hl=ko.txt"}
{"question": "Firebase 인증 SDK에서 발생하는 오류를 어떻게 처리하나요?", "answer": "Firebase 인증 SDK는 인증 방법을 사용하여 발생할 수 있는 다양한 오류를 포착하는 간단한 방법을 제공합니다. Flutter용 SDK는 FirebaseAuthException 클래스를 통해 이러한 오류를 노출합니다. 최소한 code 및 message가 제공되지만 경우에 따라 이메일 주소 및 사용자 인증 정보와 같은 추가 속성도 제공됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_errors_hl=ko.txt"}
{"question": "account-exists-with-different-credential 오류는 어떤 상황에서 발생하나요?", "answer": "account-exists-with-different-credential 오류는 Firebase Console에서 이메일 주소당 계정 1개를 사용 설정한 경우, 다른 Firebase 사용자의 제공업체(예: Facebook)에 이미 존재하는 이메일을 사용하여 Google과 같은 제공업체에 로그인을 시도할 때 발생합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_errors_hl=ko.txt"}
{"question": "account-exists-with-different-credential 오류를 해결하기 위한 절차는 무엇인가요?", "answer": "이 오류를 해결하려면 먼저 사용자가 기존 제공업체(예: Facebook)에 로그인한 후 신규 제공업체의 AuthCredential(Google ID 토큰)에 연결해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_errors_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스를 어떻게 생성하나요?", "answer": "FirebaseAuth 인스턴스는 다음과 같이 생성할 수 있습니다: \n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n```", "source": ["https://firebase.google.com/docs/auth/flutter/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_errors_hl=ko.txt"}
{"question": "이메일로 로그인하기 위해 필요한 메서드는 무엇인가요?", "answer": "이메일로 로그인하기 위해서는 다음과 같은 메서드를 사용할 수 있습니다: \n```dart\nUserCredential userCredential = await auth.signInWithEmailAndPassword(\n  email: email,\n  password: password,\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_errors_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 구현하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase에서 Google 로그인을 사용하기 위해서는 Firebase Console에서 'Google' 로그인 제공업체가 사용 설정되어 있어야 하며, Android에서는 머신의 SHA1 키를 구성해야 합니다. 인증 문서에서 키를 생성하는 방법을 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Google 로그인을 구현하는 기본 코드는 어떻게 되나요?", "answer": "Flutter에서 Google 로그인을 구현하기 위한 기본 코드는 다음과 같습니다.\n```dart\nimport 'package:google_sign_in/google_sign_in.dart';\n\nFuture<UserCredential> signInWithGoogle() async {\n  GoogleAuthProvider googleProvider = GoogleAuthProvider();\n  googleProvider.addScope('https://www.googleapis.com/auth/contacts.readonly');\n  googleProvider.setCustomParameters({\n    'login_hint': 'user@example.com'\n  });\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 사용하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase에서 Play 게임즈 로그인을 사용하기 위해서는 Firebase Console에서 'Play 게임즈' 로그인 제공업체가 사용 설정되어 있어야 하며, Play 게임즈 Firebase 프로젝트 설정에 대한 안내를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Facebook 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "Flutter에서 Facebook 로그인을 구현하기 위한 기본 코드는 다음과 같습니다.\n```dart\nimport 'package:flutter_facebook_auth/flutter_facebook_auth.dart';\n\nFuture<UserCredential> signInWithFacebook() async {\n  FacebookAuthProvider facebookProvider = FacebookAuthProvider();\n  facebookProvider.addScope('email');\n  facebookProvider.setCustomParameters({\n    'display': 'popup',\n  });\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Apple로 로그인을 구현하기 위해 필요한 사전 설정은 무엇인가요?", "answer": "Apple로 로그인을 구현하기 위해서는 시작하기 전에 Apple로 로그인을 구성하고, 해당 플랫폼에서 Apple을 로그인 제공업체로 사용 설정해야 합니다. iOS, Android, 웹 각각에 대한 설정 절차를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Play 게임즈 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Play 게임즈 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nFuture<void> _signInWithPlayGames() async {\n  final playGamesCredential = PlayGamesAuthProvider.credential();\n  await FirebaseAuth.instance.signInWithCredential(playGamesCredential);\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Facebook 로그인을 구현하기 위해 필요한 패키지는 무엇인가요?", "answer": "Flutter에서 Facebook 로그인을 구현하기 위해서는 `flutter_facebook_auth` 패키지를 설치해야 합니다. 다음은 패키지를 설치하는 방법입니다.\n\n```yaml\ndependencies:\n  flutter_facebook_auth: ^latest_version\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Apple 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Apple 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithApple() async {\n  final appleProvider = AppleAuthProvider();\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(appleProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Game Center 로그인을 사용하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase에서 Game Center 로그인을 사용하기 위해서는 Firebase Console에서 'Game Center' 로그인 제공업체가 사용 설정되어 있어야 합니다. 또한, Game Center Firebase 프로젝트 설정에 대한 안내를 따라야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Microsoft 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithMicrosoft() async {\n  final microsoftProvider = MicrosoftAuthProvider();\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(microsoftProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Apple 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Flutter에서 Apple 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithApple() async {\n  final appleProvider = AppleAuthProvider();\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(appleProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Apple 플랫폼에서 Apple 인증 토큰을 취소하는 방법은 무엇인가요?", "answer": "Apple 플랫폼에서 Apple 인증 토큰을 취소하려면 `revokeTokenWithAuthorizationCode()` API를 사용하여 승인 코드를 반환받아야 합니다. 다음은 관련 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithApple() async {\n  final appleProvider = AppleAuthProvider();\n\n  UserCredential userCredential = await FirebaseAuth.instance.signInWithPopup(appleProvider);\n  String? authCode = userCredential.additionalUserInfo?.authorizationCode;\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Game Center 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Game Center 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\niOS+\nFuture<void> _signInWithGameCenter() async {\n  final credential = GameCenterAuthProvider.credential();\n  await FirebaseAuth.instance\n      .signInWithCredential(credential);\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Microsoft 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithMicrosoft() async {\n  final microsoftProvider = MicrosoftAuthProvider();\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(microsoftProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Twitter 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Firebase에서 Twitter 로그인을 구현하기 위한 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<void> _signInWithTwitter() async {\n  TwitterAuthProvider twitterProvider = TwitterAuthProvider();\n\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(twitterProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Twitter 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Flutter에서 Twitter 로그인을 구현하는 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<void> _signInWithTwitter() async {\n  TwitterAuthProvider twitterProvider = TwitterAuthProvider();\n\n  if (kIsWeb) {\n    await FirebaseAuth.instance.signInWithPopup(twitterProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub 로그인을 구현하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase에서 GitHub 로그인을 구현하기 위해서는 GitHub 개발자 설정에서 OAuth 앱이 설정되어 있어야 하며, Firebase Console에서 'GitHub' 로그인 제공업체가 사용 설정되어 있어야 합니다. 또한 클라이언트 ID와 보안 비밀이 설정되어 있고, GitHub 앱에 콜백 URL이 설정되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 GitHub 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Flutter에서 GitHub 로그인을 구현하는 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithGitHub() async {\n  GithubAuthProvider githubProvider = GithubAuthProvider();\n\n  return await FirebaseAuth.instance.signInWithProvider(githubProvider);\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 로그인을 구현하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase에서 Yahoo 로그인을 구현하기 위해서는 Firebase Console에서 'Yahoo' 로그인 제공업체가 사용 설정되어 있어야 하며, API 키와 API 비밀번호가 설정되어 있어야 합니다. 또한 Firebase OAuth 리디렉션 URI가 앱의 Yahoo 개발자 네트워크 구성에서 리디렉션 URI로 설정되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Flutter에서 Yahoo 로그인을 구현하기 위한 기본 코드는 어떻게 되나요?", "answer": "다음은 Flutter에서 Yahoo 로그인을 구현하는 기본 코드입니다.\n\n```dart\nimport 'package:firebase_auth/firebase_auth.dart';\n\nFuture<UserCredential> signInWithYahoo() async {\n  final yahooProvider = YahooAuthProvider();\n  if (kIsWeb) {\n    await _auth.signInWithPopup(yahooProvider);\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/federated-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_federated-auth_hl=ko.txt"}
{"question": "Firebase에서 사용자를 생성하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 사용자를 생성하는 방법은 다음과 같습니다:\n1. createUserWithEmailAndPassword() 메서드를 호출합니다.\n2. Google 로그인, Facebook 로그인 또는 Apple과 같은 제휴 ID 공급업체를 사용하여 사용자를 처음으로 로그인 처리합니다.\n3. Firebase Console의 '인증' 섹션의 '사용자' 페이지에서 비밀번호 인증을 사용하는 신규 사용자를 생성할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자의 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자의 프로필 정보를 가져오려면 User 속성을 사용합니다. 다음 세 가지 방법으로 현재 사용자를 나타내는 User 객체를 가져올 수 있습니다:\n1. authStateChanges, idTokenChanges, userChanges 스트림을 사용하여 현재 User 또는 null을 수신합니다.\n2. FirebaseAuth.instance.currentUser 속성을 사용하여 현재 로그인된 사용자의 User 객체에 접근합니다.\n3. FirebaseAuth.instance.authStateChanges().listen((User? user) { ... });", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자의 이메일 주소를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소를 업데이트하려면 updateEmail() 메서드를 사용합니다. 예를 들면 다음과 같습니다:\n```dart\nawait user?.updateEmail(\"janeq@example.com\");\n```\n참고: 사용자의 이메일 주소를 설정하려면 사용자가 최근에 로그인한 적이 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자에게 인증 메일을 보내는 방법은 무엇인가요?", "answer": "사용자에게 인증 메일을 보내려면 sendEmailVerification() 메서드를 사용합니다. 예를 들면 다음과 같습니다:\n```dart\nawait user?.sendEmailVerification();\n```\n또한 인증 인스턴스의 언어 코드를 업데이트하여 인증 메일을 현지화할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자 비밀번호를 재설정하는 이메일을 보내는 방법은 무엇인가요?", "answer": "사용자에게 비밀번호 재설정 이메일을 보내려면 sendPasswordResetEmail() 메서드를 사용합니다. 예를 들면 다음과 같습니다:\n```dart\nawait FirebaseAuth.instance\n.sendPasswordResetEmail(email: \"user@example.com\");\n```\n또한 이메일을 보내기 전에 인증 인스턴스의 언어 코드를 업데이트하여 이메일을 현지화할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자 비밀번호를 설정하는 방법은 무엇인가요?", "answer": "updatePassword() 메서드로 사용자의 비밀번호를 설정할 수 있습니다. 예를 들면 다음과 같습니다.\n```dart\nawait user?.updatePassword(newPassword);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자 계정을 삭제하는 방법은 무엇인가요?", "answer": "delete() 메서드로 사용자 계정을 삭제할 수 있습니다. 예를 들면 다음과 같습니다.\n```dart\nawait user?.delete();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "사용자를 재인증하는 방법은 무엇인가요?", "answer": "사용자가 너무 오래 전에 로그인했다면 작업이 실패하고 requires-recent-login 코드와 함께 FirebaseAuthException이 발생합니다. 이때에는 사용자에게 새로운 로그인 인증 정보를 받은 다음 이 정보를 reauthenticate에 전달하여 사용자를 재인증해야 합니다. 예를 들면 다음과 같습니다.\n```dart\n// 사용자 재인증 코드 예시\nawait user?.reauthenticate(credential);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "비밀번호 재설정 이메일을 보내는 방법은 무엇인가요?", "answer": "sendPasswordResetEmail() 메서드로 사용자에게 비밀번호 재설정 이메일을 보낼 수 있습니다. 예를 들면 다음과 같습니다.\n```dart\nawait FirebaseAuth.instance\n    .sendPasswordResetEmail(email: \"user@example.com\");\n```", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "인증 메일을 현지화하는 방법은 무엇인가요?", "answer": "이메일을 보내기 전에 인증 인스턴스의 언어 코드를 업데이트하면 인증 메일을 현지화할 수 있습니다. 예를 들면 다음과 같습니다.\n```dart\nawait FirebaseAuth.instance.setLanguageCode(\"fr\");\nawait user?.sendEmailVerification();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_manage-users_hl=ko.txt"}
{"question": "Flutter 앱에서 다중 인증(MFA)을 사용하기 위해 어떤 제공업체를 사용 설정해야 하나요?", "answer": "전화 인증, 익명 인증, Apple Game Center를 제외한 모든 제공업체는 MFA를 지원합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)을 사용하기 위해 이메일 인증이 필요한 이유는 무엇인가요?", "answer": "MFA를 사용하려면 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일에 서비스를 등록한 후 두 번째 단계를 추가하여 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "Firebase Console에서 다중 인증(MFA)을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console의 인증 > 로그인 방법 페이지를 열고, 고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록 패턴을 선택할 때 고려해야 할 사항은 무엇인가요?", "answer": "앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 일반적인 패턴은 사용자의 두 번째 단계를 등록하는 방법을 선택하는 것입니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "사용자의 두 번째 단계를 등록하기 위한 첫 번째 단계는 무엇인가요?", "answer": "사용자를 다시 인증합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "Firebase Console에서 SMS 다중 인증(MFA)을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console의 인증 > 로그인 방법 페이지를 열고, 고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록 시 사용자의 두 번째 단계를 등록하는 방법은 무엇인가요?", "answer": "사용자의 새로운 두 번째 단계를 등록하려면 다음 단계를 따르세요.\n\n1. 사용자를 다시 인증합니다.\n2. 사용자에게 전화번호를 입력하도록 요청합니다.\n3. 사용자를 위한 다중 세션을 가져옵니다.\n\n```dart\nfinal multiFactorSession = await user.multiFactor.getSession();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 세션 및 콜백으로 전화번호를 확인하는 방법은 무엇인가요?", "answer": "다중 인증 세션 및 콜백으로 전화번호를 확인하려면 다음 코드를 사용합니다.\n\n```dart\nawait FirebaseAuth.instance.verifyPhoneNumber(\n  multiFactorSession: multiFactorSession,\n  phoneNumber: phoneNumber,\n  verificationCompleted: (_) {},\n  verificationFailed: (_) {},\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "사용자의 두 번째 인증 단계가 성공적으로 등록되었는지 확인하는 방법은 무엇인가요?", "answer": "사용자의 두 번째 인증 단계가 성공적으로 등록되었는지 확인하려면 다음 코드를 사용합니다.\n\n```dart\nawait user.multiFactor.enroll(\n  PhoneMultiFactorGenerator.getAssertion(credential),\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "2단계 SMS 인증으로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "2단계 SMS 인증으로 사용자를 로그인 처리하려면 다음 단계를 따르세요.\n\n1. 첫 번째 단계로 사용자를 로그인한 다음 FirebaseAuthMultiFactorException 예외를 포착합니다.\n2. 예외에서 사용자의 등록된 두 번째 단계를 가져오는 리졸버를 사용합니다.\n\n예를 들어 사용자의 첫 번째 단계가 이메일과 비밀번호인 경우는 다음과 같습니다.\n\n```dart\ntry {\n  await _auth.signInWithEmailAndPassword(\n    email: emailController.text,\n    password: passwordController.text,\n  );\n} catch (e) {\n  final hint = e.resolver.hints[selectedHint];\n  // 추가 코드...\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용하세요:\n\n```dart\nfinal multiFactorSession = await user.multiFactor.getSession();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "전화번호를 확인하기 위해 다중 인증 세션을 사용하는 방법은 무엇인가요?", "answer": "전화번호를 확인하기 위해 다중 인증 세션을 사용하는 방법은 다음과 같습니다:\n\n```dart\nawait FirebaseAuth.instance.verifyPhoneNumber(\n  multiFactorSession: multiFactorSession,\n  phoneNumber: phoneNumber,\n  verificationCompleted: (_) {},\n  verificationFailed: (_) {},\n  codeSent: (String verificationId, int? resendToken) async {\n    // SMS 코드가 전송되면 사용자에게 코드를 확인하도록 요청합니다.\n    final credential = PhoneAuthProvider.credential(\n      verificationId: verificationId,\n      smsCode: smsCode,\n    );\n  }\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "사용자의 두 번째 인증 단계를 등록하는 전체 예시 코드는 무엇인가요?", "answer": "사용자의 두 번째 인증 단계를 등록하는 전체 예시 코드는 다음과 같습니다:\n\n```dart\nfinal session = await user.multiFactor.getSession();\nfinal auth = FirebaseAuth.instance;\nawait auth.verifyPhoneNumber(\n  multiFactorSession: session,\n  phoneNumber: phoneController.text,\n  verificationCompleted: (_) {},\n  verificationFailed: (_) {},\n  codeSent: (String verificationId, int? resendToken) async {\n    if (smsCode != null) {\n      final credential = PhoneAuthProvider.credential(\n        verificationId: verificationId,\n        smsCode: smsCode,\n      );\n      try {\n        await user.multiFactor.enroll(\n          PhoneMultiFactorGenerator.getAssertion(\n            credential,\n          ),\n        );\n      }\n    }\n  }\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "2단계 SMS 인증으로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "2단계 SMS 인증으로 사용자를 로그인 처리하려면 다음 코드를 사용하세요:\n\n```dart\ntry {\n  await _auth.signInWithEmailAndPassword(\n    email: emailController.text,\n    password: passwordController.text,\n  );\n} catch (e) {\n  final hint = e.resolver.hints[selectedHint];\n  await FirebaseAuth.instance.verifyPhoneNumber(\n    multiFactorSession: session,\n    multiFactorInfo: hint,\n    verificationCompleted: (_) {},\n    verificationFailed: (_) {},\n    codeSent: (String verificationId, int? resendToken) async {\n      final smsCode = await getSmsCodeFromUser(context);\n      if (smsCode != null) {\n        await e.resolver.resolveSignIn(\n          PhoneMultiFactorGenerator.getAssertion(credential),\n        );\n      }\n    }\n  );\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "사용자가 두 번째 단계를 두 개 이상 등록하도록 권장하는 이유는 무엇인가요?", "answer": "사용자가 두 번째 단계를 두 개 이상 등록하도록 권장하는 이유는 계정 복구를 위해서입니다. 사용자가 두 번째 단계를 한 개만 등록했는데 나중에 액세스 권한을 분실하는 경우 계정에 액세스할 수 없기 때문입니다.", "source": ["https://firebase.google.com/docs/auth/flutter/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_multi-factor_hl=ko.txt"}
{"question": "Firebase에서 비밀번호 재설정 이메일을 보낼 때 어떤 매개변수를 포함해야 하나요?", "answer": "비밀번호 재설정 이메일이나 인증 메일을 보낼 때 ActionCodeSettings 인스턴스를 제공해야 합니다. 이 인터페이스는 다음과 같은 매개변수를 사용합니다.\n\n| 매개변수 | 유형 | 설명 |\n| --- | --- | --- |\n| url | 문자열 | 컨텍스트에 따라 의미가 다른 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다. 앱에서 링크가 직접 처리되는 경우 동적 링크의 딥 링크에 있는 continueUrl 쿼리 매개변수입니다. |\n| iOSBundleId | 문자열 | 번들 ID를 설정합니다. Apple 앱이 설치되어 있다면 앱에서 링크를 열려고 시도할 것입니다. 앱을 Console에 등록해야 합니다. 번들 ID를 제공하지 않으면 이 필드의 값이 앱의 기본 번들 ID로 설정됩니다. |\n| androidPackageName | 문자열 | Android 패키지 이름을 설정합니다. Android 앱이 설치되어 있다면 앱에서 링크를 열려고 시도할 것입니다. |\n| androidInstallApp | 부울 | 기기에서 Android 앱을 지원하며 앱이 아직 설치되지 않은 경우 앱을 설치할지 여부를 지정합니다. 이 필드가 packageName 없이 제공되면 필드와 함께 packageName을 제공해야 한다는 오류가 발생합니다. |\n| androidMinimumVersion | 문자열 | 이 흐름에서 지원되는 앱의 최소 버전입니다. minimumVersion이 지정되고 설치된 앱이 이전 버전이라면 앱을 업그레이드하기 위해 Play 스토어로 이동합니다. Android 앱을 Console에 등록해야 합니다. |\n| handleCodeInApp | 부울 | 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다. true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다. false면 코드가 먼저 웹 위젯에 전송되고 앱이 설치된 경우 계속해서 앱으로 리디렉션됩니다. |\n| dynamicLinkDomain | 문자열 | (지원 중단됨, `linkDomain` 사용) Firebase 동적 링크를 사용하여 열려는 경우 현재 링크에 사용할 동적 링크 도메인 또는 하위 도메인을 설정합니다. 프로젝트마다 여러 동적 링크 도메인을 구성할 수 있으므로 이 필드는 명시적으로 하나를 선택할 수 있는 기능을 제공합니다. 도메인을 지정하지 않으면 기본적으로 첫 번째 도메인이 사용됩니다. |", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "연결 URL을 통해 상태를 전달하기 위해 Firebase Console에서 어떤 설정이 필요한가요?", "answer": "연결 URL을 안전하게 전달하려면 Firebase Console에서 이 URL의 도메인을 허용해야 합니다. 아직 허용 목록에 포함되어 있지 않다면 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 링크를 모바일 앱에서 먼저 열도록 설정하려면 어떤 매개변수를 사용해야 하나요?", "answer": "이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정하려면 `handleCodeInApp` (부울) 매개변수를 사용해야 합니다. 기본값은 false이며, true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase에서 비밀번호 재설정 흐름을 완료한 후 사용자가 돌아가야 할 URL을 어떻게 설정하나요?", "answer": "비밀번호 재설정이나 사용자 이메일 확인을 위한 이메일 작업을 보낼 때 `url` (문자열) 매개변수를 사용하여 상태/연결 URL을 설정합니다. 이 URL은 컨텍스트에 따라 의미가 다르며, 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크로 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Android 앱이 설치되지 않은 경우 앱을 설치할지 여부를 어떻게 설정하나요?", "answer": "Android 앱이 설치되지 않은 경우 앱을 설치할지 여부를 지정하려면 `androidInstallApp` (부울) 매개변수를 사용해야 합니다. 이 필드가 packageName 없이 제공되면 필드와 함께 packageName을 제공해야 한다는 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase에서 비밀번호 재설정 이메일을 보낼 때 ActionCodeSettings 인스턴스를 어떻게 설정하나요?", "answer": "비밀번호 재설정 이메일을 보낼 때 ActionCodeSettings 인스턴스를 다음과 같이 설정할 수 있습니다:\n\n```dart\nfinal actionCodeSettings = ActionCodeSettings(\n  url: \"http://www.example.com/verify?email=\",\n  iOSBundleId: \"com.example.ios\",\n  androidPackageName: \"com.example.android\",\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase 동적 링크를 사용하여 이메일 인증 링크를 보내려면 어떤 설정이 필요한가요?", "answer": "Firebase 동적 링크를 사용하여 이메일 인증 링크를 보내려면 Firebase Console에서 동적 링크를 구성해야 합니다. 동적 링크 섹션을 열고 동적 링크 약관에 동의한 후 동적 링크 도메인을 만들어야 합니다. 예를 들어, 도메인의 형식은 `example.page.link`입니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Android 애플리케이션에서 Firebase 동적 링크를 처리하기 위해 어떤 설정을 해야 하나요?", "answer": "Android 애플리케이션에서 Firebase 동적 링크를 처리하려면 Firebase 콘솔 프로젝트 설정에서 Android 패키지 이름을 지정하고, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다. 또한 AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터를 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "iOS 애플리케이션에서 Firebase 동적 링크를 처리하기 위해 필요한 설정은 무엇인가요?", "answer": "iOS 애플리케이션에서 Firebase 동적 링크를 처리하려면 Firebase Console 프로젝트 설정에서 번들 ID를 지정해야 합니다. 이 설정이 완료되면 앱이 설치된 경우 링크를 열 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "ActionCodeSettings의 handleCodeInApp 매개변수는 어떤 역할을 하나요?", "answer": "ActionCodeSettings의 handleCodeInApp 매개변수는 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지를 지정합니다. 기본값은 false이며, true로 설정하면 작업 코드 링크가 앱에서 열리도록 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase 동적 링크를 사용하여 이메일 인증 링크를 보내기 위해 어떤 도메인을 설정해야 하나요?", "answer": "Firebase 동적 링크를 사용하려면 커스텀 Firebase 호스팅 도메인을 설정해야 합니다. 이 도메인은 Firebase 호스팅에서 구성되어야 하며 프로젝트에서 소유해야 합니다. 기본 호스팅 도메인(`web.app` 또는 `firebaseapp.com`)은 사용할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase 동적 링크를 통해 이메일 작업 링크를 처리할 때 Android 애플리케이션에서 어떤 설정이 필요한가요?", "answer": "Android 애플리케이션에서 Firebase 동적 링크를 처리하려면 Firebase 콘솔 프로젝트 설정에서 Android 패키지 이름을 지정해야 하며, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다. 또한 AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터도 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase 동적 링크를 통해 이메일 작업 링크를 처리할 때 Apple 애플리케이션에서 어떤 설정이 필요한가요?", "answer": "Apple 애플리케이션에서 Firebase 동적 링크를 처리하려면 Firebase Console 프로젝트 설정에서 번들 ID를 지정해야 하며, App Store ID와 Apple Developer Team ID도 지정해야 합니다. 또한 애플리케이션 기능에서 FDL 범용 링크 도메인을 연결된 도메인으로 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업을 웹 애플리케이션에서 처리할 때 ActionCodeSettings 객체의 handleCodeInApp 매개변수는 어떻게 설정해야 하나요?", "answer": "웹 애플리케이션에서 이메일 작업을 처리할 때 ActionCodeSettings 객체에서 handleCodeInApp을 false로 설정하면 됩니다. 이렇게 하면 작업 코드 링크를 처리한 후 다른 웹페이지 또는 모바일 애플리케이션으로 리디렉션할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 인증과 같은 이메일 작업을 처리할 때 oobCode 쿼리 매개변수는 어떻게 사용하나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Console에서 Apple 애플리케이션을 구성할 때 어떤 정보를 지정해야 하나요?", "answer": "애플리케이션에서 이 링크를 처리하려면 Firebase Console 프로젝트 설정에서 번들 ID(bundle ID), App Store ID, Apple Developer Team ID를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "iOS 애플리케이션에서 FDL 범용 링크 도메인을 어떻게 구성하나요?", "answer": "애플리케이션 기능에서 FDL 범용 링크 도메인을 연결된 도메인으로 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "웹 애플리케이션에서 이메일 작업을 처리한 후 리디렉션할지 여부를 어떻게 설정하나요?", "answer": "ActionCodeSettings 객체에서 handleCodeInApp을 false로 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "모바일 애플리케이션에서 이메일 작업을 처리할 때 어떤 매개변수를 사용해야 하나요?", "answer": "ActionCodeSettings 객체에서 handleCodeInApp을 true로 설정하고, androidInstallApp을 통해 설치되지 않은 앱을 설치하도록 지정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업을 처리할 때 oobCode 쿼리 매개변수는 어떻게 사용하나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "모바일 애플리케이션에서 이메일 작업을 처리할 때, ActionCodeSettings 객체의 handleCodeInApp 매개변수를 어떻게 설정해야 하나요?", "answer": "ActionCodeSettings 객체에서 handleCodeInApp을 true로 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "모바일 애플리케이션이 설치되지 않은 경우, 이메일 작업 링크를 어떻게 처리하나요?", "answer": "모바일 애플리케이션이 설치되지 않은 경우, 링크를 클릭하면 대신 웹페이지에서 링크가 열립니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업을 처리할 때, oobCode 쿼리 매개변수는 어떻게 사용하나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Android 애플리케이션에서 이메일 작업 링크를 처리할 때, 어떤 매개변수를 사용해야 하나요?", "answer": "Android 애플리케이션을 사용하면 androidInstallApp을 통해 기기에서 지원하는데도 아직 설치되지 않은 앱이 있다면 설치하도록 지정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 링크의 페이로드는 어떻게 구성되나요?", "answer": "사용자에게 전송되는 모바일 앱 링크는 페이로드가 Console에서 쿼리 매개변수 oobCode, mode, apiKey, continueUrl을 사용해 구성된 작업 코드 URL인 FDL 링크입니다.", "source": ["https://firebase.google.com/docs/auth/flutter/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Flutter에서 비밀번호 기반 계정을 만들기 위해 어떤 메서드를 사용해야 하나요?", "answer": "비밀번호가 있는 신규 사용자 계정을 만들기 위해 createUserWithEmailAndPassword() 메서드를 호출합니다. 예시는 다음과 같습니다:\n```dart\ntry {\n  final credential = await FirebaseAuth.instance.createUserWithEmailAndPassword(\n    email: emailAddress,\n    password: password,\n  );\n} catch (e) {\n  // 오류 처리\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_password-auth_hl=ko.txt"}
{"question": "Firebase에서 이메일/비밀번호 로그인 방법을 사용 설정하는 절차는 무엇인가요?", "answer": "Firebase Console의 인증 섹션에서 로그인 방법 페이지를 열고, 이메일/비밀번호 로그인 방법을 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_password-auth_hl=ko.txt"}
{"question": "사용자가 로그아웃할 때 어떤 메서드를 호출해야 하나요?", "answer": "사용자를 로그아웃시키려면 signOut() 메서드를 호출합니다. 예시는 다음과 같습니다:\n```dart\nawait FirebaseAuth.instance.signOut();\n```", "source": ["https://firebase.google.com/docs/auth/flutter/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_password-auth_hl=ko.txt"}
{"question": "Firebase 인증을 사용하여 사용자가 이메일과 비밀번호로 인증하기 위해 필요한 사전 준비는 무엇인가요?", "answer": "Firebase 인증을 사용하여 사용자가 이메일 주소와 비밀번호로 Firebase에 인증하도록 하려면, 시작하기 가이드의 단계를 따르는 것이 필요합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_password-auth_hl=ko.txt"}
{"question": "Firebase 실시간 데이터베이스와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 어떻게 가져오나요?", "answer": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 사용해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_password-auth_hl=ko.txt"}
{"question": "전화 인증을 사용하기 위해 Firebase Console에서 어떤 설정을 해야 하나요?", "answer": "Firebase Console에서 전화를 로그인 방법으로 사용 설정해야 합니다. 또한 Android의 경우 앱의 SHA-1 해시를 설정하고, iOS의 경우 Xcode에서 푸시 알림을 사용 설정하고 APN 인증 키가 Firebase 클라우드 메시징(FCM)으로 구성되었는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Flutter에서 전화번호 인증을 위해 사용해야 하는 메서드는 무엇인가요?", "answer": "Flutter용 Firebase 인증 SDK에서는 네이티브 플랫폼에서 사용해야 하는 메서드로 verifyPhoneNumber()를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "verifyPhoneNumber() 메서드의 주요 콜백 함수는 무엇이 있나요?", "answer": "verifyPhoneNumber() 메서드의 주요 콜백 함수는 verificationCompleted, verificationFailed, codeSent, codeAutoRetrievalTimeout의 4개가 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "verificationCompleted 핸들러는 어떤 상황에서 호출되나요?", "answer": "verificationCompleted 핸들러는 자동 SMS 코드 확인을 지원하는 Android 기기에서만 호출되며, SMS 코드가 기기로 전송되면 Android가 사용자가 코드를 직접 입력하지 않아도 SMS 코드를 자동으로 인증합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 잘못된 전화번호에 대한 오류는 어떻게 처리하나요?", "answer": "잘못된 전화번호나 SMS 할당량 초과와 같은 실패 이벤트는 verificationFailed 핸들러에서 처리됩니다. 이 핸들러는 FirebaseAuthException을 통해 오류를 반환합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Flutter에서 전화번호 인증을 위해 verifyPhoneNumber() 메서드를 호출할 때 필요한 파라미터는 무엇인가요?", "answer": "verifyPhoneNumber() 메서드를 호출할 때 필요한 파라미터는 다음과 같습니다:\n\n```dart\nawait FirebaseAuth.instance.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  verificationCompleted: (PhoneAuthCredential credential) {},\n  verificationFailed: (FirebaseAuthException e) {},\n  codeSent: (String verificationId, int? resendToken) {},\n  codeAutoRetrievalTimeout: (String verificationId) {},\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증 시 SMS 코드가 전송된 경우 어떤 핸들러가 호출되나요?", "answer": "SMS 코드가 전송된 경우 codeSent 핸들러가 호출됩니다. 이 핸들러는 verificationId 및 resendToken을 인자로 받습니다. 예를 들어:\n\n```dart\ncodeSent: (String verificationId, int? resendToken) async {\n  String smsCode = 'xxxx';\n  PhoneAuthCredential credential = PhoneAuthProvider.credential(verificationId: verificationId, smsCode: smsCode);\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증 시 verificationFailed 핸들러는 어떤 상황에서 호출되나요?", "answer": "verificationFailed 핸들러는 잘못된 전화번호나 SMS 할당량 초과와 같은 실패 이벤트가 발생할 때 호출됩니다. 이 핸들러는 FirebaseAuthException을 인자로 받습니다. 예를 들어:\n\n```dart\nverificationFailed: (FirebaseAuthException e) {\n  if (e.code == 'invalid-phone-number') {\n    print('The provided phone number is not valid.');\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "codeAutoRetrievalTimeout 핸들러는 어떤 경우에 호출되며, 기본 대기 시간은 얼마인가요?", "answer": "codeAutoRetrievalTimeout 핸들러는 자동 SMS 코드 확인을 지원하는 Android 기기에서 특정 기간 내에 SMS 메시지를 자동으로 확인하지 못할 경우 호출됩니다. 기본적으로 기기는 30초 동안 대기하지만, timeout 인수로 이를 맞춤설정할 수 있습니다. 예를 들어:\n\n```dart\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  timeout: const Duration(seconds: 60),\n  codeAutoRetrievalTimeout: (String verificationId) {\n    // Handle timeout\n  },\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "웹 플랫폼에서 전화번호 인증을 위해 사용자가 수행해야 하는 작업은 무엇인가요?", "answer": "웹 플랫폼에서 전화번호 인증을 위해 사용자는 Google reCAPTCHA 위젯을 완료하여 실제 사람임을 증명해야 합니다. 확인이 완료되면 SMS 코드가 전송됩니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Flutter에서 SMS 코드가 전송되었을 때 호출되는 핸들러는 무엇인가요?", "answer": "SMS 코드가 기기에 전송되면 codeSent 핸들러가 호출됩니다. 이 핸들러는 verificationId 및 resendToken으로 트리거됩니다. 아래는 해당 코드 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  codeSent: (String verificationId, int? resendToken) async {\n    String smsCode = 'xxxx';\n\n    PhoneAuthCredential credential = PhoneAuthProvider.credential(verificationId: verificationId, smsCode: smsCode);\n  },\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 SMS 메시지를 재전송하려면 어떻게 해야 하나요?", "answer": "기본적으로 Firebase는 최근에 전송된 경우 새 SMS 메시지를 다시 전송하지 않습니다. 하지만 forceResendingToken 인수에 대한 재전송 토큰으로 verifyPhoneNumber 메서드를 다시 호출하여 이 동작을 재정의할 수 있습니다. 성공하면 SMS 메시지가 다시 전송됩니다. 아래는 해당 코드 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  codeSent: (String verificationId, int? resendToken) async {\n    // SMS 코드 입력 후 재전송\n    await auth.verifyPhoneNumber(\n      phoneNumber: '+44 7123 123 456',\n      forceResendingToken: resendToken,\n    );\n  },\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "codeAutoRetrievalTimeout 핸들러는 어떤 경우에 호출되며, 기본 대기 시간은 얼마인가요?", "answer": "자동 SMS 코드 확인을 지원하는 Android 기기에서는 기기가 특정 기간 내에 SMS 메시지를 자동으로 확인하지 않으면 codeAutoRetrievalTimeout 핸들러가 호출됩니다. 기본적으로 기기는 30초 동안 대기하지만 timeout 인수로 이를 맞춤설정할 수 있습니다. 아래는 해당 코드 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  timeout: const Duration(seconds: 60),\n  codeAutoRetrievalTimeout: (String verificationId) {\n    // 타임아웃 처리\n  },\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "웹 플랫폼에서 전화번호 인증을 위해 사용자가 수행해야 하는 작업은 무엇인가요?", "answer": "웹 플랫폼에서 사용자는 제공된 전화번호로 전송된 SMS 코드를 입력하는 방식으로 휴대전화에 액세스할 수 있는지 확인하여 로그인할 수 있습니다. 보안 및 스팸 방지를 강화하기 위해 사용자는 Google reCAPTCHA 위젯을 완료하여 실제 사람임을 증명해야 합니다. 확인이 완료되면 SMS 코드가 전송됩니다. 아래는 해당 코드 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\nConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456');\nUserCredential userCredential = await confirmationResult.confirm('123456');\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 위젯을 웹 애플리케이션에 추가하는 방법은 무엇인가요?", "answer": "reCAPTCHA 위젯은 웹 애플리케이션에 보안을 제공하는 완전 관리형 흐름입니다. signInWithPhoneNumber의 두 번째 인수는 위젯을 관리하는 데 사용할 수 있는 선택적 RecaptchaVerifier 인스턴스를 허용합니다. 아래는 해당 코드 예시입니다.\n\n```dart\nConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456', RecaptchaVerifier(\n  container: 'recaptcha',\n  size: RecaptchaVerifierSize.compact,\n  theme: RecaptchaVerifierTheme.dark,\n));\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Flutter에서 reCAPTCHA 위젯을 사용자 정의하려면 어떻게 해야 하나요?", "answer": "reCAPTCHA 위젯을 사용자 정의하려면, signInWithPhoneNumber 메서드의 두 번째 인수로 RecaptchaVerifier 인스턴스를 제공해야 합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```dart\nConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456', RecaptchaVerifier(\n  container: 'recaptcha',\n  size: RecaptchaVerifierSize.compact,\n  theme: RecaptchaVerifierTheme.dark,\n));\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 위젯의 이벤트를 수신 대기하려면 어떻게 설정하나요?", "answer": "reCAPTCHA 위젯의 이벤트를 수신 대기하려면 RecaptchaVerifier 인스턴스를 생성할 때 onSuccess, onError, onExpired 콜백을 설정할 수 있습니다. 예를 들어:\n\n```dart\nRecaptchaVerifier(\n  onSuccess: () => print('reCAPTCHA Completed!'),\n  onError: (FirebaseAuthException error) => print(error),\n  onExpired: () => print('reCAPTCHA Expired!'),\n);\n```", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 로컬 테스트 전화번호를 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 '전화' 인증 제공업체를 선택한 후, '테스트용 전화번호' 드롭다운을 클릭하여 새로운 전화번호와 테스트 코드를 입력합니다. 예를 들어, 전화번호는 +44 7444 555666, 테스트 코드는 123456으로 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "테스트 전화번호를 사용하여 SMS를 전송하지 않고 인증을 테스트하는 방법은 무엇인가요?", "answer": "테스트 전화번호를 사용하여 SMS를 전송하지 않고 인증을 테스트하려면, verifyPhoneNumber 또는 signInWithPhoneNumber 메서드에 테스트 전화번호를 제공하면 됩니다. 이 경우 실제로 SMS가 전송되지 않고, PhoneAuthProvider에 직접 또는 signInWithPhoneNumber의 확인 결과 핸들러를 사용하여 테스트 코드를 제공할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "signInWithPhoneNumber 메서드를 호출한 후 어떤 일이 발생하나요?", "answer": "signInWithPhoneNumber 메서드를 호출하면 먼저 reCAPTCHA 위젯이 표시됩니다. 사용자는 SMS 코드가 전송되기 전에 테스트를 완료해야 하며, 완료되면 확인된 ConfirmationResult 응답의 confirm 메서드에 SMS 코드를 제공하여 사용자를 로그인 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_phone-auth_hl=ko.txt"}
{"question": "Firebase 인증을 Flutter 프로젝트에 추가하는 방법은 무엇인가요?", "answer": "Flutter 프로젝트 루트에서 다음 명령어를 실행하여 플러그인을 설치합니다.\n```\nflutter pub add firebase_auth\n```\n완료되면 Flutter 애플리케이션을 다시 빌드합니다.\n```\nflutter run\n```", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "Firebase 로컬 에뮬레이터를 사용하여 인증 기능을 테스트하는 방법은 무엇인가요?", "answer": "에뮬레이터에 연결하려면 앱의 테스트 구성에 코드 줄을 추가합니다. 로컬 프로젝트 디렉터리의 루트에서 다음 명령어를 실행합니다.\n```\nfirebase emulators:start\n```\n대화형 프로토타입 제작에는 로컬 에뮬레이터 도구 모음 UI를, 비대화형 테스트에는 인증 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스에서 인증 상태 변경을 구독하는 방법은 무엇인가요?", "answer": "FirebaseAuth 인스턴스에서 authStateChanges() 메서드를 호출하여 이러한 변경사항을 구독할 수 있습니다.\n```\nFirebaseAuth.instance\n.authStateChanges()\n.listen((User? user) {\nif (user == null) {\nprint('User is currently signed out!');\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "FirebaseAdmin SDK를 사용하여 커스텀 클레임을 설정한 후 ID 토큰을 갱신하는 방법은 무엇인가요?", "answer": "FirebaseAuth.instance.currentUser.getIdTokenResult(true)를 호출하여 강제로 ID 토큰을 새로고침할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "Firebase Admin SDK로 User 프로필을 업데이트한 후 최신 User 프로필을 가져오는 방법은 무엇인가요?", "answer": "Firebase Admin SDK로 User 프로필을 업데이트하면 idTokenChanges(), userChanges(), authStateChanges()가 실행되지 않습니다. 최신 User 프로필을 가져오려면 FirebaseAuth.instance.currentUser.reload()를 사용하여 강제로 새로고침해야 합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "Firebase 인증 에뮬레이터를 설정하는 방법은 무엇인가요?", "answer": "로컬 프로젝트 디렉터리의 루트에서 `firebase emulators:start`를 실행하여 Firebase 인증 에뮬레이터를 설정할 수 있습니다. 대화형 프로토타입 제작에는 로컬 에뮬레이터 도구 모음 UI를, 비대화형 테스트에는 인증 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스에서 사용자 변경 사항을 구독하는 방법은 무엇인가요?", "answer": "FirebaseAuth 인스턴스에서 `userChanges()` 메서드를 호출하여 사용자 변경 사항을 구독할 수 있습니다. 예시는 다음과 같습니다:\n```dart\nFirebaseAuth.instance\n    .userChanges()\n    .listen((User? user) {\n  if (user == null) {\n    print('User is currently signed out!');\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "Firebase Admin SDK로 User 프로필을 업데이트한 후 최신 User 프로필을 가져오는 방법은 무엇인가요?", "answer": "Firebase Admin SDK로 User 프로필을 업데이트한 후에는 `FirebaseAuth.instance.currentUser.reload()`를 사용하여 강제로 새로고침해야 최신 User 프로필을 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "Firebase 인증 상태를 유지하는 방법은 무엇인가요?", "answer": "모든 플랫폼용 Firebase SDK는 기본적으로 앱 다시 시작 또는 페이지 새로고침 후 사용자의 인증 상태가 유지되도록 지원합니다. Android 및 iOS와 같은 네이티브 플랫폼에서는 이 동작의 설정을 변경할 수 없으며, 사용자는 기기 설정을 사용하여 캐시된 앱 데이터를 삭제할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "FirebaseAuth 인스턴스의 인증 상태 지속성을 설정하는 방법은 무엇인가요?", "answer": "FirebaseAuth 인스턴스의 인증 상태 지속성을 설정하려면 `FirebaseAuth.instanceFor(app: Firebase.app(), persistence: Persistence.LOCAL);` 메서드를 호출하여 로컬 스토리지에 데이터를 저장하도록 설정할 수 있습니다. `setPersistence(Persistence.NONE)`를 사용하여 각 인증 인스턴스의 지속성을 업데이트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/flutter/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_flutter_start_hl=ko.txt"}
{"question": "FirebaseUI 인증을 사용하여 사용자 로그인을 처리하는 방법은 무엇인가요?", "answer": "FirebaseUI는 이메일 주소와 비밀번호, 전화번호는 물론 Google 로그인 및 Facebook 로그인 등의 인기 제휴 ID 공급업체를 이용하여 사용자 로그인의 UI 흐름을 처리하는 삽입형 인증 솔루션을 제공합니다. FirebaseUI 인증 구성요소는 모바일 기기 및 웹사이트를 통한 인증의 모범 사례를 구현하여 앱의 로그인 및 가입 전환을 극대화합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication SDK를 사용하여 이메일 및 비밀번호 기반 인증을 구현하는 방법은 무엇인가요?", "answer": "Firebase Authentication SDK는 사용자의 이메일 주소와 비밀번호를 사용해 로그인을 처리하는 사용자 계정을 생성하고 관리하는 수단을 제공합니다. 또한 비밀번호 재설정 이메일 전송도 처리합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화번호 인증을 구현하는 방법은 무엇인가요?", "answer": "전화번호 인증은 휴대전화로 SMS 메시지를 보내 사용자를 인증하는 방법입니다. 이 기능은 iOS, Android, 웹, C++, Unity 플랫폼에서 지원됩니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "익명 인증 기능을 사용하면 어떤 이점이 있나요?", "answer": "익명 인증은 임시 익명 계정을 생성하여 사용자들이 로그인하지 않고도 인증할 수 있게 해 줍니다. 사용자가 나중에 가입을 결심하면 익명 계정을 일반 계정으로 업그레이드하여 사용자의 이용 내역을 그대로 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 주요 기능은 무엇인가요?", "answer": "Firebase Authentication with Identity Platform은 다중 인증(MFA), 차단 함수, 사용자 활동 및 감사 로깅, SAML, 일반 OpenID Connect 지원, 멀티테넌시, 엔터프라이즈 수준의 지원과 같은 추가 기능을 제공합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication SDK를 사용하여 ID 공급업체 통합을 구현하는 방법은 무엇인가요?", "answer": "Firebase Authentication SDK는 사용자들이 Google, Facebook, Twitter, GitHub 계정으로 로그인할 수 있는 수단을 제공합니다. 각 플랫폼에 대한 로그인 방법은 다음과 같습니다:\n\n```plaintext\n// Google 계정으로 로그인\n// iOS, Android, 웹, C++, Unity에서 사용 가능\n\n// Apple로 로그인\n// iOS, Android, 웹, C++, Unity에서 사용 가능\n\n// Facebook으로 로그인\n// iOS, Android, 웹, C++, Unity에서 사용 가능\n\n// Twitter로 로그인\n// iOS, Android, 웹, C++, Unity에서 사용 가능\n\n// GitHub으로 로그인\n// iOS, Android, 웹, C++, Unity에서 사용 가능\n```", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 커스텀 인증 시스템을 통합하는 방법은 무엇인가요?", "answer": "앱의 기존 로그인 시스템을 Firebase Authentication SDK에 연결하면 Firebase Realtime Database와 기타 Firebase 서비스를 이용할 수 있습니다. 이를 통해 기존 사용자 인증 시스템을 Firebase와 통합할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 다중 인증(MFA) 기능을 어떻게 추가하나요?", "answer": "SMS를 통한 다중 인증(MFA)을 사용하면 앱에 보안 레이어가 추가되어 사용자의 데이터를 보호할 수 있습니다. Apple, Android, 웹 앱에 MFA를 추가하는 방법은 Firebase Authentication with Identity Platform 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 차단 함수(blocking function) 기능은 무엇인가요?", "answer": "차단 함수를 사용하면 사용자가 앱에 등록하거나 로그인한 결과를 수정하는 커스텀 코드를 실행할 수 있습니다. 차단 함수로 Firebase Authentication을 확장하는 방법은 Firebase Authentication with Identity Platform 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 사용자 활동 및 감사 로깅 기능을 어떻게 설정하나요?", "answer": "관리 액세스, 최종 사용자 활동을 모니터링하고 로깅할 수 있습니다. 프로젝트를 업그레이드하면 Cloud Logging에서 관리자 활동 감사 로그가 자동으로 사용 설정됩니다. Firebase Console의 인증 설정 페이지에서 사용자 활동 로깅을 사용 설정할 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform에서 다중 인증(MFA)을 추가하는 방법은 무엇인가요?", "answer": "SMS를 통한 다중 인증(MFA)을 사용하면 앱에 보안 레이어가 추가되어 사용자의 데이터를 보호할 수 있습니다. Apple, Android, 웹 앱에 MFA를 추가하는 방법을 알아보세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 차단 함수(blocking function) 기능을 어떻게 활용하나요?", "answer": "차단 함수를 사용하면 사용자가 앱에 등록하거나 로그인한 결과를 수정하는 커스텀 코드를 실행할 수 있습니다. 차단 함수로 Firebase Authentication을 확장하는 방법을 알아보세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform에서 SAML 및 OpenID Connect 제공업체를 사용하는 방법은 무엇인가요?", "answer": "SAML(웹만 해당) 및 Firebase에서 기본적으로 지원하지 않는 OpenID Connect 제공업체를 사용한 로그인을 지원합니다. SAML 로그인을 웹 앱에 추가하고 OpenID Connect 로그인을 Apple, Android, 웹 앱에 추가하는 방법을 알아보세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform에서 사용자 활동 및 감사 로깅 기능을 어떻게 설정하나요?", "answer": "프로젝트를 업그레이드하면 Cloud Logging에서 관리자 활동 감사 로그가 자동으로 사용 설정됩니다. Firebase Console의 인증 설정 페이지에서 사용자 활동 로깅을 사용 설정할 수도 있습니다. 로그를 보고 분석하는 방법을 알아보려면 Cloud Logging 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication with Identity Platform의 익명 사용자 자동 정리 기능은 어떻게 작동하나요?", "answer": "계정을 만든 지 30일이 지나면 익명 계정이 자동으로 삭제되도록 설정할 수 있습니다. 또한 익명 계정은 더 이상 결제 및 사용 할당량에 포함되지 않습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 멀티테넌시 기능을 어떻게 활용하나요?", "answer": "테넌트를 사용하면 단일 프로젝트 내에 사용자 및 구성의 고유한 사일로를 여러 개 만들 수 있습니다. Cloud Identity Platform 문서에서 멀티테넌시 시작하기를 참조하세요.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication의 익명 사용자 자동 정리 기능은 어떻게 설정하나요?", "answer": "계정을 만든 지 30일이 지나면 익명 계정이 자동으로 삭제되도록 설정할 수 있습니다. 또한 익명 계정은 더 이상 결제 및 사용 할당량에 포함되지 않습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication의 무료(Spark) 요금제에서 일일 활성 사용자(DAU) 한도는 어떻게 되나요?", "answer": "무료(Spark) 요금제의 프로젝트에서는 대부분의 로그인 제공업체에 대해 일일 활성 사용자(DAU)가 3,000명으로 새로 제한됩니다. 일일 활성 사용량은 24시간 동안의 순 사용자 로그인 수를 기준으로 계산됩니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication의 사용한 만큼만 지불(Blaze) 요금제에서 MAU 비용은 어떻게 계산되나요?", "answer": "Blaze 요금제의 프로젝트 가격은 월간 활성 사용자 수(MAU)를 기준으로 하며 무료 등급 사용자 50,000명을 포함합니다. 활성 사용자는 해당 결제 기간 내에 계정을 사용한 사용자입니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하여 사용자를 앱에 로그인시키는 기본 원리는 무엇인가요?", "answer": "사용자를 앱에 로그인시키려면 우선 사용자에게서 인증 정보를 받아야 합니다. 이 사용자 인증 정보는 사용자의 이메일 주소와 비밀번호일 수도 있고, 제휴 ID 공급업체에서 받은 OAuth 토큰일 수도 있습니다. 그런 다음 이 사용자 인증 정보를 Firebase Authentication SDK로 전달합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "FirebaseUI 인증을 사용하여 로그인 UI를 맞춤설정하는 방법은 무엇인가요?", "answer": "FirebaseUI 옵션을 설정하여 로그인 UI를 맞춤설정하거나 GitHub의 코드를 퍼 와서 로그인 경험을 한층 더 맞춤설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication SDK를 사용하여 이메일 주소와 비밀번호 로그인을 구현하는 흐름은 어떻게 되나요?", "answer": "이메일 주소 및 비밀번호를 통한 로그인의 경우 사용자에게 이메일 주소와 비밀번호를 입력하도록 하는 흐름을 구현합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "전화번호 로그인을 구현하기 위한 사용자 흐름은 어떻게 설정하나요?", "answer": "전화번호 로그인의 경우 사용자에게 전화번호를 요청한 후 수신된 SMS 메시지의 코드를 입력하도록 안내하는 흐름을 만듭니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase Authentication SDK에 사용자 인증 정보를 전달하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소와 비밀번호, 또는 제휴 ID 공급업체에서 받은 OAuth 토큰을 Firebase Authentication SDK에 전달합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase 콘솔에서 로그인 방법을 설정하는 절차는 어떻게 되나요?", "answer": "이메일 주소와 비밀번호 로그인, 전화번호 로그인 및 지원할 제휴 ID 공급업체를 통한 로그인은 Firebase 콘솔에서 사용 설정하고 OAuth 리디렉션 URL 설정과 같은 ID 공급업체의 요건에 따라 구성을 완료합니다.", "source": ["https://firebase.google.com/docs/auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_hl=ko.txt"}
{"question": "Firebase에서 사용자가 여러 인증 제공업체를 통해 로그인할 수 있도록 하려면 어떻게 해야 하나요?", "answer": "사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있도록 하려면, 기존 사용자 계정에 인증 제공업체의 사용자 인증 정보를 연결해야 합니다. 이를 위해 사용자를 인증 제공업체 또는 인증 방법을 사용해 로그인 처리한 후, 새로운 인증 제공업체의 FIRAuthCredential을 가져와야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_account-linking_hl=ko.txt"}
{"question": "Google 로그인에서 FIRAuthCredential을 가져오는 방법은 무엇인가요?", "answer": "Google 로그인에서 FIRAuthCredential을 가져오는 방법은 다음과 같습니다. Swift에서는 다음과 같이 작성합니다:\n```swift\nguard\n```", "source": ["https://firebase.google.com/docs/auth/ios/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_account-linking_hl=ko.txt"}
{"question": "Facebook 로그인에서 FIRAuthCredential을 가져오는 방법은 무엇인가요?", "answer": "Facebook 로그인에서 FIRAuthCredential을 가져오는 방법은 다음과 같습니다. Objective-C에서는 다음과 같이 작성합니다:\n```objective-c\nFIRAuthCredential *credential = [FIRFacebookAuthProvider\n```", "source": ["https://firebase.google.com/docs/auth/ios/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_account-linking_hl=ko.txt"}
{"question": "사용자가 인증 제공업체의 사용자 인증 정보를 연결할 때 발생할 수 있는 오류는 무엇인가요?", "answer": "사용자가 인증 제공업체의 사용자 인증 정보를 연결할 때 발생할 수 있는 오류 중 하나는 FIRAuthErrorCodeSecondFactorRequired입니다. 이 오류는 다단계 인증(MFA)이 활성화된 경우 발생할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_account-linking_hl=ko.txt"}
{"question": "다단계 인증(MFA) 사용 시 Firebase에서 사용자 인증을 완료하는 방법은 무엇인가요?", "answer": "다단계 인증(MFA) 사용 시 Firebase에서 사용자 인증을 완료하는 방법은 다음과 같습니다. 먼저, FIRMultiFactorResolver를 통해 다단계 인증 정보를 가져온 후, 선택한 인증 방법으로 인증을 완료해야 합니다. Objective-C에서는 다음과 같이 작성합니다:\n```objective-c\nFIRMultiFactorAssertion *assertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];\n[resolver resolveSignInWithAssertion:assertion completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\nif (error) {\n[self showMessagePrompt:error.localizedDescription];\nNSLog(@\"Multi factor finanlize sign in succeeded.\");\nFIRUser *user = authResult.user;\n```", "source": ["https://firebase.google.com/docs/auth/ios/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_account-linking_hl=ko.txt"}
{"question": "Firebase에서 익명 인증을 사용하기 위해 필요한 초기 설정은 무엇인가요?", "answer": "Firebase에서 익명 인증을 사용하기 위해서는 먼저 Firebase Console에서 인증 섹션을 열고 로그인 방법 페이지에서 익명 로그인 방법을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "SwiftUI에서 Firebase 익명 인증을 구현하는 기본 코드는 어떻게 되나요?", "answer": "SwiftUI에서 Firebase 익명 인증을 구현하기 위한 기본 코드는 다음과 같습니다:\n\n```swift\n@main\nstruct YourApp: App {\n    ContentView()\n    Auth.auth().signInAnonymously { authResult, error in\n        // Handle result\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "익명 계정을 영구 계정으로 전환하는 과정은 어떻게 되나요?", "answer": "익명 계정을 영구 계정으로 전환하기 위해서는 사용자가 가입할 때 해당 사용자가 선택한 인증 제공업체의 로그인 과정을 진행하되 FIRAuth.signInWith 메서드 호출 전까지만 진행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 계정의 자동 정리 기능은 무엇인가요?", "answer": "자동 정리 기능은 30일이 지난 익명 계정을 자동으로 삭제하는 기능입니다. 이 기능이 사용 설정된 프로젝트에서는 익명 인증이 더 이상 사용량 한도 또는 결제 할당량에 포함되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 인증을 사용할 때 IP 주소에 대한 제한이 있나요?", "answer": "네, Firebase에서는 짧은 시간 동안 같은 IP 주소에서 이메일/비밀번호 및 익명 방식으로 애플리케이션에 새로 가입할 수 있는 횟수를 제한합니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 사용자가 앱에 가입할 때 어떤 절차를 따라야 하나요?", "answer": "익명 사용자가 앱에 가입할 때는 해당 사용자가 선택한 인증 제공업체의 로그인 과정을 진행하되 FIRAuth.signInWith 메서드 호출 전까지만 진행해야 합니다. 예를 들어 사용자의 Google ID 토큰, Facebook 액세스 토큰 또는 이메일 주소와 비밀번호를 가져와야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "SwiftUI에서 Firebase 익명 인증을 설정할 때 앱 대리자를 어떻게 구성하나요?", "answer": "SwiftUI를 사용하는 경우 앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 앱 대리자 재구성도 중지해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 인증을 사용하여 로그인을 구현하는 Objective-C 코드는 어떻게 되나요?", "answer": "Objective-C에서 익명 인증을 사용하여 로그인을 구현하는 코드는 다음과 같습니다.\n```objective-c\n[[FIRAuth auth] signInAnonymouslyWithCompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\n    guard let user = authResult?.user else { return }\n    FIRUser *user = authResult.user;\n    BOOL isAnonymous = user.anonymous;  // YES\n    NSString *uid = user.uid;\n}];\n```", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 계정을 영구 계정으로 전환할 때 필요한 인증 제공업체의 자격 증명은 어떻게 가져오나요?", "answer": "익명 계정을 영구 계정으로 전환할 때는 새로운 인증 제공업체의 FIRAuthCredential을 가져와야 합니다. 예를 들어 Google 로그인의 경우 다음과 같이 자격 증명을 가져올 수 있습니다.\n```swift\nguard\n```", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Firebase에서 익명 인증을 사용할 때 IP 주소에 대한 가입 횟수 제한은 어떻게 되나요?", "answer": "Firebase에서는 짧은 시간 동안 같은 IP 주소에서 이메일/비밀번호 및 익명 방식으로 애플리케이션에 새로 가입할 수 있는 횟수를 제한합니다. Firebase Console에서 이 할당량의 한시적 변경을 요청하거나 예약할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_anonymous-auth_hl=ko.txt"}
{"question": "Apple로 로그인 기능을 사용하기 위해 사용자가 충족해야 하는 조건은 무엇인가요?", "answer": "Apple로 로그인하려면 사용자는 다음을 충족해야 합니다.\n\n- 2단계 인증(2FA)이 사용 설정된 Apple ID가 있어야 합니다.\n- Apple 기기에서 iCloud에 로그인되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인을 사용 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "사용자가 Apple 계정을 통해 로그인하도록 하려면 우선 Apple의 개발자 사이트에서 Apple로 로그인을 구성하고 Firebase 프로젝트에서 로그인 제공업체를 Apple로 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple로 로그인 기능을 구성하기 위해 Firebase Console에서 어떤 작업을 수행해야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Apple 제공업체를 사용 설정해야 합니다. 이전 섹션에서 만든 서비스 ID를 지정하고, OAuth 코드 흐름 구성 섹션에서도 Apple 팀 ID 외에 이전 섹션에서 만든 비공개 키 및 키 ID를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 익명 처리된 데이터 요구사항을 준수하기 위해 개발자가 알아야 할 사항은 무엇인가요?", "answer": "Apple로 로그인에는 사용자가 로그인할 때 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션이 제공됩니다. 이 옵션을 선택한 사용자는 privaterelay.appleid.com 도메인의 이메일 주소를 갖게 됩니다. 앱에서 Apple로 로그인을 사용하는 경우 이 익명처리된 Apple ID에 대한 Apple의 관련 개발자 정책 또는 약관을 모두 준수해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple 계정으로 인증하기 위해 Firebase AuthCredential 객체를 생성하는 방법은 무엇인가요?", "answer": "Apple 계정으로 인증하려면 우선 사용자가 Apple의 AuthenticationServices 프레임워크를 통해 Apple 계정에 로그인하도록 한 다음 Apple의 응답에서 ID 토큰을 사용하여 Firebase AuthCredential 객체를 만듭니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple 비공개 이메일 릴레이 서비스를 구성하기 위해 어떤 이메일 주소를 등록해야 하나요?", "answer": "noreply@YOUR_FIREBASE_PROJECT_ID.firebaseapp.com(또는 맞춤설정된 이메일 템플릿 도메인)을 등록해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Firebase Console에서 Apple 제공업체를 사용 설정하기 위해 어떤 단계를 거쳐야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Apple 제공업체를 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 선택할 수 있는 데이터 익명처리 옵션은 무엇인가요?", "answer": "사용자는 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션을 선택할 수 있으며, 이 경우 privaterelay.appleid.com 도메인의 이메일 주소를 갖게 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple 계정으로 인증하기 위해 Firebase AuthCredential 객체를 생성하는 과정은 어떻게 되나요?", "answer": "사용자가 Apple의 AuthenticationServices 프레임워크를 통해 Apple 계정에 로그인한 후, Apple의 응답에서 ID 토큰을 사용하여 Firebase AuthCredential 객체를 만듭니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple의 로그인 요청에서 nonce를 생성하는 방법은 무엇인가요?", "answer": "다음 예시와 같이 SecRandomCopyBytes(_:_:_)를 사용하여 암호로 보호된 nonce를 생성할 수 있습니다.\n\nSwift\nprivate func randomNonceString(length: Int = 32) -> String {\nprecondition(length > 0)\n\"Unable to generate nonce.\"\nArray(\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\")", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Swift에서 nonce를 생성하는 방법은 무엇인가요?", "answer": "Swift에서 nonce를 생성하기 위해서는 다음과 같은 함수를 사용할 수 있습니다. 이 함수는 주어진 길이의 무작위 문자열을 생성합니다.\n\n```swift\nprivate func randomNonceString(length: Int = 32) -> String {\n    precondition(length > 0)\n    let characters = Array(\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\")\n    var result = \"\"\n    for _ in 0..<length {\n        result.append(characters[Int(arc4random_uniform(UInt32(characters.count)))])\n    }\n    return result\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Objective-C에서 nonce를 생성하는 방법은 무엇인가요?", "answer": "Objective-C에서 nonce를 생성하기 위해서는 다음과 같은 코드를 사용할 수 있습니다. 이 코드는 주어진 길이의 무작위 문자열을 생성합니다.\n\n```objective-c\n- (NSString *)randomNonceString:(NSInteger)length {\n    NSAssert(length > 0, @\"Expected nonce to have positive length\");\n    NSString *characterSet = @\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\";\n    NSMutableString *result = [NSMutableString string];\n    NSInteger remainingLength = length;\n\n    while (remainingLength > 0) {\n        NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];\n        for (NSInteger i = 0; i < 16; i++) {\n            uint8_t random = 0;\n            int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);\n            NSAssert(errorCode == errSecSuccess, @\"Unable to generate nonce: OSStatus %i\", errorCode);\n            [randoms addObject:@(random)];\n        }\n        // Append random characters to result\n        for (NSInteger i = 0; i < 16; i++) {\n            [result appendFormat:@\"%C\", characterSet[randoms[i].integerValue]];\n            remainingLength--;\n        }\n    }\n    return result;\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple의 로그인 요청에서 nonce의 SHA256 해시를 포함하는 방법은 무엇인가요?", "answer": "Apple의 로그인 요청에서 nonce의 SHA256 해시를 포함하기 위해서는 다음과 같은 코드를 사용할 수 있습니다. 이 코드는 nonce를 SHA256 해시로 변환하여 요청에 포함합니다.\n\n```swift\nrequest.nonce = sha256(nonce)\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple의 로그인 요청을 시작하는 방법은 무엇인가요?", "answer": "Apple의 로그인 요청을 시작하기 위해서는 다음과 같은 코드를 사용할 수 있습니다. 이 코드는 ASAuthorizationAppleIDRequest를 생성하고 요청을 수행합니다.\n\n```objective-c\n- (void)startSignInWithAppleFlow {\n    NSString *nonce = [self randomNonce:32];\n    self.currentNonce = nonce;\n    ASAuthorizationAppleIDProvider *appleIDProvider = [[ASAuthorizationAppleIDProvider alloc] init];\n    ASAuthorizationAppleIDRequest *request = [appleIDProvider createRequest];\n    request.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n    request.nonce = [self stringBySha256HashingString:nonce];\n\n    ASAuthorizationController *authorizationController =\n    [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[request]];\n    authorizationController.delegate = self;\n    authorizationController.presentationContextProvider = self;\n    [authorizationController performRequests];\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple의 로그인 응답을 처리하는 방법은 무엇인가요?", "answer": "Apple의 로그인 응답을 처리하기 위해서는 ASAuthorizationControllerDelegate를 구현해야 합니다. 다음은 응답을 처리하는 예시 코드입니다.\n\n```swift\n@available(iOS 13.0, *)\nextension MainViewController: ASAuthorizationControllerDelegate {\n    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {\n        if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential {\n            guard let nonce = currentNonce else {\n                fatalError(\"Invalid state: A login callback was received, but no login request was sent.\");\n            }\n            // Handle the credential\n        }\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 처음 로그인할 때 Firebase가 표시 이름을 저장하도록 하려면 어떤 메서드를 사용해야 하나요?", "answer": "사용자가 Apple을 통해 처음 로그인할 때 Firebase가 표시 이름을 저장하도록 하려면 `OAuthProvider.appleCredential(withIDToken:rawNonce:fullName:)` 메서드를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Apple로 로그인 사용자 인증 정보를 다른 계정에 연결하려면 어떤 절차를 따라야 하나요?", "answer": "Apple로 로그인 사용자 인증 정보를 다른 계정에 연결하려면 먼저 이전의 Apple로 로그인 사용자 인증 정보로 계정 연결을 시도한 다음 반환된 오류를 검사하여 새 사용자 인증 정보를 찾아야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인으로 사용자를 생성할 때 사용자 토큰은 어떻게 처리되나요?", "answer": "Apple로 로그인으로 사용자를 생성할 때 Firebase는 사용자 토큰을 저장하지 않으므로 토큰을 취소하고 계정을 삭제하기 전에 사용자에게 다시 로그인하도록 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Swift에서 Apple ID 인증 요청을 수행하기 위해 nonce를 SHA256 해시로 변환하는 방법은 무엇인가요?", "answer": "Swift에서 nonce를 SHA256 해시로 변환하려면 다음과 같이 작성합니다:\n```swift\nrequest.nonce = CryptoUtils.sha256(nonce)\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Objective-C에서 Firebase에서 사용자를 로그아웃할 때 발생할 수 있는 오류를 처리하는 방법은 무엇인가요?", "answer": "Objective-C에서 Firebase에서 사용자를 로그아웃할 때 발생할 수 있는 오류를 처리하려면 다음과 같이 작성합니다:\n```objective-c\nNSError *signOutError;\nBOOL status = [[FIRAuth auth] signOut:&signOutError];\nif (!status) {\n    NSLog(@\"Error signing out: %@\", signOutError);\n    return;\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_apple_hl=ko.txt"}
{"question": "Firebase 프로젝트를 만들고 앱을 등록하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트가 없는 경우, Firebase 프로젝트를 만들고 앱을 등록하려면 [여기](https://firebase.google.com/docs/ios/setup?hl=ko)를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/ios/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_custom-auth_hl=ko.txt"}
{"question": "Swift Package Manager를 사용하여 Firebase 종속 항목을 설치하는 방법은 무엇인가요?", "answer": "Swift Package Manager를 사용해 Firebase 종속 항목을 설치하려면, Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동한 후, Firebase Apple 플랫폼 SDK 저장소를 추가합니다: https://github.com/firebase/firebase-ios-sdk.git.", "source": ["https://firebase.google.com/docs/auth/ios/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_custom-auth_hl=ko.txt"}
{"question": "Firebase Authentication 라이브러리를 추가한 후 어떤 설정을 해야 하나요?", "answer": "Firebase Authentication 라이브러리를 추가한 후, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_custom-auth_hl=ko.txt"}
{"question": "Firebase Admin SDK의 서비스 계정 키를 생성하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK의 서비스 계정 키를 생성하려면, 프로젝트 설정의 서비스 계정 페이지로 이동하여 '새 비공개 키 생성'을 클릭합니다. 이 파일이 자동으로 컴퓨터에 저장됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_custom-auth_hl=ko.txt"}
{"question": "SwiftUI에서 Firebase를 설정하는 방법은 무엇인가요?", "answer": "SwiftUI에서 Firebase를 설정하려면, 앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 예시는 다음과 같습니다:\n\n```swift\n@main\nstruct YourApp: App {\n    ContentView()\n    Auth.auth().signIn(withCustomToken: customToken ?? \"\") { user, error in\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_custom-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 이메일 링크 로그인을 사용 설정하려면 어떤 단계를 따라야 하나요?", "answer": "Firebase 프로젝트에서 이메일 링크 로그인을 사용 설정하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정해야 합니다. 이메일 링크 로그인을 사용하려면 이메일/비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인을 사용 설정한 후 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "사용자의 이메일 주소로 인증 링크를 전송하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소로 인증 링크를 전송하려면 사용자에게 이메일 주소를 제공하도록 요청하는 인터페이스를 표시하고 sendSignInLink을 호출하여 Firebase가 사용자의 이메일에 인증 링크를 전송하도록 요청해야 합니다. 이때 Firebase에 이메일 링크를 만드는 방법에 대한 지침을 제공하는 ActionCodeSettings 객체를 만들어야 하며, 다음 필드를 설정해야 합니다: url, iOSBundleID, androidPackageName, handleCodeInApp.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "ActionCodeSettings 객체에서 설정해야 하는 필드는 무엇인가요?", "answer": "ActionCodeSettings 객체에서 설정해야 하는 필드는 다음과 같습니다: url(삽입할 딥 링크 및 함께 전달할 추가 상태), iOSBundleID, androidPackageName, handleCodeInApp(true로 설정).", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 승인된 도메인을 설정하는 방법은 무엇인가요?", "answer": "Firebase Authentication에서 승인된 도메인을 설정하려면 로그인 방법 탭(인증 -> 로그인 방법)으로 이동하여 링크의 도메인을 허용 목록에 추가해야 합니다. 2025년 4월 28일 이후에 생성된 프로젝트에서는 기본적으로 localhost가 승인된 도메인으로 포함되지 않으므로, 프로덕션 프로젝트에서는 localhost를 사용하지 않는 것이 좋습니다. localhost를 승인하는 경우 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase SDK를 Apple 프로젝트에 추가하는 방법은 무엇인가요?", "answer": "Firebase SDK를 Apple 프로젝트에 추가하는 방법은 여러 가지가 있으며, Swift Package Manager를 사용해 Firebase 종속 항목을 설치하고 관리할 수 있습니다. Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동하여 Firebase Apple 플랫폼 SDK 저장소(https://github.com/firebase/firebase-ios-sdk.git)를 추가하고, Firebase Authentication 라이브러리를 선택한 후, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase SDK를 Apple 프로젝트에 추가하는 방법은 무엇인가요?", "answer": "앱 프로젝트를 연 상태로 Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동합니다. 메시지가 표시되면 Firebase Apple 플랫폼 SDK 저장소를 추가합니다. \n\n```\nhttps://github.com/firebase/firebase-ios-sdk.git\n```\n참고: 새 프로젝트에서 기본(최신) SDK 버전을 사용해야 하지만, 필요하면 이전 버전을 선택할 수도 있습니다. Firebase Authentication 라이브러리를 선택합니다. 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다. 완료되면 Xcode가 백그라운드에서 자동으로 종속 항목을 확인하고 다운로드하기 시작합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 사용 설정하기 위한 조건은 무엇인가요?", "answer": "Firebase 프로젝트에서 이메일 링크로 사용자를 로그인 처리하려면 우선 Firebase 프로젝트에서 이메일 제공업체 및 이메일 링크 로그인을 사용 설정해야 합니다. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다. 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정합니다. 이메일 링크 로그인을 사용하려면 이메일/비밀번호 로그인이 사용 설정되어야 합니다. 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인을 사용 설정합니다. 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "ActionCodeSettings 객체에서 iOSBundleID와 androidPackageName을 설정하는 방법은 무엇인가요?", "answer": "Swift에서 ActionCodeSettings 객체의 iOSBundleID와 androidPackageName을 설정하는 방법은 다음과 같습니다. \n\n```\nactionCodeSettings.setIOSBundleID(Bundle.main.bundleIdentifier!)\nactionCodeSettings.setAndroidPackageName(\"com.example.android\",\ninstallIfNotAvailable: false, minimumVersion: \"12\")\n```\nObjective-C에서는 다음과 같이 설정할 수 있습니다. \n\n```\nFIRActionCodeSettings *actionCodeSettings = [[FIRActionCodeSettings alloc] init];\n[actionCodeSettings setURL:[NSURL URLWithString:@\"https://www.example.com\"]];\n[actionCodeSettings setIOSBundleID:[[NSBundle mainBundle] bundleIdentifier]];\n[actionCodeSettings setAndroidPackageName:@\"com.example.android\"\ninstallIfNotAvailable:NO];\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크를 전송하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소로 인증 링크를 전송하려면 사용자의 이메일 주소를 제공하도록 요청하는 인터페이스를 표시하고 sendSignInLink을 호출하여 Firebase가 사용자의 이메일에 인증 링크를 전송하도록 요청합니다. Swift에서는 다음과 같이 사용할 수 있습니다. \n\n```\nAuth.auth().sendSignInLink(toEmail: email,\nactionCodeSettings: actionCodeSettings) { error in\nreturn\n}\n```\nObjective-C에서는 다음과 같이 사용할 수 있습니다. \n\n```\n[[FIRAuth auth] sendSignInLinkToEmail:email\nactionCodeSettings:actionCodeSettings\ncompletion:^(NSError *_Nullable error) {\nreturn;\n[self showMessagePrompt:@\"Check your email for link\"];\n}];\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 완료하는 방법은 무엇인가요?", "answer": "Firebase Authentication에서는 Firebase Hosting을 사용하여 모바일 기기로 이메일 링크를 보냅니다. 모바일 애플리케이션으로 로그인을 완료하는 경우 애플리케이션에서 수신 애플리케이션 링크를 감지하고 이 링크에 포함된 딥 링크를 파싱한 다음 로그인을 완료하도록 구성해야 합니다. 이를 수행하는 방법에 관한 자세한 내용은 iOS의 범용 링크 및 연결된 도메인 [https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content/]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 위해 앱에서 수신 링크를 어떻게 처리해야 하나요?", "answer": "Firebase Authentication에서는 모바일 애플리케이션에서 열릴 링크를 보낼 때 Firebase Hosting 도메인을 사용합니다. 수신 링크를 가로채도록 앱을 구성할 때, 이메일 링크 인증을 위한 링크인지 확인하고 로그인을 완료해야 합니다. 아래는 Swift와 Objective-C에서 수신 링크를 처리하는 방법입니다.\n\nSwift\n```swift\nif Auth.auth().isSignIn(withEmailLink: link) {\n    Auth.auth().signIn(withEmail: email, link: self.link) { user, error in\n        // Handle sign-in\n    }\n}\n```\n\nObjective-C\n```objective-c\nif ([[FIRAuth auth] isSignInWithEmailLink:link]) {\n    [[FIRAuth auth] signInWithEmail:email link:link completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\n        // Handle sign-in\n    }];\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Hosting 도메인을 구성하는 방법은 무엇인가요?", "answer": "Firebase Hosting 도메인을 구성하려면 Firebase Console에서 호스팅 섹션을 엽니다. 모바일 애플리케이션에서 열리는 이메일 링크에 기본 도메인을 사용하려면 기본 사이트로 이동하여 기본 Hosting 도메인을 기록합니다. 기본 Hosting 도메인의 형식은 일반적으로 다음과 같습니다: PROJECT_ID.firebaseapp.com.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 위해 handleCodeInApp을 true로 설정하는 이유는 무엇인가요?", "answer": "handleCodeInApp을 true로 설정하는 이유는 다른 대역 외 이메일 작업(비밀번호 재설정 및 이메일 인증)과 달리 이 로그인 작업은 항상 앱에서 완료해야 하기 때문입니다. 인증 과정 마지막에 사용자가 로그인하고 사용자의 인증 상태를 앱에서 유지해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 커스텀 도메인을 사용하려면 어떻게 해야 하나요?", "answer": "이메일 링크에 커스텀 도메인을 사용하려면 Firebase Hosting에 도메인을 등록하여 링크의 도메인으로 사용할 수 있습니다. 이를 위해 Firebase Console에서 호스팅 섹션을 열고 도메인을 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 링크 로그인을 위한 iOSBundleID와 androidPackageName을 설정하는 방법은 무엇인가요?", "answer": "iOSBundleID 및 androidPackageName은 Firebase Authentication이 Android 또는 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. 아래는 Swift에서 설정하는 방법입니다.\n\nSwift\n```swift\nactionCodeSettings.setIOSBundleID(Bundle.main.bundleIdentifier!)\nactionCodeSettings.setAndroidPackageName(\"com.example.android\", installIfNotAvailable: false, minimumVersion: \"12\")\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Hosting 도메인을 구성하는 방법은 무엇인가요?", "answer": "Firebase Hosting 도메인을 구성하려면 Firebase Console에서 호스팅 섹션을 열고, 기본 사이트로 이동하여 기본 Hosting 도메인을 기록합니다. 기본 Hosting 도메인의 형식은 일반적으로 다음과 같습니다: PROJECT_ID.firebaseapp.com.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 인증을 위한 링크를 수신한 후 어떻게 확인하나요?", "answer": "링크를 수신한 후, 이메일 링크 인증을 위한 링크인지 확인하고 로그인을 완료합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Swift에서 이메일 링크로 로그인을 처리하는 방법은 무엇인가요?", "answer": "Swift에서 이메일 링크로 로그인을 처리하려면 다음 코드를 사용합니다:\n```swift\nif Auth.auth().isSignIn(withEmailLink: link) {\n    Auth.auth().signIn(withEmail: email, link: self.link) { user, error in\n        // Handle result\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Objective-C에서 이메일 링크로 로그인을 처리하는 방법은 무엇인가요?", "answer": "Objective-C에서 이메일 링크로 로그인을 처리하려면 다음 코드를 사용합니다:\n```objective-c\nif ([[FIRAuth auth] isSignInWithEmailLink:link]) {\n    [[FIRAuth auth] signInWithEmail:email link:link completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\n        // Handle result\n    }];\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "기존 사용자에게 이메일 링크 인증 방법을 연결하는 방법은 무엇인가요?", "answer": "기존 사용자에게 이메일 링크 인증 방법을 연결하려면 다음 코드를 사용합니다:\n```objective-c\nFIRAuthCredential *credential = [FIREmailAuthProvider credentialWithEmail:email link:link];\n[FIRAuth auth].currentUser linkWithCredential:credential completion:^(FIRAuthDataResult *_Nullable result, NSError *_Nullable error) {\n    if (error) {\n        // Handle error\n    }\n};\n```", "source": ["https://firebase.google.com/docs/auth/ios/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-auth_hl=ko.txt"}
{"question": "Firebase Dynamic Links에서 이메일 링크 로그인을 마이그레이션할 때 어떤 Firebase Hosting 도메인을 사용해야 하나요?", "answer": "앞으로 Firebase Authentication은 Firebase Dynamic Links 도메인을 사용하는 대신 프로젝트의 Firebase Hosting 기본 도메인을 사용하여 모바일 앱에서 이메일 링크 및 기타 대역 외 링크 작업의 링크를 만듭니다. 기본 Firebase Hosting 도메인은 applinks:PROJECT_ID.firebaseapp.com입니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-migration_hl=ko.txt"}
{"question": "이메일 링크 인증을 위해 Firebase Hosting 도메인을 앱에 연결하는 방법은 무엇인가요?", "answer": "앱에서 사용 권한을 설정하려면 Xcode에서 대상의 서명 및 기능 탭을 열고 이전 단계의 Firebase Hosting 도메인을 연결된 도메인 기능에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-migration_hl=ko.txt"}
{"question": "Firebase Hosting 도메인에 연결된 도메인 파일을 배포하는 방법은 무엇인가요?", "answer": "연결된 도메인 파일이 모든 Firebase Hosting 도메인에 배포되었습니다. 액세스하려면 PROJECT_ID.firebaseapp.com/.well-known/apple-app-site-association으로 이동하세요.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-migration_hl=ko.txt"}
{"question": "Firebase Dynamic Links 기능이 더 이상 지원되지 않는 경우, 기존 인텐트 필터를 유지해야 하는 이유는 무엇인가요?", "answer": "원활한 롤백을 위해 Firebase Hosting 링크 솔루션을 사용해 보는 동안 Firebase Dynamic Links를 처리하는 기존 인텐트 필터를 유지하는 것이 좋습니다. Firebase Dynamic Links 솔루션은 2025년 8월 25일까지 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-migration_hl=ko.txt"}
{"question": "이메일 링크 생성을 업데이트하기 위해 Firebase Admin SDK를 사용하는 방법은 무엇인가요?", "answer": "Firebase Admin SDK를 사용하여 이메일 링크 생성 방식을 업데이트하고 백엔드에 새 Firebase Hosting 도메인을 사용하여 링크 생성을 시작하도록 지시할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/email-link-migration?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_email-link-migration_hl=ko.txt"}
{"question": "FIRAuthErrorCodeUserTokenExpired 오류가 발생했을 때 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeUserTokenExpired 오류가 발생하면 사용자를 다시 로그인 처리해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeNetworkError가 발생했을 때 재시도해도 되나요?", "answer": "FIRAuthErrorCodeNetworkError 또는 FIRAuthErrorCodeTooManyRequests가 아니라면 실패한 작업을 같은 인수로 재시도해선 절대로 성공할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeInvalidAPIKey 오류의 원인은 무엇인가요?", "answer": "FIRAuthErrorCodeInvalidAPIKey 오류는 애플리케이션 구성의 API 키가 유효하지 않음을 나타냅니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeAppNotAuthorized 오류를 해결하기 위해 어떤 조치를 취해야 하나요?", "answer": "FIRAuthErrorCodeAppNotAuthorized 오류는 제공한 API 키로 앱이 Firebase 인증을 사용할 권한이 없음을 나타냅니다. Google API 콘솔로 가서 사용자 인증 정보 탭에서 사용 중인 API 키의 허용 목록에 애플리케이션의 번들 ID가 등록되어 있는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "signInWithEmail:password:completion: 메서드에서 FIRAuthErrorCodeUserDisabled 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeUserDisabled 오류는 사용자의 계정이 사용 중지 상태임을 나타냅니다. 이 경우 사용자가 계정을 활성화해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeTooManyRequests 오류가 발생했을 때 어떻게 대처해야 하나요?", "answer": "FIRAuthErrorCodeTooManyRequests 오류는 호출 기기에서 Firebase Authentication 서버로 비정상적인 횟수만큼 요청이 이루어진 후 요청이 차단되었음을 나타냅니다. 이 오류가 발생하면 조금 후에 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeKeychainError가 발생했을 때 어떤 정보를 확인해야 하나요?", "answer": "FIRAuthErrorCodeKeychainError는 키체인 액세스 중에 오류가 발생했음을 나타냅니다. NSError.userInfo 사전 내의 NSLocalizedFailureReasonErrorKey 필드와 NSUnderlyingErrorKey 필드에는 오류에 대한 추가 정보가 포함되어 있으므로 이를 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "FIRAuthErrorCodeInternalError가 발생했을 때 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeInternalError는 내부 오류가 발생했음을 나타냅니다. 이 오류가 발생하면 NSError 객체를 모두 포함해 오류를 신고해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "signInWithCredential:completion: 메서드에서 FIRAuthErrorCodeInvalidCredential 오류가 발생하면 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeInvalidCredential 오류는 제공받은 사용자 인증 정보가 유효하지 않음을 나타냅니다. 이 오류는 사용자 인증 정보의 기한이 다했거나 형식이 잘못되었을 때 발생할 수 있습니다. 따라서 사용자 인증 정보를 다시 확인하고 올바른 정보를 제공해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "createUserWithEmail:password:completion: 메서드에서 FIRAuthErrorCodeWeakPassword 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeWeakPassword 오류는 너무 안전성이 낮은 비밀번호를 설정하려고 했음을 나타냅니다. NSError.userInfo 사전 객체 내의 NSLocalizedFailureReasonErrorKey 필드에 사용자에게 표시할 수 있는 자세한 설명이 포함되어 있으므로 이를 참고하여 더 강력한 비밀번호를 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "signInAnonymouslyWithCompletion: 메서드에서 FIRAuthErrorCodeOperationNotAllowed 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeOperationNotAllowed 오류는 익명 계정의 사용 설정이 되어 있지 않음을 나타냅니다. 이 오류를 해결하기 위해서는 Firebase Console의 인증 섹션에서 익명 인증을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "signInWithCustomToken:completion: 메서드에서 FIRAuthErrorCodeInvalidCustomToken 오류가 발생했을 때 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeInvalidCustomToken 오류는 맞춤 토큰의 유효성 검사 오류를 나타냅니다. 이 오류를 해결하기 위해서는 서버에서 생성한 맞춤 토큰이 올바른지 확인하고, 필요한 경우 토큰을 다시 생성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "createUserWithEmail:password:completion: 메서드에서 FIRAuthErrorCodeInvalidEmail 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeInvalidEmail 오류는 이메일 주소의 형식이 잘못되었음을 나타냅니다. 이 오류를 해결하기 위해서는 사용자가 입력한 이메일 주소의 형식을 확인하고, 올바른 형식으로 수정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "reauthenticateWithCredential:completion: 메서드에서 FIRAuthErrorCodeUserMismatch 오류가 발생했을 때 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeUserMismatch 오류는 현재 사용자가 아닌 다른 사용자로 재인증을 시도했음을 나타냅니다. 이 오류를 해결하기 위해서는 올바른 사용자 인증 정보를 사용하여 재인증을 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "updateEmail:completion: 메서드에서 FIRAuthErrorCodeRequiresRecentLogin 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeRequiresRecentLogin 오류는 사용자의 이메일을 변경하는 것이 보안에 민감한 작업이므로 사용자가 최근 로그인한 적이 있어야 함을 나타냅니다. 이 오류를 해결하기 위해서는 사용자가 최근에 로그인하도록 유도한 후 이메일 변경을 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "reauthenticateWithCredential:completion: 메서드에서 FIRAuthErrorCodeWrongPassword 오류가 발생하면 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeWrongPassword 오류는 사용자가 잘못된 비밀번호로 재인증을 시도했음을 나타냅니다. 이 경우 사용자는 올바른 비밀번호를 입력하여 재인증을 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "updatePassword:completion: 메서드에서 FIRAuthErrorCodeWeakPassword 오류가 발생했을 때 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeWeakPassword 오류는 너무 안전성이 낮은 비밀번호를 설정하려고 했음을 나타냅니다. 이 경우 사용자는 더 강력한 비밀번호를 설정해야 합니다. NSError.userInfo 사전 객체 내의 NSLocalizedFailureReasonErrorKey 필드에 사용자에게 표시할 수 있는 자세한 설명이 포함되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "linkWithCredential:completion: 메서드에서 FIRAuthErrorCodeProviderAlreadyLinked 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeProviderAlreadyLinked 오류는 이미 이 계정에 연결되어 있는 유형의 제공업체를 연결하려고 시도했음을 나타냅니다. 이 경우 사용자는 다른 제공업체를 사용하여 연결을 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "unlinkFromProvider:completion: 메서드에서 FIRAuthErrorCodeNoSuchProvider 오류가 발생했을 때 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeNoSuchProvider 오류는 계정에 연결되어 있지 않은 제공업체의 연결을 해제하려고 시도했음을 나타냅니다. 이 경우 사용자는 연결된 제공업체 목록을 확인하고, 연결된 제공업체에 대해서만 연결 해제를 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "updateEmail:completion: 메서드에서 FIRAuthErrorCodeRequiresRecentLogin 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeRequiresRecentLogin 오류는 사용자의 이메일을 변경하는 것은 보안에 민감한 작업이므로 사용자가 최근 로그인한 적이 있어야 진행할 수 있음을 나타냅니다. 이 오류를 해결하려면 FIRUser에 reauthenticateWithCredential:completion:을 호출하여 사용자를 재인증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "updateEmail:completion: 메서드에서 FIRAuthErrorCodeEmailAlreadyInUse 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeEmailAlreadyInUse 오류는 이메일 주소를 이미 다른 계정에서 사용 중임을 나타냅니다. 이 경우, 사용자가 입력한 이메일 주소를 변경하거나 다른 이메일 주소를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "updatePassword:completion: 메서드에서 FIRAuthErrorCodeOperationNotAllowed 오류가 발생했을 때 어떻게 처리해야 하나요?", "answer": "FIRAuthErrorCodeOperationNotAllowed 오류는 관리자가 지정 ID 제공업체의 로그인을 사용 중지했음을 나타냅니다. 이 경우, Firebase Console의 인증 섹션에서 해당 ID 제공업체의 로그인을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "linkWithCredential:completion: 메서드에서 FIRAuthErrorCodeCredentialAlreadyInUse 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeCredentialAlreadyInUse 오류는 이미 다른 Firebase 계정에 연결되어 있는 사용자 인증 정보를 연결하려고 시도했음을 나타냅니다. 이 경우, 다른 인증 정보를 사용하거나 기존 계정의 연결을 해제해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "unlinkFromProvider:completion: 메서드에서 FIRAuthErrorCodeRequiresRecentLogin 오류가 발생했을 때 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeRequiresRecentLogin 오류는 사용자의 이메일을 변경하는 것은 보안에 민감한 작업이므로 사용자가 최근 로그인한 적이 있어야 진행할 수 있음을 나타냅니다. 이 오류를 해결하려면 FIRUser에 reauthenticateWithCredential:completion:을 호출하여 사용자를 재인증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "deleteWithCompletion 메서드에서 FIRAuthErrorCodeRequiresRecentLogin 오류가 발생하면 어떻게 해야 하나요?", "answer": "FIRAuthErrorCodeRequiresRecentLogin 오류는 사용자 계정을 삭제하는 것은 보안에 민감한 작업이므로 사용자가 최근 로그인한 적이 있어야 진행할 수 있음을 나타냅니다. 이 오류를 해결하려면 FIRUser에 reauthenticateWithCredential:completion:을 호출하여 사용자를 재인증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/errors?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_errors_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "Firebase Authentication 라이브러리를 선택하고, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Swift에서 FBSDKLoginButton 객체를 초기화할 때 어떤 대리자를 설정해야 하나요?", "answer": "FBSDKLoginButton 객체를 초기화할 때 로그인 및 로그아웃 이벤트를 받을 대리자를 설정해야 합니다. 예를 들면 다음과 같습니다.\n\n```swift\nlet loginButton = FBSDKLoginButton()\nloginButton.delegate = self\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인이 성공적으로 완료되었을 때, Swift에서 어떤 메서드를 구현해야 하나요?", "answer": "대리자에서 didCompleteWithResult:error: 메서드를 구현해야 합니다. 예를 들면 다음과 같습니다.\n\n```swift\nfunc loginButton(_ loginButton: FBSDKLoginButton!, didCompleteWith result: FBSDKLoginManagerLoginResult!, error: Error!) {\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n    // 로그인 성공 처리\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Facebook Limited 로그인을 구현하기 위해 nonce를 생성하는 방법은 무엇인가요?", "answer": "다음 예시와 같이 SecRandomCopyBytes(_:_:_)를 사용하여 암호로 보호된 nonce를 생성할 수 있습니다.\n\n```swift\nprivate func randomNonceString(length: Int = 32) -> String {\n    precondition(length > 0)\n    // nonce 생성 로직\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "SwiftUI를 사용하는 경우 앱 대리자를 어떻게 설정해야 하나요?", "answer": "앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 자세한 내용은 SwiftUI 안내를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Swift에서 FBSDKLoginButton을 설정할 때 로그인 추적 모드를 어떻게 설정하나요?", "answer": "FBSDKLoginButton을 설정할 때 로그인 추적 모드를 FBSDKLoginTrackingLimited로 설정할 수 있습니다. 예를 들어, 다음과 같이 설정합니다.\n\n```swift\nfunc setupLoginButton() {\n    loginButton.delegate = self\n    loginButton.loginTracking = .limited\n    loginButton.nonce = sha256(nonce)\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Objective-C에서 FBSDKLoginButton의 nonce를 설정하는 방법은 무엇인가요?", "answer": "Objective-C에서 FBSDKLoginButton의 nonce를 설정하려면 다음과 같이 구현합니다.\n\n```objective-c\n- (void)setupLoginButton {\n    NSString *nonce = [self randomNonce:32];\n    self.currentNonce = nonce;\n    self.loginButton.delegate = self;\n    self.loginButton.loginTracking = FBSDKLoginTrackingLimited;\n    self.loginButton.nonce = [self stringBySha256HashingString:nonce];\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 필요한 자격 증명(credential)은 어떻게 생성하나요?", "answer": "Firebase에 인증하기 위해서는 FBSDKAuthenticationToken을 사용하여 ID 토큰을 가져온 후, 다음과 같이 자격 증명(credential)을 생성합니다.\n\n```objective-c\nNSString *idTokenString = FBSDKAuthenticationToken.currentAuthenticationToken.tokenString;\nNSString *rawNonce = self.currentNonce;\nFIROAuthCredential *credential = [FIROAuthProvider credentialWithProviderID:@\"facebook.com\"\n    IDToken:idTokenString];\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Swift에서 Firebase에 인증을 시도할 때 오류가 발생하면 어떻게 처리하나요?", "answer": "Swift에서 Firebase에 인증을 시도할 때 오류가 발생하면 다음과 같이 처리할 수 있습니다.\n\n```swift\nAuth.auth().signIn(with: credential) { authResult, error in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "SwiftUI를 사용할 때 앱 대리자를 어떻게 설정하나요?", "answer": "SwiftUI를 사용할 때 앱 대리자는 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 예를 들어, 다음과 같이 설정합니다.\n\n```swift\n@main\nstruct YourApp: App {\n    ContentView()\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Swift에서 FBSDKLoginButton을 설정할 때 nonce를 생성하는 방법은 무엇인가요?", "answer": "Swift에서 nonce를 생성하려면 randomNonce 메서드를 사용하여 32바이트 길이의 랜덤 문자열을 생성할 수 있습니다. 예를 들어, 다음과 같이 구현할 수 있습니다.\n\n```swift\nfunc randomNonce(length: Int) -> String {\n    var randoms = [UInt8](repeating: 0, count: length)\n    let errorCode = SecRandomCopyBytes(kSecRandomDefault, length, &randoms)\n    NSAssert(errorCode == errSecSuccess, \"Unable to generate nonce: OSStatus %i\", errorCode)\n    return randoms.map { String(format: \"%02x\", $0) }.joined()\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Objective-C에서 Firebase에 인증하기 위해 필요한 자격 증명(credential)은 어떻게 생성하나요?", "answer": "Objective-C에서 Firebase에 인증하기 위해 필요한 자격 증명은 다음과 같이 생성할 수 있습니다. ID 토큰과 nonce를 사용하여 FIROAuthCredential 객체를 생성합니다.\n\n```objective-c\nNSString *idTokenString = FBSDKAuthenticationToken.currentAuthenticationToken.tokenString;\nNSString *rawNonce = self.currentNonce;\nFIROAuthCredential *credential = [FIROAuthProvider credentialWithProviderID:@\"facebook.com\"\nIDToken:idTokenString];\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Swift에서 Firebase에 인증을 시도할 때 발생할 수 있는 오류를 어떻게 처리하나요?", "answer": "Swift에서 Firebase에 인증을 시도할 때 오류가 발생하면, completion 핸들러 내에서 error를 확인하고 적절한 처리를 할 수 있습니다. 예를 들어, 다음과 같이 구현할 수 있습니다.\n\n```swift\nAuth.auth().signIn(with: credential) { authResult, error in\n    if let error = error {\n        print(error.localizedDescription)\n        return\n    }\n    // 인증 성공 처리\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "Objective-C에서 FBSDKLoginButton의 로그인 및 로그아웃 이벤트를 처리하는 방법은 무엇인가요?", "answer": "Objective-C에서 FBSDKLoginButton의 로그인 및 로그아웃 이벤트를 처리하려면, FBSDKLoginButtonDelegate를 구현하고 loginButton:didCompleteWithResult:error: 메서드를 사용하여 결과를 처리합니다. 예를 들어:\n\n```objective-c\n- (void)loginButton:(FBSDKLoginButton *)loginButton\ndidCompleteWithResult:(FBSDKLoginManagerLoginResult *)result\nerror:(NSError *)error {\n    if (error == nil) {\n        NSLog(@\"로그인 성공\");\n    } else {\n        NSLog(error.localizedDescription);\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "SwiftUI를 사용할 때 Firebase 앱 대리자를 어떻게 설정하나요?", "answer": "SwiftUI를 사용할 때 Firebase 앱 대리자는 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 예를 들어:\n\n```swift\n@main\nstruct YourApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_facebook-login_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크 인증을 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정합니다. 이메일 링크 로그인을 사용하려면 이메일 또는 비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인 방법을 사용 설정하고 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Google 로그인을 설정하는 방법은 무엇인가요?", "answer": "이 튜토리얼을 사용하여 Google 로그인 설정을 진행합니다: [Google 로그인 설정 튜토리얼](https://firebase.google.com/docs/auth/ios/google-signin?hl=ko).", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Facebook 로그인을 설정하기 위한 필수 단계는 무엇인가요?", "answer": "Facebook의 시작하기 페이지에 따라 Facebook 로그인 SDK를 설정하고, Firebase Console에서 인증 섹션을 열어 Facebook을 사용 설정해야 합니다. 또한 Facebook 앱 ID와 앱 비밀번호를 입력하고, Xcode 프로젝트에서 키체인 공유를 사용 설정해야 하며, Info.plist 파일에 Facebook 앱 ID와 표시 이름을 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Apple 로그인을 설정하기 위해 필요한 초기화 코드는 무엇인가요?", "answer": "Swift에서 Apple 로그인용으로 구성된 OAuth 제공업체 인스턴스를 초기화하는 코드는 다음과 같습니다:\n```swift\nprovider = FUIOAuth.appleAuthProvider()\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 익명 계정을 ID 공급업체에 연결하는 방법은 무엇인가요?", "answer": "FirebaseUI는 익명 계정을 ID 공급업체에 자동으로 연결하는 흐름을 제공합니다. 이를 통해 사용자는 익명으로 앱을 사용하다가 나중에 계정을 생성할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크 인증을 사용하기 위해 필요한 설정은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정해야 합니다. 이메일 링크 로그인을 사용하려면 이메일 또는 비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인 방법을 사용 설정하고 저장을 클릭해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Apple 로그인을 설정하기 위한 초기화 코드는 무엇인가요?", "answer": "Apple 로그인용으로 구성된 OAuth 제공업체 인스턴스를 초기화하는 코드는 다음과 같습니다.\n\nSwift\n```swift\nprovider = FUIOAuth.appleAuthProvider()\n```\n\nObjective-C\n```objective-c\nFUIOAuth *provider = [FUIOAuth appleAuthProvider];\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Facebook 로그인을 설정하기 위해 Info.plist 파일에 추가해야 할 내용은 무엇인가요?", "answer": "Info.plist 파일에 다음과 같은 Facebook 앱 ID와 표시 이름을 추가해야 합니다.\n\n| 키 | 값 |\n| --- | --- |\n| FacebookAppID | FACEBOOK_APP_ID(예: 1234567890) |\n| FacebookDisplayName | 앱의 이름 |", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Twitter 로그인을 설정하기 위해 필요한 초기화 코드는 무엇인가요?", "answer": "Twitter 로그인용으로 구성된 OAuth 제공업체 인스턴스를 초기화하는 코드는 다음과 같습니다.\n\nSwift\n```swift\nprovider = FUIOAuth.twitterAuthProvider()\n```\n\nObjective-C\n```objective-c\nFUIOAuth *provider = [FUIOAuth twitterAuthProvider];\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 전화번호 로그인을 사용하기 위해 Firebase Console에서 어떤 설정을 해야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 전화번호 로그인을 사용 설정해야 합니다. 또한 Firebase에서 전화번호 로그인 요청이 내 앱에서 발생한 것인지 확인할 수 있어야 하며, 확인 방법 중 하나는 APN 알림을 통해 확인하는 것입니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 Twitter 로그인을 설정하기 위한 초기화 코드는 무엇인가요?", "answer": "Twitter 로그인용으로 구성된 OAuth 제공업체 인스턴스를 초기화하려면 다음 코드를 사용합니다.\n\nSwift\nprovider = FUIOAuth.twitterAuthProvider()\n\nObjective-C\nFUIOAuth *provider = [FUIOAuth twitterAuthProvider];", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 전화번호 로그인을 사용하기 위해 Firebase Console에서 어떤 설정을 해야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 전화번호 로그인을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 APN 알림을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 전화번호 로그인 요청이 내 앱에서 발생한 것인지 확인하기 위해 APN 알림을 사용 설정해야 합니다. Xcode에서 프로젝트에 푸시 알림을 사용 설정하고, Firebase에 APNs 인증 키를 업로드해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 reCAPTCHA 인증을 사용 설정하려면 어떻게 해야 하나요?", "answer": "reCAPTCHA 인증을 사용 설정하려면 Xcode에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 열고, 대상 섹션에서 앱을 선택한 후 정보 탭을 선택하고 URL 유형 섹션을 펼친 다음 인코딩된 앱 ID를 URL 스키마로 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI 로그인 흐름을 시작하기 위한 초기화 코드는 무엇인가요?", "answer": "FirebaseUI 로그인 흐름을 시작하려면 먼저 FirebaseUI를 초기화해야 합니다. 다음 코드를 사용하세요.\n\nSwift\nimport FirebaseAuthUI\n\nFirebaseApp.configure()\n\nObjective-C\n@import FirebaseAuthUI;\n\n...\n[FIRApp configure];\nFUIAuth *authUI = [FUIAuth defaultAuthUI];", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 APN 인증서를 업로드하는 방법은 무엇인가요?", "answer": "프로덕션 인증 키 또는 둘 다를 업로드합니다. 최소 하나 이상이 필요합니다. 키를 저장한 위치로 이동하여 키를 선택하고 열기를 클릭합니다. 해당하는 키 ID(Apple Developer Member Center [https://developer.apple.com/membercenter/index.action]에서 확인 가능)를 추가하고 업로드를 클릭합니다. APN 인증서가 이미 있다면 인증서를 대신 업로드할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 reCAPTCHA 인증을 사용 설정하는 방법은 무엇인가요?", "answer": "reCAPTCHA 인증을 사용 설정하려면 Xcode에서 다음을 수행합니다. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 [https://console.firebase.google.com/project/_/settings/general/?hl=ko] 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다. 다른 필드는 비워 둡니다.", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 방법 선택기를 가져오는 방법은 무엇인가요?", "answer": "Swift에서 로그인 방법 선택기를 가져오는 방법은 다음과 같습니다. \n```swift\nUINavigationController *authViewController = [authUI authViewController];\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 전화번호 로그인만 사용하려면 어떻게 해야 하나요?", "answer": "전화번호 로그인만 사용하려면 전화번호 로그인 보기를 바로 표시할 수 있습니다. 다음 코드를 사용하세요: \n```swift\nFUIPhoneAuth *phoneProvider = [FUIAuth defaultAuthUI].providers.firstObject;\n[phoneProvider signInWithPresentingViewController:currentlyVisibleController phoneNumber:nil];\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그아웃하는 방법은 무엇인가요?", "answer": "FirebaseUI는 Firebase 인증은 물론 모든 소셜 ID 공급업체에서 로그아웃시키는 편리한 방법을 제공합니다. Swift에서는 다음과 같이 로그아웃할 수 있습니다: \n```swift\nauthUI.signOut()\n```", "source": ["https://firebase.google.com/docs/auth/ios/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_firebaseui_hl=ko.txt"}
{"question": "Game Center를 사용하여 Firebase에 로그인하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "Game Center를 사용하여 Firebase에 로그인하려면 우선 로컬 플레이어가 Game Center에 로그인했는지 확인한 다음 GameCenterAuthProvider 객체를 사용하여 Firebase 사용자 인증 정보를 생성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase 프로젝트에 Game Center를 로그인 제공업체로 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Game Center 로그인 제공업체를 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Game Center 인증 핸들러를 정의하는 이유는 무엇인가요?", "answer": "Game Center 통합의 일부로 Game Center 인증 프로세스의 여러 지점에서 호출되는 인증 핸들러를 정의하여 플레이어가 Game Center로 로그인했는지 확인하고, 로그인한 경우 Firebase에 로그인할 수 있도록 하기 위함입니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "Firebase에서 사용자를 로그아웃시키려면 Auth.signOut()을 호출하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Game Center에서 로컬 플레이어 인증을 확인하기 위한 Objective-C 코드 예시는 무엇인가요?", "answer": "__weak GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];\nlocalPlayer.authenticateHandler = ^(UIViewController *gcAuthViewController,\nNSError *error) {\nif (gcAuthViewController != nil) {", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase에 Apple 앱을 등록하기 위해 필요한 정보는 무엇인가요?", "answer": "Firebase로 Apple 앱을 등록하기 위해서는 앱의 번들 ID와 App Store ID 및 팀 ID와 같은 선택적인 추가 정보를 등록 섹션에 입력해야 합니다. 이 정보는 로그인을 완료하기 전에 Game Center 사용자 인증 정보의 잠재고객을 안전하게 확인하는 데 필요합니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase Console에서 Game Center 로그인 제공업체를 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 탭에서 Game Center 로그인 제공업체를 사용 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Game Center 인증 핸들러를 정의하는 방법은 무엇인가요?", "answer": "Game Center 통합의 일부로 Game Center 인증 프로세스의 여러 지점에서 호출되는 인증 핸들러를 정의해야 합니다. 이 핸들러에서 플레이어가 Game Center로 로그인했는지 확인하고, 로그인한 경우 Firebase에 로그인할 수 있도록 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃시키기 위한 Objective-C 코드 예시는 무엇인가요?", "answer": "Firebase에서 사용자를 로그아웃시키려면 다음과 같은 Objective-C 코드를 사용할 수 있습니다:\n```objective-c\nNSError *signOutError;\nBOOL status = [[FIRAuth auth] signOut:&signOutError];\nif (!status) {\n    NSLog(@\"Error signing out: %@\", signOutError);\n    return;\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Game Center에서 로컬 플레이어 인증을 확인하기 위한 Swift 코드 예시는 무엇인가요?", "answer": "Game Center에서 로컬 플레이어 인증을 확인하기 위해 다음과 같은 Swift 코드를 사용할 수 있습니다:\n```swift\n__weak GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];\nlocalPlayer.authenticateHandler = ^(UIViewController *gcAuthViewController,\nNSError *error) {\n    if (gcAuthViewController != nil) {\n        // Firebase에 인증\n    }\n};\n```", "source": ["https://firebase.google.com/docs/auth/ios/game-center?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_game-center_hl=ko.txt"}
{"question": "Firebase 프로젝트에 GitHub를 로그인 제공업체로 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에 GitHub를 로그인 제공업체로 사용 설정하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고 로그인 방법 탭에서 GitHub 제공업체를 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Xcode에서 Firebase SDK를 설치하는 방법은 무엇인가요?", "answer": "Xcode에서 Firebase SDK를 설치하려면 File(파일) > Add Packages(패키지 추가)로 이동한 후 Firebase Apple 플랫폼 SDK 저장소를 추가합니다: https://github.com/firebase/firebase-ios-sdk.git. Firebase Authentication 라이브러리를 선택하고, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "OAuthProvider 인스턴스를 생성하려면 제공업체 ID OAuthProvider을 사용하여 다음과 같이 코드를 작성합니다:\n\n```swift\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"github.com\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "GitHub OAuth 요청에 맞춤 매개변수를 추가하는 방법은 무엇인가요?", "answer": "GitHub OAuth 요청에 맞춤 매개변수를 추가하려면 다음과 같이 코드를 작성합니다:\n\n```swift\nprovider.customParameters = [\n    \"allow_signup\": \"false\"\n]\n```", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇이며, 어떻게 처리해야 하나요?", "answer": "Firebase에서 요구하는 매개변수는 client_id, redirect_uri, response_type, scope, state입니다. 이러한 매개변수는 setCustomParameters와 함께 전달할 수 없으며, GitHub OAuth 요청 시 별도로 처리해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub OAuth 인증을 위해 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면 다음 단계를 따르세요. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다. 다른 필드는 비워 둡니다.", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub OAuthProvider 인스턴스를 생성하는 Swift 코드 예시는 무엇인가요?", "answer": "다음과 같이 OAuthProvider 인스턴스를 생성할 수 있습니다.\n\n```swift\nlet provider = FIROAuthProvider(providerID: \"github.com\")\n```", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub OAuth 인증 후 기존 제공업체와 연결하는 방법은 무엇인가요?", "answer": "기존 제공업체(Google)에 로그인한 후 신규 제공업체의 FIRAuthCredential(GitHub 사용자 인증 정보)에 연결해야 합니다. 다음은 Swift 코드 예시입니다.\n\n```swift\nlet existingAcctEmail = error.userInfo[FIRAuthErrorUserInfoEmailKey]\nlet pendingCred = error.userInfo[FIRAuthErrorUserInfoUpdatedCredentialKey]\n```\nObjective-C\n```objective-c\nNSError *signOutError;\nBOOL status = [[FIRAuth auth] signOut:&signOutError];\nif (!status) {\n    NSLog(@\"Error signing out: %@\", signOutError);\n    return;\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_github-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 Google 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 Google 로그인을 사용 설정하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 탭에서 Google 제공업체를 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Xcode에서 Google 로그인 SDK를 추가하는 방법은 무엇인가요?", "answer": "Xcode에서 Google 로그인 SDK를 추가하려면 앱 프로젝트를 연 상태로 File(파일) > Add Packages(패키지 추가)로 이동하고, 메시지가 표시되면 Google 로그인 SDK 저장소 https://github.com/google/GoogleSignIn-iOS를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Google 로그인을 구현하기 위해 필요한 헤더 파일은 무엇인가요?", "answer": "Google 로그인을 구현하기 위해 필요한 헤더 파일은 다음과 같습니다. Swift에서는 `import FirebaseCore`, `import FirebaseAuth`, `import GoogleSignIn`을 사용하고, Objective-C에서는 `@import FirebaseCore;`와 `@import GoogleSignIn;`을 사용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면 왼쪽 트리 보기에서 프로젝트 이름을 클릭하여 프로젝트 구성을 열고, 대상 섹션에서 앱을 선택한 후 정보 탭을 선택하고 URL 유형 섹션을 펼칩니다. + 버튼을 클릭하고 반전된 클라이언트 ID의 URL 스키마를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "앱 대리자의 application:didFinishLaunchingWithOptions: 메서드에서 FirebaseApp 객체를 구성하는 방법은 무엇인가요?", "answer": "앱 대리자의 application:didFinishLaunchingWithOptions: 메서드에서 FirebaseApp 객체를 구성하려면 Swift에서는 `FirebaseApp.configure()`를 호출합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase SDK와 Google 로그인 SDK의 헤더 파일을 Swift로 가져오는 방법은 무엇인가요?", "answer": "Swift에서 Firebase SDK와 Google 로그인 SDK의 헤더 파일을 가져오려면 다음 코드를 사용합니다.\n\n```swift\nimport FirebaseCore\nimport FirebaseAuth\nimport GoogleSignIn\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Google 로그인을 구현하기 위해 Xcode 프로젝트에 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면 다음 단계를 따르세요:\n1. 왼쪽 트리 보기에서 프로젝트 이름을 클릭하여 프로젝트 구성을 엽니다.\n2. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다.\n3. + 버튼을 클릭하고 반전된 클라이언트 ID의 URL 스키마를 추가합니다. 이 값은 GoogleService-Info.plist 구성 파일에서 REVERSED_CLIENT_ID 키를 찾아 복사하여 붙여넣습니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "앱 대리자의 application:openURL:options: 메서드를 Swift로 구현하는 방법은 무엇인가요?", "answer": "앱 대리자의 application:openURL:options: 메서드를 Swift로 구현하려면 다음 코드를 사용합니다.\n\n```swift\nfunc application(_ app: UIApplication,\nopen url: URL,\noptions: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {\n    return GIDSignIn.sharedInstance.handle(url)\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Objective-C에서 인증 사용자 인증 정보를 사용하는 방법은 무엇인가요?", "answer": "Objective-C에서 Firebase에 인증하기 위해 인증 사용자 인증 정보를 사용하는 방법은 다음과 같습니다.\n\n```objective-c\n[[FIRAuth auth] signInWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\n    // Handle the result\n}];\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "GIDSignInButton을 스토리보드에 추가한 후 로그인 버튼이 보이지 않는 이유는 무엇인가요?", "answer": "GIDSignInButton 뷰를 스토리보드에 추가하면 인터페이스 빌더에서 로그인 버튼이 렌더링되지 않습니다. 로그인 버튼을 보려면 앱을 실행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Swift에서 인증 사용자 인증 정보를 사용하는 방법은 무엇인가요?", "answer": "Firebase에 인증하기 위해 Swift에서는 다음과 같이 인증 사용자 인증 정보를 사용합니다.\n\n```swift\nAuth.auth().signIn(with: credential) { result, error in\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Objective-C에서 인증 사용자 인증 정보를 사용하는 방법은 무엇인가요?", "answer": "Firebase에 인증하기 위해 Objective-C에서는 다음과 같이 인증 사용자 인증 정보를 사용합니다.\n\n```objective-c\n[[FIRAuth auth] signInWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase 로그인 프로세스에서 다중 인증이 활성화된 경우 어떻게 처리하나요?", "answer": "Firebase 로그인 프로세스에서 다중 인증이 활성화된 경우, 다음과 같이 처리합니다.\n\n```objective-c\nif (isMFAEnabled && error && error.code == FIRAuthErrorCodeSecondFactorRequired) {\nFIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Objective-C에서 Firebase 로그인을 완료한 후 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "Objective-C에서 Firebase 로그인을 완료한 후 사용자 정보를 가져오는 방법은 다음과 같습니다.\n\n```objective-c\nFIRUser *user = authResult.user;\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase에서 로그아웃하는 방법은 무엇인가요?", "answer": "Firebase에서 로그아웃하는 방법은 다음과 같습니다.\n\n```objective-c\nNSError *signOutError;\nBOOL status = [[FIRAuth auth] signOut:&signOutError];\nif (!status) {\nNSLog(@\"Error signing out: %@\", signOutError);\nreturn;\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_google-signin_hl=ko.txt"}
{"question": "Firebase에서 신규 사용자를 생성하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 신규 사용자를 생성할 때는 createUser 메서드를 호출하거나 Google 로그인 또는 Facebook 로그인과 같은 제휴 ID 공급업체를 이용해 사용자의 최초 로그인을 처리할 수 있습니다. 또한 Firebase Console의 '인증' 섹션의 '사용자' 페이지에서 비밀번호 인증을 사용하는 신규 사용자를 생성할 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_manage-users_hl=ko.txt"}
{"question": "현재 로그인한 사용자를 가져오는 권장 방법은 무엇인가요?", "answer": "현재 사용자를 가져올 때 권장하는 방법은 Auth 객체에 리스너를 설정하는 것입니다. 예를 들어, Swift에서는 다음과 같이 사용할 수 있습니다: \n```swift\nhandle = Auth.auth().addStateDidChangeListener { auth, user in\n```\nObjective-C에서는 다음과 같이 사용할 수 있습니다: \n```objective-c\nself.handle = [[FIRAuth auth] addAuthStateDidChangeListener:^(FIRAuth *_Nonnull auth, FIRUser *_Nullable user) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_manage-users_hl=ko.txt"}
{"question": "사용자의 프로필 정보를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 표시 이름 및 프로필 사진 URL 등의 기본 프로필 정보를 업데이트할 때는 UserProfileChangeRequest 클래스를 사용합니다. 예를 들어, Swift에서는 다음과 같이 사용할 수 있습니다: \n```swift\nlet changeRequest = Auth.auth().currentUser?.createProfileChangeRequest()\nchangeRequest?.displayName = displayName\nchangeRequest?.commitChanges { error in\n```\nObjective-C에서는 다음과 같이 사용할 수 있습니다: \n```objective-c\nCFIRUserProfileChangeRequest *changeRequest = [[FIRAuth auth].currentUser profileChangeRequest];\nchangeRequest.displayName = userInput;\n[changeRequest commitChangesWithCompletion:^(NSError *_Nullable error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_manage-users_hl=ko.txt"}
{"question": "사용자의 이메일을 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 이메일을 업데이트하려면 다음과 같이 updateEmail 메서드를 사용할 수 있습니다. Swift에서는 다음과 같이 사용할 수 있습니다: \n```swift\nAuth.auth().currentUser?.updateEmail(to: email) { error in\n```\nObjective-C에서는 다음과 같이 사용할 수 있습니다: \n```objective-c\n[FIRAuth auth].currentUser updateEmail:email completion:^(NSError *_Nullable error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_manage-users_hl=ko.txt"}
{"question": "사용자를 삭제하는 방법은 무엇인가요?", "answer": "사용자를 삭제하려면 delete 메서드를 사용할 수 있습니다. Swift에서는 다음과 같이 사용할 수 있습니다: \n```swift\nuser?.delete { error in\nif let error = error {\n```\nObjective-C에서는 다음과 같이 사용할 수 있습니다: \n```objective-c\n[user deleteWithCompletion:^(NSError *_Nullable error) {\nif (error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_manage-users_hl=ko.txt"}
{"question": "Firebase에서 Microsoft를 로그인 제공업체로 사용 설정하려면 어떤 단계를 따라야 하나요?", "answer": "Firebase 프로젝트에서 Microsoft를 로그인 제공업체로 사용 설정하려면 다음 단계를 따르세요:\n1. Firebase Console에서 인증 섹션을 엽니다.\n2. 로그인 방법 탭에서 Microsoft 제공업체를 사용 설정합니다.\n3. 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_microsoft-oauth_hl=ko.txt"}
{"question": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면 다음 단계를 따르세요:\n1. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다.\n2. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다.\n3. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_microsoft-oauth_hl=ko.txt"}
{"question": "OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "OAuthProvider의 인스턴스를 생성하려면 다음과 같이 코드를 작성합니다:\n\n```objc\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"microsoft.com\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_microsoft-oauth_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 맞춤 OAuth 매개변수를 추가하는 방법은 무엇인가요?", "answer": "OAuth 요청과 함께 전송할 맞춤 OAuth 매개변수를 추가하려면 다음과 같이 코드를 작성합니다:\n\nSwift:\n```swift\nprovider.customParameters = [\n    \"prompt\": \"consent\",\n    \"login_hint\": \"user@firstadd.onmicrosoft.com\"\n]\n```\n\nObjective-C:\n```objc\n[provider setCustomParameters:@{@", "source": ["https://firebase.google.com/docs/auth/ios/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_microsoft-oauth_hl=ko.txt"}
{"question": "iOS 앱에서 SMS 다중 인증(MFA)을 사용 설정하려면 어떤 단계를 따라야 하나요?", "answer": "Firebase Console의 인증 > 로그인 방법 페이지를 열고, 고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정합니다. 또한, 앱을 테스트할 전화번호를 입력해야 하며, 개발 중 제한이 발생하지 않도록 테스트 전화번호를 등록하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Firebase에서 SMS 요청이 앱에서 오는지 확인하는 방법은 무엇인가요?", "answer": "Firebase는 두 가지 방법으로 SMS 요청이 앱에서 오는지 확인할 수 있습니다. 첫 번째는 자동 APN 알림을 사용하는 방법으로, 사용자가 처음으로 로그인 처리하면 Firebase에서 자동으로 푸시 알림을 보냅니다. 두 번째는 reCAPTCHA 인증을 사용하는 방법으로, 자동 알림을 보낼 수 없는 경우에 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "APN 알림을 Firebase와 함께 사용하기 위해 설정하는 방법은 무엇인가요?", "answer": "Xcode에서 프로젝트에 푸시 알림을 사용 설정한 후, Firebase Console을 사용하여 APN 인증 키를 업로드합니다. 프로젝트 설정으로 이동하여 클라우드 메시징 탭을 선택하고, iOS 앱 구성 섹션의 APN 인증 키에서 업로드를 클릭하여 인증 키를 업로드합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA 인증을 클라이언트 SDK에서 사용하도록 설정하려면 어떤 단계를 따라야 하나요?", "answer": "Xcode에서 프로젝트 구성을 열고, 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭한 후, 타겟 섹션에서 앱을 선택합니다. 정보 탭을 선택하고 URL 유형 섹션을 펼친 후, 화면의 + 버튼을 클릭하여 URL 스키마 입력란에 반전된 클라이언트 ID를 입력합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)을 사용할 때 사용자 등록 방법과 시기를 어떻게 선택하나요?", "answer": "앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 일반적인 패턴을 고려하여 결정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Firebase에서 APN 인증 키를 업로드하는 방법은 무엇인가요?", "answer": "Firebase Console을 사용하여 APN 인증 키를 업로드하는 방법은 다음과 같습니다.\n\n1. Firebase Console을 엽니다.\n2. 프로젝트 설정으로 이동합니다.\n3. 클라우드 메시징 탭을 선택합니다.\n4. iOS 앱 구성 섹션의 APN 인증 키에서 업로드를 클릭하여 개발 인증 키, 프로덕션 인증 키 또는 둘 다를 업로드합니다. 최소 하나 이상이 필요합니다.\n5. 키를 선택합니다.\n6. 키의 키 ID를 추가합니다. 키 ID는 Apple 개발자 구성원 센터의 인증서, 식별자, 프로필에서 찾을 수 있습니다.\n7. 업로드를 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA 인증을 클라이언트 SDK에서 설정하는 방법은 무엇인가요?", "answer": "클라이언트 SDK에서 reCAPTCHA를 사용하도록 설정하려면 다음 단계를 따르세요.\n\n1. Xcode에서 프로젝트 구성을 엽니다.\n2. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭합니다.\n3. 타겟 섹션에서 앱을 선택합니다.\n4. 정보 탭을 선택합니다.\n5. URL 유형 섹션을 펼칩니다.\n6. 화면의 + 버튼을 클릭합니다.\n7. URL 스키마 입력란에 반전된 클라이언트 ID를 입력합니다. 이 값은 GoogleService-Info.plist 구성 파일에 REVERSED_CLIENT_ID로 표시됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 사용자 등록 방법을 선택하는 일반적인 패턴은 무엇인가요?", "answer": "다중 인증(MFA)에서 사용자 등록 방법을 선택하는 일반적인 패턴은 다음과 같습니다.\n\n1. 등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n2. 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 다중 인증(MFA)을 권고하지만 필수이지는 않은 앱은 이 방법을 사용하는 것이 좋습니다.\n3. 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다.\n4. 사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "사용자의 새로운 두 번째 단계를 등록하는 방법은 무엇인가요?", "answer": "사용자의 새로운 두 번째 단계를 등록하려면 다음 단계를 따르세요.\n\n1. 사용자를 다시 인증합니다.\n2. 사용자에게 전화번호를 입력하도록 요청합니다. 참고: Google은 모든 Google 서비스의 스팸 및 악용 방지를 위해 전화번호를 저장하고 사용합니다. 전화번호를 Firebase로 보내기 전에 사용자에게 적절한 동의를 얻어야 합니다.\n3. 사용자를 위한 다중 세션을 가져옵니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "SMS 인증 코드를 전송하는 방법은 무엇인가요?", "answer": "SMS 인증 코드를 전송하는 방법은 다음과 같습니다.\n\nSwift:\n```swift\nPhoneAuthProvider.provider().verifyPhoneNumber(\n    phoneNumber,\n    uiDelegate: nil,\n    multiFactorSession: session) { (verificationId, error) in\n    // Handle verification\n}\n```\n\nObjective-C:\n```objective-c\n[FIRPhoneAuthProvider.provider verifyPhoneNumber:phoneNumber\n    UIDelegate:nil\n    multiFactorSession:session\n    completion:^(NSString * _Nullable verificationID,\n    NSError * _Nullable error) {\n    // Handle verification\n}];\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "사용자의 두 번째 단계를 등록하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "사용자의 새로운 두 번째 단계를 등록하려면 사용자를 다시 인증해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "SMS 인증 코드를 전송한 후 사용자가 해야 할 작업은 무엇인가요?", "answer": "SMS 코드가 전송되면 사용자에게 코드를 확인하도록 요청합니다. 그런 다음 응답을 사용하여 PhoneAuthCredential을 빌드합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 두 번째 단계를 등록할 때 사용자가 입력해야 하는 정보는 무엇인가요?", "answer": "사용자에게 전화번호를 입력하도록 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 두 번째 단계의 표시 이름을 지정하는 이유는 무엇인가요?", "answer": "인증 과정에서 전화번호가 마스킹되므로(예: +1******1234) 두 번째 단계가 여러 개인 사용자에게 유용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)에서 사용자가 로그인할 때 어떤 과정을 거치나요?", "answer": "사용자가 로그인할 때, 사용자는 이메일과 비밀번호로 인증을 시도하고, 이후 다중 인증(MFA) 절차를 통해 SMS 인증 코드를 요청하고 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Swift에서 SMS 인증 코드를 요청한 후 사용자가 입력해야 하는 단계는 무엇인가요?", "answer": "SMS 코드가 전송되면 사용자에게 코드를 확인하도록 요청합니다. 그런 다음 응답을 사용하여 PhoneAuthCredential을 빌드합니다. 예를 들어:\n\n```swift\n// Ask user for the verification code. Then:\nFIRPhoneAuthCredential *credential = [FIRPhoneAuthProvider.provider\ncredentialWithVerificationID:verificationID\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Objective-C에서 다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "Objective-C에서 다중 인증(MFA) 등록을 완료하려면 다음과 같이 합니다:\n\n```objective-c\nFIRMultiFactorAssertion *assertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Swift에서 사용자의 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "Swift에서 사용자의 다중 인증(MFA) 세션을 가져오려면 다음과 같이 합니다:\n\n```swift\nlet user = Auth.auth().currentUser\nuser?.multiFactor.getSessionWithCompletion({ (session, error) in\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Objective-C에서 SMS 인증 코드를 전송하는 방법은 무엇인가요?", "answer": "Objective-C에서 SMS 인증 코드를 전송하려면 다음과 같이 합니다:\n\n```objective-c\n[FIRPhoneAuthProvider.provider\nverifyPhoneNumberWithMultiFactorInfo:hint\nUIDelegate:nil\nmultiFactorSession:resolver.session\ncompletion:^(NSString * _Nullable verificationID, NSError * _Nullable error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "Swift에서 다중 인증(MFA) 로그인 문제를 해결하는 방법은 무엇인가요?", "answer": "Swift에서 다중 인증(MFA) 로그인 문제를 해결하려면 다음과 같이 합니다:\n\n```swift\nresolver.resolveSignIn(with: assertion) { (authResult, error) in\n```", "source": ["https://firebase.google.com/docs/auth/ios/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_multi-factor_hl=ko.txt"}
{"question": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 무엇인가요?", "answer": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 다음과 같습니다:\n\n1. 클라이언트 ID (client ID): 앱을 식별하는 제공업체의 고유한 문자열입니다. 이 값은 제공업체에서 발급한 ID 토큰의 aud 클레임 값 중 하나입니다.\n2. 클라이언트 보안 비밀번호 (client secret): 제공업체가 클라이언트 ID의 소유권을 확인하는 데 사용하는 보안 비밀 문자열입니다. 인증 코드 흐름을 사용하는 경우에만 필요합니다.\n3. 발급기관 (issuer): 제공업체를 식별하는 문자열로, OIDC 탐색 문서가 위치하는 URL이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "Firebase SDK로 OpenID Connect 인증을 처리하는 방법은 무엇인가요?", "answer": "Firebase SDK로 OpenID Connect 인증을 처리하는 방법은 다음과 같습니다:\n\n1. Xcode 프로젝트에 커스텀 URL 스킴을 추가합니다. 프로젝트 구성에서 앱을 선택하고 URL 유형 섹션을 펼친 후 인코딩된 앱 ID를 URL 스키마로 추가합니다.\n2. Firebase Console에서 가져온 제공업체 ID를 사용하여 OAuthProvider의 인스턴스를 만듭니다:\n\n```swift\nvar provider = OAuthProvider(providerID: \"oidc.example-provider\")\n```\n\n```objective-c\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"oidc.example-provider\"];\n```\n3. 선택적으로 맞춤 OAuth 매개변수를 추가하고, 인증 제공업체에서 요청하고자 하는 범위를 지정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "OpenID Connect 제공업체를 Firebase Console에서 설정할 때 어떤 흐름을 선택해야 하나요?", "answer": "OpenID Connect 제공업체를 Firebase Console에서 설정할 때는 승인 코드 흐름을 사용하는 것이 좋습니다. 암시적 권한 부여 흐름은 보안 수준이 낮으므로 사용하지 않는 것이 권장됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 다음과 같습니다:\n- client_id\n- response_type\n- redirect_uri\n- state\n- scope\n- response_mode\n이러한 매개변수는 setCustomParameters와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 수 있는 맞춤 OAuth 매개변수는 어떻게 설정하나요?", "answer": "OAuth 요청과 함께 전송할 맞춤 OAuth 매개변수는 다음과 같이 설정할 수 있습니다:\n\n```swift\nprovider.customParameters = [\n    \"login_hint\": \"user@example.com\"\n]\n```\n\n```objective-c\n[provider setCustomParameters:@{@", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정할 때 어떤 정보를 입력해야 하나요?", "answer": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정할 때는 제공업체의 이름, 클라이언트 ID(client ID), 클라이언트 보안 비밀번호(client secret), 제공업체의 발급기관 문자열(issuer string)을 입력해야 합니다. 이 값들은 제공업체에서 할당한 값과 정확하게 일치해야 하며, 생성된 제공업체 ID는 기록해 두어야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 OIDC 제공업체로 로그인하는 과정은 어떻게 되나요?", "answer": "Firebase SDK로 OIDC 제공업체를 사용하여 로그인하는 과정은 다음과 같습니다. 먼저, Firebase Console에서 가져온 제공업체 ID를 사용하여 OAuthProvider의 인스턴스를 만듭니다. Swift에서는 다음과 같이 작성합니다:\n\n```swift\nvar provider = OAuthProvider(providerID: \"oidc.example-provider\")\n```\nObjective-C에서는 다음과 같이 작성합니다:\n\n```objective-c\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"oidc.example-provider\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 client_id, response_type, redirect_uri, state, scope, response_mode입니다. 이러한 매개변수는 setCustomParameters와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 수 있는 맞춤 OAuth 매개변수는 어떻게 설정하나요?", "answer": "OAuth 요청과 함께 전송하고자 하는 맞춤 OAuth 매개변수는 다음과 같이 설정할 수 있습니다. Swift에서는 다음과 같이 작성합니다:\n\n```swift\nprovider.customParameters = [\n    \"login_hint\": \"user@example.com\"\n]\n```\nObjective-C에서는 다음과 같이 작성합니다:\n\n```objective-c\n[provider setCustomParameters:@{@", "source": ["https://firebase.google.com/docs/auth/ios/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_openid-connect_hl=ko.txt"}
{"question": "Firebase Console에서 연결 URL을 안전하게 전달하기 위해 어떤 절차를 따라야 하나요?", "answer": "연결 URL을 안전하게 전달하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 이 URL의 도메인을 허용해야 합니다. 만약 아직 허용 목록에 포함되어 있지 않다면 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "비밀번호 재설정 이메일이나 인증 메일을 보낼 때 어떤 인스턴스를 제공해야 하나요?", "answer": "비밀번호 재설정 이메일이나 인증 메일을 보낼 때 FIRActionCodeSettings 인스턴스를 제공해야 합니다. 이 인터페이스는 다음과 같은 매개변수를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Swift에서 이메일 인증 링크를 보내는 방법은 무엇인가요?", "answer": "다음 예시에서는 커스텀 Hosting 링크 도메인 custom-domain.com을 사용하여 모바일 앱에서 먼저 열리는 이메일 인증 링크를 보내는 방법을 보여줍니다.\n\n```swift\nString(format: \"https://www.example.com/?email=%@\", user.email)\nactionCodeSettings.iOSbundleID = Bundle.main.bundleIdentifier!\nactionCodeSettings.setAndroidPakageName(\"com.example.android\")\nuser.sendEmailVerification(withActionCodeSettings:actionCodeSettings { error in\nif error {\n```", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Objective-C에서 이메일 인증 링크를 보내는 방법은 무엇인가요?", "answer": "다음 예시에서는 Objective-C를 사용하여 이메일 인증 링크를 보내는 방법을 보여줍니다.\n\n```objective-c\nFIRActionCodeSettings *actionCodeSettings = [[FIRActionCodeSettings alloc] init];\nactionCodeSettings.handleCodeInApp = YES;\nFIRUser *user = [FIRAuth auth].currentUser;\nNSString *urlString =\n[NSString stringWithFormat:@\"https://www.example.com/?email=%@\", user.email];\nactionCodeSettings.URL = [NSURL URLWithString:urlString];\nactionCodeSettings.iOSBundleID = [NSBundle mainBundle].bundleIdentifier;\n[actionCodeSettings setAndroidPackageName:@\"com.example.android\"];\n[user sendEmailVerificationWithActionCodeSettings:actionCodeSettings\ncompletion:^(NSError *_Nullable error) {\nif (error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Hosting 링크를 구성하기 위해 어떤 절차를 따라야 하나요?", "answer": "Firebase Authentication은 모바일 애플리케이션에서 열릴 링크를 보낼 때 Firebase Hosting [https://firebase.google.com/docs/hosting?hl=ko]을 사용합니다. 이 기능을 사용하려면 Firebase Console에서 Hosting 링크를 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Console에서 이메일 작업의 연결 URL 도메인을 허용 목록에 추가하는 방법은 무엇인가요?", "answer": "Firebase Console에서 연결 URL의 도메인을 허용하려면 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Swift에서 FIRActionCodeSettings 인스턴스를 설정하는 방법은 무엇인가요?", "answer": "Swift에서 FIRActionCodeSettings 인스턴스를 설정하려면 다음과 같이 코드를 작성합니다.\n```swift\nactionCodeSettings.iOSbundleID = Bundle.main.bundleIdentifier!\nactionCodeSettings.setAndroidPakageName(\"com.example.android\")\n```", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Objective-C에서 이메일 인증 링크를 보내기 위한 FIRActionCodeSettings 설정 방법은 무엇인가요?", "answer": "Objective-C에서 FIRActionCodeSettings를 설정하는 방법은 다음과 같습니다.\n```objective-c\nFIRActionCodeSettings *actionCodeSettings = [[FIRActionCodeSettings alloc] init];\nactionCodeSettings.handleCodeInApp = YES;\nFIRUser *user = [FIRAuth auth].currentUser;\nNSString *urlString =\n[NSString stringWithFormat:@\"https://www.example.com/?email=%@\", user.email];\nactionCodeSettings.URL = [NSURL URLWithString:urlString];\nactionCodeSettings.iOSBundleID = [NSBundle mainBundle].bundleIdentifier;\n[actionCodeSettings setAndroidPackageName:@\"com.example.android\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Hosting 링크를 모바일 애플리케이션에서 처리하기 위해 필요한 설정은 무엇인가요?", "answer": "모바일 애플리케이션에서 Firebase Hosting 링크를 처리하려면 애플리케이션 기능에서 Hosting 링크 도메인을 연결된 도메인으로 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 처리 시 웹 애플리케이션에서 리디렉션을 설정하는 방법은 무엇인가요?", "answer": "웹 애플리케이션에서 리디렉션을 설정하려면 FIRActionCodeSettings(Obj-C) 또는 ActionCodeSettings(Swift) 객체에서 handleCodeInApp을 false로 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Android 애플리케이션에서 이메일 작업 링크를 처리하기 위해 어떤 설정이 필요한가요?", "answer": "Android 애플리케이션에서 이메일 작업 링크를 처리하려면 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정해야 합니다. 또한 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 하며, AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터도 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "웹 애플리케이션에서 이메일 작업을 처리한 후 리디렉션을 설정하는 방법은 무엇인가요?", "answer": "웹 애플리케이션에서 이메일 작업을 처리한 후 리디렉션을 설정하려면 FIRActionCodeSettings(Obj-C) 또는 ActionCodeSettings(Swift) 객체에서 handleCodeInApp을 false로 설정하면 됩니다. 이렇게 하면 작업 코드 링크를 처리하고 정상적으로 완료된 후 다른 웹페이지 또는 모바일 애플리케이션으로 리디렉션할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "모바일 애플리케이션에서 이메일 작업 링크를 처리할 때 어떤 조건이 필요한가요?", "answer": "모바일 애플리케이션에서 이메일 작업 링크를 처리할 때는 모바일 애플리케이션이 설치되어 있어야 하며, FIRActionCodeSettings(Obj-C) 또는 ActionCodeSettings(Swift) 객체에서 handleCodeInApp을 true로 설정해야 합니다. 또한 모바일 애플리케이션의 Android 패키지 이름 또는 번들 ID도 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업 처리 시 사용되는 continueURL 쿼리 파라미터는 무엇인가요?", "answer": "이메일 작업 처리 시 사용되는 continueURL 쿼리 파라미터는 페이로드가 ActionCodeSettings 객체에 지정된 URL인 Hosting 링크가 됩니다. 이 링크는 이메일 작업 템플릿 섹션에서 구성된 URL입니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 인증을 처리할 때 oobCode 쿼리 매개변수는 어떻게 사용되나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하여 비밀번호 기반 계정을 생성하는 방법은 무엇인가요?", "answer": "비밀번호가 있는 신규 사용자 계정을 만들려면 앱의 로그인 작업에서 다음 절차를 완료합니다.\n\n```swift\nAuth.auth().createUser(withEmail: email, password: password) { authResult, error in\n```\n\nObjective-C에서는 다음과 같이 작성합니다:\n\n```objective-c\n[[FIRAuth auth] createUserWithEmail:email\npassword:password\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\n```", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책을 설정하는 방법은 무엇인가요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다:\n- 소문자 필요\n- 대문자 필요\n- 숫자 필요\n- 영숫자가 아닌 문자 필요\n\n비밀번호 최소 길이는 6~30자이며, 기본값은 6입니다. 최대 길이는 4,096자입니다. 비밀번호 정책 적용 모드는 '필수'와 '알림' 두 가지로 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "SwiftUI에서 Firebase를 설정하는 방법은 무엇인가요?", "answer": "SwiftUI를 사용하는 경우 앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 예시는 다음과 같습니다:\n\n```swift\n@main\nstruct YourApp: App {\n    ContentView()\n}\n```\n\nFirebase를 설정하려면 다음 코드를 추가합니다:\n\n```swift\nFirebaseApp.configure()\n```", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 및 비밀번호 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 로그인 방법을 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책의 '필수' 모드와 '알림' 모드의 차이는 무엇인가요?", "answer": "'필수' 모드는 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. 반면, '알림' 모드는 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있으며, 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "SwiftUI에서 Firebase Authentication을 설정하는 방법은 무엇인가요?", "answer": "SwiftUI에서 Firebase Authentication을 설정하려면, 먼저 FirebaseCore, FirebaseFirestore, FirebaseAuth를 임포트해야 합니다. 그런 다음 FirebaseApp.configure()를 호출하여 Firebase를 초기화합니다. 아래는 SwiftUI에서 Firebase를 설정하는 코드 예시입니다.\n\n```swift\nimport SwiftUI\nimport FirebaseCore\nimport FirebaseFirestore\nimport FirebaseAuth\n\n@main\nstruct YourApp: App {\n    ContentView()\n}\n\nFirebaseApp.configure()\n```", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Objective-C에서 Firebase Authentication을 설정하는 방법은 무엇인가요?", "answer": "Objective-C에서 Firebase Authentication을 설정하려면, FirebaseCore, FirebaseFirestore, FirebaseAuth를 임포트한 후 FirebaseApp.configure()를 호출하여 Firebase를 초기화해야 합니다. 아래는 Objective-C에서 Firebase를 설정하는 코드 예시입니다.\n\n```objective-c\n@import FirebaseCore;\n@import FirebaseFirestore;\n@import FirebaseAuth;\n\nFirebaseApp.configure();\n```", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책의 '필수' 모드를 사용 설정하면 어떤 결과가 발생하나요?", "answer": "Firebase Authentication에서 비밀번호 정책의 '필수' 모드를 사용 설정하면 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. 즉, 사용자는 비밀번호가 정책을 준수하지 않으면 계정을 생성할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 비밀번호 정책의 '알림' 모드를 사용 설정하면 어떻게 되나요?", "answer": "Firebase Authentication에서 비밀번호 정책의 '알림' 모드를 사용 설정하면 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있습니다. 이 경우 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고, 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 열거 보호 기능을 사용 설정하는 이유는 무엇인가요?", "answer": "Firebase Authentication에서 이메일 열거 보호 기능을 사용 설정하는 이유는 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 것을 방지하기 위해서입니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경되어, 특정 오류가 발생할 때 사용자에게 특정 조치를 제안할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자의 비밀번호가 정책을 준수하지 않을 경우 어떻게 처리해야 하나요?", "answer": "클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고, 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 어떤 방식으로든 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "활성 사용자가 있는 경우 비밀번호 정책을 준수하지 않는 사용자의 액세스를 차단하려면 어떤 설정을 해야 하나요?", "answer": "활성 사용자가 있는 경우 비밀번호가 정책을 준수하지 않는 사용자의 액세스를 차단하려는 경우가 아니면 로그인 강제 업그레이드를 사용 설정하지 않는 것이 좋습니다. 대신 사용자가 현재 비밀번호로 로그인할 수 있게 해주고 비밀번호에 부족한 요구사항을 알리는 알림 모드를 사용하세요.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 열거 보호 기능을 사용 설정하는 이유는 무엇인가요?", "answer": "이메일 주소가 등록되어 있어야 하는데 등록되지 않은 경우 또는 이메일 주소를 사용해서는 안 되는데 등록된 경우, 이메일 주소를 파라미터로 사용하는 일부 Firebase Authentication 메서드에서 특정 오류가 발생합니다. 이는 사용자에게 특정 조치를 제안하는 데 유용할 수 있지만 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 데 악용될 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication의 오류 보고 동작을 변경하려면 어떻게 해야 하나요?", "answer": "이메일 열거 보호 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다. 앱이 더 구체적인 오류에 의존하지 않는지 확인하세요.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트의 일부로 저장되며 사용자의 로그인 방법에 관계없이 프로젝트 내 모든 앱에서 사용자를 식별하는 데 사용될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_password-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 전화번호 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 전화번호 로그인을 사용 설정하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 사용하기 위해 Firebase에서 어떤 확인 절차가 필요한가요?", "answer": "전화번호 인증을 사용하려면 Firebase에서 전화번호 로그인 요청이 앱에서 발생한 것인지 확인할 수 있어야 합니다. Firebase Authentication은 자동 APN 알림 또는 reCAPTCHA 인증을 통해 이를 수행합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 자동 APN 알림은 어떻게 작동하나요?", "answer": "자동 APN 알림은 기기에서 처음으로 전화번호를 통해 사용자를 로그인 처리할 때 Firebase Authentication에서 사용자 모르게 기기로 푸시 알림을 전송하여 토큰을 보냅니다. 앱이 Firebase의 알림을 성공적으로 수신하면 전화번호 로그인을 진행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증은 어떤 상황에서 사용되나요?", "answer": "reCAPTCHA 인증은 사용자가 앱의 백그라운드 새로고침을 중지했거나 iOS 시뮬레이터에서 앱을 테스트하는 경우와 같이 자동 푸시 알림을 주고받을 수 없는 경우에 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 구현할 때 푸시 알림 수신 권한을 요청해야 하나요?", "answer": "iOS 8.0 이상에서는 자동 알림이 명시적인 사용자 동의를 요구하지 않으므로 사용자가 앱에서 APN 알림 수신을 거부하더라도 영향을 받지 않습니다. 따라서 Firebase 전화번호 인증을 구현할 때 푸시 알림을 수신할 수 있는 사용자 권한을 앱에서 요청할 필요가 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증을 사용하기 위해 APN 알림을 어떻게 설정하나요?", "answer": "Firebase Authentication와 함께 사용하기 위해 APN 알림을 사용 설정하는 방법은 다음과 같습니다.\n\n1. Xcode에서 프로젝트에 푸시 알림을 사용 설정합니다.\n2. Firebase에 APNs 인증 키를 업로드합니다. 아직 APNs 인증 키가 없다면 Apple Developer Member Center에서 만드세요.\n3. Firebase Console 프로젝트 내에서 톱니바퀴 아이콘을 선택하고 프로젝트 설정을 선택한 다음 클라우드 메시징 탭을 선택합니다.\n4. iOS 앱 구성의 APN 인증 키에서 업로드를 클릭하여 개발 인증 키, 프로덕션 인증 키 또는 둘 다를 업로드합니다. 최소 하나 이상이 필요합니다.\n5. 키를 저장한 위치로 이동하여 키를 선택하고 열기를 클릭합니다. 해당하는 키 ID(Apple Developer Member Center에서 확인 가능)를 추가하고 업로드를 클릭합니다.\n6. APN 인증서가 이미 있다면 인증서를 대신 업로드 할 수 있습니다.\n7. Xcode에서 프로젝트에 백그라운드 모드 기능을 사용 설정한 다음 백그라운드 가져오기 및 원격 알림 모드의 체크박스를 선택합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증을 Firebase SDK에서 어떻게 설정하나요?", "answer": "Firebase SDK에서 reCAPTCHA 인증을 사용하도록 설정하는 방법은 다음과 같습니다.\n\n1. Xcode 프로젝트에 커스텀 URL 스킴을 추가합니다.\n2. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다.\n3. 대상 섹션에서 앱을 선택하고 정보 탭을 선택합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 구현할 때 자동 APN 알림이 실패하면 어떤 대체 방법이 사용되나요?", "answer": "전화번호 인증은 클라이언트 앱 인증에 자동 푸시 알림을 사용합니다. 이 방법이 실패하면 reCAPTCHA 인증이 대체됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 사용할 때 사용자에게 어떤 보안 경고를 해야 하나요?", "answer": "전화번호만 사용하는 인증은 편리하지만, 전화번호 소유권은 사용자 간에 쉽게 이전될 수 있으므로 다른 방식보다 보안성이 떨어집니다. 따라서 전화번호 로그인을 사용하면 보안이 약화된다는 점을 사용자에게 알려야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증을 테스트할 때 어떤 시나리오를 고려해야 하나요?", "answer": "두 시나리오가 모두 제대로 작동하는지 확인하려면 백그라운드 앱 새로고침을 사용 설정한 상태와 중지한 상태로 실제 기기에서 앱을 테스트합니다. 백그라운드 앱 새로고침을 중지했을 때는 reCAPTCHA 테스트를 완료하여 로그인할 수 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증을 위해 APN 알림을 설정하는 방법은 무엇인가요?", "answer": "Firebase Authentication와 함께 사용하기 위해 APN 알림을 사용 설정하는 방법은 다음과 같습니다.\n\n1. Xcode에서 프로젝트에 푸시 알림을 사용 설정합니다.\n2. Firebase에 APNs 인증 키를 업로드합니다. 아직 APNs 인증 키가 없다면 Apple Developer Member Center에서 만드세요.\n3. Firebase Console 프로젝트 내에서 톱니바퀴 아이콘을 선택하고 프로젝트 설정을 선택한 다음 클라우드 메시징 탭을 선택합니다.\n4. iOS 앱 구성의 APN 인증 키에서 업로드를 클릭하여 개발 인증 키, 프로덕션 인증 키 또는 둘 다를 업로드합니다. 최소 하나 이상이 필요합니다.\n5. 키를 저장한 위치로 이동하여 키를 선택하고 열기를 클릭합니다. 해당하는 키 ID를 추가하고 업로드를 클릭합니다.\n6. APN 인증서가 이미 있다면 인증서를 대신 업로드 할 수 있습니다.\n7. Xcode에서 프로젝트에 백그라운드 모드 기능을 사용 설정한 다음 백그라운드 가져오기 및 원격 알림 모드의 체크박스를 선택합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증을 Firebase SDK에서 설정하는 방법은 무엇인가요?", "answer": "Firebase SDK에서 reCAPTCHA 인증을 사용하도록 설정하는 방법은 다음과 같습니다.\n\n1. Xcode 프로젝트에 커스텀 URL 스킴을 추가합니다.\n2. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다.\n3. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다. 다른 필드는 비워 둡니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자가 전화번호를 제공하도록 요청하는 방법은 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시하고 verifyPhoneNumber(_:uiDelegate:completion:)을 호출하여 Firebase가 사용자의 전화에 SMS로 인증 코드를 전송하도록 요청합니다. 사용자의 전화번호를 확인합니다. 일반적으로는 사용자가 제반 상황을 미리 알 수 있도록 휴대전화 로그인을 사용하면 인증용 SMS 메시지가 발송되고 일반 요금이 부과될 수 있다는 점을 알려야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "verifyPhoneNumber(_:uiDelegate:completion:) 메서드를 호출하는 방법은 무엇인가요?", "answer": "verifyPhoneNumber(_:uiDelegate:completion:)을 호출하면서 사용자의 전화번호를 전달합니다. Swift 예제:\n```swift\nPhoneAuthProvider.provider()\n.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n}\n```\nObjective-C 예제:\n```objective-c\n[[FIRPhoneAuthProvider provider] verifyPhoneNumber:userInput\nUIDelegate:nil\ncompletion:^(NSString * _Nullable verificationID, NSError * _Nullable error) {\nif (error) {\n[self showMessagePrompt:error.localizedDescription];\nreturn;\n}\n}];\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 인증 언어를 지정하는 방법은 무엇인가요?", "answer": "Auth 인스턴스의 languageCode 속성을 통해 인증 언어를 지정하면 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다. Swift 예제:\n```swift\nAuth.auth().languageCode = \"ko\" // 예: 한국어로 설정\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase SDK에서 reCAPTCHA 인증을 설정하는 방법은 무엇인가요?", "answer": "Firebase SDK에서 reCAPTCHA 인증을 사용하도록 설정하려면, Xcode 프로젝트에 커스텀 URL 스킴을 추가해야 합니다. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 열고, 대상 섹션에서 앱을 선택한 후 정보 탭을 선택하고 URL 유형 섹션을 펼칩니다. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자가 전화번호를 제공하도록 요청하는 방법은 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시하고 verifyPhoneNumber(_:uiDelegate:completion:)을 호출하여 Firebase가 사용자의 전화에 SMS로 인증 코드를 전송하도록 요청합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "인증 언어를 지정하여 Firebase에서 보내는 SMS 메시지를 현지화하는 방법은 무엇인가요?", "answer": "Auth 인스턴스의 languageCode 속성을 통해 인증 언어를 지정하면 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다. 예를 들어, Swift에서는 다음과 같이 설정할 수 있습니다: \n```swift\nAuth.auth().languageCode = \"fr\";\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "인증 ID를 저장하고 복원하는 방법은 무엇인가요?", "answer": "인증 ID를 저장한 후 앱이 로드되면 이를 복원하여 사용자가 로그인 과정을 완료하기 전에 앱이 종료되더라도 올바른 인증 ID를 유지할 수 있습니다. 인증 ID를 저장하는 방법은 다음과 같습니다: \n```swift\nUserDefaults.standard.set(verificationID, forKey: \"authVerificationID\")\n``` 인증 ID를 복원하는 방법은 다음과 같습니다: \n```swift\nNSString *verificationID = [defaults stringForKey:@\"authVerificationID\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한되는 경우 어떻게 해야 하나요?", "answer": "Firebase는 악용을 방지하기 위해 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 인증 언어를 지정하여 SMS 메시지를 현지화하는 방법은 무엇인가요?", "answer": "Auth 인스턴스의 languageCode 속성을 통해 인증 언어를 지정하면 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다. 예를 들어, 프랑스어로 설정하려면 다음과 같이 코드를 작성합니다.\n\n```swift\nAuth.auth().languageCode = \"fr\";\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "인증 ID를 저장하고 복원하는 방법은 무엇인가요?", "answer": "인증 ID를 저장한 후 앱이 로드되면 이를 복원하여 사용자가 로그인 과정을 완료하기 전에 앱이 종료되더라도 올바른 인증 ID를 유지할 수 있습니다. 인증 ID를 저장하는 방법은 다음과 같습니다.\n\n```swift\nUserDefaults.standard.set(verificationID, forKey: \"authVerificationID\")\n```\n저장된 값을 복원하는 방법은 다음과 같습니다.\n\n```swift\nNSString *verificationID = [defaults stringForKey:@\"authVerificationID\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한되는 경우 어떻게 해야 하나요?", "answer": "Firebase는 악용을 방지하기 위해 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 SMS 메시지의 인증 코드를 앱에 제공하면 인증 코드와 인증 ID를 사용하여 FIRPhoneAuthCredential 객체를 만들고 이 객체를 signInWithCredential:completion:에 전달합니다. 다음은 Swift 코드 예시입니다.\n\n```swift\nFIRAuthCredential *credential = [[FIRPhoneAuthProvider provider]\ncredentialWithVerificationID:verificationID];\nAuth.auth().signIn(with: credential) { authResult, error in\n    // 로그인 처리\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 설정하여 전화번호 인증을 테스트하는 방법은 무엇인가요?", "answer": "Firebase Console을 통해 개발용 가상 전화번호를 설정할 수 있습니다. 가상 전화번호로 테스트하면 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있으며, 실제 SMS 메시지를 보내지 않고도 테스트할 수 있습니다. 가상 전화번호는 실제로 존재하지 않는 번호여야 하며, 예를 들어 555로 시작하는 번호(예: +1 650-555-3434)를 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Console에서 가상 전화번호를 설정하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다. 전화 제공업체를 아직 사용 설정하지 않은 경우 로그인 방법 탭에서 사용 설정합니다. 테스트용 전화번호 아코디언 메뉴를 엽니다. 테스트할 전화번호(예: +1 650-555-3434)를 입력합니다. 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력합니다. 번호를 추가합니다. 필요한 경우 해당 행 위에 마우스를 가져가서 휴지통 아이콘을 클릭하면 전화번호와 코드를 삭제할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 Firebase에서 인증을 테스트할 때 어떤 이점이 있나요?", "answer": "가상 전화번호로 테스트하면 다음과 같은 이점이 있습니다. 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있습니다. 실제 SMS 메시지를 보내지 않고 전화번호 인증을 테스트할 수 있습니다. 제한 없이 동일한 전화번호로 연속 테스트를 실행할 수 있습니다. 앱 스토어 검토 절차 중에 검토자가 동일한 전화번호를 테스트에 사용하게 될 경우 번호가 거부될 위험이 최소화됩니다. 별도의 노력 없이도 개발 환경에서 쉽게 테스트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 인증을 테스트할 때 어떤 조건을 충족해야 하나요?", "answer": "가상 전화번호는 다음 요구사항을 충족해야 합니다. 실제로 존재하지 않는 가상의 전화번호여야 합니다. Firebase Authentication에서는 실제 사용자가 사용하는 기존 전화번호를 테스트 전화번호로 설정할 수 없습니다. 전화번호를 만드는 방법 중 하나는 555로 시작하는 번호(예: +1 650-555-3434)를 미국 테스트 전화번호로 사용하는 것입니다. 길이 및 기타 조건에 맞게 전화번호 형식을 올바르게 지정해야 합니다. 테스트 전화번호도 실제 사용자의 전화번호와 동일한 유효성 검사를 거칩니다. 개발용으로 최대 10개의 전화번호를 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 인증을 테스트할 때 실제 SMS 메시지가 전송되나요?", "answer": "가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않습니다. 그 대신 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호로 생성된 Firebase 사용자는 어떤 속성을 가지나요?", "answer": "로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다. 사용자는 실제 전화번호 사용자와 동일한 행동과 속성을 가지며 동일한 방식으로 Realtime Database/Cloud Firestore 및 기타 서비스에 액세스할 수 있습니다. 이 절차 중에 발급된 ID 토큰에는 실제 전화번호 사용자와 같은 서명이 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Console에서 가상 전화번호를 추가하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 전화 제공업체를 사용 설정한 후, 테스트용 전화번호 아코디언 메뉴를 열어 테스트할 전화번호(예: +1 650-555-3434)와 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력한 후 번호를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 인증을 테스트할 때 실제 SMS 메시지가 전송되나요?", "answer": "가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않습니다. 대신 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 가상 전화번호 사용 시 사용자 속성은 어떻게 되나요?", "answer": "로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다. 사용자는 실제 전화번호 사용자와 동일한 행동과 속성을 가지며 동일한 방식으로 Realtime Database/Cloud Firestore 및 기타 서비스에 액세스할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "iOS에서 가상 전화번호를 테스트하기 위해 어떤 설정을 해야 하나요?", "answer": "iOS에서는 verifyPhoneNumber를 호출하기 전에 appVerificationDisabledForTesting 설정을 TRUE로 설정해야 합니다. 이렇게 하면 백그라운드에서 APN 토큰이 요청되거나 자동 푸시 알림이 전송되는 일 없이 처리됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 앱 인증을 사용 중지하는 방법은 무엇인가요?", "answer": "Firebase Authentication은 직접 테스트 외에도 전화 인증 테스트용 통합 테스트를 작성할 수 있는 API를 제공합니다. 이 API를 사용하여 앱 인증을 사용 중지할 수 있습니다. 프로덕션 앱에서는 앱 인증이 사용 중지되거나 가상 전화번호가 프로덕션 앱에 하드코딩되어서는 안 됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화 인증 테스트를 위한 통합 테스트를 어떻게 작성하나요?", "answer": "Firebase Authentication은 전화 인증 테스트용 통합 테스트를 작성할 수 있는 API를 제공합니다. 이러한 API는 웹에서 reCAPTCHA 요구사항을, iOS에서 백그라운드 푸시 알림을 중지하여 앱 인증을 사용 중지합니다. 이를 통해 테스트를 자동화하고 더 쉽게 구현할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "iOS에서 verifyPhoneNumber 메서드를 호출하기 전에 어떤 설정을 해야 하나요?", "answer": "iOS에서는 verifyPhoneNumber를 호출하기 전에 appVerificationDisabledForTesting 설정을 TRUE로 설정해야 합니다. 이렇게 하면 백그라운드에서 APN 토큰이 요청되거나 자동 푸시 알림이 전송되는 일 없이 처리되므로 시뮬레이터에서 훨씬 쉽게 테스트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 앱 인증을 사용 중지하면 어떤 결과가 발생하나요?", "answer": "앱 인증이 사용 중지될 경우 실제 전화번호를 사용하면 로그인에 실패하게 됩니다. 이 API로는 가상 전화번호만 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 APN 기기 토큰을 가져오는 방법은 무엇인가요?", "answer": "APN 기기 토큰을 가져오려면 application(_:didRegisterForRemoteNotificationsWithDeviceToken:) 메서드를 구현하고 이 메서드에서 Auth의 setAPNSToken(_:type:) 메서드에 기기 토큰을 전달해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 재구성을 비활성화하는 방법은 무엇인가요?", "answer": "재구성을 비활성화하려면 앱의 Info.plist 파일에 FirebaseAppDelegateProxyEnabled 플래그를 추가하고 NO로 설정해야 합니다. 이 플래그를 NO로 설정하면 Firebase Cloud Messaging을 비롯한 기타 Firebase 제품에서도 재구성이 비활성화됩니다.", "source": ["https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_phone-auth_hl=ko.txt"}
{"question": "앱 간 인증 상태를 공유하기 위해 어떤 절차를 따라야 하나요?", "answer": "앱 간에 인증 상태를 공유하려면 다음 안내를 따르세요. 1. 앱에 대한 액세스 그룹을 설정합니다. 2. Xcode에서 Project settings(프로젝트 설정) > Capabilities(기능)로 이동합니다. 3. 키체인 공유를 사용 설정합니다. 4. 키체인 그룹 식별자를 추가합니다. 상태를 공유하려는 모든 앱에 동일한 식별자를 사용합니다. 5. 각 앱에서 이전 단계에서 만든 키체인 액세스 그룹 또는 앱 그룹으로 액세스 그룹을 설정합니다.", "source": ["https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_single-sign-on_hl=ko.txt"}
{"question": "Swift에서 인증 상태를 공유하기 위해 액세스 그룹을 설정하는 방법은 무엇인가요?", "answer": "Swift에서 인증 상태를 공유하기 위해 액세스 그룹을 설정하려면 다음 코드를 사용합니다: \n```swift\ntry Auth.auth().useUserAccessGroup(\"TEAMID.com.example.group1\")\n```", "source": ["https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_single-sign-on_hl=ko.txt"}
{"question": "Objective-C에서 현재 사용자를 가져오는 방법은 무엇인가요?", "answer": "Objective-C에서 현재 사용자를 가져오려면 다음 코드를 사용합니다: \n```objective-c\nFIRUser *user = FIRAuth.auth.currentUser;\n```", "source": ["https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_single-sign-on_hl=ko.txt"}
{"question": "비공유 키체인으로 전환하는 방법은 무엇인가요?", "answer": "비공유 키체인으로 전환하려면 액세스 그룹을 nil로 설정합니다. Swift에서는 다음 코드를 사용합니다: \n```swift\ntry Auth.auth().useUserAccessGroup(nil)\n``` Objective-C에서는 다음 코드를 사용합니다: \n```objective-c\n[FIRAuth.auth useUserAccessGroup:nil error:nil];\n```", "source": ["https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_single-sign-on_hl=ko.txt"}
{"question": "공유 키체인에서 비공유 키체인으로 전환할 때 어떤 주의사항이 있나요?", "answer": "공유 키체인에서 비공유 키체인으로 전환하면 로그인한 사용자가 삭제됩니다. 공유 키체인에서 비공유 키체인으로 전환하면 앱에서 액세스 그룹을 사용하지 않아도 로그인한 사용자가 삭제되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_single-sign-on_hl=ko.txt"}
{"question": "Firebase Authentication을 앱에 추가하기 위해 Swift Package Manager를 사용하여 Firebase 종속 항목을 설치하는 방법은 무엇인가요?", "answer": "앱 프로젝트를 연 상태로 Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동합니다. 메시지가 표시되면 Firebase Apple 플랫폼 SDK 저장소를 추가합니다. URL은 https://github.com/firebase/firebase-ios-sdk.git입니다. Firebase Authentication 라이브러리를 선택하고, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Firebase SDK를 초기화하는 방법은 무엇인가요?", "answer": "앱 대리자에서 Firebase SDK를 가져온 후, application:didFinishLaunchingWithOptions: 메서드에서 FirebaseApp 객체를 초기화합니다. Swift에서는 다음과 같이 작성합니다:\n```swift\n// Use Firebase library to configure APIs\nFirebaseApp.configure()\n```\nObjective-C에서는 다음과 같이 작성합니다:\n```objective-c\n// Use Firebase library to configure APIs\n[FIRApp configure];\n```", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Firebase Local Emulator Suite을 사용하여 프로토타입을 제작하고 테스트하는 방법은 무엇인가요?", "answer": "Firebase Local Emulator Suite을 사용하려면, 앱의 테스트 구성에 코드 줄을 추가하고, 로컬 프로젝트 디렉터리의 루트에서 `firebase emulators:start`를 실행합니다. 대화형 프로토타입 제작에는 Local Emulator Suite UI를, 비대화형 테스트에는 Authentication 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Mac 앱에서 Firebase SDK가 키체인에 사용자 항목을 저장할 권한을 갖도록 설정하는 방법은 무엇인가요?", "answer": "Mac 앱의 경우 SDK가 키체인에 사용자 항목을 저장할 권한을 갖도록 키체인 공유 기능을 사용 설정해야 합니다. 자세한 내용은 FAQ 가이드를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Firebase Authentication 에뮬레이터를 사용하기 위해 필요한 단계는 무엇인가요?", "answer": "Authentication 에뮬레이터를 사용하려면, 앱의 테스트 구성에 코드 줄을 추가하고, 로컬 프로젝트 디렉터리의 루트에서 `firebase emulators:start`를 실행합니다. 이후 대화형 프로토타입 제작에는 Local Emulator Suite UI를, 비대화형 테스트에는 Authentication 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Firebase Authentication 에뮬레이터를 사용하여 앱을 테스트하기 위해 필요한 초기 설정 단계는 무엇인가요?", "answer": "Firebase Authentication 에뮬레이터를 사용하려면 다음 단계를 수행해야 합니다.\n\n1. 에뮬레이터에 연결하려면 앱의 테스트 구성에 코드 줄을 추가합니다.\n2. 로컬 프로젝트 디렉터리의 루트에서 `firebase emulators:start`를 실행합니다.\n3. 대화형 프로토타입 제작에는 Local Emulator Suite UI를, 비대화형 테스트에는 Authentication 에뮬레이터 REST API를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Firebase SDK를 Swift에서 초기화하는 방법은 무엇인가요?", "answer": "Firebase SDK를 Swift에서 초기화하려면, 앱 대리자에서 FirebaseCore를 가져온 후, `application:didFinishLaunchingWithOptions:` 메서드에서 FirebaseApp 객체를 초기화해야 합니다. 아래는 코드 예시입니다.\n\n```swift\n// Use Firebase library to configure APIs\nFirebaseApp.configure()\n```", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Objective-C에서 Firebase SDK를 초기화하는 방법은 무엇인가요?", "answer": "Objective-C에서 Firebase SDK를 초기화하려면, 앱 대리자에서 FirebaseCore를 가져온 후, `application:didFinishLaunchingWithOptions:` 메서드에서 FIRApp 객체를 초기화해야 합니다. 아래는 코드 예시입니다.\n\n```objective-c\n// Use Firebase library to configure APIs\n[FIRApp configure];\n```", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "앱에서 로그인한 사용자에 대한 정보를 얻기 위해 FIRAuth 객체와 리스너를 연결하는 방법은 무엇인가요?", "answer": "앱에서 로그인한 사용자에 대한 정보를 얻기 위해 FIRAuth 객체와 리스너를 연결하려면, 뷰 컨트롤러의 `viewWillAppear` 메서드에서 리스너를 추가해야 합니다. 아래는 Swift 코드 예시입니다.\n\n```swift\nhandle = Auth.auth().addStateDidChangeListener { auth, user in\n    // 사용자 정보 처리\n}\n```", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "Objective-C에서 로그인 상태 변경 리스너를 추가하는 방법은 무엇인가요?", "answer": "Objective-C에서 로그인 상태 변경 리스너를 추가하려면, 뷰 컨트롤러의 적절한 메서드에서 FIRAuth 객체의 `addAuthStateDidChangeListener` 메서드를 사용해야 합니다. 아래는 코드 예시입니다.\n\n```objective-c\nself.handle = [[FIRAuth auth]\n    addAuthStateDidChangeListener:^(FIRAuth *_Nonnull auth, FIRUser *_Nullable user) {\n        // 사용자 정보 처리\n    }];\n```", "source": ["https://firebase.google.com/docs/auth/ios/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_start_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정하기 위해 Admin SDK에서 어떤 코드를 실행해야 하나요?", "answer": "다음 코드를 실행하여 TOTP MFA를 사용 설정할 수 있습니다.\n\n```javascript\nimport { getAuth } from 'firebase-admin/auth';\n\ngetAuth().projectConfigManager().updateProjectConfig(\n  multiFactorConfig: {\n    providerConfigs: [{\n      state: \"ENABLED\",\n      totpProviderConfig: {\n        adjacentIntervals: NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n);\n```", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "REST API를 사용하여 TOTP MFA를 사용 설정하는 방법은 무엇인가요?", "answer": "다음 curl 명령어를 사용하여 REST API를 통해 TOTP MFA를 사용 설정할 수 있습니다.\n\n```bash\ncurl -X PATCH \"https://identitytoolkit.googleapis.com/admin/v2/projects/PROJECT_ID/config?updateMask=mfa\" \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\" \\\n-d \\\n'{\n  \"mfa\": {\n    \"providerConfigs\": [{\n      \"state\": \"ENABLED\",\n      \"totpProviderConfig\": {\n        \"adjacentIntervals\": NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n}'\n```", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정하기 전에 어떤 조건을 충족해야 하나요?", "answer": "MFA를 지원하는 하나 이상의 제공업체를 사용 설정해야 하며, 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일 주소에 서비스를 등록한 후 두 번째 단계를 추가하여 이메일 주소의 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "사용자가 TOTP MFA에 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "사용자를 TOTP MFA에 등록하기 위해 다음과 같은 클라이언트 측 로직을 구현해야 합니다.\n\n```swift\n// 사용자를 다시 인증합니다.\n// 인증된 사용자의 TOTP 보안 비밀을 생성합니다.\nwith: multiFactorAssertion,\ndisplayName: \"TOTP\"\n```\nMFA를 사용하지 않을 때와 마찬가지로 signIn(with...:) 메서드 중 하나를 호출합니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA에서 사용자가 등록 해제할 때 어떤 오류가 발생하나요?", "answer": "사용자가 여러 MFA 옵션에 가입했고, 가장 최근에 사용 설정된 옵션에서 등록 해제한 경우 auth/user-token-expired 오류를 수신하고 로그아웃됩니다. 사용자는 다시 로그인하여 기존 사용자 인증 정보(예: 이메일 주소와 비밀번호)를 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정한 후 사용자를 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현합니다. 사용자를 다시 인증하고, 인증된 사용자의 TOTP 보안 비밀을 생성합니다. 다음 코드를 사용하세요:\n\n```swift\nsignIn(with: multiFactorAssertion,\n         displayName: \"TOTP\")\n```\nMFA를 사용하지 않을 때와 마찬가지로 signIn(with...:) 메서드 중 하나를 호출합니다(예: signIn(withEmail:password:)). 메서드에서 secondFactorRequired 코드와 함께 오류가 발생하면 앱의 MFA 흐름을 시작합니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정할 때 필요한 curl 명령어는 무엇인가요?", "answer": "TOTP MFA를 사용 설정하기 위해 다음 curl 명령어를 실행합니다:\n\n```bash\ncurl -X PATCH \"https://identitytoolkit.googleapis.com/admin/v2/projects/PROJECT_ID/config?updateMask=mfa\" \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\" \\\n-d \\\n'{\n\"mfa\": {\n\"providerConfigs\": [{\n\"state\": \"ENABLED\",\n\"totpProviderConfig\": {\n\"adjacentIntervals\": NUM_ADJ_INTERVALS\n```", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "사용자가 TOTP MFA에서 등록 해제할 때 어떤 오류가 발생하나요?", "answer": "사용자가 여러 MFA 옵션에 가입했고, 가장 최근에 사용 설정된 옵션에서 등록 해제한 경우 auth/user-token-expired 오류를 수신하고 로그아웃됩니다. 사용자는 다시 로그인하여 기존 사용자 인증 정보(예: 이메일 주소와 비밀번호)를 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정할 때 등록 패턴은 어떻게 선택하나요?", "answer": "앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 몇몇 일반적인 패턴은 다음과 같습니다:\n1. 등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n2. 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 앱에서 다중 인증(MFA)을 권장하지만 필수가 아니라면 이 방법을 사용할 수 있습니다.\n3. 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용 설정한 후 사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 어떻게 해야 하나요?", "answer": "사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다. 이를 통해 사용자는 보안에 민감한 기능에 접근할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_totp-mfa_hl=ko.txt"}
{"question": "Firebase SDK를 Apple 프로젝트에 추가하는 방법은 무엇인가요?", "answer": "Firebase SDK를 Apple 프로젝트에 추가하려면, Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동하여 Firebase Apple 플랫폼 SDK 저장소를 추가합니다. URL은 https://github.com/firebase/firebase-ios-sdk.git입니다. 이후 Firebase Authentication 라이브러리를 선택하고, 타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Twitter 로그인을 Firebase에서 사용 설정하는 방법은 무엇인가요?", "answer": "Twitter 로그인을 Firebase에서 사용 설정하려면, Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Twitter 제공업체를 사용 설정합니다. 또한, 해당 제공업체의 개발자 콘솔에서 제공되는 API 키와 API 비밀번호를 제공업체 구성에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Firebase SDK로 Twitter 로그인을 처리하는 과정은 어떻게 되나요?", "answer": "Firebase SDK로 Twitter 로그인을 처리하려면, 먼저 Xcode 프로젝트에 커스텀 URL 스킴을 추가해야 합니다. 그런 다음, 제공업체 ID OAuthProvider을 사용하여 OAuthProvider의 인스턴스를 생성하고, provider.getCredentialWith(nil) 메서드를 호출하여 Firebase에 인증합니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "OAuthProvider의 인스턴스를 생성하는 Swift 코드 예시는 무엇인가요?", "answer": "OAuthProvider의 인스턴스를 생성하는 Swift 코드 예시는 다음과 같습니다:\n```swift\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"twitter.com\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "사용자에게 reCAPTCHA를 제시할 때 앱에서 SFSafariViewController를 표시하는 방법은 무엇인가요?", "answer": "사용자에게 reCAPTCHA를 제시할 때 앱에서 SFSafariViewController 또는 UIWebView를 표시하는 방식을 맞춤설정하려면, AuthUIDelegate 프로토콜을 준수하는 커스텀 클래스를 만들어 credentialWithUIDelegate에 전달해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Firebase SDK에서 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면, 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "OAuthProvider의 인스턴스를 생성하는 Swift 코드 예시는 무엇인가요?", "answer": "다음은 OAuthProvider의 인스턴스를 생성하는 Swift 코드 예시입니다.\n\n```swift\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"twitter.com\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇이며, 어떻게 처리해야 하나요?", "answer": "Firebase에서 요구하는 매개변수는 client_id, redirect_uri, response_type, scope, state입니다. 이러한 매개변수는 setCustomParameters와 함께 전달할 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "사용자가 원하는 제공업체로 로그인하기 위해 기존 제공업체에 로그인하는 방법은 무엇인가요?", "answer": "사용자가 원하는 제공업체로 로그인하려면 먼저 기존 제공업체(Google)에 로그인한 후 신규 제공업체의 FIRAuthCredential(Twitter 사용자 인증 정보)에 연결해야 합니다. 다음은 Swift 코드 예시입니다.\n\n```swift\nNSString *existingAcctEmail = error.userInfo[FIRAuthErrorUserInfoEmailKey];\nFIRAuthCredential *pendingCred = error.userInfo[FIRAuthErrorUserInfoUpdatedCredentialKey];\n```", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 사용자에게 reCAPTCHA를 제시할 때 커스텀 클래스를 만드는 방법은 무엇인가요?", "answer": "사용자에게 reCAPTCHA를 제시할 때 앱에서 SFSafariViewController 또는 UIWebView를 표시하는 방식을 맞춤설정하려면 AuthUIDelegate 프로토콜을 준수하는 커스텀 클래스를 만들어 credentialWithUIDelegate에 전달해야 합니다.", "source": ["https://firebase.google.com/docs/auth/ios/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_twitter-login_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 Yahoo를 로그인 제공업체로 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 Yahoo를 로그인 제공업체로 사용 설정하려면 다음 단계를 따르세요:\n1. Firebase Console에서 인증 섹션을 엽니다.\n2. 로그인 방법 탭에서 Yahoo 제공업체를 사용 설정합니다.\n3. 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/ios/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_yahoo-oauth_hl=ko.txt"}
{"question": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하는 방법은 무엇인가요?", "answer": "Xcode 프로젝트에 커스텀 URL 스킴을 추가하려면 다음 단계를 따르세요:\n1. 왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다.\n2. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다.\n3. + 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/ios/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_yahoo-oauth_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 맞춤 OAuth 매개변수를 추가하는 방법은 무엇인가요?", "answer": "OAuth 요청과 함께 전송할 맞춤 OAuth 매개변수를 추가하려면 다음과 같이 설정합니다:\n\nSwift\n```swift\nprovider.customParameters = [\n    \"prompt\": \"login\",\n    \"language\": \"fr\"\n]\n```\n\nObjective-C\n```objective-c\n[provider setCustomParameters:@{@", "source": ["https://firebase.google.com/docs/auth/ios/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_yahoo-oauth_hl=ko.txt"}
{"question": "OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "제공업체 ID OAuthProvider을 사용하여 OAuthProvider의 인스턴스를 만듭니다.\n\nSwift\n```swift\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"yahoo.com\"];\n```\n\nObjective-C\n```objective-c\nFIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@\"yahoo.com\"];\n```", "source": ["https://firebase.google.com/docs/auth/ios/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_yahoo-oauth_hl=ko.txt"}
{"question": "OAuth 요청에 맞춤 매개변수를 추가하는 방법은 무엇인가요?", "answer": "선택사항: OAuth 요청과 함께 전송하고자 하는 맞춤 OAuth 매개변수를 추가로 지정합니다.\n\nSwift\n```swift\nprovider.customParameters = [\n    \"prompt\": \"login\",\n    \"language\": \"fr\"\n]\n```\n\nObjective-C\n```objective-c\n[provider setCustomParameters:@{@", "source": ["https://firebase.google.com/docs/auth/ios/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_ios_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 계정 생성 시 IP 주소당 한도는 어떻게 되나요?", "answer": "새 계정 생성 시 IP 주소당 계정 100개/시간의 한도가 있습니다.", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 이메일 전송 한도는 어떻게 되나요?", "answer": "이메일 전송 한도는 사용자 수에 따라 확장됩니다. 예를 들어, Spark 요금제에서는 주소 확인 이메일이 1,000개/일로 제한되며, Blaze 요금제에서는 100,000개/일로 제한됩니다.", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "전화번호 로그인 한도는 어떻게 설정되어 있나요?", "answer": "전화번호 로그인 한도는 사용자 로그인 시 1,600건/분으로 설정되어 있으며, 인증 요청은 요청 150회/IP 주소/시간으로 제한됩니다.", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 인증 SMS 전송 한도는 어떻게 되나요?", "answer": "인증 SMS 전송 한도는 1,000개 전송/분으로 설정되어 있으며, IP 주소당 전송된 인증 SMS는 50개 전송/분, 500개 전송/시간으로 제한됩니다.", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 계정 삭제 한도는 어떻게 되나요?", "answer": "계정 삭제 한도는 계정 10개/초로 설정되어 있으며, 계정 일괄 삭제는 요청 1회/초로 제한됩니다.", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 주소 확인 이메일을 전송할 수 있는 한도는 어떻게 되나요?", "answer": "| 작업 | Spark 요금제 한도 | Blaze 요금제 한도 |\n| --- | --- | --- |\n| 주소 확인 이메일 | 이메일 1,000개/일 | 이메일 100,000개/일 |", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 비밀번호 재설정 이메일의 전송 한도는 어떻게 되나요?", "answer": "| 작업 | Spark 요금제 한도 | Blaze 요금제 한도 |\n| --- | --- | --- |\n| 비밀번호 재설정 이메일 | 이메일 150개/일 | 이메일 10,000개/일 |", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 주소 변경 이메일을 전송할 수 있는 한도는 어떻게 되나요?", "answer": "| 작업 | Spark 요금제 한도 | Blaze 요금제 한도 |\n| --- | --- | --- |\n| 주소 변경 이메일 | 이메일 1,000개/일 | 이메일 10,000개/일 |", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 인증 SMS 전송 한도는 어떻게 되나요?", "answer": "| 작업 | 한도 |\n| --- | --- |\n| 인증 SMS 전송. | 1,000개 전송/분 |\n| IP 주소당 전송된 인증 SMS | 50개 전송/분, 500개 전송/시간 |", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Firebase에서 프로젝트당 작업 수의 한도는 어떻게 되나요?", "answer": "| 작업 | 한도 |\n| --- | --- |\n| 프로젝트당 작업 수 | 요청 1,000회/초, 1,000만 회/일 |", "source": ["https://firebase.google.com/docs/auth/limits?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_limits_hl=ko.txt"}
{"question": "Unity에서 Firebase 사용자 계정에 Google 인증 제공업체를 연결하는 방법은 무엇인가요?", "answer": "Google 인증 제공업체를 연결하기 위해서는 먼저 사용자를 로그인 처리한 후, Google ID 토큰과 Google 액세스 토큰을 가져와야 합니다. 그런 다음, 다음과 같이 Firebase.Auth.Credential 객체를 생성합니다:\n\n```csharp\nFirebase.Auth.Credential credential =\nFirebase.Auth.GoogleAuthProvider.GetCredential(googleIdToken, googleAccessToken);\n```\n이후, `auth.CurrentUser.LinkWithCredentialAsync(credential)` 메서드를 호출하여 연결을 완료합니다.", "source": ["https://firebase.google.com/docs/auth/unity/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_account-linking_hl=ko.txt"}
{"question": "Firebase에서 사용자 계정과 Facebook 인증 제공업체의 연결을 해제하는 방법은 무엇인가요?", "answer": "사용자 계정과 Facebook 인증 제공업체의 연결을 해제하려면, 제공업체 ID를 `UnlinkAsync` 메서드에 전달해야 합니다. 사용자 계정에 연결된 인증 제공업체의 ID는 `ProviderData`를 호출하여 가져올 수 있습니다. 다음은 연결 해제 코드 예시입니다:\n\n```csharp\nawait auth.CurrentUser.UnlinkAsync(\"facebook.com\");\n```", "source": ["https://firebase.google.com/docs/auth/unity/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_account-linking_hl=ko.txt"}
{"question": "Firebase에서 사용자 계정에 이메일-비밀번호 인증 제공업체를 연결하는 방법은 무엇인가요?", "answer": "이메일-비밀번호 인증 제공업체를 연결하기 위해서는 사용자의 이메일과 비밀번호를 가져온 후, 다음과 같이 Firebase.Auth.Credential 객체를 생성합니다:\n\n```csharp\nFirebase.Auth.Credential credential =\nFirebase.Auth.EmailAuthProvider.GetCredential(email, password);\n```\n그 후, `auth.CurrentUser.LinkWithCredentialAsync(credential)` 메서드를 호출하여 연결을 완료합니다.", "source": ["https://firebase.google.com/docs/auth/unity/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_account-linking_hl=ko.txt"}
{"question": "Firebase에서 `LinkWithCredentialAsync` 메서드 호출 후 성공적으로 연결되었는지 확인하는 방법은 무엇인가요?", "answer": "`LinkWithCredentialAsync` 메서드 호출 후, `ContinueWith` 메서드를 사용하여 작업의 결과를 확인할 수 있습니다. 성공적으로 연결되면 다음과 같은 로그를 출력할 수 있습니다:\n\n```csharp\nDebug.LogFormat(\"Credentials successfully linked to Firebase user: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n```", "source": ["https://firebase.google.com/docs/auth/unity/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_account-linking_hl=ko.txt"}
{"question": "Firebase에서 `SignInAndRetrieveDataWithCredentialAsync` 메서드 호출 시 주의해야 할 점은 무엇인가요?", "answer": "`SignInAndRetrieveDataWithCredentialAsync` 메서드를 호출하기 전에 사용자의 인증 정보를 가져와야 하며, 이 메서드 호출이 완료되기 전에 다른 작업을 진행하지 않아야 합니다. 예를 들어, Google ID 토큰이나 Facebook 액세스 토큰을 가져온 후에 호출해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_account-linking_hl=ko.txt"}
{"question": "Unity에서 Firebase에 익명으로 인증하기 위해 어떤 초기 설정이 필요한가요?", "answer": "Firebase Authentication을 사용하려면 먼저 Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 합니다. 이러한 초기 설정 단계에 관한 자세한 내용은 Unity 프로젝트에 Firebase 추가를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/unity/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_anonymous-auth_hl=ko.txt"}
{"question": "Firebase Console에서 익명 인증을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고, 로그인 방법 페이지에서 익명 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_anonymous-auth_hl=ko.txt"}
{"question": "자동 정리를 사용 설정하면 익명 계정에 어떤 영향을 미치나요?", "answer": "자동 정리를 사용 설정하면 30일이 지난 익명 계정은 자동으로 삭제됩니다. 자동 정리가 사용 설정된 프로젝트에서는 익명 인증이 더 이상 사용량 한도 또는 결제 할당량에 포함되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/unity/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_anonymous-auth_hl=ko.txt"}
{"question": "Unity에서 익명으로 로그인하기 위한 코드 예시는 어떻게 되나요?", "answer": "다음 코드를 사용하여 익명으로 로그인할 수 있습니다:\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\nauth.SignInAnonymouslyAsync().ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAnonymouslyAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAnonymouslyAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자가 Firebase의 인증이 필요한 앱 기능을 사용할 때 어떤 절차를 따라야 하나요?", "answer": "로그아웃 상태의 사용자가 Firebase의 인증이 필요한 앱 기능을 사용할 때, FirebaseAuth.DefaultInstance를 통해 액세스하고, Firebase.Auth.FirebaseAuth.SignInAnonymouslyAsync를 호출하여 익명으로 로그인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_anonymous-auth_hl=ko.txt"}
{"question": "Apple로 로그인 기능을 사용하기 위해 사용자가 충족해야 하는 조건은 무엇인가요?", "answer": "Apple로 로그인하려면 사용자는 2단계 인증(2FA)이 사용 설정된 Apple ID가 있어야 하며, Apple 기기에서 iCloud에 로그인되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase Console에서 Apple 로그인을 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Apple 제공업체를 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Apple 로그인을 구성할 때 Android 기기에 대한 지원이 필요한 경우 어떤 추가 작업이 필요한가요?", "answer": "Android 기기에 대한 지원이 필요한 경우, Android 프로젝트에 Firebase를 추가하고 Firebase Console에서 앱을 설정할 때 앱의 SHA-1 서명을 등록해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "익명처리된 Apple ID와 개인 식별 정보를 연결하기 위해 필요한 절차는 무엇인가요?", "answer": "개인 식별 정보를 익명처리된 Apple ID와 연결하려면 먼저 사용자 동의를 받아야 하며, 이메일 주소와 익명처리된 Apple ID 연결, 전화번호와 익명처리된 Apple ID 연결, 익명처리되지 않은 소셜 사용자 인증 정보(Facebook, Google 등)와 익명처리된 Apple ID 연결이 포함될 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase.Auth.FirebaseAuth 클래스에 어떻게 접근하나요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다. 예제 코드는 다음과 같습니다:\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Apple 로그인 제공업체를 Firebase Console에서 설정할 때 필요한 필드는 무엇인가요?", "answer": "Apple 로그인 제공업체 설정을 구성할 때, Apple 플랫폼에서만 앱을 배포하는 경우 서비스 ID, Apple Team ID, 비공개 키, 키 ID 필드는 비워두면 됩니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Apple 로그인 흐름을 처리하는 방법은 무엇인가요?", "answer": "Apple 플랫폼에서 Apple 로그인 흐름을 처리하기 위해서는 Unity의 Apple 로그인 애셋 스토리지 패키지를 설치하고, nonce와 토큰 생성을 처리해야 합니다. 다음은 코드 예시입니다:\n```csharp\nFirebase.Auth.Credential credential =\nFirebase.Auth.OAuthProvider.GetCredential(\"apple.com\", appleIdToken, rawNonce, null);\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Apple 로그인 시 기존 Firebase 계정과 연결된 Apple 계정이 있을 경우 발생하는 오류는 무엇인가요?", "answer": "Apple 로그인으로 연결할 때 기존 Firebase 계정이 이미 Apple 계정에 연결되었다는 오류가 발생할 수 있습니다. 이 경우 표준 Firebase.FirebaseException 대신 Firebase.Auth.FirebaseAccountLinkException이 발생합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase.Auth.FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. 다음과 같이 접근할 수 있습니다:\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Apple로 로그인할 때 익명처리된 데이터 요구사항을 준수하기 위해 필요한 절차는 무엇인가요?", "answer": "Apple로 로그인 시 사용자가 로그인할 때 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션이 제공됩니다. 이 경우, 앱에서 Apple로 로그인을 사용하는 경우 익명처리된 Apple ID에 대한 Apple의 관련 개발자 정책 또는 약관을 모두 준수해야 하며, 개인 식별 정보를 익명처리된 Apple ID와 연결하기 위해서는 먼저 사용자 동의를 받아야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Apple 로그인 흐름을 처리할 때 필요한 nonce 문자열을 어떻게 생성하나요?", "answer": "Unity의 Apple 로그인 애셋 스토리지 패키지와 같은 제3자 플러그인을 설치하여 Apple 로그인 nonce와 토큰 생성을 처리합니다. Firebase 작업에 사용하도록 원시 문자열 상태로 생성된 임의의 nonce 문자열을 연결하기 위해 코드를 변경해야 할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 계정과 기존 Firebase 계정을 연결할 때 발생할 수 있는 예외는 무엇인가요?", "answer": "Apple 플랫폼에서 Apple 로그인으로 연결할 때 기존 Firebase 계정이 이미 Apple 계정에 연결되었다는 오류가 발생할 수 있습니다. 이 경우 표준 Firebase.FirebaseException 대신 Firebase.Auth.FirebaseAccountLinkException이 발생합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Apple 로그인 시 사용자 인증 정보를 생성하는 방법은 무엇인가요?", "answer": "결과 토큰 문자열과 원래의 nonce를 사용하여 Firebase 사용자 인증 정보를 만들고 Firebase에 로그인합니다. 다음 코드를 사용합니다:\n```csharp\nFirebase.Auth.Credential credential =\nFirebase.Auth.OAuthProvider.GetCredential(\"apple.com\", appleIdToken, rawNonce, null);\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Android에서 Firebase SDK를 통해 Apple 로그인을 처리하는 방법은 무엇인가요?", "answer": "Android에서는 Firebase SDK를 통해 엔드 투 엔드 로그인 과정을 실행하는 앱에 웹 기반의 일반 OAuth 로그인을 통합하여 Firebase에 사용자를 인증합니다. 다음 단계를 따릅니다:\n1. Apple에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 만듭니다.\n```csharp\nFirebase.Auth.FederatedOAuthProviderData providerData =\nnew Firebase.Auth.FederatedOAuthProviderData();\nproviderData.ProviderId = \"apple.com\";\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 로그인 시 사용자에게 명시적인 동의를 얻는 방법은 무엇인가요?", "answer": "Apple에서는 개발자가 사용자의 Apple 계정을 다른 데이터에 연결하기 전에 사용자에게 명시적인 동의를 얻도록 요청합니다. 예를 들어 Facebook 계정을 현재 Firebase 계정에 연결하려면 사용자가 Facebook에 로그인할 때 얻은 액세스 토큰을 사용합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Apple 로그인을 처리할 때 FederatedOAuthProviderData를 어떻게 구성하나요?", "answer": "Apple에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 만듭니다. 다음과 같이 구성할 수 있습니다:\n\n```csharp\nFirebase.Auth.FederatedOAuthProviderData providerData =\nnew Firebase.Auth.FederatedOAuthProviderData();\n\nproviderData.ProviderId = \"apple.com\";\n\n// 선택사항: OAuth 2.0 범위를 추가로 지정\nproviderData.Scopes = new List<string>();\nproviderData.Scopes.Add(\"email\");\nproviderData.Scopes.Add(\"name\");\n\n// 선택사항: locale 매개변수 설정\nproviderData.CustomParameters = new Dictionary<string,string>();\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 로그인을 시작하기 위해 signInWithProvider를 호출하는 방법은 무엇인가요?", "answer": "로그인 과정을 시작하려면 다음과 같이 signInWithProvider를 호출합니다:\n\n```csharp\nauth.SignInWithProviderAsync(provider).ContinueOnMainThread(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInWithProviderAsync was canceled.\");\nreturn;\n}\nFirebase.Auth.AuthResult authResult = task.Result;\nFirebase.Auth.FirebaseUser user = authResult.User;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nuser.DisplayName, user.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Apple 로그인 시 사용자의 이메일을 앱에 공유하지 않을 경우 어떤 이메일 주소가 제공되나요?", "answer": "사용자가 자신의 이메일을 앱에 공유하지 않으면 Apple은 이 사용자의 고유 이메일 주소(xyz@privaterelay.appleid.com 형식)를 프로비저닝하여 개발자 앱으로 공유합니다. 비공개 이메일 릴레이 서비스를 구성한 경우 Apple은 익명처리된 주소로 전송된 이메일을 사용자의 실제 이메일 주소로 전달합니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 계정으로 처음 로그인할 때 어떤 사용자 정보를 앱에 공유하나요?", "answer": "Apple은 사용자가 처음 로그인할 때만 표시 이름 등의 사용자 정보를 앱에 공유합니다. 일반적으로 Firebase는 사용자가 Apple 계정으로 처음 로그인할 때 표시 이름을 저장하며, 이 표시 이름은 auth.CurrentUser.DisplayName을 사용하여 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 로그인을 통해 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_apple_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하기 위해 Unity 프로젝트에서 어떤 초기 설정을 해야 하나요?", "answer": "Firebase Authentication을 사용하기 위해서는 먼저 Firebase 프로젝트로 Unity 프로젝트를 등록하고, Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_custom-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트의 서버 키를 어떻게 가져오나요?", "answer": "Firebase 프로젝트의 서버 키를 가져오려면 프로젝트 설정의 서비스 계정 페이지로 이동한 후, Firebase Admin SDK 섹션 하단에서 '새 비공개 키 생성'을 클릭합니다. 그러면 새 서비스 계정의 공개 키/비공개 키 쌍이 자동으로 컴퓨터에 저장됩니다.", "source": ["https://firebase.google.com/docs/auth/unity/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_custom-auth_hl=ko.txt"}
{"question": "사용자가 로그인할 때 커스텀 토큰을 어떻게 처리하나요?", "answer": "사용자가 앱에 로그인하면 사용자의 로그인 인증 정보(예: 사용자 이름과 비밀번호)를 인증 서버로 전송합니다. 서버가 사용자 인증 정보를 확인하여 정보가 유효하면 커스텀 토큰을 반환합니다. 인증 서버에서 커스텀 토큰을 받은 후, 이 토큰을 Firebase.Auth.FirebaseAuth.SignInWithCustomTokenAsync에 전달하여 사용자를 로그인 처리합니다.", "source": ["https://firebase.google.com/docs/auth/unity/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_custom-auth_hl=ko.txt"}
{"question": "Firebase.Auth.FirebaseAuth.SignInWithCustomTokenAsync 메서드의 사용 예시는 무엇인가요?", "answer": "다음은 Firebase.Auth.FirebaseAuth.SignInWithCustomTokenAsync 메서드의 사용 예시입니다:\n```csharp\nauth.SignInWithCustomTokenAsync(custom_token).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInWithCustomTokenAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInWithCustomTokenAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_custom-auth_hl=ko.txt"}
{"question": "FirebaseAuth 클래스는 어떤 역할을 하나요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이 역할을 합니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다:\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_custom-auth_hl=ko.txt"}
{"question": "Unity 프로젝트에서 Firebase를 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "Unity 프로젝트에서 Firebase를 사용하기 위해서는 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 하며, Firebase Console 및 열려 있는 Unity 프로젝트 모두에서 작업을 수행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_facebook-login_hl=ko.txt"}
{"question": "FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 FirebaseAuth.DefaultInstance를 통해 접근할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_facebook-login_hl=ko.txt"}
{"question": "Facebook 사용자의 액세스 토큰을 Firebase 사용자 인증 정보로 교환하는 방법은 무엇인가요?", "answer": "Facebook 사용자의 액세스 토큰을 Firebase 사용자 인증 정보로 교환하기 위해서는 다음과 같은 코드를 사용합니다: \n```csharp\nFirebase.Auth.Credential credential = Firebase.Auth.FacebookAuthProvider.GetCredential(accessToken);\n```", "source": ["https://firebase.google.com/docs/auth/unity/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_facebook-login_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 SignInAndRetrieveDataWithCredentialAsync 메서드를 사용하는 방법은 무엇인가요?", "answer": "Firebase에 인증하기 위해 SignInAndRetrieveDataWithCredentialAsync 메서드를 사용할 때는 다음과 같은 코드를 사용합니다: \n```csharp\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n```", "source": ["https://firebase.google.com/docs/auth/unity/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_facebook-login_hl=ko.txt"}
{"question": "Firebase 인증 후 현재 사용자의 정보를 가져오는 방법은 무엇인가요?", "answer": "Firebase 인증 후 현재 사용자의 정보를 가져오기 위해서는 다음과 같은 코드를 사용할 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_facebook-login_hl=ko.txt"}
{"question": "Unity 프로젝트에서 Firebase를 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "Unity 프로젝트에서 Firebase를 사용하려면 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 하며, Firebase Console 및 열려 있는 Unity 프로젝트 모두에서 작업을 수행해야 합니다. 예를 들어, Console에서 Firebase 구성 파일을 다운로드한 후 이 파일을 Unity 프로젝트로 이동하는 작업이 필요합니다.", "source": ["https://firebase.google.com/docs/auth/unity/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_github-auth_hl=ko.txt"}
{"question": "FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_github-auth_hl=ko.txt"}
{"question": "GitHub 사용자의 토큰을 Firebase 사용자 인증 정보로 교환하는 방법은 무엇인가요?", "answer": "사용자가 정상적으로 로그인한 후에 액세스 토큰을 Firebase 사용자 인증 정보로 교환하려면 다음과 같이 Firebase.Auth.Credential을 생성합니다: \n```csharp\nFirebase.Auth.Credential credential = Firebase.Auth.GitHubAuthProvider.GetCredential(accessToken);\n```", "source": ["https://firebase.google.com/docs/auth/unity/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_github-auth_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 SignInAndRetrieveDataWithCredentialAsync 메서드를 사용하는 방법은 무엇인가요?", "answer": "Firebase에 인증하기 위해 SignInAndRetrieveDataWithCredentialAsync 메서드를 사용하려면 다음과 같이 코드를 작성합니다: \n```csharp\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_github-auth_hl=ko.txt"}
{"question": "Firebase 사용자 인증 후 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "Firebase 사용자 인증 후 사용자 정보를 가져오려면 Firebase.Auth.FirebaseUser 객체를 사용하여 DisplayName, Email, PhotoUrl을 다음과 같이 가져올 수 있습니다: \n```csharp\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_github-auth_hl=ko.txt"}
{"question": "Unity 프로젝트에서 Firebase를 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "Unity 프로젝트에서 Firebase를 사용하려면 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 하며, Firebase Console 및 열려 있는 Unity 프로젝트 모두에서 작업을 수행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_google-signin_hl=ko.txt"}
{"question": "FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_google-signin_hl=ko.txt"}
{"question": "Google 로그인을 통해 Firebase에 인증하기 위한 코드 예시는 무엇인가요?", "answer": "Google 로그인을 통해 Firebase에 인증하기 위해서는 먼저 Google 로그인의 ID 토큰을 가져온 후, 다음과 같은 코드를 사용하여 Firebase 사용자 인증 정보를 생성하고 인증할 수 있습니다: \n```csharp\nFirebase.Auth.Credential credential = Firebase.Auth.GoogleAuthProvider.GetCredential(googleIdToken, googleAccessToken);\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n```", "source": ["https://firebase.google.com/docs/auth/unity/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_google-signin_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Google 로그인의 ID 토큰을 가져오는 방법은 무엇인가요?", "answer": "Firebase에 인증하기 위해서는 Android 및 iOS+ 안내에 따라 Google 로그인의 ID 토큰을 가져와야 합니다. 이 과정은 Firebase 문서에서 제공하는 플랫폼별 가이드를 참조하여 진행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_google-signin_hl=ko.txt"}
{"question": "Firebase 인증 후 사용자 정보를 어떻게 가져올 수 있나요?", "answer": "Firebase 인증 후, 현재 사용자 정보를 가져오기 위해 Firebase.Auth.FirebaseUser 객체를 사용할 수 있습니다. 예를 들어, 다음과 같이 현재 사용자의 이름, 이메일, 사진 URL을 가져올 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n```", "source": ["https://firebase.google.com/docs/auth/unity/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_google-signin_hl=ko.txt"}
{"question": "Firebase에서 사용자의 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "사용자의 프로필 정보를 가져오려면 Firebase.Auth.FirebaseUser 인스턴스의 접근자 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    string name = user.DisplayName;\n    string email = user.Email;\n    System.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 현재 로그인한 사용자를 가져오는 방법은 무엇인가요?", "answer": "현재 사용자를 가져올 때 권장하는 방법은 Auth 객체에 리스너를 설정하는 것입니다. 다음과 같이 설정할 수 있습니다.\n\n```csharp\nFirebase.Auth.FirebaseAuth auth;\nFirebase.Auth.FirebaseUser user;\n\nDebug.Log(\"Setting up Firebase Auth\");\nauth = Firebase.Auth.FirebaseAuth.DefaultInstance;\nauth.StateChanged += AuthStateChanged;\nAuthStateChanged(this, null);\nif (!signedIn && user != null) {\n    Debug.Log(\"Signed out \" + user.UserId);\n}\nif (signedIn) {\n    Debug.Log(\"Signed in \" + user.UserId);\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 이메일 주소를 설정하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소를 설정하려면 UpdateEmail 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    user.UpdateEmailAsync(\"user@example.com\").ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"UpdateEmailAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"UpdateEmailAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"User email updated successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자에게 인증 메일을 보내는 방법은 무엇인가요?", "answer": "사용자에게 인증 메일을 보내려면 SendEmailVerification 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    user.SendEmailVerificationAsync().ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"SendEmailVerificationAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"SendEmailVerificationAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"Email sent successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 비밀번호를 설정하는 방법은 무엇인가요?", "answer": "사용자의 비밀번호를 설정하려면 UpdatePassword 메서드를 사용합니다. 사용자의 현재 비밀번호를 확인한 후에 이 메서드를 호출해야 합니다. 구체적인 코드 예시는 문서에 포함되어 있지 않지만, 일반적으로 다음과 같은 형식으로 사용됩니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    user.UpdatePasswordAsync(\"newPassword\").ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"UpdatePasswordAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"UpdatePasswordAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"User password updated successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 프로필 정보를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 프로필 정보를 업데이트하려면 Firebase.Auth.FirebaseUser 인스턴스의 UpdateUserProfile 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    Firebase.Auth.UserProfile profile = new Firebase.Auth.UserProfile {\n        DisplayName = \"Jane Q. User\",\n        PhotoUrl = new System.Uri(\"https://example.com/jane-q-user/profile.jpg\")\n    };\n    user.UpdateUserProfileAsync(profile).ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"UpdateUserProfileAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"UpdateUserProfileAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"User profile updated successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 비밀번호를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 비밀번호를 업데이트하려면 Firebase.Auth.FirebaseUser 인스턴스의 UpdatePassword 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nstring newPassword = \"SOME-SECURE-PASSWORD\";\nif (user != null) {\n    user.UpdatePasswordAsync(newPassword).ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"UpdatePasswordAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"UpdatePasswordAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"Password updated successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자에게 비밀번호 재설정 이메일을 보내는 방법은 무엇인가요?", "answer": "사용자에게 비밀번호 재설정 이메일을 보내려면 Firebase.Auth.FirebaseAuth 인스턴스의 SendPasswordResetEmail 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nstring emailAddress = \"user@example.com\";\nif (user != null) {\n    auth.SendPasswordResetEmailAsync(emailAddress).ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"SendPasswordResetEmailAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"SendPasswordResetEmailAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"Password reset email sent successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자를 재인증하는 방법은 무엇인가요?", "answer": "사용자를 재인증하려면 Firebase.Auth.FirebaseUser 인스턴스의 ReauthenticateAsync 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nFirebase.Auth.Credential credential =\n    Firebase.Auth.EmailAuthProvider.GetCredential(\"user@example.com\", \"password1234\");\nif (user != null) {\n    user.ReauthenticateAsync(credential).ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"ReauthenticateAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"ReauthenticateAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"User reauthenticated successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase에서 사용자 계정을 삭제하는 방법은 무엇인가요?", "answer": "사용자 계정을 삭제하려면 Firebase.Auth.FirebaseUser 인스턴스의 Delete 메서드를 사용합니다. 예를 들면 다음과 같습니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    user.DeleteAsync().ContinueWith(task => {\n        if (task.IsCanceled) {\n            Debug.LogError(\"DeleteAsync was canceled.\");\n            return;\n        }\n        if (task.IsFaulted) {\n            Debug.LogError(\"DeleteAsync encountered an error: \" + task.Exception);\n            return;\n        }\n        Debug.Log(\"User deleted successfully.\");\n    });\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_manage-users_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Microsoft OAuth 로그인을 처리하는 기본 단계는 무엇인가요?", "answer": "Firebase SDK로 로그인 과정을 처리하려면 다음 단계를 따르세요.\n\n1. Microsoft에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 생성합니다.\n   ```csharp\n   Firebase.Auth.FederatedOAuthProviderData providerData =\n   new Firebase.Auth.FederatedOAuthProviderData();\n   providerData.ProviderId = Firebase.Auth.MicrosoftAuthProvider.ProviderId;\n   ```\n2. 선택사항: OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다.\n   ```csharp\n   providerData.CustomParameters = new Dictionary<string,string>();\n   providerData.CustomParameters.Add(\"tenant\", \"user@firstadd.onmicrosoft.com\");\n   ```\n3. 제공업체 데이터가 구성되었으면 이를 사용하여 FederatedOAuthProvider를 만듭니다.\n   ```csharp\n   Firebase.Auth.FederatedOAuthProvider provider = new Firebase.Auth.FederatedOAuthProvider();\n   provider.SetProviderData(providerData);\n   ```\n4. 인증 제공업체 객체를 사용해 Firebase에 인증합니다.", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "FirebaseAuth.DefaultInstance를 통해 FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다.\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 로그인을 위해 추가할 수 있는 OAuth 2.0 범위는 무엇인가요?", "answer": "인증 제공업체에 요청하고자 하는 기본 프로필 범위를 넘는 OAuth 2.0 범위를 추가로 지정할 수 있습니다. 예를 들어:\n```csharp\nproviderData.Scopes = new List<string>();\nproviderData.Scopes.Add(\"mail.read\");\nproviderData.Scopes.Add(\"calendars.read\");\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 요구하는 매개변수는 무엇이며, 어떻게 처리해야 하나요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, response_type, redirect_uri, state, scope, response_mode가 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "로그인 과정을 시작하기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "로그인 과정을 시작하려면 다음과 같이 SignInWithProviderAsync를 호출합니다.\n```csharp\nauth.SignInWithProviderAsync(provider).ContinueOnMainThread(task => {\n    if (task.IsCanceled) {\n        Debug.LogError(\"SignInWithProviderAsync was canceled.\");\n        return;\n    }\n    Firebase.Auth.AuthResult authResult = task.Result;\n    Firebase.Auth.FirebaseUser user = authResult.User;\n    Debug.LogFormat(\"User signed in successfully: {0} ({1})\",\n    user.DisplayName, user.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft OAuth 로그인을 위해 FederatedOAuthProviderData의 인스턴스를 어떻게 생성하나요?", "answer": "FederatedOAuthProviderData의 인스턴스를 생성하려면 다음과 같이 코드를 작성합니다.\n\n```csharp\nFirebase.Auth.FederatedOAuthProviderData providerData =\nnew Firebase.Auth.FederatedOAuthProviderData();\nproviderData.ProviderId = Firebase.Auth.MicrosoftAuthProvider.ProviderId;\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "OAuth 요청과 함께 전송할 커스텀 매개변수를 어떻게 추가하나요?", "answer": "커스텀 매개변수를 추가하려면 다음과 같이 Dictionary를 사용하여 설정합니다.\n\n```csharp\nproviderData.CustomParameters = new Dictionary<string,string>();\nproviderData.CustomParameters.Add(\"key\", \"user@firstadd.onmicrosoft.com\");\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "특정 Azure AD 테넌트의 사용자만 로그인하도록 허용하려면 어떻게 해야 하나요?", "answer": "특정 Azure AD 테넌트의 사용자만 로그인하도록 허용하려면 커스텀 매개변수 객체의 '테넌트' 필드를 지정해야 합니다. 예를 들어, 다음과 같이 설정할 수 있습니다.\n\n```csharp\nproviderData.CustomParameters.Add(\"tenant\", \"your-tenant-id\");\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 FederatedOAuthProvider를 어떻게 생성하나요?", "answer": "FederatedOAuthProvider를 생성하려면 다음과 같이 코드를 작성합니다.\n\n```csharp\nFirebase.Auth.FederatedOAuthProvider provider = new Firebase.Auth.FederatedOAuthProvider();\nprovider.SetProviderData(providerData);\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "로그인 과정을 시작하기 위해 어떤 메서드를 호출해야 하나요?", "answer": "로그인 과정을 시작하려면 다음과 같이 SignInWithProviderAsync 메서드를 호출합니다.\n\n```csharp\nauth.SignInWithProviderAsync(provider).ContinueOnMainThread(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInWithProviderAsync was canceled.\");\nreturn;\n}\nFirebase.Auth.AuthResult authResult = task.Result;\nFirebase.Auth.FirebaseUser user = authResult.User;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nuser.DisplayName, user.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_microsoft-oauth_hl=ko.txt"}
{"question": "FirebaseAuth.DefaultInstance를 사용하여 FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다.\n\n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 기반 계정을 생성하기 위해 필요한 절차는 무엇인가요?", "answer": "비밀번호가 있는 신규 사용자 계정을 생성하려면 앱의 로그인 코드에서 다음 절차를 완료해야 합니다. 신규 사용자가 앱의 가입 양식을 사용해 가입한 후, 이메일 주소와 비밀번호를 FirebaseAuth.CreateUserWithEmailAndPassword에 전달하여 신규 계정을 생성합니다. 예시는 다음과 같습니다.\n\n```csharp\nauth.CreateUserWithEmailAndPasswordAsync(email, password).ContinueWith(task => {\n    if (task.IsCanceled) {\n        Debug.LogError(\"CreateUserWithEmailAndPasswordAsync was canceled.\");\n        return;\n    }\n    Debug.LogError(\"CreateUserWithEmailAndPasswordAsync encountered an error: \" + task.Exception);\n    return;\n    Firebase.Auth.AuthResult result = task.Result;\n    Debug.LogFormat(\"Firebase user created successfully: {0} ({1})\",\n        result.User.DisplayName, result.User.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책을 설정할 때 지원되는 요구사항은 무엇인가요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다:\n- 소문자 필요\n- 대문자 필요\n- 숫자 필요\n- 영숫자가 아닌 문자 필요\n\n비밀번호 최소 길이는 6~30자이며, 기본값은 6입니다. 최대 길이는 4,096자입니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책 적용 모드에는 어떤 것들이 있나요?", "answer": "비밀번호 정책 적용을 사용 설정할 수 있는 두 가지 모드는 다음과 같습니다:\n1. 필수: 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다.\n2. 알림: 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있습니다. 이 모드에서는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하기 위해 사전에 어떤 작업을 해야 하나요?", "answer": "Firebase Authentication을 사용하려면 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Unity 프로젝트가 없는 경우 샘플 앱을 다운로드하여 사용할 수 있습니다. 또한, Firebase Unity SDK를 Unity 프로젝트에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "FirebaseAuth.CreateUserWithEmailAndPasswordAsync 메서드를 사용하여 신규 사용자 계정을 생성하는 방법은 무엇인가요?", "answer": "신규 사용자의 이메일 주소와 비밀번호를 FirebaseAuth.CreateUserWithEmailAndPassword에 전달하여 신규 계정을 생성합니다. 아래는 코드 예시입니다.\n\n```csharp\nauth.CreateUserWithEmailAndPasswordAsync(email, password).ContinueWith(task => {\n    if (task.IsCanceled) {\n        Debug.LogError(\"CreateUserWithEmailAndPasswordAsync was canceled.\");\n        return;\n    }\n    if (task.IsFaulted) {\n        Debug.LogError(\"CreateUserWithEmailAndPasswordAsync encountered an error: \" + task.Exception);\n        return;\n    }\n    Firebase.Auth.AuthResult result = task.Result;\n    Debug.LogFormat(\"Firebase user created successfully: {0} ({1})\",\n        result.User.DisplayName, result.User.UserId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책을 설정할 때 지원되는 비밀번호 요구사항은 무엇인가요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다.\n- 소문자 필요\n- 대문자 필요\n- 숫자 필요\n- 영숫자가 아닌 문자 필요\n\n다음 문자는 영숫자가 아닌 문자 요구사항을 충족합니다: ^ $ * . [ ] { } ( ) ? \" ! @ # % & / \\ , > < ' : ; | _ ~\n비밀번호 최소 길이는 6~30자이며, 기본값은 6입니다. 비밀번호 최대 길이는 최대 4,096자입니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책 적용 모드에는 어떤 것들이 있나요?", "answer": "비밀번호 정책 적용 모드는 다음 두 가지로 나뉩니다.\n1. 필수: 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다.\n2. 알림: 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있습니다. 이 모드를 사용할 때는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고, 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "이메일 열거 보호 기능을 사용 설정하는 방법은 무엇인가요?", "answer": "이메일 열거 보호 기능을 사용 설정하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 이메일 열거 보호 기능을 사용 설정하는 것이 좋습니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다. 앱이 더 구체적인 오류에 의존하지 않도록 해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "Firebase.Auth.FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "Firebase.Auth.FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져오려면 아래와 같이 코드를 작성합니다.\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    string name = user.DisplayName;\n    string email = user.Email;\n    System.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책을 준수하지 않는 비밀번호로 가입할 경우 어떤 점을 유의해야 하나요?", "answer": "정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있습니다. 이 모드를 사용할 때는 클라이언트 측에서 사용자의 비밀번호가 정책을 준수하는지 확인하고, 정책을 준수하지 않는 경우 사용자에게 비밀번호를 업데이트하라는 메시지를 어떤 방식으로든 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "활성 사용자가 있는 경우 비밀번호 정책을 어떻게 적용하는 것이 좋나요?", "answer": "활성 사용자가 있는 경우 비밀번호가 정책을 준수하지 않는 사용자의 액세스를 차단하려는 경우가 아니면 로그인 강제 업그레이드를 사용 설정하지 않는 것이 좋습니다. 대신 사용자가 현재 비밀번호로 로그인할 수 있게 해주고 비밀번호에 부족한 요구사항을 알리는 알림 모드를 사용하세요.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "이메일 열거 보호 기능을 사용 설정하는 이유는 무엇인가요?", "answer": "이메일 주소가 등록되어 있어야 하는데 등록되지 않은 경우 또는 이메일 주소를 사용해서는 안 되는데 등록된 경우, 이메일 주소를 파라미터로 사용하는 일부 Firebase Authentication 메서드에서 특정 오류가 발생합니다. 이는 사용자에게 특정 조치를 제안하는 데 유용할 수 있지만 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 데 악용될 수도 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication의 오류 보고 동작을 변경하는 방법은 무엇인가요?", "answer": "이러한 위험을 완화하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 이메일 열거 보호 기능을 사용 설정하는 것이 좋습니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다. 앱이 더 구체적인 오류에 의존하지 않는지 확인하세요.", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "Firebase.Auth.FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?", "answer": "다음 코드를 사용하여 Firebase.Auth.FirebaseUser 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다:\n\n```csharp\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null) {\n    string name = user.DisplayName;\n    string email = user.Email;\n    System.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 전화번호 로그인을 사용하기 위해 어떤 초기 설정이 필요한가요?", "answer": "Firebase Authentication을 사용하려면 먼저 Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 합니다. 이러한 초기 설정 단계에 관한 자세한 내용은 Unity 프로젝트에 Firebase 추가를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 사용하기 위해 Firebase 프로젝트에서 어떤 설정을 해야 하나요?", "answer": "SMS 메시지로 사용자를 로그인 처리하려면 우선 Firebase 프로젝트에서 전화번호 로그인 방법을 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "iOS에서 전화번호 인증을 사용하기 위해 필요한 APN 알림 설정 방법은 무엇인가요?", "answer": "iOS에서 전화번호 인증을 사용하려면 앱에서 Firebase가 전송하는 APN 알림을 수신할 수 있어야 합니다. Xcode에서 프로젝트에 푸시 알림을 사용 설정하고, Firebase에 APN 인증서를 업로드해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자의 전화로 인증 코드를 전송하는 방법은 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시한 다음, PhoneAuthProvider.VerifyPhoneNumber을 호출하여 Firebase가 사용자의 전화에 SMS 인증 코드를 전송하도록 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증의 보안 문제는 무엇인가요?", "answer": "전화번호만 사용하는 인증은 편리하지만, 전화번호 소유권은 사용자 간에 쉽게 이전될 수 있으므로 다른 방식보다 보안성이 떨어집니다. 또한 기기에 여러 사용자 프로필이 있는 경우 SMS 메시지를 받을 수 있는 사람이라면 누구든지 기기의 전화번호로 계정에 로그인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 사용하기 위해 Firebase Console에서 어떤 단계를 따라야 하나요?", "answer": "Firebase 프로젝트에서 전화번호 로그인을 사용 설정하려면 다음 단계를 따르세요.\n\n1. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다.\n2. 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "iOS에서 전화번호 인증을 사용하기 위해 APN 알림을 설정하는 방법은 무엇인가요?", "answer": "iOS에서 전화번호 인증을 사용하려면 다음 단계를 따르세요.\n\n1. Xcode에서 프로젝트에 푸시 알림을 사용 설정합니다. [http://help.apple.com/xcode/mac/current/#/dev11b059073?sub=dev73a37248c]\n2. Firebase에 APN 인증서를 업로드합니다. Apple Developer Member Center [https://developer.apple.com/membercenter/index.action]에서 APN 인증서를 만듭니다.\n3. Firebase Console 프로젝트 내에서 톱니바퀴 아이콘을 선택하고 프로젝트 설정을 선택한 다음 클라우드 메시징 탭을 선택합니다.\n4. 인증서 업로드 버튼을 선택하고 각 인증서에 대해 .p12 파일을 선택하고 비밀번호를 입력합니다. 이 인증서의 번들 ID가 앱의 번들 ID와 일치해야 합니다. 저장을 선택합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자의 전화번호를 확인하는 방법은 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 다음 단계를 따르세요.\n\n1. 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시합니다.\n2. PhoneAuthProvider.VerifyPhoneNumber을 호출하여 Firebase가 사용자의 전화에 SMS 인증 코드를 전송하도록 요청합니다.\n\n예제 코드:\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\n    new Firebase.Auth.PhoneAuthOptions {\n        PhoneNumber = phoneNumber,\n        TimeoutInMilliseconds = phoneAuthTimeoutMs,\n        ForceResendingToken = null\n    }\n);\n```", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 SMS 메시지의 인증 코드를 앱에 제공하면 다음 단계를 따르세요.\n\n1. 인증 코드 및 인증 ID를 사용하여 PhoneAuthCredential 객체를 만듭니다.\n2. 이 객체를 FirebaseAuth.SignInAndRetrieveDataWithCredentialAsync에 전달합니다.\n\n예제 코드:\n```csharp\nPhoneAuthCredential credential =\n    phoneAuthProvider.GetCredential(verificationId, verificationCode);\n```", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한되는 경우 어떻게 해야 하나요?", "answer": "Firebase는 악용을 방지하기 위해 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 로그인을 시작하기 위해 사용자의 전화번호를 확인하는 방법은 무엇인가요?", "answer": "전화번호 로그인을 시작하려면 사용자의 전화번호를 확인하기 위해 PhoneAuthProvider.VerifyPhoneNumber을 호출해야 합니다. 이 메서드는 사용자의 전화번호가 포함된 PhoneAuthOptions에 전달되어야 합니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\n    new Firebase.Auth.PhoneAuthOptions {\n        PhoneNumber = phoneNumber,\n        TimeoutInMilliseconds = phoneAuthTimeoutMs,\n        ForceResendingToken = null\n    }\n);\n```", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "사용자가 SMS 메시지의 인증 코드를 앱에 제공하면, 인증 코드와 인증 ID를 사용하여 PhoneAuthCredential 객체를 만들어야 합니다. 이 객체는 FirebaseAuth.SignInAndRetrieveDataWithCredentialAsync에 전달됩니다. 아래는 그 예시입니다:\n\n```csharp\n// 사용자로부터 인증 코드를 받습니다.\n// 인증 코드 및 인증 ID를 사용하여 Credential 객체를 만듭니다.\nPhoneAuthCredential credential =\n    phoneAuthProvider.GetCredential(verificationId, verificationCode);\n\n// PhoneAuthCredential 객체로 사용자를 로그인 처리합니다.\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\n    if (task.IsFaulted) {\n        Debug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" +\n            task.Exception);\n        return;\n    }\n    FirebaseUser newUser = task.Result.User;\n    Debug.Log(\"User signed in successfully\");\n    Debug.Log(\"Phone number: \" + newUser.PhoneNumber);\n    Debug.Log(\"Phone provider ID: \" + newUser.ProviderId);\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "전화번호 인증 요청이 제한되는 경우 어떻게 해야 하나요?", "answer": "Firebase는 악용을 방지하기 위해 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "인증 ID를 어떻게 저장하고 복원하나요?", "answer": "인증 ID는 사용자가 로그인 과정을 완료하기 전에 앱이 종료되더라도 올바른 인증 ID를 유지할 수 있도록 저장해야 합니다. 간단한 방법은 UnityEngine.PlayerPrefs를 사용하여 인증 ID를 저장하는 것입니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "SMS 메시지로 인증 코드를 전송하기 위해 어떤 메서드를 호출해야 하나요?", "answer": "사용자에게 전화번호를 제공하도록 요청한 후, PhoneAuthProvider.VerifyPhoneNumber을 호출하여 Firebase가 사용자의 전화에 SMS 인증 코드를 전송하도록 요청해야 합니다. 이 메서드는 사용자의 전화번호가 포함된 PhoneAuthOptions를 필요로 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_phone-auth_hl=ko.txt"}
{"question": "Unity 프로젝트에 Firebase를 추가하는 방법은 무엇인가요?", "answer": "Unity 프로젝트에 Firebase를 추가하려면 Firebase 구성 파일과 Firebase Unity SDK를 Unity 프로젝트에 추가해야 합니다. Android용 안내를 따르며, FirebaseAuth.unitypackage를 가져와야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Firebase 콘솔에서 SHA-1 지문을 설정하는 방법은 무엇인가요?", "answer": "Firebase 콘솔에서 SHA-1 지문을 설정하려면 Unity에서 설정한 키를 사용하여 Firebase 콘솔의 설정 페이지에서 게임의 SHA-1 지문을 설정해야 합니다. 이를 위해 keytool 명령어를 사용하여 SHA-1 디지털 지문을 가져올 수 있습니다. 예: \n\n```bash\nkeytool -exportcert -list -v \\\n-alias YOUR-KEY-NAME -keystore PATH-TO-KEYSTORE\n```", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Google Play Games를 로그인 제공업체로 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase Console에서 Authentication 섹션을 열고, 로그인 방법 탭에서 Google 로그인 제공업체와 Play Games 로그인 제공업체를 사용 설정해야 합니다. 이때 프로젝트의 웹 서버 클라이언트 ID와 클라이언트 보안 비밀번호를 지정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Play Games services를 Firebase 앱 정보로 구성하는 과정은 어떻게 되나요?", "answer": "Play Games services를 Firebase 앱 정보로 구성하려면 Google Play Console에서 Google Play 앱을 열거나 만들고, 성장 섹션에서 Play Games services > 설정 및 관리 > 구성을 클릭합니다. 이후 사용자 인증 정보를 추가하고, 게임 서버 유형과 Android 유형을 선택하여 프로젝트의 클라이언트 ID를 지정합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "APK를 서명해야 하는 이유는 무엇인가요?", "answer": "APK를 서명해야 Play 게임즈 로그인이 작동합니다. 이 요구사항은 게시뿐 아니라 게임 개발 단계에도 적용됩니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Play Games services에서 사용자 인증 정보를 추가하는 방법은 무엇인가요?", "answer": "Play Games services 구성 페이지에서 사용자 인증 정보 추가를 클릭합니다. 게임 서버 유형을 선택한 후 OAuth 클라이언트 입력란에서 프로젝트의 웹 클라이언트 ID를 선택합니다. 이 ID는 Play Games 로그인을 사용 설정할 때 지정한 클라이언트 ID와 일치해야 합니다. 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Unity에서 Play 게임즈 플러그인을 설정하는 방법은 무엇인가요?", "answer": "Unity에서 Play 게임즈 플러그인을 설정하려면 Window > Google Play Games > Setup > Android Setup을 클릭하여 Android Configuration 화면을 엽니다. Play Console에서 가져온 Android 리소스 스니펫을 Resources Definition 필드에 붙여넣고, Firebase 콘솔에서 Play 게임즈 로그인을 사용 설정할 때 입력한 웹 서버 클라이언트 ID를 Client ID 필드에 붙여넣습니다. 설정을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Play 게임즈 로그인 후 어떤 코드를 사용해야 하나요?", "answer": "플레이어가 Play 게임으로 로그인한 후 로그인 지속 핸들러에서 플레이어 계정의 인증 코드를 가져옵니다. 다음 코드를 사용합니다: \n```csharp\nSocial.localUser.Authenticate((bool success) => {\nif (success) {\nauthCode = PlayGamesPlatform.Instance.GetServerAuthCode();\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth\n```", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Play Games services에서 Android 클라이언트 ID를 추가하는 방법은 무엇인가요?", "answer": "Play Games services 구성 페이지에서 다시 사용자 인증 정보 추가를 클릭합니다. Android 유형을 선택한 후 OAuth 클라이언트 입력란에서 프로젝트의 Android 클라이언트 ID를 선택합니다. (Android 클라이언트 ID가 표시되지 않는 경우 Firebase Console에서 게임의 SHA-1 디지털 지문을 설정해야 합니다.) 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Play 게임즈 로그인 통합을 위해 Unity용 Play 게임즈 플러그인을 어떻게 다운로드하나요?", "answer": "Unity용 Play 게임즈 플러그인의 최신 출시 버전을 다운로드하고 압축을 풉니다. 플러그인의 Unity 패키지를 Unity 프로젝트로 가져옵니다. 출시 보관파일의 current-build 디렉터리에서 Unity 패키지를 찾을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Unity에서 Play 게임즈 플러그인을 설정한 후 Android Configuration 화면에서 어떤 정보를 입력해야 하나요?", "answer": "Android Configuration 화면에서 Play Console에서 가져온 Android 리소스 스니펫을 Resources Definition 필드에 붙여넣고, Firebase 콘솔에서 Play 게임즈 로그인을 사용 설정할 때 입력한 웹 서버 클라이언트 ID를 Client ID 필드에 붙여넣습니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Play 게임즈 클라이언트를 구성하기 위해 RequestServerAuthCode 설정을 어떻게 사용하나요?", "answer": "Play 게임즈 클라이언트를 구성하기 위해 다음 코드를 사용합니다:\n```csharp\nusing GooglePlayGames;\nusing GooglePlayGames.BasicApi;\nusing UnityEngine.SocialPlatforms;\nusing System.Threading.Tasks;\n\nPlayGamesClientConfiguration config = new PlayGamesClientConfiguration.Builder()\n.RequestServerAuthCode(false /* Don't force refresh */)\n.Build();\n\nPlayGamesPlatform.InitializeInstance(config);\nPlayGamesPlatform.Activate();\n```", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Play 게임즈 로그인 후 어떤 코드를 사용해야 하나요?", "answer": "Firebase에 인증하기 위해 다음 코드를 사용합니다:\n```csharp\nSocial.localUser.Authenticate((bool success) => {\nif (success) {\nauthCode = PlayGamesPlatform.Instance.GetServerAuthCode();\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\nFirebase.Auth.Credential credential =\nFirebase.Auth.PlayGamesAuthProvider.GetCredential(authCode);\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\nif (user != null && user.IsValid()) {\nstring playerName = user.DisplayName;\n}\n});\n}\n});\n```", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "사용자가 로그아웃하려면 어떤 메서드를 호출해야 하나요?", "answer": "사용자가 로그아웃하려면 `SignOut()` 메서드를 호출합니다:\n```csharp\nauth.SignOut();\n```", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙에서 로그인한 사용자의 고유 사용자 ID를 어떻게 가져오나요?", "answer": "Firebase 실시간 데이터베이스와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/play-games?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_play-games_hl=ko.txt"}
{"question": "Unity에서 Firebase Authentication을 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "Firebase Authentication을 사용하려면 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Unity 프로젝트가 없는 경우 샘플 앱을 다운로드하여 사용할 수 있습니다. 또한 Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 합니다. 초기 설정 작업에 대한 자세한 안내는 Unity 프로젝트에 Firebase 추가를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/unity/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_start_hl=ko.txt"}
{"question": "신규 사용자가 이메일 주소와 비밀번호로 가입할 때 사용하는 메서드는 무엇인가요?", "answer": "신규 사용자가 자신의 이메일 주소와 비밀번호를 사용해 게임에 가입할 때는 CreateUserWithEmailAndPasswordAsync 메서드를 사용합니다. 사용자가 양식을 작성한 후, 입력한 이메일 주소와 비밀번호의 유효성을 검사한 후 이 메서드에 전달합니다. 예시는 다음과 같습니다:\n```csharp\nauth.CreateUserWithEmailAndPasswordAsync(email, password).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"CreateUserWithEmailAndPasswordAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"CreateUserWithEmailAndPasswordAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"Firebase user created successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\n```", "source": ["https://firebase.google.com/docs/auth/unity/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_start_hl=ko.txt"}
{"question": "사용자가 로그인할 때 발생하는 이벤트를 처리하기 위해 어떤 필드를 사용하나요?", "answer": "사용자가 로그인할 때 이벤트를 처리하기 위해 FirebaseAuth 객체의 StateChanged 필드를 사용합니다. 이 필드에 이벤트 핸들러를 등록하면 사용자가 로그인되었을 때 해당 핸들러에서 사용자에 대한 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_start_hl=ko.txt"}
{"question": "FirebaseAuth 객체의 참조를 삭제하는 방법은 무엇인가요?", "answer": "FirebaseAuth 객체의 참조를 삭제하려면 OnDestroy 메서드에서 해당 객체에 대한 참조를 null로 설정하면 됩니다. 예를 들어, 다음과 같이 구현할 수 있습니다:\n```csharp\nvoid OnDestroy() {\n    auth = null;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_start_hl=ko.txt"}
{"question": "Firebase Authentication에서 사용자가 로그인했는지 확인하는 방법은 무엇인가요?", "answer": "사용자가 로그인했는지 확인하려면 FirebaseAuth 객체의 CurrentUser 속성을 사용하여 사용자의 유효성을 검사할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n```csharp\nif (auth.CurrentUser != null) {\n    Debug.Log(\"User is signed in: \" + auth.CurrentUser.UserId);\n} else {\n    Debug.Log(\"No user is signed in.\");\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_start_hl=ko.txt"}
{"question": "Unity 프로젝트에서 Firebase Authentication을 사용하기 위해 필요한 초기 설정 작업은 무엇인가요?", "answer": "Unity 프로젝트에서 Firebase Authentication을 사용하려면 먼저 Unity 프로젝트를 등록하고 Firebase를 사용하도록 구성해야 합니다. Firebase를 이미 사용하고 있는 프로젝트라면 이미 등록되어 있는 것입니다. 새로운 프로젝트의 경우 샘플 앱을 다운로드하여 사용할 수 있습니다. 또한, Firebase Unity SDK(특히 FirebaseAuth.unitypackage)를 Unity 프로젝트에 추가해야 합니다. 초기 설정 작업에 대한 자세한 안내는 'Unity 프로젝트에 Firebase 추가'를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/unity/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_twitter-login_hl=ko.txt"}
{"question": "FirebaseAuth 클래스에 접근하는 방법은 무엇인가요?", "answer": "FirebaseAuth 클래스는 모든 API 호출을 위한 게이트웨이입니다. FirebaseAuth.DefaultInstance를 통해 액세스할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n```csharp\nFirebase.Auth.FirebaseAuth auth = Firebase.Auth.FirebaseAuth.DefaultInstance;\n```", "source": ["https://firebase.google.com/docs/auth/unity/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_twitter-login_hl=ko.txt"}
{"question": "Twitter로 로그인하기 위해 필요한 OAuth 액세스 토큰과 암호는 어떻게 얻나요?", "answer": "Twitter로 로그인하기 위해서는 Twitter의 관련 안내에 따라 OAuth 액세스 토큰 및 OAuth 암호를 가져와야 합니다. 이 과정은 Twitter API를 통해 이루어지며, 사용자가 정상적으로 로그인한 후에 이 정보를 Firebase 사용자 인증 정보로 교환해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_twitter-login_hl=ko.txt"}
{"question": "Firebase에 인증하기 위해 Twitter 인증 정보를 사용하는 방법은 무엇인가요?", "answer": "Twitter 인증 정보를 사용하여 Firebase에 인증하기 위해서는 다음과 같은 코드를 사용합니다: \n```csharp\nFirebase.Auth.Credential credential = Firebase.Auth.TwitterAuthProvider.GetCredential(accessToken, secret);\nauth.SignInAndRetrieveDataWithCredentialAsync(credential).ContinueWith(task => {\nif (task.IsCanceled) {\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync was canceled.\");\nreturn;\n}\nDebug.LogError(\"SignInAndRetrieveDataWithCredentialAsync encountered an error: \" + task.Exception);\nreturn;\nFirebase.Auth.AuthResult result = task.Result;\nDebug.LogFormat(\"User signed in successfully: {0} ({1})\",\nresult.User.DisplayName, result.User.UserId);\nFirebase.Auth.FirebaseUser user = auth.CurrentUser;\n```", "source": ["https://firebase.google.com/docs/auth/unity/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_twitter-login_hl=ko.txt"}
{"question": "Firebase 사용자 정보를 가져오는 방법은 무엇인가요?", "answer": "Firebase 사용자 정보를 가져오려면 Firebase.Auth.FirebaseUser 객체를 사용합니다. 사용자가 정상적으로 로그인한 후, 다음과 같은 코드를 통해 사용자 정보를 가져올 수 있습니다: \n```csharp\nif (user != null) {\nstring name = user.DisplayName;\nstring email = user.Email;\nSystem.Uri photo_url = user.PhotoUrl;\n}\n```", "source": ["https://firebase.google.com/docs/auth/unity/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_twitter-login_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 Yahoo 인증을 처리하는 기본 단계는 무엇인가요?", "answer": "Firebase SDK로 로그인 과정을 처리하려면 다음 단계를 따르세요.\n\n1. Yahoo에 적합한 제공업체 ID로 구성된 FederatedOAuthProviderData의 인스턴스를 생성합니다.\n   ```csharp\n   Firebase.Auth.FederatedOAuthProviderData providerData =\n   new Firebase.Auth.FederatedOAuthProviderData();\n   providerData.ProviderId = Firebase.Auth.YahooAuthProvider.ProviderId;\n   ```\n\n2. 선택사항: OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정합니다.\n   ```csharp\n   providerData.CustomParameters = new Dictionary<string,string>();\n   ```\n\n3. 선택사항: 인증 제공업체에서 요청하고자 하는 profile 및 email 범위를 넘는 OAuth 2.0 범위를 추가로 지정합니다.\n   ```csharp\n   providerData.Scopes = new List<string>();\n   ```\n\n4. 제공업체 데이터가 구성되었으면 이를 사용하여 FederatedOAuthProvider를 만듭니다.\n   ```csharp\n   Firebase.Auth.FederatedOAuthProvider provider =\n   new Firebase.Auth.FederatedOAuthProvider();\n   provider.SetProviderData(providerData);\n   ```\n\n5. 인증 제공업체 객체를 사용해 Firebase에 인증합니다.", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo OAuth 인증을 위해 Firebase에서 요구하는 매개변수는 무엇인가요?", "answer": "Firebase에서 요구하는 매개변수는 custom_parameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, redirect_uri, response_type, scope, state가 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Yahoo 인증을 위한 로그인 과정을 시작하는 방법은 무엇인가요?", "answer": "로그인 과정을 시작하려면 다음과 같이 SignInAndRetrieveDataWithCredentialAsync를 호출합니다.\n   ```csharp\n   // 예시 코드\n   provider.SignInAndRetrieveDataWithCredentialAsync(...);\n   ```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "LinkWithProviderAsync 메서드는 어떤 용도로 사용되나요?", "answer": "LinkWithProviderAsync를 사용하여 Yahoo 제공업체를 기존 사용자에 연결할 수 있습니다. 예를 들어 여러 제공업체를 동일한 사용자에 연결하여 그 중 하나로 로그인하도록 허용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "LinkWithProviderAsync 메서드 호출 후 작업이 취소된 경우 어떻게 처리하나요?", "answer": "작업이 취소된 경우 다음과 같이 처리할 수 있습니다.\n   ```csharp\n   user.LinkWithProviderAsync(provider).ContinueOnMainThread(task => {\n   if (task.IsCanceled) {\n   Debug.LogError(\"LinkWithProviderAsync was canceled.\");\n   return;\n   }\n   Firebase.Auth.AuthResult authResult = task.Result;\n   });\n   ```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Yahoo 인증을 위한 FederatedOAuthProviderData를 어떻게 구성하나요?", "answer": "Yahoo 인증을 위한 FederatedOAuthProviderData를 구성하려면 다음과 같이 합니다:\n\n```csharp\nFirebase.Auth.FederatedOAuthProviderData providerData =\nnew Firebase.Auth.FederatedOAuthProviderData();\nproviderData.ProviderId = Firebase.Auth.YahooAuthProvider.ProviderId;\n```\n선택적으로 커스텀 OAuth 매개변수를 추가하려면 다음과 같이 합니다:\n\n```csharp\nproviderData.CustomParameters = new Dictionary<string,string>();\n```\n추가적인 OAuth 범위는 다음과 같이 설정할 수 있습니다:\n\n```csharp\nproviderData.Scopes = new List<string>();\n```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Yahoo 인증을 위한 OAuth 범위를 어떻게 설정하나요?", "answer": "Yahoo 인증을 위한 OAuth 범위를 설정하려면 FederatedOAuthProviderData의 Scopes 필드를 사용합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```csharp\nproviderData.Scopes = new List<string>();\n``` \n여기서 요청받은 OAuth 범위는 앱의 API 권한에서 사전 구성된 범위와 정확하게 일치해야 합니다.", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Yahoo 인증을 위한 FederatedOAuthProvider를 어떻게 생성하나요?", "answer": "FederatedOAuthProvider를 생성하려면 다음과 같이 FederatedOAuthProviderData를 사용하여 인스턴스를 만듭니다:\n\n```csharp\nFirebase.Auth.FederatedOAuthProvider provider =\nnew Firebase.Auth.FederatedOAuthProvider();\nprovider.SetProviderData(providerData);\n```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase SDK에서 Yahoo 인증을 시작하기 위해 어떤 메서드를 호출해야 하나요?", "answer": "Yahoo 인증을 시작하기 위해서는 다음과 같이 SignInAndRetrieveDataWithCredentialAsync 메서드를 호출해야 합니다:\n\n```csharp\n// SignInAndRetrieveDataWithCredentialAsync 호출 예시\n```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "LinkWithProviderAsync 메서드 호출 후 성공적으로 사용자 연결이 이루어졌는지 확인하는 방법은 무엇인가요?", "answer": "LinkWithProviderAsync 메서드 호출 후 성공적으로 사용자 연결이 이루어졌는지 확인하려면 다음과 같이 task.Result를 사용하여 AuthResult를 가져오고, 사용자 정보를 확인합니다:\n\n```csharp\nFirebase.Auth.AuthResult authResult = task.Result;\nFirebase.Auth.FirebaseUser user = authResult.User;\nDebug.LogFormat(\"User linked successfully: {0} ({1})\",\nuser.DisplayName, user.UserId);\n```", "source": ["https://firebase.google.com/docs/auth/unity/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_unity_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase 사용자 객체의 기본 속성에는 어떤 것들이 포함되나요?", "answer": "Firebase 사용자는 프로젝트의 사용자 데이터베이스에 고유 ID, 기본 이메일 주소, 이름, 사진 URL과 같은 고정된 기본 속성 집합을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "사용자가 Firebase에 가입할 때 프로필 데이터는 어떻게 채워지나요?", "answer": "사용자가 앱에 처음 가입할 때 사용자의 프로필 데이터에 정보를 채웁니다. 사용자가 이메일 주소와 비밀번호로 가입했다면 기본 이메일 주소 속성만 채웁니다. 사용자가 Google 또는 Facebook 등의 제휴 ID 공급업체를 사용해 가입했다면 업체에서 제공하는 계정 정보를 가져와 사용자의 프로필을 채웁니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 로그인 제공업체는 어떻게 관리되나요?", "answer": "사용자 인스턴스는 해당 사용자에게 연결된 모든 공급업체를 추적합니다. 따라서 공급업체가 전달하는 정보를 이용해 프로필의 빈 속성을 업데이트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "현재 사용자의 상태를 유지하기 위해 Firebase에서 어떤 방법을 권장하나요?", "answer": "인증 인스턴스의 현재 상태를 추적할 때 권장하는 방법은 리스너(자바스크립트에서는 '관찰자'라고 함)를 사용하는 것입니다. Auth 리스너는 Auth 객체에 유의미한 사건이 발생할 때마다 알림을 받습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "사용자가 로그아웃하면 Firebase에서 어떤 일이 발생하나요?", "answer": "사용자가 로그아웃하면 인증 인스턴스가 user 객체에 대한 참조 유지를 중단하고 사용자 상태를 유지하지 않습니다. 즉, 현재 사용자가 없는 것입니다. 그러나 사용자 인스턴스는 계속 온전히 작동합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자의 액세스 토큰이 갱신되는 상황은 어떤 경우인가요?", "answer": "현재 사용자의 액세스 토큰이 갱신될 때는 다음과 같은 상황이 발생합니다:\n\n1. 액세스 토큰이 만료되었을 때: 흔한 경우입니다. 갱신 토큰을 사용해 유효한 토큰 세트를 새로 가져옵니다.\n2. 사용자가 비밀번호를 변경할 때: Firebase가 새 액세스 및 갱신 토큰을 발급하고 기존 토큰을 만료시킵니다. 이때 보안상의 이유로 자동으로 사용자의 토큰이 만료되거나 사용자가 모든 기기에서 로그아웃됩니다.\n3. 사용자가 다시 인증할 때: 일부 작업은 사용자의 인증 정보가 최근에 발급된 경우에만 진행될 수 있습니다. 이런 작업으로는 계정 삭제, 기본 이메일 주소 설정, 비밀번호 변경 등이 있습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자 관리 작업을 수동으로 수행하려면 어떻게 해야 하나요?", "answer": "Admin SDK 또는 Firebase Console을 사용하여 관리자를 통해 수동으로 또는 프로그래매틱 방식으로 사용자를 생성하려면, Firebase Authentication 설정 페이지에서 사용자 작업을 사용 중지하여 최종 사용자의 계정 생성 및 삭제를 방지할 수 있습니다. 멀티테넌시를 사용하는 경우 테넌트별로 이러한 기능을 사용 중지하도록 HTTP 요청을 수행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자가 계정을 만들거나 삭제하려고 할 때 발생하는 오류는 무엇인가요?", "answer": "최종 사용자가 시스템 내에서 계정을 만들거나 삭제하려고 시도하면 Firebase 서비스가 오류 코드를 반환합니다. 웹 API 호출의 경우 'auth/admin-restricted-operation' 오류가 발생하며, Android 및 iOS의 경우 'ERROR_ADMIN_RESTRICTED_OPERATION' 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 인증 토큰의 종류는 무엇이 있나요?", "answer": "Firebase로 인증을 진행할 때 다루는 인증 토큰에는 3가지 유형이 있습니다:\n\n1. Firebase ID 토큰: 사용자가 앱에 로그인할 때 Firebase가 만드는 토큰입니다. 이 토큰은 서명된 JWT로, Firebase 프로젝트에서 사용자의 신원을 안전하게 식별합니다. 이 토큰은 Firebase 프로젝트에 고유한 사용자의 ID 문자열을 비롯하여, 사용자의 기본 프로필 정보를 담고 있습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 현재 사용자의 상태를 유지하기 위한 권장 방법은 무엇인가요?", "answer": "현재 사용자 상태를 유지하기 위해 Firebase에서는 리스너(자바스크립트에서는 '관찰자'라고 함)를 사용하는 것을 권장합니다. Auth 리스너는 Auth 객체에 유의미한 사건이 발생할 때마다 알림을 받습니다. 예를 들어, 사용자가 로그인할 때, 로그아웃할 때, 현재 사용자의 액세스 토큰이 갱신될 때 알림을 받습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "액세스 토큰이 만료되었을 때 Firebase에서 어떻게 처리하나요?", "answer": "액세스 토큰이 만료되었을 때, Firebase는 갱신 토큰을 사용해 유효한 토큰 세트를 새로 가져옵니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "사용자가 비밀번호를 변경할 때 Firebase에서 어떤 일이 발생하나요?", "answer": "사용자가 비밀번호를 변경할 때, Firebase는 새 액세스 및 갱신 토큰을 발급하고 기존 토큰을 만료시킵니다. 이때 보안상의 이유로 자동으로 사용자의 토큰이 만료되거나 사용자가 모든 기기에서 로그아웃됩니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "사용자가 다시 인증할 때 어떤 작업을 수행해야 하나요?", "answer": "사용자가 다시 인증할 때는 사용자에게서 새로운 인증 정보를 받아서 user 객체의 reauthenticate 메서드에 전달하면 됩니다. 로그아웃 처리하고 다시 로그인할 필요는 없습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자가 계정을 만들거나 삭제하려고 할 때 발생하는 오류 코드는 무엇인가요?", "answer": "Firebase 서비스가 오류 코드를 반환합니다. 웹 API 호출의 경우 auth/admin-restricted-operation, Android 및 iOS의 경우 ERROR_ADMIN_RESTRICTED_OPERATION입니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 인증된 이메일 주소는 어떤 조건을 충족해야 하나요?", "answer": "Firebase는 사용자가 Firebase 인증 과정을 완료하고 신뢰할 수 있는 ID 공급업체(줄여서 IdP)에 의해 이메일이 인증된 경우 이메일을 인증된 것으로 간주합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 인증 토큰의 종류는 무엇이 있나요?", "answer": "인증 토큰에는 3가지 유형이 있습니다. 1. Firebase ID 토큰: 사용자가 앱에 로그인할 때 Firebase가 만드는 서명된 JWT로, 사용자의 신원을 안전하게 식별합니다. 2. ID 공급업체 토큰: Google과 Facebook 등의 제휴 ID 공급업체에서 생성하는 주로 OAuth 2.0 액세스 토큰입니다. 3. Firebase 커스텀 토큰: 사용자가 자체 인증 시스템을 통해 앱에 로그인할 수 있게 해 주는 맞춤 인증 시스템이 만드는 서명된 JWT입니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 이메일 주소가 인증된 것으로 간주되는 조건은 무엇인가요?", "answer": "Firebase는 사용자가 Firebase 인증 과정을 완료하고 신뢰할 수 있는 ID 공급업체(IdP)에 의해 이메일이 인증된 경우 이메일을 인증된 것으로 간주합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 있는 ID 공급업체는 어떤 것들이 있나요?", "answer": "신뢰할 수 있는 ID 공급업체는 다음과 같습니다: Google(@gmail.com 주소의 경우), Yahoo(@yahoo.com 주소의 경우), Microsoft(@outlook.com 및 @hotmail.com 주소의 경우), Apple(계정이 항상 인증되며 다중 인증(MFA)을 사용하므로 항상 신뢰할 수 있음)입니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 사용자가 동일한 이메일 주소를 사용하여 다른 제공업체로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 동일한 이메일 주소를 사용하여 다른 제공업체로 로그인하면 Firebase에서 계정을 자동으로 연결하기도 합니다. 하지만 이 방법은 특정 기준이 충족되는 경우에만 가능합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 없는 제공업체는 어떤 것들이 있나요?", "answer": "신뢰할 수 없는 제공업체는 Facebook, Twitter, GitHub, 해당 ID 공급업체에서 발급하지 않은 도메인에 대한 Google, Yahoo, Microsoft, 이메일 인증이 없는 이메일/비밀번호입니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 없는 제공업체로 로그인한 후 동일한 이메일을 사용하여 다른 신뢰할 수 없는 제공업체로 로그인하면 어떤 오류가 발생하나요?", "answer": "사용자가 신뢰할 수 없는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 없는 다른 제공업체로 로그인하는 경우, 계정 연결을 요구하는 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 있는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 없는 제공업체로 로그인하면 어떤 일이 발생하나요?", "answer": "사용자가 신뢰할 수 있는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 없는 제공업체로 로그인하는 경우, 계정 연결을 요구하는 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 없는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 있는 제공업체로 로그인하면 어떤 결과가 발생하나요?", "answer": "사용자가 신뢰할 수 없는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 있는 제공업체로 로그인하는 경우, 신뢰할 수 있는 제공업체가 신뢰할 수 없는 제공업체를 덮어씁니다. 사용자가 신뢰할 수 없는 제공업체로 다시 로그인을 시도하는 경우 계정 연결을 요구하는 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 신뢰할 수 있는 제공업체로 로그인한 후 동일한 이메일을 사용하여 다른 신뢰할 수 있는 제공업체로 로그인하면 어떤 일이 발생하나요?", "answer": "사용자가 신뢰할 수 있는 제공업체로 로그인한 후 동일한 이메일을 사용하여 신뢰할 수 있는 다른 제공업체로 로그인하는 경우, 두 제공업체 모두 오류 없이 연결됩니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "Firebase에서 Admin SDK를 사용하여 이메일을 인증된 것으로 설정할 때 주의해야 할 점은 무엇인가요?", "answer": "Admin SDK를 사용하여 이메일을 인증된 것으로 직접 설정할 수 있지만, 사용자가 해당 이메일을 실제로 소유하고 있음을 알고 있는 경우에만 이를 설정하는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_users_hl=ko.txt"}
{"question": "사용자 계정에 Google 인증 제공업체를 연결하는 방법은 무엇인가요?", "answer": "사용자 계정에 Google 인증 제공업체의 사용자 인증 정보를 연결하려면, 먼저 사용자를 Google로 로그인 처리한 후, 다음과 같이 linkWithPopup 메서드를 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, linkWithPopup, GoogleAuthProvider } from \"firebase/auth\";\nconst auth = getAuth();\nconst provider = new GoogleAuthProvider();\n\nauth.currentUser.linkWithPopup(provider)\n  .then((result) => {\n    // 연결 성공\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_account-linking_hl=ko.txt"}
{"question": "사용자가 로그인한 후 리디렉션된 페이지에서 로그인 결과를 검색하는 방법은 무엇인가요?", "answer": "사용자가 로그인한 후 리디렉션된 페이지에서 로그인 결과를 검색하려면, getRedirectResult 메서드를 호출하여 결과를 가져올 수 있습니다. 다음은 그 예시입니다:\n\n```javascript\nimport { getAuth, getRedirectResult } from \"firebase/auth\";\nconst auth = getAuth();\n\ngetRedirectResult(auth)\n  .then((result) => {\n    if (result.credential) {\n      // 로그인 성공\n    }\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_account-linking_hl=ko.txt"}
{"question": "사용자 계정에 Facebook 인증 제공업체를 연결하는 방법은 무엇인가요?", "answer": "사용자 계정에 Facebook 인증 제공업체의 사용자 인증 정보를 연결하려면, 사용자를 Facebook으로 로그인 처리한 후, linkWithPopup 메서드를 사용할 수 있습니다. 다음은 그 예시입니다:\n\n```javascript\nimport { getAuth, linkWithPopup, FacebookAuthProvider } from \"firebase/auth\";\nconst auth = getAuth();\nconst provider = new FacebookAuthProvider();\n\nauth.currentUser.linkWithPopup(provider)\n  .then((result) => {\n    // 연결 성공\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_account-linking_hl=ko.txt"}
{"question": "linkWithCredential 메서드를 사용하여 사용자 계정에 인증 정보를 연결하는 방법은 무엇인가요?", "answer": "linkWithCredential 메서드를 사용하여 사용자 계정에 인증 정보를 연결하려면, 먼저 인증 정보를 생성한 후 다음과 같이 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, linkWithCredential, EmailAuthProvider } from \"firebase/auth\";\nconst auth = getAuth();\nconst credential = EmailAuthProvider.credential(email, password);\n\nauth.currentUser.linkWithCredential(credential)\n  .then((usercred) => {\n    // 연결 성공\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_account-linking_hl=ko.txt"}
{"question": "사용자 계정에서 인증 제공업체를 분리하는 방법은 무엇인가요?", "answer": "사용자 계정에서 인증 제공업체를 분리하려면 unlink 메서드를 사용할 수 있습니다. 다음은 그 예시입니다:\n\n```javascript\nimport { getAuth, unlink } from \"firebase/auth\";\nconst auth = getAuth();\nconst providerId = 'facebook.com'; // 분리할 제공업체 ID\n\nauth.currentUser.unlink(providerId)\n  .then(() => {\n    // 분리 성공\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/account-linking?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_account-linking_hl=ko.txt"}
{"question": "익명 인증을 사용하기 위해 Firebase Console에서 어떤 단계를 따라야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고, 로그인 방법 페이지에서 익명 로그인 방법을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_anonymous-auth_hl=ko.txt"}
{"question": "익명 계정의 자동 정리 기능은 어떻게 설정하나요?", "answer": "프로젝트를 Firebase Authentication with Identity Platform으로 업그레이드한 후, 자동 정리를 사용 설정하면 30일이 지난 익명 계정이 자동으로 삭제됩니다.", "source": ["https://firebase.google.com/docs/auth/web/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_anonymous-auth_hl=ko.txt"}
{"question": "익명으로 Firebase에 인증하기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "익명으로 Firebase에 인증하기 위해서는 signInAnonymously 메서드를 호출해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_anonymous-auth_hl=ko.txt"}
{"question": "익명 사용자의 인증 상태를 확인하기 위해 어떤 메서드를 사용하나요?", "answer": "익명 사용자의 인증 상태를 확인하기 위해 onAuthStateChanged 메서드를 사용합니다.", "source": ["https://firebase.google.com/docs/auth/web/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_anonymous-auth_hl=ko.txt"}
{"question": "익명 계정에 다른 인증 정보를 연결하려면 어떤 메서드를 사용해야 하나요?", "answer": "익명 계정에 다른 인증 정보를 연결하려면 linkWithCredential 메서드를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/anonymous-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_anonymous-auth_hl=ko.txt"}
{"question": "Apple로 로그인을 사용하기 위해 사용자가 충족해야 하는 조건은 무엇인가요?", "answer": "Apple로 로그인하려면 사용자는 다음을 충족해야 합니다.\n\n- 2단계 인증(2FA)이 사용 설정된 Apple ID가 있어야 합니다.\n- Apple 기기에서 iCloud에 로그인되어 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인을 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "사용자가 Apple 계정을 통해 로그인하도록 하려면 우선 Apple의 개발자 사이트에서 Apple로 로그인을 구성하고 Firebase 프로젝트에서 로그인 제공업체를 Apple로 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple Developer Program에 가입하지 않고 Apple로 로그인을 구성할 수 있나요?", "answer": "아니요, Apple로 로그인은 Apple Developer Program의 멤버만 구성할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인을 설정할 때 필요한 반환 URL은 무엇인가요?", "answer": "다음 URL을 반환 URL로 등록해야 합니다.\nhttps://YOUR_FIREBASE_PROJECT_ID.firebaseapp.com/__/auth/handler\nFirebase 프로젝트 ID는 Firebase Console 설정 페이지에서 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase JavaScript SDK로 Apple 계정을 사용하여 인증하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK로 로그인 과정을 처리하려면 다음 단계를 따르세요.\n\n해당하는 제공업체 ID OAuthProvider을 사용하여 OAuthProvider 인스턴스를 만듭니다.\n\n```javascript\nimport { OAuthProvider } from \"firebase/auth\";\n\nprovider.addScope('email');\nprovider.addScope('name');\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인을 설정할 때 비공개 이메일 릴레이 서비스를 어떻게 구성하나요?", "answer": "비공개 이메일 릴레이 서비스를 구성하고 noreply@YOUR_FIREBASE_PROJECT_ID.firebaseapp.com(또는 맞춤설정된 이메일 템플릿 도메인)을 등록해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase JavaScript SDK로 Apple 계정을 사용하여 인증할 때 어떤 OAuthProvider 인스턴스를 사용해야 하나요?", "answer": "해당하는 제공업체 ID OAuthProvider을 사용하여 OAuthProvider 인스턴스를 만듭니다. 예시 코드는 다음과 같습니다:\n```javascript\nimport { OAuthProvider } from \"firebase/auth\";\nconst provider = new OAuthProvider('apple.com');\nprovider.addScope('email');\nprovider.addScope('name');\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자에게 제공되는 익명처리된 데이터 요구사항은 무엇인가요?", "answer": "Apple로 로그인에는 사용자가 로그인할 때 이메일 주소 등의 데이터를 익명처리할 수 있는 옵션이 제공됩니다. 이 옵션을 선택한 사용자는 privaterelay.appleid.com 도메인의 이메일 주소를 갖게 됩니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인을 처리할 때 사용자가 로그인 후 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에 getRedirectResult()를 호출하여 로그인 결과를 가져올 수 있습니다. 예시 코드는 다음과 같습니다:\n```javascript\nimport { getAuth, getRedirectResult } from \"firebase/auth\";\ngetRedirectResult(auth)\n  .then((result) => {\n    if (result.credential) {\n      // 로그인 성공\n    }\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 자신의 이메일을 앱에 공유하지 않으면 어떻게 되나요?", "answer": "사용자가 자신의 이메일을 앱에 공유하지 않으면 Apple은 이 사용자의 고유 이메일 주소를 xyz@privaterelay.appleid.com 형식으로 프로비저닝하여 개발자 앱으로 공유합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인 시 이메일 및 이름 범위를 요청하는 기본 설정은 무엇인가요?", "answer": "기본적으로 이메일 주소당 계정 1개가 사용 설정되어 있으면 Firebase는 이메일 및 이름 범위를 요청합니다. 이 설정을 이메일 주소당 여러 계정으로 변경하면 별도로 지정하지 않는 한 Firebase는 Apple에 범위를 요청하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple의 로그인 화면을 다른 언어로 표시하려면 어떻게 해야 하나요?", "answer": "Apple의 로그인 화면을 영어가 아닌 다른 언어로 표시하려면 locale 매개변수를 설정하세요. 지원되는 언어는 Apple로 로그인 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인할 때 사용자가 로그인 후 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에 getRedirectResult()를 호출하여 로그인 결과를 가져올 수 있습니다.\n\n```javascript\nimport { getAuth, getRedirectResult, OAuthProvider } from \"firebase/auth\";\n\n.then((result) => {\n  .auth()\n  .getRedirectResult()\n  .then((result) => {\n    if (result.credential) {\n      // Handle the result\n    }\n  });\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 자신의 이메일을 앱에 공유하지 않으면 어떻게 되나요?", "answer": "사용자가 자신의 이메일을 앱에 공유하지 않으면 Apple은 이 사용자의 고유 이메일 주소를 xyz@privaterelay.appleid.com 형식으로 프로비저닝하여 개발자 앱으로 공유합니다. 비공개 이메일 릴레이 서비스를 구성한 경우 Apple은 익명처리된 주소로 전송된 이메일을 사용자의 실제 이메일 주소로 전달합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인 시 사용자 정보를 어떻게 저장하나요?", "answer": "Apple은 사용자가 처음 로그인할 때만 표시 이름 등의 사용자 정보만 앱에 공유합니다. 일반적으로 Firebase는 사용자가 Apple 계정으로 처음 로그인할 때 표시 이름을 저장하며, 이 표시 이름은 firebase.auth().currentUser.displayName을 사용하여 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple로 로그인 시 사용자의 표시 이름을 어떻게 가져올 수 있나요?", "answer": "사용자가 Apple 계정으로 처음 로그인할 때 Firebase는 표시 이름을 저장합니다. 이 표시 이름은 다음과 같이 가져올 수 있습니다: \n```javascript\nfirebase.auth().currentUser.displayName\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 계정을 다른 데이터에 연결하기 위해 사용자가 동의를 얻는 방법은 무엇인가요?", "answer": "Apple에서는 개발자가 사용자의 Apple 계정을 다른 데이터에 연결하기 전에 사용자에게 명시적인 동의를 얻도록 요구합니다. 예를 들어, Facebook 계정을 현재 Firebase 계정에 연결하려면 사용자가 Facebook에 로그인할 때 얻은 액세스 토큰을 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 Apple 로그인을 위한 리디렉션 도메인을 커스텀 도메인으로 설정하는 방법은 무엇인가요?", "answer": "커스텀 도메인을 설정하려면 다음 단계를 따르세요: 1. Firebase Hosting에서 커스텀 도메인을 설정합니다. 2. Firebase Console에서 승인된 도메인 목록에 커스텀 도인을 추가합니다. 3. Apple 개발자 콘솔에서 커스텀 도메인에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 계정을 삭제할 수 있도록 하려면 어떤 단계를 구현해야 하나요?", "answer": "사용자가 앱 내에서 계정 삭제를 시작할 수 있도록 하려면 다음 단계를 구현해야 합니다: 1. Apple로 로그인 제공업체 구성의 서비스 ID 및 OAuth 코드 흐름 구성 섹션을 작성합니다. 2. 사용자에게 다시 로그인하도록 요청한 후, OAuthCredential에서 Apple OAuth 액세스 토큰을 가져와 revokeAccessToken(auth, token)을 호출하여 토큰을 취소합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Node.js 애플리케이션에서 Apple 계정으로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "Node.js 애플리케이션에서 사용자를 로그인 처리하려면 다음과 같은 과정을 수행합니다: 1. 백엔드에서 임의 문자열('nonce')을 생성하고 SHA256 해시를 계산합니다. 2. POST된 인증 응답에서 Apple ID 토큰을 가져옵니다. 예제 코드: \n```javascript\napp.post('/redirect', (req, res) => {\nimport { getAuth, signInWithCredential, OAuthProvider } from \"firebase/auth\";\n\n.then((result) => {\n\n.then((result) => {\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 커스텀 도메인을 Apple에 인증하는 방법은 무엇인가요?", "answer": "기본 firebaseapp.com 도메인과 마찬가지로 커스텀 도메인을 Apple에 인증해야 합니다. 인증을 위해 다음 URL을 사용해야 합니다: http://auth.custom.example.com/.well-known/apple-developer-domain-association.txt", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자가 계정을 삭제할 수 있도록 하려면 어떤 단계를 구현해야 하나요?", "answer": "Apple로 로그인 구성 섹션에 설명된 대로 Apple로 로그인 제공업체 구성의 서비스 ID 및 OAuth 코드 흐름 구성 섹션을 작성해야 합니다. 사용자가 계정을 삭제하기 전에 다시 로그인하도록 요청해야 하며, 이후 OAuthCredential에서 Apple OAuth 액세스 토큰을 가져와 revokeAccessToken(auth, token)을 호출하여 Apple OAuth 액세스 토큰을 취소해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Node.js 애플리케이션에서 Apple 계정으로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "Node.js 앱에 브라우저 프런트엔드가 있는 경우, 백엔드에서 임의 문자열('nonce')을 생성하고 SHA256 해시를 계산하여 사용합니다. POST된 인증 응답 서버 측에서 Apple ID 토큰을 가져오는 방법은 다음과 같습니다:\n\n```javascript\napp.post('/redirect', (req, res) => {\n  import { getAuth, signInWithCredential, OAuthProvider } from \"firebase/auth\";\n  // 추가 코드\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase에서 커스텀 도메인의 SSL 인증서를 프로비저닝하는 방법은 무엇인가요?", "answer": "도메인 소유권을 확인하면 Hosting에서 커스텀 도메인의 SSL 인증서를 프로비저닝합니다. Firebase Console에서 승인된 도메인 목록에 커스텀 도메인을 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Apple로 로그인 시 사용자 토큰을 저장하지 않는 이유는 무엇인가요?", "answer": "Firebase는 사용자 토큰을 저장하지 않기 때문에, 사용자가 Apple로 로그인으로 생성된 후 계정을 삭제하기 전에 다시 로그인하도록 요청해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/apple?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_apple_hl=ko.txt"}
{"question": "Firebase 인증 상태 지속성을 설정하는 방법은 무엇인가요?", "answer": "Firebase 인증 상태 지속성을 설정하려면 `firebase.auth().setPersistence` 메서드를 호출하여 기존의 지속 유형을 지정하거나 수정할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, setPersistence, signInWithEmailAndPassword, browserSessionPersistence } from \"firebase/auth\";\n\nsetPersistence(getAuth(), browserSessionPersistence)\n  .then(() => {\n    // 로그인 코드\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Firebase에서 지원하는 인증 상태 지속성 유형은 무엇이 있나요?", "answer": "Firebase에서는 다음과 같은 3가지 인증 상태 지속성 유형을 지원합니다:\n\n| Enum | 값 | 설명 |\n| --- | --- | --- |\n| firebase.auth.Auth.Persistence.LOCAL | 'local' | 브라우저 창이 닫히거나 React Native에서 활동이 폐기된 경우에도 상태가 유지됨을 나타냅니다. |\n| firebase.auth.Auth.Persistence.SESSION | 'session' | 현재의 세션이나 탭에서만 상태가 유지되며 사용자가 인증된 탭이나 창이 닫히면 삭제됨을 나타냅니다. |\n| firebase.auth.Auth.Persistence.NONE | 'none' | 상태가 메모리에만 저장되며 창이나 활동이 새로고침되면 삭제됨을 나타냅니다. |", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "인증 상태 지속성을 수정할 때 주의해야 할 점은 무엇인가요?", "answer": "인증 상태 지속성을 수정할 때는 `setPersistence` 메서드를 호출하면 기존의 지속성이 정의된 경우 리디렉션 흐름이 시작된 이전 페이지에서 유지된 인증 상태 지속성이 재정의된다는 점에 주의해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "어떤 경우에 인증 상태를 삭제하는 것이 좋나요?", "answer": "민감한 정보가 있는 애플리케이션에서는 창이나 탭을 닫을 때마다 상태를 삭제하는 것이 좋습니다. 또한 여러 사용자가 공유하는 기기에서 사용되는 애플리케이션에도 적합하지 않습니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "여러 탭에서 서로 다른 사용자가 애플리케이션에 로그인할 수 있도록 하려면 어떻게 해야 하나요?", "answer": "여러 탭에서 서로 다른 사용자가 애플리케이션에 로그인할 수 있도록 하려면 기본 동작을 재정의해야 합니다. 로그인 과정에 '내 계정정보 저장' 옵션을 추가하여 사용자가 세션 유지 여부를 선택할 수 있는 기능을 제공할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Firebase 인증 상태 지속성을 수정하는 방법은 무엇인가요?", "answer": "firebase.auth().setPersistence 메서드를 호출하면 기존의 지속 유형을 지정하거나 수정할 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, setPersistence, signInWithEmailAndPassword, browserSessionPersistence } from \"firebase/auth\";\n\nsetPersistence(getAuth(), browserSessionPersistence)\n  .then(() => {\n    // 로그인 코드\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Firebase 인증 상태 지속성의 LOCAL 유형은 어떤 경우에 사용되나요?", "answer": "firebase.auth.Auth.Persistence.LOCAL은 브라우저 창이 닫히거나 React Native에서 활동이 폐기된 경우에도 상태가 유지됨을 나타냅니다. 이 상태를 삭제하려면 명시적으로 로그아웃해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Firebase 인증 상태 지속성의 SESSION 유형은 어떤 경우에 사용되나요?", "answer": "firebase.auth.Auth.Persistence.SESSION은 현재의 세션이나 탭에서만 상태가 유지되며 사용자가 인증된 탭이나 창이 닫히면 삭제됨을 나타냅니다. 이 유형은 웹 앱에만 적용됩니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Firebase 인증 상태 지속성의 NONE 유형은 어떤 경우에 사용되나요?", "answer": "firebase.auth.Auth.Persistence.NONE은 상태가 메모리에만 저장되며 창이나 활동이 새로고침되면 삭제됨을 나타냅니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "여러 탭에서 서로 다른 인증 상태를 유지하려면 어떻게 해야 하나요?", "answer": "사용자가 이전에 여러 탭이 열려 있는 상태에서 local 지속성을 사용해 로그인한 후 한 탭에서 none 또는 session 지속성으로 전환한 경우, 이 탭의 상태가 session 또는 none으로 유지된 사용자로 수정되고 다른 모든 탭에서는 사용자가 로그아웃됩니다.", "source": ["https://firebase.google.com/docs/auth/web/auth-state-persistence?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_auth-state-persistence_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 사용하여 이메일과 비밀번호로 로그인하는 방법은 무엇인가요?", "answer": "이메일과 비밀번호로 로그인하려면 `createUserWithEmailAndPassword`와 `signInWithEmailAndPassword` 메서드를 사용합니다. 아래는 예시 코드입니다.\n\n```javascript\nimport { getAuth, signInWithEmailAndPassword } from 'firebase/auth/web-extension';\n\nconst auth = getAuth();\n\nsignInWithEmailAndPassword(auth, email, password)\n  .then((userCredential) => {\n    // 로그인 성공\n  })\n  .catch((error) => {\n    // 로그인 실패\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 reCAPTCHA를 사용하여 전화번호로 로그인하는 방법은 무엇인가요?", "answer": "reCAPTCHA를 사용하여 전화번호로 로그인하려면 추가적인 설정이 필요합니다. 이 문서에서는 구체적인 코드 예시를 제공하지 않지만, reCAPTCHA를 설정하고 이를 통해 SMS 인증을 구현해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 사용할 때, 승인된 도메인 목록에 추가해야 하는 URI는 무엇인가요?", "answer": "승인된 도메인 목록에 추가해야 하는 URI는 `chrome-extension://CHROME_EXTENSION_ID`입니다. 여기서 `CHROME_EXTENSION_ID`는 해당 Chrome 확장 프로그램의 ID입니다.", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 구현할 때, content_security_policy에 추가해야 하는 URL은 무엇인가요?", "answer": "content_security_policy에 추가해야 하는 URL은 다음과 같습니다:\n- `https://apis.google.com`\n- `https://www.gstatic.com`\n- `https://www.googleapis.com`\n- `https://securetoken.googleapis.com`", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 사용할 때, 오프스크린 문서의 역할은 무엇인가요?", "answer": "오프스크린 문서는 Chrome 확장 프로그램에서 인증 흐름을 구현하는 데 사용됩니다. 이 문서에서 일반 인증 흐름을 구현하고 그 결과를 다시 확장 프로그램으로 프록시 처리하는 방식으로 작동합니다.", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 사용하여 signInWithPopup을 구현하는 방법은 무엇인가요?", "answer": "다음 HTML 문서를 생성하여 signInWithPopup을 구현할 수 있습니다.\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<title>signInWithPopup</title>\n<script src=\"signInWithPopup.js\"></script>\n</head>\n<body><h1>signInWithPopup</h1></body>\n</html>\n```", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 사용할 때, 승인된 도메인 목록에 추가해야 하는 URI는 무엇인가요?", "answer": "Chrome 확장 프로그램 ID를 포함한 URI를 승인된 도메인 목록에 추가해야 합니다. 예를 들어, `chrome-extension://CHROME_EXTENSION_ID`를 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램의 매니페스트 파일에서 content_security_policy에 추가해야 하는 URL은 무엇인가요?", "answer": "다음 URL을 content_security_policy 허용 목록에 추가해야 합니다.\n- https://apis.google.com\n- https://www.gstatic.com\n- https://www.googleapis.com\n- https://securetoken.googleapis.com", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램에서 Firebase Authentication을 구현할 때, 인증 요청 및 응답을 프록시하기 위해 어떤 메서드를 사용해야 하나요?", "answer": "인증 요청 및 응답을 프록시하기 위해 `postMessage` 리스너에 인증 로직을 래핑해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Chrome 확장 프로그램의 manifest.json 파일에 추가해야 하는 권한은 무엇인가요?", "answer": "manifest.json 파일에 `offscreen` 권한을 추가해야 합니다. 예:\n\n```json\n{\n  \"name\": \"signInWithPopup Demo\",\n  \"manifest_version\": 3,\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  }\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/chrome-extension?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_chrome-extension_hl=ko.txt"}
{"question": "Cordova에서 OAuth 제공업체를 통해 인증하기 위해 어떤 단계를 따라야 하나요?", "answer": "Firebase JS SDK를 사용하여 Cordova 환경에서 지원되는 모든 OAuth 제공업체를 통해 인증할 수 있습니다. 지원되는 OAuth 제공업체를 통합하려면 OAuth 과정을 수동으로 진행하면서 그 결과인 OAuth 인증 정보를 Firebase에 전달해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/cordova?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_cordova_hl=ko.txt"}
{"question": "Apple 계정으로 사용자를 로그인하기 위한 절차는 무엇인가요?", "answer": "Apple로 로그인할 수 있도록 웹페이지 구성 [https://developer.apple.com/documentation/signinwithapplejs/configuring_your_webpage_for_sign_in_with_apple]에 따라 Apple 계정으로 사용자를 로그인하고 사용자의 Apple ID 토큰을 가져옵니다. 사용자의 Apple ID 토큰을 가져온 후 해당 토큰으로 사용자 인증 정보 객체 [https://firebase.google.com/docs/auth/web/apple?hl=ko#advanced_authenticate_with_firebase_in_nodejs]를 만들고 이 객체로 사용자를 로그인 처리합니다.", "source": ["https://firebase.google.com/docs/auth/web/cordova?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_cordova_hl=ko.txt"}
{"question": "Firebase Dynamic Links 종료가 Cordova OAuth 지원에 미치는 영향은 무엇인가요?", "answer": "2025년 8월 25일에 Firebase Dynamic Links가 종료되면 모바일 앱의 이메일 링크 인증, 이전 버전의 Authentication SDK를 사용하는 Android 앱의 OAuth 흐름, 웹 앱의 Cordova OAuth 지원이 영향을 받습니다. Dynamic Links 종료 후 이러한 기능을 사용하려면 최신 SDK 버전을 사용하도록 마이그레이션하고 몇 가지 추가 단계를 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/cordova?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_cordova_hl=ko.txt"}
{"question": "Firebase에서 지원하는 OAuth 제공업체는 어떤 것들이 있나요?", "answer": "Firebase에서 지원하는 OAuth 제공업체는 Google, Facebook, Twitter, GitHub, Microsoft, Yahoo, Apple입니다. 각 제공업체의 로그인 과정을 수동으로 처리하는 방법에 대한 안내는 해당 링크를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/cordova?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_cordova_hl=ko.txt"}
{"question": "Firebase Authentication 기능을 사용하기 위해 필요한 SDK 버전은 어떻게 확인하나요?", "answer": "Firebase Dynamic Links 종료 후 OAuth 흐름을 포함한 Firebase Authentication 기능을 사용하려면 최신 SDK 버전을 사용해야 합니다. SDK 버전 확인 및 마이그레이션에 대한 자세한 내용은 Firebase 공식 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/cordova?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_cordova_hl=ko.txt"}
{"question": "Firebase에서 커스텀 인증 시스템을 사용하기 위해 필요한 초기 설정은 무엇인가요?", "answer": "자바스크립트 프로젝트에 Firebase를 추가한 후, 프로젝트 설정의 서비스 계정 페이지로 이동하여 새 비공개 키 생성을 클릭합니다. 이 과정에서 생성된 공개 키/비공개 키 쌍을 인증 서버에 복사해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-auth_hl=ko.txt"}
{"question": "사용자가 로그인할 때 인증 서버에 어떤 정보를 전송해야 하나요?", "answer": "사용자가 앱에 로그인하면 사용자의 로그인 인증 정보(예: 사용자 이름과 비밀번호)를 인증 서버로 전송해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-auth_hl=ko.txt"}
{"question": "인증 서버에서 커스텀 토큰을 반환받은 후, 이를 Firebase에 어떻게 전달하나요?", "answer": "인증 서버에서 커스텀 토큰을 받은 후, 다음과 같이 이 토큰을 signInWithCustomToken에 전달하여 사용자를 로그인 처리합니다.\n\n```javascript\nimport { getAuth, signInWithCustomToken } from \"firebase/auth\";\n\n.then((userCredential) => {\n  firebase.auth().signInWithCustomToken(token)\n  .then((userCredential) => {\n```", "source": ["https://firebase.google.com/docs/auth/web/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-auth_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃하는 방법은 무엇인가요?", "answer": "사용자를 로그아웃하려면 다음과 같이 signOut 메서드를 사용합니다.\n\n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n```", "source": ["https://firebase.google.com/docs/auth/web/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-auth_hl=ko.txt"}
{"question": "커스텀 인증 시스템을 Firebase에 통합하기 위해 인증 서버에서 어떤 작업을 수행해야 하나요?", "answer": "인증 서버를 수정하여 사용자가 정상적으로 로그인할 때 커스텀 서명 토큰을 발행하도록 해야 합니다. 이렇게 하면 앱이 이 토큰을 받아 Firebase 인증에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-auth_hl=ko.txt"}
{"question": "Firebase JS SDK에서 인증 라이브러리를 초기화하는 두 가지 방법은 무엇인가요?", "answer": "인증 라이브러리를 초기화하는 방법에는 getAuth() 함수와 initializeAuth() 함수를 사용하는 두 가지 방법이 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-dependencies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-dependencies_hl=ko.txt"}
{"question": "getAuth() 함수를 사용할 때의 단점은 무엇인가요?", "answer": "getAuth() 함수를 사용하는 방법의 단점은 앱에서 사용하지 않을 가능성이 있는 다량의 코드를 가져온다는 것입니다. 또한 대상 플랫폼에서 지원되지 않는 코드까지 가져오기 때문에 오류가 발생할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-dependencies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-dependencies_hl=ko.txt"}
{"question": "initializeAuth() 함수를 사용하는 이유는 무엇인가요?", "answer": "initializeAuth() 함수를 사용하면 종속 항목 맵을 통해 필요한 종속 항목만 가져올 수 있어, 불필요한 코드 로드를 방지하고 오류를 줄일 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-dependencies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-dependencies_hl=ko.txt"}
{"question": "커스텀 초기화를 사용하는 경우의 장점은 무엇인가요?", "answer": "커스텀 초기화를 사용하면 앱의 인증 SDK 사용을 훨씬 더 세부적으로 제어할 수 있으며, 번들 크기와 로드 시간을 줄일 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-dependencies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-dependencies_hl=ko.txt"}
{"question": "DOM 외의 컨텍스트에서 실행되는 코드에서 어떤 초기화 방법을 사용해야 하나요?", "answer": "DOM 외의 컨텍스트(예: 웹 및 서비스 워커)에서 실행되는 코드의 경우 오류를 방지하기 위해 initializeAuth()를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/custom-dependencies?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_custom-dependencies_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 이메일 링크 로그인을 사용 설정하려면 어떤 단계를 따라야 하나요?", "answer": "Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 이메일/비밀번호 제공업체를 사용 설정합니다. 이메일 링크 로그인을 사용하려면 이메일/비밀번호 로그인이 사용 설정되어야 하며, 같은 섹션에서 이메일 링크(비밀번호가 없는 로그인) 로그인을 사용 설정한 후 저장을 클릭합니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크를 전송하기 위해 필요한 ActionCodeSettings 객체의 필드는 무엇인가요?", "answer": "ActionCodeSettings 객체를 만들 때 다음 필드를 설정해야 합니다: \n- url: 삽입할 딥 링크 및 함께 전달할 추가 상태입니다. \n- android 및 ios: Firebase Authentication이 Android 또는 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. \n- handleCodeInApp: true로 설정합니다. \n- linkDomain: 프로젝트에 대해 커스텀 Hosting 링크 도메인이 정의된 경우 지정된 모바일 앱에서 링크를 열 때 사용할 도메인을 지정합니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 로그인을 완료하기 위해 사용해야 하는 메서드는 무엇인가요?", "answer": "방문 페이지에서 로그인을 완료하려면 사용자의 이메일과 1회용 코드가 포함된 실제 이메일 링크를 사용하여 signInWithEmailLink 메서드를 호출해야 합니다. 예시는 다음과 같습니다: \n```javascript\nimport { getAuth, isSignInWithEmailLink, signInWithEmailLink } from \"firebase/auth\";\n\n.then((result) => {\n  // 로그인 완료 후 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "Firebase에서 이메일 링크를 사용한 로그인 링크인지 확인하는 방법은 무엇인가요?", "answer": "Firebase 인증에서는 이메일 링크를 사용한 로그인 링크인지 간편하게 확인할 수 있도록 isSignInWithEmailLink API를 제공합니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 localhost를 승인된 도메인으로 추가하려면 어떻게 해야 하나요?", "answer": "프로덕션 프로젝트에서는 localhost를 사용하지 않는 것이 좋습니다. 그러나 localhost를 승인하는 경우 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 로그인을 시작하기 위해 사용자가 제공해야 하는 정보는 무엇인가요?", "answer": "이메일 링크 로그인을 시작하려면 사용자에게 이메일 주소를 제공하도록 요청하는 인터페이스를 제시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "ActionCodeSettings 객체에서 설정해야 하는 url 필드는 어떤 용도로 사용되나요?", "answer": "url 필드는 삽입할 딥 링크 및 함께 전달할 추가 상태를 지정하는 데 사용됩니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "Firebase 프로젝트에서 localhost를 승인된 도메인으로 추가하는 방법은 무엇인가요?", "answer": "localhost를 승인하는 경우 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크 로그인을 완료하기 위해 호출해야 하는 메서드는 무엇인가요?", "answer": "로그인을 완료하려면 사용자의 이메일과 1회용 코드가 포함된 실제 이메일 링크를 사용하여 signInWithEmailLink를 호출해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "이메일 링크를 사용하여 기존 사용자에게 인증 방법을 연결하는 방법은 무엇인가요?", "answer": "기존 사용자에게 이메일 링크 인증 방법을 연결하려면 linkWithCredential 메서드를 사용하여 기존 사용자 계정에 이 로그인 방법을 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/email-link-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_email-link-auth_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 Facebook 로그인을 처리하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK로 Facebook 로그인을 처리하려면 다음 단계를 따르세요. 먼저 Facebook 제공업체 객체의 인스턴스를 생성합니다.\n\n```javascript\nimport { FacebookAuthProvider } from \"firebase/auth\";\nconst provider = new FacebookAuthProvider();\nprovider.addScope('user_birthday');\n```\n그 다음, `signInWithPopup` 또는 `signInWithRedirect` 메서드를 사용하여 사용자를 인증합니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인 과정에서 사용자의 언어를 현지화하려면 어떻게 해야 하나요?", "answer": "사용자의 언어를 현지화하려면 인증 인스턴스의 언어 코드를 업데이트해야 합니다. 예를 들어, 다음과 같이 설정할 수 있습니다.\n\n```javascript\nimport { getAuth } from \"firebase/auth\";\nconst auth = getAuth();\nauth.languageCode = 'it';\n```\n이렇게 하면 OAuth 과정을 사용자가 선호하는 언어로 현지화할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 설정하기 위해 필요한 앱 ID와 앱 비밀번호는 어디서 가져오나요?", "answer": "Facebook 로그인을 설정하기 위해서는 Facebook for Developers 사이트에서 내 앱의 앱 ID와 앱 비밀번호를 가져와야 합니다. 이 정보를 Firebase Console의 인증 섹션에서 Facebook 로그인 방법을 사용 설정할 때 입력해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 발생할 수 있는 auth/account-exists-with-different-credential 오류는 무엇인가요?", "answer": "이 오류는 사용자가 이미 다른 Firebase 사용자의 제공업체(예: Google)에 존재하는 이메일을 사용하여 Facebook과 같은 제공업체에 로그인하려고 할 때 발생합니다. 사용자가 원하는 제공업체에 로그인하려면 먼저 기존 제공업체에 로그인한 후 신규 제공업체의 AuthCredential(Facebook 액세스 토큰)에 연결해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Facebook 로그인 과정에서 팝업 모드를 사용하는 방법은 무엇인가요?", "answer": "팝업 모드를 사용하여 Facebook 로그인을 진행하려면 `signInWithPopup` 메서드를 호출합니다. 예를 들어, 다음과 같은 코드를 사용할 수 있습니다.\n\n```javascript\nimport { getAuth, signInWithPopup, FacebookAuthProvider } from \"firebase/auth\";\nconst provider = new FacebookAuthProvider();\n\nsignInWithPopup(auth, provider)\n  .then((result) => {\n    // 로그인 성공 시 처리\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 구현할 때 사용자가 Facebook 계정으로 인증한 후 Firebase에 로그인하는 방법은 무엇인가요?", "answer": "Facebook 인증 상태 콜백에서 Facebook의 인증 응답의 인증 토큰을 Firebase 사용자 인증 정보로 교환하여 Firebase에 로그인합니다. 다음은 그 예시입니다.\n\n```javascript\nimport { getAuth, onAuthStateChanged, signInWithCredential, signOut, FacebookAuthProvider } from \"firebase/auth\";\n\n.catch((error) => {\n  // 오류 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 사용자의 Facebook 액세스 토큰을 가져오는 방법은 무엇인가요?", "answer": "사용자의 Facebook 계정으로 로그인한 후, Facebook 액세스 토큰을 가져옵니다. 이 토큰을 사용하여 사용자 인증 정보 객체를 만들고, 이 객체로 사용자를 로그인시킵니다. 다음은 그 예시입니다.\n\n```javascript\nimport { getAuth, signInWithCredential, FacebookAuthProvider } from \"firebase/auth\";\n\n.then((result) => {\n  // 로그인 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 설정할 때 Facebook 앱 ID를 입력하는 방법은 무엇인가요?", "answer": "다음과 같이 Facebook 앱 ID를 입력하여 Facebook 로그인을 구성합니다.\n\n```html\n<script src=\"//connect.facebook.net/en_US/sdk.js\"></script>\n<script>\nFB.init({\n  /**********************************************************************\n  * TODO(Developer): Change the value below with your Facebook app ID. *\n  **********************************************************************/\n  appId: '<YOUR_FACEBOOK_APP_ID>',\n  status: true,\n  xfbml: true,\n  version: 'v2.6',\n});\n</script>\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 팝업 모드로 로그인하는 방법은 무엇인가요?", "answer": "팝업 창을 사용하여 로그인하려면 `signInWithPopup`을 호출합니다. 다음은 그 예시입니다.\n\n```javascript\nimport { getAuth, signInWithPopup, FacebookAuthProvider } from \"firebase/auth\";\n\n.then((result) => {\n  // 로그인 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 발생할 수 있는 auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "팝업 모드를 사용하는 경우, 다음 예시와 같은 코드를 사용해 `auth/account-exists-with-different-credential` 오류를 처리할 수 있습니다.\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  FacebookAuthProvider,\n} from \"firebase/auth\";\n\n// 오류 처리\n.catch((error) => {\n  // 오류 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 설정한 후 웹 페이지에 Facebook 로그인 버튼을 추가하는 방법은 무엇인가요?", "answer": "<fb:login-button\n data-auto-logout-link=\"true\"\n scope=\"public_profile,email\"\n size=\"large\"\n></fb:login-button>", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 구현할 때 사용자의 Facebook 액세스 토큰을 사용하여 Firebase에 로그인하는 방법은 무엇인가요?", "answer": "Facebook 인증 상태 콜백에서 Facebook의 인증 응답의 인증 토큰을 Firebase 사용자 인증 정보로 교환하여 Firebase에 로그인합니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 커스텀 도메인을 설정하는 방법은 무엇인가요?", "answer": "하위 도메인이 표시되지 않게 하려면 Firebase Hosting으로 커스텀 도메인을 설정하면 됩니다. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 Facebook 로그인을 사용할 때 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 사용자가 Facebook 계정으로 로그인한 후 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 커스텀 도메인을 설정하여 하위 도메인이 표시되지 않게 하려면 어떤 단계를 따라야 하나요?", "answer": "하위 도메인이 표시되지 않게 하려면 Firebase Hosting으로 커스텀 도메인을 설정해야 합니다. 다음 단계를 따르세요: 1. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 2. 도메인 소유권을 확인하면 Hosting에서 커스텀 도메인의 SSL 인증서를 프로비저닝합니다. 3. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다. 4. Facebook 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 그러면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut 메서드를 호출합니다. 예제 코드는 다음과 같습니다: \n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase에서 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?", "answer": "Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/facebook-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_facebook-login_hl=ko.txt"}
{"question": "FirebaseUI를 웹 애플리케이션에 포함하는 방법은 무엇인가요?", "answer": "FirebaseUI를 웹 애플리케이션에 포함하는 방법은 두 가지가 있습니다. 첫 번째는 CDN을 사용하는 방법으로, Firebase Console에서 페이지의 <head> 태그의 초기화 스니펫 밑에 다음 스크립트와 CSS 파일을 포함합니다.\n\n```html\n<script src=\"https://www.gstatic.com/firebasejs/ui/6.0.1/firebase-ui-auth.js\"></script>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"https://www.gstatic.com/firebasejs/ui/6.0.1/firebase-ui-auth.css\" />\n```\n\n두 번째 방법은 npm 모듈을 사용하는 것으로, 다음 명령어를 사용하여 FirebaseUI와 종속 항목을 설치합니다.\n\n```bash\n$ npm install firebaseui --save\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI를 초기화할 때 필요한 설정은 무엇인가요?", "answer": "FirebaseUI를 초기화할 때는 SDK를 가져온 후 인증 UI를 초기화하고, FirebaseUI signInOptions 목록에 이메일 제공업체 ID를 추가해야 합니다. 예를 들어, 다음과 같이 초기화할 수 있습니다.\n\n```javascript\nui.start('#firebaseui-auth-container', {\n  signInOptions: [\n    firebase.auth.EmailAuthProvider.PROVIDER_ID\n  ]\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 이메일 링크 인증을 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 이메일 링크 인증을 설정하려면 FirebaseUI signInOptions 목록에 이메일 제공업체 ID와 이메일 링크 signInMethod를 추가해야 합니다. 다음과 같이 설정할 수 있습니다.\n\n```javascript\nui.start('#firebaseui-auth-container', {\n  signInOptions: [\n    {\n      provider: firebase.auth.EmailAuthProvider.PROVIDER_ID,\n      signInMethod: firebase.auth.EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD\n    }\n  ]\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 OAuth 제공업체를 설정하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 OAuth 제공업체를 설정하려면 Firebase Console에서 인증 섹션을 열고 지정된 OAuth 제공업체 로그인을 사용 설정해야 합니다. 이때 해당 OAuth 클라이언트 ID와 보안 비밀도 필요합니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI의 주요 이점은 무엇인가요?", "answer": "FirebaseUI의 주요 이점은 다음과 같습니다. 여러 제공업체(이메일/비밀번호, 이메일 링크, 휴대전화 인증, Google, Facebook, Twitter, GitHub 로그인), 계정 연결, 맞춤설정, 원탭 가입 및 자동 로그인, 현지화된 UI, 익명 사용자 업그레이드 기능을 제공합니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 익명 사용자 업그레이드를 활성화하는 방법은 무엇인가요?", "answer": "익명 사용자 업그레이드를 활성화하려면 로그인 UI를 구성할 때 autoUpgradeAnonymousUsers를 true로 설정하면 됩니다. 이 옵션은 기본적으로 중지되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 익명 사용자 업그레이드 시 병합 충돌이 발생하는 경우 어떻게 처리하나요?", "answer": "익명 사용자가 기존 Firebase 사용자로 업그레이드하려고 할 때, FirebaseUI는 firebaseui/anonymous-upgrade-merge-conflict 오류 코드와 함께 signInFailure 콜백을 트리거합니다. 이 오류 객체는 영구 사용자 인증 정보도 포함합니다. 로그인을 완료하려면 auth.signInWithCredential(error.credential)을 통해 로그인을 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 OAuth 제공업체를 추가하는 방법은 무엇인가요?", "answer": "FirebaseUI signInOptions 목록에 OAuth 제공업체 ID를 추가합니다. 예를 들어, 다음과 같이 설정할 수 있습니다: \n```javascript\nui.start('#firebaseui-auth-container', {\n  signInOptions: [\n    firebase.auth.FacebookAuthProvider.PROVIDER_ID,\n    firebase.auth.TwitterAuthProvider.PROVIDER_ID,\n    firebase.auth.GithubAuthProvider.PROVIDER_ID,\n    firebase.auth.EmailAuthProvider.PROVIDER_ID,\n    firebase.auth.PhoneAuthProvider.PROVIDER_ID\n  ]\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI를 CDN을 통해 포함하는 방법은 무엇인가요?", "answer": "Firebase Console에서 페이지의 <head> 태그의 초기화 스니펫 밑에 다음 스크립트와 CSS 파일을 포함합니다: \n```html\n<script src=\"https://www.gstatic.com/firebasejs/ui/6.0.1/firebase-ui-auth.js\"></script>\n<link type=\"text/css\" rel=\"stylesheet\" href=\"https://www.gstatic.com/firebasejs/ui/6.0.1/firebase-ui-auth.css\" />\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI를 npm을 통해 설치하는 방법은 무엇인가요?", "answer": "다음 명령어를 사용하여 npm을 통해 FirebaseUI와 종속 항목을 설치합니다: \n```bash\n$ npm install firebaseui --save\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 전화번호 제공업체를 추가하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 전화번호 제공업체를 추가하려면 signInOptions 목록에 전화번호 제공업체 ID를 추가해야 합니다. 아래와 같이 코드를 작성합니다.\n\n```javascript\nui.start('#firebaseui-auth-container', {\n  signInOptions: [\n    firebase.auth.PhoneAuthProvider.PROVIDER_ID\n  ]\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 익명 사용자 업그레이드를 활성화하는 방법은 무엇인가요?", "answer": "익명 사용자 업그레이드를 활성화하려면 로그인 UI를 구성할 때 autoUpgradeAnonymousUsers를 true로 설정해야 합니다. 기본적으로 이 옵션은 중지되어 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 익명 사용자 업그레이드 시 병합 충돌이 발생하는 경우 어떻게 처리하나요?", "answer": "익명 사용자 업그레이드 시 병합 충돌이 발생하면 FirebaseUI가 firebaseui/anonymous-upgrade-merge-conflict 오류 코드와 함께 signInFailure 콜백을 트리거합니다. 이 경우, 영구 사용자 인증 정보를 사용한 로그인이 콜백에서 트리거되어야 합니다. 아래 예는 이러한 흐름의 작동 방식을 보여줍니다.\n\n```javascript\n// 익명 사용자의 데이터를 저장하고 익명 사용자를 삭제한 후\nauth.signInWithCredential(error.credential);\n// 로그인이 완료되면 데이터를 다시 복사합니다.\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 지원되는 OAuth 제공업체를 추가하는 방법은 무엇인가요?", "answer": "FirebaseUI에서 지원되는 OAuth 제공업체를 추가하려면 signInOptions 목록에 해당 제공업체 ID를 추가해야 합니다. 예를 들어, Facebook, Twitter, GitHub 제공업체를 추가하는 코드는 다음과 같습니다.\n\n```javascript\nui.start('#firebaseui-auth-container', {\n  signInOptions: [\n    firebase.auth.FacebookAuthProvider.PROVIDER_ID,\n    firebase.auth.TwitterAuthProvider.PROVIDER_ID,\n    firebase.auth.GithubAuthProvider.PROVIDER_ID\n  ]\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "FirebaseUI에서 로그인 페이지를 렌더링할 도메인을 승인된 도메인 목록에 추가하는 방법은 무엇인가요?", "answer": "Firebase Console의 인증 섹션에서 로그인 페이지를 렌더링할 도메인을 승인된 도메인 목록에 추가해야 합니다. 이 작업은 Firebase Console에서 직접 수행해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/firebaseui?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_firebaseui_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 GitHub 인증을 처리하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK로 GitHub 인증을 처리하려면 다음 단계를 따르세요. 먼저 GitHub 제공업체 객체의 인스턴스를 생성합니다. 이후, 사용자가 GitHub 계정에 로그인하도록 유도하기 위해 팝업 창을 띄우거나 로그인 페이지로 리디렉션할 수 있습니다. 팝업 창을 사용하여 로그인하려면 다음 코드를 사용합니다:\n\n```javascript\nimport { getAuth, signInWithPopup, GithubAuthProvider } from \"firebase/auth\";\n\nconst provider = new GithubAuthProvider();\n\nsignInWithPopup(getAuth(), provider)\n  .then((result) => {\n    // 로그인 성공 시 처리\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "GitHub OAuth 2.0 클라이언트 ID와 클라이언트 보안 비밀번호는 어디서 가져오나요?", "answer": "GitHub OAuth 2.0 클라이언트 ID와 클라이언트 보안 비밀번호는 GitHub에서 개발자 애플리케이션으로 앱을 등록한 후, 앱의 OAuth 2.0 클라이언트 ID와 클라이언트 보안 비밀번호를 가져와야 합니다. 이를 위해 GitHub 앱 구성의 앱 설정 페이지에서 해당 정보를 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub 인증을 설정하기 위해 필요한 초기 설정은 무엇인가요?", "answer": "Firebase에서 GitHub 인증을 설정하기 위해서는 다음과 같은 초기 설정이 필요합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 GitHub 제공업체를 사용 설정합니다. 또한, GitHub에서 개발자 애플리케이션으로 앱을 등록하고, Firebase OAuth 리디렉션 URI를 승인 콜백 URL로 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "signInWithRedirect 메서드는 어떻게 사용하나요?", "answer": "signInWithRedirect 메서드는 사용자가 GitHub 계정에 로그인하도록 리디렉션할 때 사용됩니다. 다음과 같은 코드를 사용하여 GitHub 제공업체 객체를 통해 Firebase 인증을 진행할 수 있습니다:\n\n```javascript\nimport { getAuth, signInWithRedirect, GithubAuthProvider } from \"firebase/auth\";\n\nconst provider = new GithubAuthProvider();\n\nsignInWithRedirect(getAuth(), provider);\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "auth/account-exists-with-different-credential 오류는 무엇이며, 어떻게 처리하나요?", "answer": "auth/account-exists-with-different-credential 오류는 사용자가 GitHub와 같은 제공업체에 로그인하려고 할 때, 이미 다른 Firebase 사용자의 제공업체(예: Google)에 존재하는 이메일을 사용하고 있을 경우 발생합니다. 이 오류를 처리하기 위해서는 사용자가 기존 제공업체(Google)에 로그인한 후, 신규 제공업체의 AuthCredential(GitHub 액세스 토큰)에 연결해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "GitHub 인증을 위해 커스텀 OAuth 제공업체 매개변수를 추가하는 방법은 무엇인가요?", "answer": "커스텀 매개변수를 추가하려면 OAuth 제공업체 문서에 지정된 키가 포함된 객체와 해당 값을 사용하여 초기화된 제공업체에서 setCustomParameters를 호출합니다. 예를 들면 다음과 같습니다.\n\n```javascript\nprovider.setCustomParameters({\n  'allow_signup': 'false'\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "signInWithPopup 메서드를 사용하여 GitHub 인증을 처리하는 방법은 무엇인가요?", "answer": "signInWithPopup을 사용하여 GitHub 인증을 처리하려면 다음과 같은 코드를 사용합니다.\n\n```javascript\nimport { getAuth, signInWithPopup, GithubAuthProvider } from \"firebase/auth\";\n\nconst provider = new GithubAuthProvider();\nconst auth = getAuth();\n\nsignInWithPopup(auth, provider)\n  .then((result) => {\n    // 사용자 인증 정보 처리\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "getRedirectResult 메서드는 어떤 용도로 사용되며, 어떻게 호출하나요?", "answer": "getRedirectResult 메서드는 페이지가 로드될 때 GitHub 제공업체의 OAuth 토큰을 가져오는 데 사용됩니다. 다음과 같은 코드를 사용하여 호출할 수 있습니다.\n\n```javascript\nimport { getAuth, getRedirectResult, GithubAuthProvider } from \"firebase/auth\";\n\nconst auth = getAuth();\ngetRedirectResult(auth)\n  .then((result) => {\n    if (result.credential) {\n      // 사용자 인증 정보 처리\n    }\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "auth/account-exists-with-different-credential 오류는 사용자가 다른 Firebase 사용자의 제공업체에 이미 존재하는 이메일을 사용하여 GitHub와 같은 제공업체에 로그인을 시도할 때 발생합니다. 이 오류를 처리하려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```javascript\nimport { getAuth, linkWithCredential, signInWithPopup, GithubAuthProvider } from \"firebase/auth\";\n\nconst provider = new GithubAuthProvider();\nconst auth = getAuth();\n\nsignInWithPopup(auth, provider)\n  .then((result) => {\n    // 사용자 인증 정보 처리\n  })\n  .catch((error) => {\n    if (error.code === 'auth/account-exists-with-different-credential') {\n      // 기존 제공업체에 로그인 후 신규 제공업체의 AuthCredential에 연결\n    }\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub 로그인을 위한 리디렉션 도메인을 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 GitHub 로그인을 위한 리디렉션 도메인을 설정하려면 다음 단계를 따릅니다:\n1. Firebase Console에서 승인된 도메인 목록에 커스텀 도메인을 추가합니다.\n2. GitHub 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 URL을 허용 목록에 추가합니다.\n3. 자바스크립트 라이브러리를 초기화할 때 authDomain 필드를 사용하여 커스텀 도메인을 지정합니다.\n\n예시:\n```javascript\nvar config = {\n  apiKey: '...',\n  authDomain: 'auth.custom.domain.com'\n};\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Node.js 애플리케이션에서 GitHub OAuth 2.0 액세스 토큰을 Firebase 사용자 인증 정보로 교환하는 방법은 무엇인가요?", "answer": "사용자가 GitHub에 정상적으로 로그인한 후에 OAuth 2.0 액세스 토큰을 Firebase 사용자 인증 정보로 교환합니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase에서 GitHub 로그인을 위한 커스텀 도메인을 설정하는 방법은 무엇인가요?", "answer": "하위 도메인이 표시되지 않게 하려면 Firebase Hosting으로 커스텀 도메인을 설정하면 됩니다. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 도메인 소유권을 확인하면 Hosting에서 커스텀 도메인의 SSL 인증서를 프로비저닝합니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 그러면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?", "answer": "Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut을 호출합니다. 다음은 예제 코드입니다:\n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/github-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_github-auth_hl=ko.txt"}
{"question": "Firebase JavaScript SDK로 Google 로그인을 처리하기 위해 어떤 단계를 따라야 하나요?", "answer": "Firebase JavaScript SDK로 로그인 과정을 처리하려면 다음 단계를 따르세요.\n\n1. Google 제공업체 객체의 인스턴스를 생성합니다.\n   ```javascript\n   import { GoogleAuthProvider } from \"firebase/auth\";\n   ```\n2. 인증 인스턴스의 언어 코드를 업데이트합니다. 예를 들면 다음과 같습니다.\n   ```javascript\n   import { getAuth } from \"firebase/auth\";\n   firebase.auth().languageCode = 'it';\n   provider.setCustomParameters({\n     'login_hint': 'user@example.com'\n   });\n   ```\n3. Google 제공업체 객체를 사용해 Firebase에 인증합니다. 팝업 창을 띄우거나 로그인 페이지로 리디렉션하여 사용자가 Google 계정에 로그인하도록 유도할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "signInWithPopup을 사용하여 Google 로그인을 처리하는 방법은 무엇인가요?", "answer": "팝업 창을 사용하여 로그인하려면 signInWithPopup을 호출합니다. 예를 들면 다음과 같습니다.\n   ```javascript\n   import { getAuth, signInWithPopup, GoogleAuthProvider } from \"firebase/auth\";\n   firebase.auth()\n     .signInWithPopup(provider)\n     .then((result) => {\n       // 로그인 성공 후 처리\n     });\n   ```", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "signInWithRedirect을 사용하여 Google 로그인을 처리하는 방법은 무엇인가요?", "answer": "signInWithRedirect을 사용하여 Google 로그인을 처리하려면 다음과 같이 코드를 작성합니다.\n   ```javascript\n   import { getAuth, signInWithRedirect, GoogleAuthProvider } from \"firebase/auth\";\n   firebase.auth().signInWithRedirect(provider);\n   ```", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "getRedirectResult을 사용하여 Google 로그인 후 결과를 처리하는 방법은 무엇인가요?", "answer": "페이지가 로드될 때 getRedirectResult를 호출하여 Google 제공업체의 OAuth 토큰을 검색할 수 있습니다. 예를 들면 다음과 같습니다.\n   ```javascript\n   import { getAuth, getRedirectResult, GoogleAuthProvider } from \"firebase/auth\";\n   firebase.auth()\n     .getRedirectResult()\n     .then((result) => {\n       if (result.credential) {\n         // 로그인 성공 후 처리\n       }\n     });\n   ```", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "signInWithPopup을 사용하는 경우 auth/account-exists-with-different-credential 오류를 처리하기 위해 다음과 같은 코드를 사용할 수 있습니다.\n   ```javascript\n   import {\n     getAuth,\n     linkWithCredential,\n     signInWithPopup,\n     GoogleAuthProvider,\n   } from \"firebase/auth\";\n   // 오류 처리 로직\n   ```", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 위한 커스텀 도메인을 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 Google 로그인을 위한 커스텀 도메인을 설정하려면 다음 단계를 따르세요:\n1. Firebase Hosting으로 커스텀 도메인을 설정합니다. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 도메인 소유권을 확인하면 Hosting에서 커스텀 도메인의 SSL 인증서를 프로비저닝합니다.\n2. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다.\n3. Google 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.\n4. 자바스크립트 라이브러리를 초기화할 때는 authDomain 필드를 사용하여 커스텀 도메인을 지정합니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 수동으로 처리하는 방법은 무엇인가요?", "answer": "Firebase에서 Google 로그인을 수동으로 처리하려면 다음과 같은 방법을 사용할 수 있습니다. 앱에 브라우저 프런트엔드가 있는 경우, Google 로그인을 사용하고 인증 응답에서 Google ID 토큰을 가져옵니다. 다음 코드를 사용하여 Google ID 토큰을 가져올 수 있습니다:\n\n```javascript\nimport { getAuth, signInWithCredential, GoogleAuthProvider } from \"firebase/auth\";\n```\n이 코드를 사용하여 Google ID 토큰을 가져온 후, 필요한 인증 작업을 수행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 사용할 때 발생할 수 있는 auth/account-exists-with-different-credential 오류를 어떻게 처리하나요?", "answer": "auth/account-exists-with-different-credential 오류를 처리하기 위해서는 사용자가 먼저 기존 제공업체(예: Facebook)에 로그인한 다음, 다른 제공업체의 AuthCredential(Google ID 토큰)에 연결해야 합니다. 다음과 같은 코드를 사용하여 오류를 처리할 수 있습니다:\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  GoogleAuthProvider,\n} from \"firebase/auth\";\n```\n이 코드를 사용하여 오류를 처리하고 적절한 인증 절차를 진행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 위한 OAuth 토큰을 가져오는 방법은 무엇인가요?", "answer": "Firebase에서 Google 로그인을 위한 OAuth 토큰을 가져오려면, 페이지가 로드될 때 getRedirectResult를 호출하여 Google 제공업체의 OAuth 토큰을 검색할 수 있습니다. 다음 코드를 사용하여 OAuth 토큰을 가져올 수 있습니다:\n\n```javascript\nimport { getAuth, getRedirectResult, GoogleAuthProvider } from \"firebase/auth\";\n```\n이 코드를 사용하여 OAuth 토큰을 가져오고, 이후 인증 작업을 진행할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 위한 언어 코드를 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 Google 로그인을 위한 언어 코드를 설정하려면, 다음과 같은 코드를 사용하여 languageCode를 설정할 수 있습니다:\n\n```javascript\nfirebase.auth().languageCode = 'it';\n```\n이 코드를 사용하여 원하는 언어 코드로 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 Google 로그인을 위한 커스텀 도메인을 설정할 때 어떤 단계를 따라야 하나요?", "answer": "Firebase에서 Google 로그인을 위한 커스텀 도메인을 설정하려면 다음 단계를 따르세요:\n1. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 도메인 소유권을 확인합니다.\n2. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다.\n3. Google 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 이렇게 하면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 사용자가 로그아웃할 때 어떤 메서드를 호출해야 하나요?", "answer": "사용자를 로그아웃시키려면 signOut 메서드를 호출합니다. 예시는 다음과 같습니다:\n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 사용자의 Google ID 토큰을 가져오는 방법은 무엇인가요?", "answer": "Google 계정으로 사용자를 로그인하고 사용자의 Google ID 토큰을 가져오는 방법은 여러 가지가 있습니다. 예를 들어, 앱에 브라우저 프런트엔드가 있는 경우 수동으로 로그인 과정 처리 [https://firebase.google.com/docs/auth/web/google-signin?hl=ko#advanced-handle-the-sign-in-flow-manually] 섹션의 설명에 따라 Google 로그인을 사용하고 인증 응답에서 Google ID 토큰을 가져옵니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하는 방법은 무엇인가요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하려면 [https://firebase.google.com/docs/auth/web/account-linking?hl=ko]를 참조하여 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있도록 설정합니다.", "source": ["https://firebase.google.com/docs/auth/web/google-signin?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_google-signin_hl=ko.txt"}
{"question": "Firebase에서 신규 사용자를 생성하는 방법은 무엇인가요?", "answer": "Firebase 프로젝트에서 신규 사용자를 생성할 때는 createUserWithEmailAndPassword 메서드를 호출하거나 Google 로그인 또는 Facebook 로그인과 같은 제휴 ID 공급업체를 이용해 사용자의 최초 로그인을 처리할 수 있습니다. 또한 Firebase Console '인증' 섹션의 '사용자' 페이지에서 또는 Admin SDK를 활용하여 비밀번호 인증을 사용하는 신규 사용자를 생성할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_manage-users_hl=ko.txt"}
{"question": "현재 로그인한 사용자를 가져오는 권장 방법은 무엇인가요?", "answer": "현재 사용자를 가져올 때 권장하는 방법은 Auth 개체에 관찰자를 설정하는 것입니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n```javascript\nimport { getAuth, onAuthStateChanged } from \"firebase/auth\";\n\nfirebase.auth().onAuthStateChanged((user) => {\n  if (user) {\n    // 사용자 정보 처리\n  }\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_manage-users_hl=ko.txt"}
{"question": "현재 로그인한 사용자의 정보를 가져오는 방법은 무엇인가요?", "answer": "현재 로그인한 사용자의 정보를 가져오려면 currentUser 속성을 사용할 수 있습니다. 사용자가 로그인 상태가 아니라면 currentUser 값은 null입니다.", "source": ["https://firebase.google.com/docs/auth/web/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_manage-users_hl=ko.txt"}
{"question": "사용자의 이메일 주소를 업데이트하는 방법은 무엇인가요?", "answer": "사용자의 이메일 주소를 업데이트하려면 updateEmail 메서드를 사용할 수 있습니다. 예를 들어:\n```javascript\nimport { getAuth, updateEmail } from \"firebase/auth\";\n\nconst user = firebase.auth().currentUser;\nupdateEmail(user, newEmail).then(() => {\n  // 이메일 업데이트 성공\n}).catch((error) => {\n  // 오류 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_manage-users_hl=ko.txt"}
{"question": "비밀번호 재설정 이메일을 보내는 방법은 무엇인가요?", "answer": "비밀번호 재설정 이메일을 보내려면 sendPasswordResetEmail 메서드를 사용할 수 있습니다. 예를 들어:\n```javascript\nimport { getAuth, sendPasswordResetEmail } from \"firebase/auth\";\n\nconst auth = getAuth();\nsendPasswordResetEmail(auth, email).then(() => {\n  // 이메일 전송 성공\n}).catch((error) => {\n  // 오류 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/manage-users?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_manage-users_hl=ko.txt"}
{"question": "Microsoft 계정을 통해 Firebase로 인증하기 위해 필요한 초기 설정은 무엇인가요?", "answer": "Microsoft 계정을 통해 Firebase로 인증하려면 먼저 Firebase 프로젝트에서 Microsoft를 로그인 제공업체로 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Microsoft 제공업체를 사용 설정한 후, 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 Microsoft 계정으로 로그인하는 과정은 어떻게 되나요?", "answer": "Firebase JavaScript SDK로 Microsoft 계정으로 로그인하려면 다음 단계를 따릅니다. 1. OAuthProvider을 사용하여 OAuthProvider의 인스턴스를 생성합니다. 2. provider.setCustomParameters()를 사용하여 필요한 매개변수를 설정합니다. 3. signInWithPopup() 또는 signInWithRedirect()를 호출하여 사용자가 Microsoft 계정으로 로그인하도록 유도합니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?", "answer": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 커스텀 매개변수 객체의 '테넌트' 필드를 지정해야 합니다. 예를 들어, provider.setCustomParameters({ tenant: 'your-tenant-id' });와 같이 설정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "로그인 후 사용자가 페이지로 돌아온 후 로그인 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에는 getRedirectResult()를 호출하여 로그인 결과를 가져올 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다: \n```javascript\nimport { getAuth, getRedirectResult, OAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().getRedirectResult()\n  .then((result) => {\n    // 로그인 결과 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft 계정으로 로그인 시 이미 존재하는 이메일을 사용하는 경우 발생할 수 있는 오류는 무엇인가요?", "answer": "Firebase Console에서 이메일 주소당 계정 1개를 사용 설정한 경우, 다른 Firebase 사용자의 제공업체(예: Google)에 이미 존재하는 이메일을 사용하여 Microsoft와 같은 제공업체에 로그인을 시도하면 auth/account-exists-with-different-credential 오류가 발생합니다. 사용자가 원하는 제공업체에 로그인하려면 먼저 기존 제공업체에 로그인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft 계정으로 로그인할 때 사용자가 특정 Azure AD 테넌트의 사용자로 제한하려면 어떻게 설정하나요?", "answer": "특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용하면 됩니다. 이렇게 하려면 커스텀 매개변수 객체의 '테넌트' 필드를 지정합니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft 계정으로 로그인할 때 팝업 창을 사용하는 방법은 무엇인가요?", "answer": "팝업 창을 사용해 로그인하려면 다음과 같이 signInWithPopup을 호출합니다.\n\n```javascript\nimport { getAuth, signInWithPopup, OAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().signInWithPopup(provider)\n  .then((result) => {\n    // 로그인 성공 시 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "로그인 후 사용자가 페이지로 돌아온 후 로그인 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에 getRedirectResult를 호출하여 로그인 결과를 가져올 수 있습니다.\n\n```javascript\nimport { getAuth, getRedirectResult, OAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().getRedirectResult()\n  .then((result) => {\n    // 로그인 결과 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft 계정으로 로그인 시 이미 존재하는 이메일을 사용하는 경우 발생할 수 있는 오류를 어떻게 처리하나요?", "answer": "signInWithPopup을 사용하는 경우 다음 예시와 같은 코드를 사용해 auth/account-exists-with-different-credential 오류를 처리할 수 있습니다.\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  OAuthProvider\n} from \"firebase/auth\";\n\nfirebase.auth().signInWithPopup(provider)\n  .then((result) => {\n    // 로그인 성공 시 처리\n  })\n  .catch((error) => {\n    if (error.code === 'auth/account-exists-with-different-credential') {\n      // 오류 처리\n    }\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft 로그인을 위한 리디렉션 도메인을 어떻게 설정하나요?", "answer": "Firebase에서는 프로젝트의 고유한 하위 도메인(https://my-app-12345.firebaseapp.com)을 프로비저닝합니다. 이 도메인은 OAuth 로그인을 위한 리디렉션 메커니즘으로 사용됩니다. 하위 도메인이 표시되지 않게 하려면 Firebase Hosting으로 커스텀 도메인을 설정해야 합니다. 커스텀 도메인 설정은 Hosting용 도메인 설정 문서의 1~3단계를 따릅니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Microsoft 계정으로 로그인 시 auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "signInWithPopup을 사용하는 경우, 다음과 같은 코드를 사용하여 auth/account-exists-with-different-credential 오류를 처리할 수 있습니다.\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  OAuthProvider,\n} from \"firebase/auth\";\n```\n이 코드를 통해 사용자가 원하는 제공업체에 로그인하기 위해 기존 제공업체에 먼저 로그인한 후 신규 제공업체의 AuthCredential에 연결할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 Microsoft 로그인을 위한 커스텀 도메인을 설정하는 방법은 무엇인가요?", "answer": "커스텀 도메인을 설정하려면 다음 단계를 따르세요:\n1. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다.\n2. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다.\n3. Microsoft 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 이렇게 하면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?", "answer": "사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut 메서드를 호출합니다. 다음은 JavaScript에서 사용 예시입니다:\n\n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/microsoft-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_microsoft-oauth_hl=ko.txt"}
{"question": "Firebase에서 다중 인증(MFA)을 사용 설정하기 위해 필요한 첫 번째 단계는 무엇인가요?", "answer": "다중 인증(MFA)을 사용 설정하기 위해서는 Firebase Console의 인증 > 로그인 방법 페이지를 열고 고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA)을 사용할 때, 사용자 이메일 인증이 필요한 이유는 무엇인가요?", "answer": "MFA를 사용하려면 이메일 인증이 필요합니다. 이는 악의적인 행위자가 자신이 소유하지 않은 이메일에 서비스를 등록한 후 두 번째 단계를 추가하여 실제 소유자의 접근을 막는 일을 방지하기 위함입니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA 확인자를 설정하는 이유는 무엇인가요?", "answer": "reCAPTCHA 확인자는 SMS 코드를 보내기 위해 필요합니다. Firebase는 reCAPTCHA를 통해 전화번호 인증 요청이 앱의 허용된 도메인 중 하나에서 발생하도록 하여 악용을 방지합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "보이지 않는 reCAPTCHA를 사용하려면 어떻게 설정하나요?", "answer": "보이지 않는 reCAPTCHA를 사용하려면 size 매개변수를 invisible로 설정된 RecaptchaVerifier를 만들고 다단계 등록을 시작하는 UI 요소의 ID를 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록 패턴에서 사용자가 두 번째 단계를 등록하는 방법은 어떤 것이 있나요?", "answer": "일반적인 등록 패턴은 다음과 같습니다: 1) 등록 시 사용자의 두 번째 단계를 등록합니다. 2) 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공합니다. 3) 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록 시 사용자가 두 번째 단계를 등록하는 방법에는 어떤 패턴이 있나요?", "answer": "다중 인증(MFA) 등록 패턴은 다음과 같습니다:\n1. 등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n2. 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 다중 인증(MFA)을 권고하지만 필수이지는 않은 앱은 이 방법을 사용하는 것이 좋습니다.\n3. 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.\n4. 사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA 확인자를 설정하는 방법은 무엇인가요?", "answer": "SMS 코드를 보내려면 reCAPTCHA 확인자를 구성해야 합니다. Firebase는 reCAPTCHA를 통해 전화번호 인증 요청이 앱의 허용된 도메인 중 하나에서 발생하도록 하여 악용을 방지합니다. 클라이언트 SDK의 RecaptchaVerifier 객체는 필요한 클라이언트 키 및 보안 비밀을 자동으로 만들고 초기화합니다.", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "보이지 않는 reCAPTCHA를 사용하려면 어떻게 설정하나요?", "answer": "보이지 않는 reCAPTCHA를 사용하려면 size 매개변수가 invisible로 설정된 RecaptchaVerifier를 만들고 다단계 등록을 시작하는 UI 요소의 ID를 지정합니다. 예시는 다음과 같습니다:\n```javascript\nvar recaptchaVerifier = new firebase.auth.RecaptchaVerifier(\n  'recaptcha-container',\n  { size: 'invisible' }\n);\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA 위젯을 사용하려면 어떤 HTML 요소를 만들어야 하나요?", "answer": "표시되는 reCAPTCHA 위젯을 사용하려면 위젯을 포함할 HTML 요소를 만든 다음 UI 컨테이너의 ID가 있는 RecaptchaVerifier 객체를 만듭니다. 예시는 다음과 같습니다:\n```javascript\nvar recaptchaVerifier = new firebase.auth.RecaptchaVerifier(\n  'recaptcha-container'\n);\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "등록을 완료하려면 선택사항으로 두 번째 단계의 표시 이름을 지정할 수 있습니다. 인증 과정에서 전화번호가 마스킹되므로(예: +1******1234) 두 번째 단계가 여러 개인 사용자에게 유용합니다. 예시는 다음과 같습니다:\n```javascript\n// Complete enrollment. This will update the underlying tokens\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "reCAPTCHA를 미리 렌더링하는 방법은 무엇인가요?", "answer": "reCAPTCHA를 미리 렌더링하려면 다음 코드를 사용합니다:\n```javascript\nrecaptchaVerifier.render()\n.then(function (widgetId) {\n  // reCAPTCHA가 성공적으로 렌더링되었습니다.\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용합니다:\n```javascript\nimport { multiFactor } from \"firebase/auth\";\n\nmultiFactor(user).getSession().then(function (multiFactorSession) {\n  // MFA 세션을 성공적으로 가져왔습니다.\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "SMS 코드 전송 후 사용자에게 확인을 요청하는 방법은 무엇인가요?", "answer": "SMS 코드가 전송된 후 사용자에게 코드를 확인하도록 요청하려면 다음과 같이 작성합니다:\n```javascript\n// Ask user for the verification code. Then:\nconst cred = PhoneAuthProvider.credential(verificationId, verificationCode);\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?", "answer": "다중 인증(MFA) 등록을 완료하려면 다음 코드를 사용합니다:\n```javascript\nresolver.resolveSignIn(multiFactorAssertion)\n.then(function (userCredential) {\n  // 인증이 완료되었습니다.\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "PhoneInfoOptions 객체를 초기화하는 방법은 무엇인가요?", "answer": "PhoneInfoOptions 객체를 초기화하려면 다음과 같이 작성합니다:\n```javascript\nconst phoneInfoOptions = {\n  multiFactorHint: resolver.hints[selectedIndex],\n  session: resolver.session\n};\n```", "source": ["https://firebase.google.com/docs/auth/web/multi-factor?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_multi-factor_hl=ko.txt"}
{"question": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 무엇인가요?", "answer": "OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 다음과 같습니다:\n\n1. 클라이언트 ID: 앱을 식별하는 제공업체의 고유한 문자열입니다. 이 값은 제공업체에서 발급한 ID 토큰의 aud 클레임 값 중 하나입니다.\n2. 클라이언트 보안 비밀번호: 제공업체가 클라이언트 ID의 소유권을 확인하는 데 사용하는 보안 비밀 문자열입니다. 인증 코드 흐름을 사용하는 경우에만 필요합니다.\n3. 발급기관: 제공업체를 식별하는 문자열로, 이 값은 /.well-known/openid-configuration이 추가될 때 제공업체의 OIDC 탐색 문서가 위치하는 URL이어야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OpenID Connect를 사용 설정하는 방법은 무엇인가요?", "answer": "Firebase에서 OpenID Connect를 사용 설정하는 방법은 다음과 같습니다:\n\n1. Firebase Console의 로그인 제공업체 페이지에서 새 제공업체 추가를 클릭한 다음 OpenID Connect를 클릭합니다.\n2. 승인 코드 흐름을 사용할지 또는 암시적 권한 부여 흐름을 사용할지 선택합니다. 제공업체가 지원하는 경우 항상 코드 흐름을 사용해야 합니다.\n3. 제공업체에 이름을 지정하고 생성된 제공업체 ID를 기록합니다.\n4. 클라이언트 ID, 클라이언트 보안 비밀번호, 발급기관 문자열을 지정합니다.\n5. 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 OIDC 제공업체로 로그인하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK를 사용하여 OIDC 제공업체로 로그인하는 방법은 다음과 같습니다:\n\n1. Firebase Console에서 가져온 제공업체 ID를 사용하여 OAuthProvider의 인스턴스를 만듭니다:\n```javascript\nimport { OAuthProvider } from \"firebase/auth\";\nvar provider = new firebase.auth.OAuthProvider('oidc.example-provider');\n```\n2. 사용자를 제공업체의 로그인 페이지로 리디렉션하거나 팝업 브라우저 창에서 로그인 페이지를 엽니다. 리디렉션 흐름을 사용할 경우 다음과 같이 호출합니다:\n```javascript\nimport { getAuth, signInWithRedirect } from \"firebase/auth\";\nfirebase.auth().signInWithRedirect(provider);\n```\n3. 사용자가 로그인을 완료하고 앱으로 돌아간 후에 로그인 결과를 가져옵니다:\n```javascript\nimport { getAuth, getRedirectResult } from \"firebase/auth\";\nfirebase.auth().getRedirectResult()\n.then((result) => {\n  // 로그인 결과 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "OIDC 제공업체에서 추가로 요청할 수 있는 OAuth 2.0 범위는 어떻게 지정하나요?", "answer": "OIDC 제공업체에서 추가로 요청할 수 있는 OAuth 2.0 범위는 다음과 같이 지정할 수 있습니다:\n```javascript\nprovider.addScope('mail.read');\nprovider.addScope('calendars.read');\n```\n지원하는 범위에 대해서는 제공업체에 문의해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OIDC 제공업체를 사용하여 인증할 때 주의해야 할 점은 무엇인가요?", "answer": "Firebase에서 OIDC 제공업체를 사용하여 인증할 때 주의해야 할 점은 다음과 같습니다:\n- 제공업체가 지원하는 경우 항상 코드 흐름을 사용해야 하며, 암시적 흐름은 보안 수준이 낮으므로 사용하지 않는 것이 좋습니다.", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase JavaScript SDK에서 OIDC 제공업체로 로그인하기 위해 OAuthProvider 인스턴스를 생성하는 방법은 무엇인가요?", "answer": "Firebase Console에서 가져온 제공업체 ID를 사용하여 OAuthProvider의 인스턴스를 만듭니다. 다음 코드를 사용하세요:\n\n```javascript\nimport { OAuthProvider } from \"firebase/auth\";\nvar provider = new firebase.auth.OAuthProvider('oidc.example-provider');\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OIDC 제공업체로 로그인할 때 커스텀 OAuth 매개변수를 추가하는 방법은 무엇인가요?", "answer": "선택사항으로 OAuth 요청과 함께 전송하고자 하는 커스텀 OAuth 매개변수를 추가로 지정할 수 있습니다. 다음 코드를 사용하세요:\n\n```javascript\nprovider.setCustomParameters({\n  // Firebase에서 요구하는 매개변수는 setCustomParameters와 함께 전달할 수 없습니다.\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OIDC 제공업체로 리디렉션 흐름을 사용하여 로그인하는 방법은 무엇인가요?", "answer": "리디렉션 흐름을 사용하려면 `signInWithRedirect()`를 호출하여 제공업체 로그인 페이지로 리디렉션합니다. 다음 코드를 사용하세요:\n\n```javascript\nimport { getAuth, signInWithRedirect } from \"firebase/auth\";\nfirebase.auth().signInWithRedirect(provider);\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "사용자가 OIDC 제공업체 로그인 후 Firebase로 돌아왔을 때 로그인 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 앱으로 돌아간 후에 `getRedirectResult()`를 호출하여 로그인 결과를 가져올 수 있습니다. 다음 코드를 사용하세요:\n\n```javascript\nimport { getAuth, getRedirectResult } from \"firebase/auth\";\n\nfirebase.auth().getRedirectResult()\n  .then((result) => {\n    // 로그인 결과 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase에서 OIDC 제공업체로 팝업 창을 사용하여 로그인하는 방법은 무엇인가요?", "answer": "팝업 창을 사용하여 로그인하려면 `signInWithPopup()`을 호출합니다. 다음 코드를 사용하세요:\n\n```javascript\nimport { getAuth, signInWithPopup } from \"firebase/auth\";\nfirebase.auth().signInWithPopup(provider)\n  .then((result) => {\n    // 로그인 결과 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/openid-connect?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_openid-connect_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업을 위한 연결 URL을 설정할 때 어떤 매개변수를 사용해야 하나요?", "answer": "비밀번호 재설정 이메일이나 인증 메일을 보낼 때 firebase.auth.ActionCodeSettings 인스턴스를 제공해야 합니다. 이 인터페이스는 다음과 같은 매개변수를 사용합니다.\n\n| 매개변수 | 유형 | 설명 |\n| --- | --- | --- |\n| url | 문자열 | 컨텍스트에 따라 다른 의미를 가지는 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다. 앱에서 링크가 직접 처리되는 경우 Hosting 링크의 딥 링크에 있는 continueUrl 쿼리 파라미터입니다. |\n| iOS | ({bundleId: string}\\|undefined) | Firebase Authentication이 Apple 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| android | ({packageName: string, installApp:boolean\\|undefined, minimumVersion: string\\|undefined}\\|undefined) | Firebase Authentication이 Android 기기에서 열리는 웹 전용 링크 또는 모바일 링크를 만들어야 하는지 결정하는 데 도움이 됩니다. |\n| handleCodeInApp | (boolean\\|undefined) | 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정합니다. 기본값은 false입니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase 콘솔에서 연결 URL을 안전하게 전달하기 위해 어떤 절차를 따라야 하나요?", "answer": "연결 URL을 안전하게 전달하려면 Firebase 콘솔에서 이 URL의 도메인을 승인된 도메인으로 추가해야 합니다. 아직 허용 목록에 포함되어 있지 않다면 인증 섹션에서 로그인 방법 탭의 승인된 도메인 목록에 도메인을 추가하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 localhost를 승인된 도메인으로 사용하는 경우 주의해야 할 점은 무엇인가요?", "answer": "중요: 2025년 4월 28일 이후에 생성된 프로젝트에서는 Firebase Authentication에 더 이상 localhost가 기본적으로 승인된 도메인으로 포함되지 않습니다. 프로덕션 프로젝트에서는 localhost를 사용하지 않는 것이 좋습니다. localhost를 승인하는 경우 설정 페이지의 승인된 도메인에서 도메인 추가를 클릭하여 수동으로 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "이메일 작업에서 상태 전달 기능이 유용한 시나리오는 어떤 경우인가요?", "answer": "이 기능은 다음과 같은 시나리오에서 매우 유용합니다.\n\n- 현재 로그인하지 않은 사용자가 로그인이 필요한 콘텐츠에 액세스하려고 시도합니다. 하지만 사용자가 비밀번호를 잊어버려 비밀번호 재설정 흐름을 트리거합니다. 이 흐름이 완료되면 사용자는 액세스하려고 했던 앱 섹션으로 돌아가기를 기대합니다.\n- 애플리케이션에서는 인증된 계정에만 액세스를 제공합니다. 예를 들어 뉴스레터를 구독하려면 먼저 사용자의 이메일 인증이 필요합니다. 사용자는 이메일 인증 흐름을 거친 다음 앱으로 돌아가 구독을 완료할 수 있기를 기대합니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 어떻게 지정하나요?", "answer": "이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정하려면 firebase.auth.ActionCodeSettings의 handleCodeInApp 매개변수를 사용합니다. 기본값은 false입니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 모바일 앱에서 먼저 열도록 설정하려면 어떤 매개변수를 사용해야 하나요?", "answer": "이메일 작업 링크를 모바일 앱과 웹 링크 중 어디에서 먼저 열지 지정하려면 firebase.auth.ActionCodeSettings의 handleCodeInApp 매개변수를 사용해야 합니다. 기본값은 false이며, true로 설정하면 작업 코드 링크가 범용 링크 또는 Android 앱 링크로 전송되고 앱이 설치된 경우 앱에서 열립니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 Android 애플리케이션을 구성할 때 필요한 설정은 무엇인가요?", "answer": "Android 애플리케이션에서 Firebase Authentication 링크를 처리하려면 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정해야 하며, 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다. 또한 AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터도 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 보낼 때 사용할 수 있는 커스텀 Hosting 도메인을 설정하는 방법은 무엇인가요?", "answer": "이메일 작업 링크를 보낼 때 사용할 커스텀 Hosting 도메인을 설정하려면 firebase.auth.ActionCodeSettings의 linkDomain 매개변수를 사용하여 프로젝트에 대해 커스텀 Hosting 링크 도메인을 지정해야 합니다. 지정하지 않으면 기본 도메인이 자동으로 선택됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 iOS 애플리케이션을 구성할 때 어떤 절차를 따라야 하나요?", "answer": "iOS 애플리케이션에서 Firebase Authentication 링크를 처리하려면 애플리케이션 기능에서 Hosting 링크 도메인을 연결된 도메인으로 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크의 상태 전달 기능은 어떤 이점을 제공하나요?", "answer": "연결 URL을 통한 상태 전달은 Firebase 인증이 제공하는 강력한 기능으로 사용자 환경을 크게 개선할 수 있습니다. 사용자는 이메일 인증 흐름을 거친 후 앱으로 돌아가 구독을 완료할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 모바일 애플리케이션에서 먼저 열도록 설정할 때 필요한 AndroidManifest.xml 파일의 구성은 무엇인가요?", "answer": "Android 애플리케이션에서 이메일 작업 링크를 처리하려면 Firebase Console 프로젝트 설정에서 앱의 패키지 이름을 지정해야 합니다. 또한 애플리케이션 인증서의 SHA-1 및 SHA-256을 제공해야 합니다. AndroidManifest.xml 파일의 딥 링크에 대한 인텐트 필터도 구성해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 웹 애플리케이션에서 처리할 때 어떤 설정이 필요한가요?", "answer": "웹 애플리케이션의 이메일 작업을 처리하려면 firebase.auth.ActionCodeSettings 객체에서 handleCodeInApp을 false로 설정해야 합니다. 이렇게 하면 작업 코드 링크를 먼저 웹 애플리케이션에서 처리하고 정상적으로 완료된 후 다른 웹페이지 또는 모바일 애플리케이션으로 리디렉션할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크를 모바일 애플리케이션에서 먼저 열도록 설정할 때 어떤 파라미터를 사용해야 하나요?", "answer": "이메일 작업 링크를 모바일 애플리케이션에서 먼저 열도록 설정하려면 firebase.auth.ActionCodeSettings 객체에서 handleCodeInApp을 true로 설정해야 합니다. 또한 모바일 애플리케이션의 Android 패키지 이름 또는 iOS 번들 ID도 지정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 링크의 continueUrl 쿼리 파라미터는 어떻게 구성되나요?", "answer": "continueUrl 쿼리 파라미터의 링크는 페이로드가 ActionCodeSettings 객체에 지정된 URL인 호스팅 링크가 됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업을 처리할 때 oobCode 쿼리 매개변수는 어떤 역할을 하나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다(즉, 이메일 인증).", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 웹 애플리케이션의 이메일 작업을 처리할 때, 다른 웹페이지 또는 모바일 애플리케이션으로 리디렉션할 수 있는 방법은 무엇인가요?", "answer": "웹 애플리케이션의 작업 코드 링크를 처리하고 정상적으로 완료된 후 다른 웹페이지 또는 모바일 애플리케이션으로 리디렉션할지 여부를 지정할 수 있습니다. firebase.auth.ActionCodeSettings 객체에서 handleCodeInApp을 false로 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업을 처리할 때, oobCode 쿼리 매개변수는 어떤 역할을 하나요?", "answer": "이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다(즉, 이메일 인증).", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 모바일 애플리케이션이 설치된 경우, 이메일 작업 코드 링크를 처리할지 여부를 어떻게 지정하나요?", "answer": "모바일 애플리케이션이 설치된 경우 먼저 모바일 애플리케이션의 작업 코드 링크를 처리할지 여부를 지정할 수 있습니다. firebase.auth.ActionCodeSettings 객체에서 handleCodeInApp을 true로 설정하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업을 처리할 때, 모바일 애플리케이션이 없을 경우 어떤 URL이 사용되나요?", "answer": "사용할 수 있는 모바일 앱이 없을 때 여기에 사용된 대체 웹 URL은 이메일 작업 템플릿 섹션에서 구성된 URL입니다. 모든 프로젝트에 기본 URL이 프로비저닝됩니다.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase Authentication에서 이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용은 어디에서 확인할 수 있나요?", "answer": "이메일 작업 핸들러의 맞춤설정에 대한 자세한 내용은 이메일 핸들러 맞춤설정 [https://firebase.google.com/docs/auth/custom-email-handler?hl=ko]을 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/passing-state-in-email-actions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_passing-state-in-email-actions_hl=ko.txt"}
{"question": "Firebase에서 비밀번호 기반 계정을 만들기 위해 필요한 절차는 무엇인가요?", "answer": "비밀번호가 있는 신규 사용자 계정을 만들기 위해서는 앱의 로그인 페이지에서 신규 사용자가 가입 양식을 사용하여 가입하고, 앱에서 요구하는 새 계정 유효성 검사 단계를 완료해야 합니다. 이후 신규 사용자의 이메일 주소와 비밀번호를 createUserWithEmailAndPassword에 전달하여 신규 계정을 생성합니다.", "source": ["https://firebase.google.com/docs/auth/web/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_password-auth_hl=ko.txt"}
{"question": "Firebase Authentication의 비밀번호 정책에서 요구하는 비밀번호의 조건은 무엇인가요?", "answer": "Firebase Authentication 비밀번호 정책은 다음과 같은 비밀번호 요구사항을 지원합니다: 소문자 필요, 대문자 필요, 숫자 필요, 영숫자가 아닌 문자 필요. 비밀번호는 최소 6자에서 최대 4,096자까지 허용됩니다.", "source": ["https://firebase.google.com/docs/auth/web/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_password-auth_hl=ko.txt"}
{"question": "비밀번호 정책 적용 모드에는 어떤 것들이 있으며, 각각의 차이점은 무엇인가요?", "answer": "비밀번호 정책 적용 모드는 '필수'와 '알림' 두 가지가 있습니다. '필수' 모드에서는 사용자가 정책을 준수하는 비밀번호로 업데이트할 때까지 가입 시도가 실패합니다. '알림' 모드에서는 사용자가 정책을 준수하지 않는 비밀번호를 사용하여 가입할 수 있으며, 클라이언트 측에서 비밀번호가 정책을 준수하는지 확인하고 부족한 요구사항을 알리는 메시지를 표시해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_password-auth_hl=ko.txt"}
{"question": "비밀번호 유효성 검사를 클라이언트에서 수행하는 방법은 무엇인가요?", "answer": "클라이언트에서 비밀번호 유효성 검사를 수행하기 위해서는 다음과 같은 코드를 사용할 수 있습니다: \n```javascript\nimport { getAuth, validatePassword } from \"firebase/auth\";\n```\n이 코드를 통해 비밀번호의 유효성을 검사할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_password-auth_hl=ko.txt"}
{"question": "활성 사용자가 있는 경우 비밀번호 정책을 어떻게 설정하는 것이 좋나요?", "answer": "활성 사용자가 있는 경우 비밀번호가 정책을 준수하지 않는 사용자의 액세스를 차단하려는 경우가 아니면 로그인 강제 업그레이드를 사용 설정하지 않는 것이 좋습니다. 대신 사용자가 현재 비밀번호로 로그인할 수 있게 해주고 비밀번호에 부족한 요구사항을 알리는 알림 모드를 사용하는 것이 바람직합니다.", "source": ["https://firebase.google.com/docs/auth/web/password-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_password-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 로그인을 사용하기 위해 어떤 설정을 해야 하나요?", "answer": "Firebase 프로젝트에서 전화번호 로그인 방법을 사용 설정해야 합니다. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다. 또한, OAuth 리디렉션 도메인 섹션에 앱을 호스팅할 도메인이 나열되지 않은 경우 도메인을 추가해야 합니다. 전화 인증을 목적으로 localhost는 호스팅된 도메인으로 허용되지 않습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 인증기를 설정하는 방법은 무엇인가요?", "answer": "전화번호로 사용자를 로그인 처리하려면 Firebase의 reCAPTCHA 인증기를 설정해야 합니다. Firebase는 전화번호 인증 요청이 앱의 허용 도메인 중 하나에서 전송되었는지 확인하는 등 reCAPTCHA를 통해 악용을 방지합니다. RecaptchaVerifier 객체를 사용하면 Firebase에서 필요한 클라이언트 키와 보안 비밀을 자동으로 만들고 처리합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 위젯을 페이지에 포함시키는 방법은 무엇인가요?", "answer": "reCAPTCHA 위젯을 사용하려면 페이지에 위젯을 포함할 요소를 만들고 RecaptchaVerifier 객체를 만들면서 컨테이너의 ID를 지정해야 합니다. 예를 들어 다음과 같이 작성할 수 있습니다: \n```javascript\nimport { getAuth, RecaptchaVerifier } from \"firebase/auth\";\n\nconst recaptchaVerifier = new RecaptchaVerifier('recaptcha-container', {\n  'size': 'invisible',\n  'callback': (response) => {\n    // reCAPTCHA completed\n  }\n}, getAuth());\n```", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "signInWithPhoneNumber 호출이 성공하면 사용자에게 SMS 메시지로 받은 인증 코드를 입력하라는 메시지를 표시해야 합니다. 예를 들어 다음과 같이 작성할 수 있습니다: \n```javascript\nimport { getAuth, signInWithPhoneNumber } from \"firebase/auth\";\n\nsignInWithPhoneNumber(auth, phoneNumber, recaptchaVerifier)\n  .then((confirmationResult) => {\n    // SMS 메시지로 받은 인증 코드를 입력하라는 메시지를 표시\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증 요청의 제한은 어떻게 되나요?", "answer": "Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다. 이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다. 개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증을 위한 reCAPTCHA 인증기를 설정하는 방법은 무엇인가요?", "answer": "전화번호로 사용자를 로그인 처리하려면 우선 Firebase의 reCAPTCHA 인증기를 설정해야 합니다. Firebase는 전화번호 인증 요청이 앱의 허용 도메인 중 하나에서 전송되었는지 확인하는 등 reCAPTCHA를 통해 악용을 방지합니다. RecaptchaVerifier 객체를 사용하면 Firebase에서 필요한 클라이언트 키와 보안 비밀을 자동으로 만들고 처리합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "reCAPTCHA 위젯을 페이지에 포함시키기 위해 어떤 요소를 만들어야 하나요?", "answer": "표시되는 reCAPTCHA 위젯을 사용하려면 페이지에 위젯을 포함할 요소를 만들고 RecaptchaVerifier 객체를 만들면서 컨테이너의 ID를 지정해야 합니다. 예를 들면 다음과 같습니다.\n\n```javascript\nimport { getAuth, RecaptchaVerifier } from \"firebase/auth\";\n\nconst recaptchaVerifier = new RecaptchaVerifier('recaptcha-container', {}, getAuth());\n```", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "인증 코드로 사용자를 로그인 처리하는 방법은 무엇인가요?", "answer": "signInWithPhoneNumber 호출이 성공하면 사용자에게 SMS 메시지로 받은 인증 코드를 입력하라는 메시지를 표시합니다. 그런 다음 signInWithPhoneNumber의 처리 핸들러(즉, then 블록)에 전달된 ConfirmationResult 객체의 confirm 메서드에 코드를 전달하여 사용자를 로그인 처리합니다. 예를 들면 다음과 같습니다.\n\n```javascript\nimport { getAuth, signInWithPhoneNumber } from \"firebase/auth\";\n\nsignInWithPhoneNumber(auth, phoneNumber, appVerifier)\n  .then((confirmationResult) => {\n    // SMS로 받은 인증 코드를 입력받아 사용자를 로그인 처리\n    return confirmationResult.confirm(code);\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 전화번호 인증 요청의 제한을 우회하기 위한 방법은 무엇인가요?", "answer": "개발 중에 전화번호 인증 요청의 제한이 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도해야 합니다. Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호로 테스트하는 방법과 그 이점은 무엇인가요?", "answer": "Firebase Console을 통해 개발용 가상 전화번호를 설정할 수 있습니다. 가상 전화번호로 테스트하면 다음과 같은 이점이 있습니다:\n- 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있습니다.\n- 실제 SMS 메시지를 보내지 않고 전화번호 인증을 테스트할 수 있습니다.\n- 제한 없이 동일한 전화번호로 연속 테스트를 실행할 수 있습니다.\n- 개발 환경에서 쉽게 테스트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase에서 가상 전화번호를 설정하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다. 전화 제공업체를 아직 사용 설정하지 않은 경우 로그인 방법 탭에서 사용 설정합니다. 테스트용 전화번호 아코디언 메뉴를 엽니다. 테스트할 전화번호(예: +1 650-555-3434)를 입력합니다. 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력합니다. 번호를 추가합니다. 필요한 경우 해당 행 위에 마우스를 가져가서 휴지통 아이콘을 클릭하면 전화번호와 코드를 삭제할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호로 테스트할 때의 이점은 무엇인가요?", "answer": "가상 전화번호로 테스트하면 다음과 같은 이점이 있습니다. 사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있습니다. 실제 SMS 메시지를 보내지 않고 전화번호 인증을 테스트할 수 있습니다. 제한 없이 동일한 전화번호로 연속 테스트를 실행할 수 있습니다. 앱 스토어 검토 절차 중에 검토자가 동일한 전화번호를 테스트에 사용하게 될 경우 번호가 거부될 위험이 최소화됩니다. 별도의 노력 없이도 개발 환경에서 쉽게 테스트할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호의 요구사항은 무엇인가요?", "answer": "가상 전화번호는 다음 요구사항을 충족해야 합니다. 실제로 존재하지 않는 가상의 전화번호여야 합니다. Firebase Authentication에서는 실제 사용자가 사용하는 기존 전화번호를 테스트 전화번호로 설정할 수 없습니다. 전화번호를 만드는 방법 중 하나는 555로 시작하는 번호(예: +1 650-555-3434)를 미국 테스트 전화번호로 사용하는 것입니다. 길이 및 기타 조건에 맞게 전화번호 형식을 올바르게 지정해야 합니다. 테스트 전화번호도 실제 사용자의 전화번호와 동일한 유효성 검사를 거칩니다. 개발용으로 최대 10개의 전화번호를 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 수동 테스트를 수행하는 방법은 무엇인가요?", "answer": "애플리케이션에서 직접 가상 전화번호를 사용할 수 있습니다. 따라서 할당량 문제나 제한 없이 개발 단계 중에 직접 테스트를 수행할 수 있습니다. 또한 Google Play 서비스를 설치하지 않고 iOS 시뮬레이터 또는 Android 에뮬레이터에서 바로 테스트할 수 있습니다. 가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않습니다. 그 대신 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호로 로그인한 후의 사용자 행동은 어떻게 되나요?", "answer": "로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다. 사용자는 실제 전화번호 사용자와 동일한 행동과 속성을 가지며 동일한 방식으로 Realtime Database/Cloud Firestore 및 기타 서비스에 액세스할 수 있습니다. 이 절차 중에 발급된 ID 토큰에는 실제 전화번호 사용자와 같은 서명이 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase Console에서 가상 전화번호를 추가하는 방법은 무엇인가요?", "answer": "Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고, 로그인 방법 탭에서 전화 제공업체를 사용 설정합니다. 그런 다음 테스트용 전화번호 아코디언 메뉴를 열고, 테스트할 전화번호(예: +1 650-555-3434)와 해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력한 후 번호를 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호를 사용하여 수동 테스트를 수행할 때의 절차는 어떻게 되나요?", "answer": "애플리케이션에서 가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않습니다. 대신 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다. 로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "가상 전화번호의 ID 토큰은 어떻게 처리되나요?", "answer": "가상 전화번호의 ID 토큰에는 실제 전화번호 사용자와 같은 서명이 있으므로 가상 전화번호를 안전하게 저장하고 지속적으로 재활용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "Firebase Authentication에서 통합 테스트를 작성하는 방법은 무엇인가요?", "answer": "Firebase Authentication은 전화 인증 테스트용 통합 테스트를 작성할 수 있는 API를 제공합니다. 이러한 API는 웹에서 reCAPTCHA 요구사항을, iOS에서 백그라운드 푸시 알림을 중지하여 앱 인증을 사용 중지합니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "웹에서 reCAPTCHA를 사용 중지하고 가상 전화번호를 사용하는 방법은 무엇인가요?", "answer": "웹에서 firebase.auth.RecaptchaVerifier를 렌더링하기 전에 appVerificationDisabledForTesting을 true로 설정합니다. 이렇게 하면 reCAPTCHA가 자동으로 확인되어 직접 처리하지 않고도 전화번호를 전달할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/phone-auth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_phone-auth_hl=ko.txt"}
{"question": "서드 파티 스토리지 액세스를 차단하는 브라우저에서 signInWithRedirect()를 사용하기 위한 권장사항은 무엇인가요?", "answer": "서드 파티 스토리지 액세스를 차단하는 브라우저에서 signInWithRedirect() 흐름을 원활하게 진행하기 위해서는 다음 설정 옵션 중 하나를 앱에 적용해야 합니다. firebaseapp.com의 하위 도메인에서 Firebase 호스팅으로 앱을 호스팅하는 경우에는 영향을 받지 않으며, 커스텀 도메인이나 web.app의 하위 도메인에서 Firebase 호스팅으로 앱을 호스팅하는 경우에는 옵션 1을 사용해야 합니다. Firebase 이외의 서비스로 앱을 호스팅하는 경우에는 옵션 2, 3, 4, 5 중 하나를 사용해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "커스텀 도메인을 authDomain으로 사용하도록 Firebase 구성을 업데이트하는 방법은 무엇인가요?", "answer": "커스텀 도메인을 authDomain으로 사용하도록 Firebase JS SDK를 구성하려면, 먼저 커스텀 도메인을 authDomain으로 설정해야 합니다. 이렇게 하면 앱과 인증 iframe에서 같은 도메인을 사용하게 되어 로그인 문제가 방지됩니다. 인증에 사용하는 것과 동일한 프로젝트에 커스텀 도메인을 설정했는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "signInWithRedirect 흐름에서 firebaseapp.com에 프록시 인증 요청을 설정하는 방법은 무엇인가요?", "answer": "signInWithRedirect 흐름에서 firebaseapp.com에 프록시 인증 요청을 설정하려면, 앱 서버에 리버스 프록시를 설정하여 https://<app domain>/__/auth/에 대한 GET/POST 요청이 https://<project>.firebaseapp.com/__/auth/에 전달되도록 해야 합니다. 이 전달은 브라우저에 표시되어야 하며, 302 리디렉션을 통해 실행될 수 없습니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "nginx를 사용하여 커스텀 도메인을 제공하는 경우 역방향 프록시 구성은 어떻게 하나요?", "answer": "nginx를 사용하여 커스텀 도메인을 제공하는 경우 역방향 프록시 구성은 다음과 같이 설정할 수 있습니다. \n```\n# reverse proxy for signin-helpers for popup\n```\n이 설정을 통해 signInWithRedirect 흐름을 원활하게 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "서드 파티 쿠키를 차단하는 브라우저에서 signInWithRedirect()가 작동하기 위해 필요한 조건은 무엇인가요?", "answer": "서드 파티 쿠키를 차단하는 브라우저에서 signInWithRedirect()가 의도한 대로 작동하려면, 2024년 6월 24일부터 Chrome M115 이상에서 리디렉션 로그인이 작동하려면 옵션 중 하나를 구현해야 합니다. 이는 Firefox 109 이상 및 Safari 16.1 이상에서도 이미 필요합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "Firebase에서 커스텀 도메인을 authDomain으로 사용하도록 구성하는 방법은 무엇인가요?", "answer": "커스텀 도메인을 authDomain으로 사용하도록 Firebase JS SDK를 구성하려면, Firebase 호스팅으로 앱을 호스팅하고 인증에 사용하는 것과 동일한 프로젝트에 커스텀 도메인을 설정해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "signInWithRedirect 흐름에서 firebaseapp.com에 프록시 인증 요청을 설정하는 방법은 무엇인가요?", "answer": "signInWithRedirect 흐름은 앱 도메인에서 Firebase 구성의 authDomain 매개변수에 지정된 도메인으로 리디렉션됩니다. 이를 위해 앱 서버에 리버스 프록시를 설정하여 https://<app domain>/__/auth/에 대한 GET/POST 요청이 https://<project>.firebaseapp.com/__/auth/에 전달되도록 해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "nginx를 사용하여 커스텀 도메인을 제공하는 경우 역방향 프록시 구성 예시는 무엇인가요?", "answer": "nginx를 사용하여 커스텀 도메인을 제공하는 경우 역방향 프록시 구성은 다음과 같습니다.\n```nginx\n# reverse proxy for signin-helpers for popup/redirect sign in.\nlocation /__/auth {\nproxy_pass https://<project>.firebaseapp.com;\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "Firebase 인증 SDK를 사용하여 공급업체 로그인을 개별적으로 처리하는 방법은 무엇인가요?", "answer": "Firebase 인증 SDK는 signInWithPopup() 및 signInWithRedirect()를 제공하며, 공급업체에 개별적으로 로그인한 후 signInWithCredential()을 사용하여 제공업체의 사용자 인증 정보를 Firebase 인증 사용자 인증 정보로 교환할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "Firebase에서 인증 흐름이 앱 도메인으로 돌아오면 어떤 작업이 수행되나요?", "answer": "인증 흐름이 앱 도메인으로 돌아오면 로그인 도우미 도메인의 브라우저 스토리지에 액세스하게 됩니다. 이 과정에서 교차 출처 스토리지 액세스가 제거됩니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "nginx를 사용하여 커스텀 도메인을 제공할 때, 리버스 프록시 설정은 어떻게 하나요?", "answer": "nginx를 사용하여 커스텀 도메인을 제공하는 경우 역방향 프록시 구성은 다음과 같습니다.\n```nginx\n# reverse proxy for signin-helpers for popup/redirect sign in.\nlocation /__/auth {\nproxy_pass https://<project>.firebaseapp.com;\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "Firebase 인증 SDK를 사용하여 공급업체 로그인을 개별적으로 처리하는 방법은 무엇인가요?", "answer": "Firebase 인증 SDK는 signInWithPopup() 및 signInWithRedirect()를 제공하며, 제공업체에 개별적으로 로그인한 후 signInWithCredential()을 사용하여 제공업체의 사용자 인증 정보를 Firebase 인증 사용자 인증 정보로 교환할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "Google 로그인 SDK를 사용하여 Google 사용자 인증 정보를 가져온 후, Firebase에 인증 정보를 인스턴스화하는 방법은 무엇인가요?", "answer": "Google 로그인 SDK인 샘플 코드를 사용하여 Google 계정 사용자 인증 정보를 가져온 후, 다음 코드를 실행하여 새 Google 사용자 인증 정보를 인스턴스화할 수 있습니다.\n```javascript\n// `googleUser` from the onsuccess Google Sign In callback.\n```", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "앱 서버에 리버스 프록시를 설정할 때, 어떤 요청이 전달되어야 하나요?", "answer": "앱 서버에 리버스 프록시를 설정할 때, https://<app domain>/__/auth/에 대한 GET/POST 요청이 https://<project>.firebaseapp.com/__/auth/에 전달되어야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "리버스 프록시 설정 후, 웹 서버가 응답할 수 있는 URL은 무엇인가요?", "answer": "웹 서버가 https://<app domain>/__/auth/<filename> 및 https://<app domain>/__/firebase/init.json에 응답할 수 있는지 확인해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/redirect-best-practices?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_redirect-best-practices_hl=ko.txt"}
{"question": "SAML ID 공급업체를 설정하기 위해 필요한 정보는 무엇인가요?", "answer": "SAML ID 공급업체를 설정하기 위해 필요한 정보는 다음과 같습니다: 1. 제공업체의 엔티티 ID: ID 공급업체를 식별하는 URI 2. 제공업체의 SAML SSO URL: ID 공급업체의 로그인 페이지 URL 3. 제공업체의 공개 키 인증서: ID 공급업체가 서명한 토큰을 인증하는 데 사용되는 인증서 4. 앱의 엔티티 ID: 앱을 식별하는 URI, 즉 '서비스 제공업체'", "source": ["https://firebase.google.com/docs/auth/web/saml?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_saml_hl=ko.txt"}
{"question": "Firebase Console에서 SAML 제공업체를 추가하는 방법은 무엇인가요?", "answer": "Firebase Console에서 SAML 제공업체를 추가하려면 다음 단계를 따르세요: 1. Firebase Console의 로그인 공급업체 페이지에서 '새 제공업체 추가'를 클릭한 다음 SAML을 클릭합니다. 2. 이 제공업체에 이름을 지정합니다. 3. ID 공급업체의 엔티티 ID, SSO URL, 공개키 인증서를 지정합니다. 4. 앱의 엔티티 ID(서비스 제공업체)도 지정합니다. 5. 변경사항을 저장합니다.", "source": ["https://firebase.google.com/docs/auth/web/saml?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_saml_hl=ko.txt"}
{"question": "Firebase JavaScript SDK로 SAML 인증을 처리하는 기본 코드는 무엇인가요?", "answer": "Firebase JavaScript SDK로 SAML 인증을 처리하는 기본 코드는 다음과 같습니다: \n```javascript\nimport { SAMLAuthProvider } from \"firebase/auth\";\nvar provider = new firebase.auth.SAMLAuthProvider('saml.example-provider');\n```", "source": ["https://firebase.google.com/docs/auth/web/saml?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_saml_hl=ko.txt"}
{"question": "사용자를 SAML 제공업체의 로그인 페이지로 리디렉션하는 방법은 무엇인가요?", "answer": "사용자를 SAML 제공업체의 로그인 페이지로 리디렉션하려면 `signInWithRedirect()` 메서드를 호출합니다. 예제 코드는 다음과 같습니다: \n```javascript\nimport { getAuth, signInWithRedirect } from \"firebase/auth\";\nfirebase.auth().signInWithRedirect(provider);\n```", "source": ["https://firebase.google.com/docs/auth/web/saml?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_saml_hl=ko.txt"}
{"question": "로그인 후 결과를 가져오는 방법은 무엇인가요?", "answer": "로그인 후 결과를 가져오려면 `getRedirectResult()` 메서드를 호출합니다. 예제 코드는 다음과 같습니다: \n```javascript\nimport { getAuth, getRedirectResult } from \"firebase/auth\";\nfirebase.auth().getRedirectResult()\n.then((result) => {\n  // 로그인 결과 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/saml?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_saml_hl=ko.txt"}
{"question": "서비스 워커에서 Firebase ID 토큰을 가져오는 방법은 무엇인가요?", "answer": "서비스 워커에서 Firebase ID 토큰을 가져오려면 인증 라이브러리를 포함하고 사용자가 로그인한 경우 현재 ID 토큰을 가져와야 합니다. 다음은 이를 구현하는 코드 예시입니다:\n\n```javascript\nimport { getAuth, getIdToken } from \"firebase/auth\";\n\nif (user) {\n  getIdToken(user).then((idToken) => {\n    resolve(idToken);\n  });\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커를 사용하여 ID 토큰을 새로고침하는 방법은 무엇인가요?", "answer": "서비스 워커는 현재 사용자 ID 토큰에 접근할 수 있으며, 토큰이 만료되면 클라이언트 SDK에서 새로고침하고 새 토큰을 반환합니다. 이를 통해 ID 토큰을 자동으로 새로고침할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 HTTP 요청을 가로채고 수정하는 방법은 무엇인가요?", "answer": "서비스 워커는 가져오기 요청을 가로채고 수정할 수 있습니다. 이를 통해 요청을 처리하기 전에 필요한 헤더를 추가하거나 요청 본문을 변경할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "Firebase 인증을 사용하여 서버 측 세션 관리를 어떻게 할 수 있나요?", "answer": "Firebase 인증은 서비스 워커를 사용하여 사용자 세션의 서버 측 사용 정보를 관리할 수 있습니다. 서비스 워커는 현재 Firebase 인증 상태에 접근할 수 있으며, 이를 통해 ID 토큰을 서버에 전달할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커를 사용하여 Firebase 인증 소스 코드를 페이지마다 포함하지 않는 방법은 무엇인가요?", "answer": "서비스 워커를 로드하고 초기화하면 백그라운드에서 모든 클라이언트의 세션 관리를 처리할 수 있습니다. 이를 통해 페이지마다 Firebase 인증 소스 코드를 포함할 필요가 없어지며, 지연 시간을 줄일 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 Firebase 인증 상태를 확인하는 방법은 무엇인가요?", "answer": "서비스 워커는 현재 Firebase 인증 상태에 액세스할 수 있습니다. 사용자가 로그인한 경우, 현재 ID 토큰을 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 ID 토큰을 가져오는 코드 예시는 무엇인가요?", "answer": "다음은 서비스 워커에서 ID 토큰을 가져오는 코드 예시입니다:\n```javascript\nimport { getAuth, getIdToken } from \"firebase/auth\";\n\nif (user) {\n  getIdToken(user).then((idToken) => {\n    resolve(idToken);\n  });\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 HTTP 요청을 수정하는 방법은 무엇인가요?", "answer": "서비스 워커는 가져오기 요청을 가로채 수정할 수 있습니다. 이를 통해 요청의 메서드, 헤더, 본문 등을 변경할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 Firebase 인증 라이브러리를 포함하는 방법은 무엇인가요?", "answer": "서비스 워커는 인증 라이브러리를 포함하고 사용자가 로그인한 경우 현재 ID 토큰을 가져올 수 있어야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "서비스 워커에서 ID 토큰을 가져오는 함수의 예시는 무엇인가요?", "answer": "다음은 서비스 워커에서 ID 토큰을 가져오는 함수의 예시입니다:\n```javascript\nfunction getIdToken(req) {\n  import { getAuth } from 'firebase/auth';\n  import { headers } from 'next/headers';\n  import { redirect } from 'next/navigation';\n\n  // 함수 내용\n}\n```", "source": ["https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_service-worker-sessions_hl=ko.txt"}
{"question": "Firebase Authentication을 초기화하기 위해 필요한 코드 예시는 무엇인가요?", "answer": "Firebase Authentication을 초기화하기 위해 다음과 같은 코드를 사용합니다:\n\n```javascript\nimport { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\nimport \"firebase/compat/auth\";\n```", "source": ["https://firebase.google.com/docs/auth/web/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_start_hl=ko.txt"}
{"question": "Firebase Authentication 에뮬레이터를 사용하기 위한 기본적인 설정 방법은 무엇인가요?", "answer": "Firebase Authentication 에뮬레이터를 사용하기 위해서는 다음 단계를 따릅니다:\n1. 에뮬레이터에 연결하려면 앱의 테스트 구성에 코드 줄을 추가합니다.\n2. 로컬 프로젝트 디렉터리의 루트에서 `firebase emulators:start`를 실행합니다.", "source": ["https://firebase.google.com/docs/auth/web/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_start_hl=ko.txt"}
{"question": "신규 사용자가 이메일과 비밀번호로 가입할 때 사용하는 메서드는 무엇인가요?", "answer": "신규 사용자가 이메일 주소와 비밀번호로 가입할 때는 `createUserWithEmailAndPassword` 메서드를 사용합니다. 예시는 다음과 같습니다:\n\n```javascript\nimport { getAuth, createUserWithEmailAndPassword } from \"firebase/auth\";\n```", "source": ["https://firebase.google.com/docs/auth/web/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_start_hl=ko.txt"}
{"question": "사용자의 인증 상태를 관찰하기 위해 어떤 메서드를 사용하나요?", "answer": "사용자의 인증 상태를 관찰하기 위해 `onAuthStateChanged` 메서드를 사용합니다. 예시는 다음과 같습니다:\n\n```javascript\nimport { getAuth, onAuthStateChanged } from \"firebase/auth\";\n```", "source": ["https://firebase.google.com/docs/auth/web/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_start_hl=ko.txt"}
{"question": "Firebase Authentication을 사용하여 사용자가 로그인할 수 있는 방법은 어떤 것들이 있나요?", "answer": "Firebase Authentication을 사용하면 사용자가 이메일 주소와 비밀번호를 통한 로그인 방법이나 Google 로그인, Facebook 로그인과 같은 제휴 ID 공급업체를 통한 로그인 등 1개 이상의 로그인 방법을 사용할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_start_hl=ko.txt"}
{"question": "TOTP 다중 인증(MFA)을 사용 설정하기 위해 Admin SDK에서 어떤 단계를 따라야 하나요?", "answer": "TOTP를 두 번째 단계로 사용 설정하려면 Admin SDK를 사용하거나 프로젝트 구성 REST 엔드포인트를 호출해야 합니다. Admin SDK를 사용하려면 다음 단계를 따르세요. 아직 설치하지 않았다면 Firebase Admin Node.js SDK를 설치합니다. TOTP MFA는 Firebase Admin Node.js SDK 버전 11.6.0 이상에서만 지원됩니다. 다음 코드를 실행합니다.\n\n```javascript\nimport { getAuth } from 'firebase-admin/auth';\n\ngetAuth().projectConfigManager().updateProjectConfig(\n  multiFactorConfig: {\n    providerConfigs: [{\n      state: \"ENABLED\",\n      totpProviderConfig: {\n        adjacentIntervals: NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n);\n```", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "REST API를 사용하여 TOTP MFA를 사용 설정하는 방법은 무엇인가요?", "answer": "REST API를 사용하여 TOTP MFA를 사용 설정하려면 다음 코드를 실행합니다.\n\n```bash\ncurl -X PATCH \"https://identitytoolkit.googleapis.com/admin/v2/projects/PROJECT_ID/config?updateMask=mfa\" \\\n-H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n-H \"Content-Type: application/json\" \\\n-H \"X-Goog-User-Project: PROJECT_ID\" \\\n-d \\\n'{\n  \"mfa\": {\n    \"providerConfigs\": [{\n      \"state\": \"ENABLED\",\n      \"totpProviderConfig\": {\n        \"adjacentIntervals\": NUM_ADJ_INTERVALS\n      }\n    }]\n  }\n}'\n```", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "사용자가 TOTP MFA에 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현해야 합니다. 필요한 MFA 클래스와 함수를 가져옵니다.\n\n```javascript\nimport {\n  multiFactor,\n  TotpMultiFactorGenerator,\n  TotpSecret,\n  getAuth,\n} from 'firebase/auth';\n```\n보안 비밀을 사용자에게 표시하고 OTP 앱에 입력하라는 메시지를 표시합니다. 많은 OTP 앱에서 사용자는 Google OTP 호환 키 URI를 나타내는 QR 코드를 스캔하여 새 TOTP 보안 비밀을 빠르게 추가할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA로 사용자 로그인을 처리하는 방법은 무엇인가요?", "answer": "TOTP MFA로 사용자 로그인을 처리하려면 다음 코드를 사용하세요. 필요한 MFA 클래스와 함수를 가져옵니다.\n\n```javascript\nimport {\n  getAuth,\n  getMultiFactorResolver,\n  TotpMultiFactorGenerator,\n} from 'firebase/auth';\n```\nMFA를 사용하지 않을 때와 마찬가지로 signInWith- 메서드 중 하나를 호출합니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용하기 위해 이메일 인증이 필요한 이유는 무엇인가요?", "answer": "MFA를 사용하려면 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일 주소에 서비스를 등록한 후 두 번째 단계를 추가하여 이메일 주소의 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA를 사용하여 사용자를 등록하기 위해 클라이언트 측에서 어떤 로직을 구현해야 하나요?", "answer": "앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현합니다. 필요한 MFA 클래스와 함수를 가져옵니다.\n\n```javascript\nimport {\n  multiFactor,\n  TotpMultiFactorGenerator,\n  TotpSecret,\n  getAuth,\n} from 'firebase/auth';\n```\n\n보안 비밀을 사용자에게 표시하고 OTP 앱에 입력하라는 메시지를 표시합니다. 많은 OTP 앱에서 사용자는 Google OTP 호환 키 URI를 나타내는 QR 코드를 스캔하여 새 TOTP 보안 비밀을 빠르게 추가할 수 있습니다. 이 용도로 QR 코드를 생성하려면 `generateQrCodeUrl()`로 URI를 생성한 다음 원하는 QR 코드 라이브러리를 사용하여 인코딩합니다. 예를 들면 다음과 같습니다.\n\n```javascript\nconst totpUri = await TotpMultiFactorGenerator.getTotpUri(\n  currentUser,\n  'Your App's Name'\n);\nawait QRExampleLib.toCanvas(totpUri, qrElement);\n```\n\nQR 코드 표시 여부와 관계없이 항상 보안 비밀 키를 표시하여 QR 코드를 읽을 수 없는 OTP 앱을 지원합니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA로 사용자 로그인을 처리하기 위해 필요한 코드는 무엇인가요?", "answer": "TOTP MFA로 사용자 로그인을 처리하려면 다음 코드를 사용하세요. 필요한 MFA 클래스와 함수를 가져옵니다.\n\n```javascript\nimport {\n  getAuth,\n  getMultiFactorResolver,\n  TotpMultiFactorGenerator,\n} from 'firebase/auth';\n```\n\nMFA를 사용하지 않을 때와 마찬가지로 `signInWith-` 메서드 중 하나를 호출합니다(예: `signInWithEmailAndPassword()`). 메서드에서 `auth/multi-factor-auth-required` 오류가 발생하면 앱의 MFA 흐름을 시작합니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "사용자가 TOTP MFA에서 등록 해제할 때 어떤 오류가 발생하나요?", "answer": "사용자가 여러 MFA 옵션에 가입했고, 가장 최근에 사용 설정된 옵션에서 등록 해제한 경우 `auth/user-token-expired`를 수신하고 로그아웃됩니다. 사용자는 다시 로그인하여 기존 사용자 인증 정보(예: 이메일 주소와 비밀번호)를 확인합니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "TOTP MFA에서 사용자를 등록 해제하고 오류를 처리하는 방법은 무엇인가요?", "answer": "사용자를 등록 해제하고 오류를 처리하고 재인증을 트리거하려면 다음 코드를 사용하세요.\n\n```javascript\nimport {\n  EmailAuthProvider,\n  TotpMultiFactorGenerator,\n  getAuth,\n  multiFactor,\n  reauthenticateWithCredential,\n  currentUser,\n} from 'firebase/auth';\n```\n\n이 코드를 통해 사용자의 MFA 등록 해제를 처리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "앱에서 다중 인증(MFA)을 요구하는 일반적인 패턴은 무엇인가요?", "answer": "앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 몇몇 일반적인 패턴은 다음과 같습니다.\n1. 등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n2. 등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 앱에서 다중 인증(MFA)을 권장하지만 필수가 아니라면 이 방법을 사용할 수 있습니다.\n3. 가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.\n4. 사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.", "source": ["https://firebase.google.com/docs/auth/web/totp-mfa?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_totp-mfa_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 Twitter 인증을 처리하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK로 Twitter 인증을 처리하려면 다음 단계를 따르세요. Twitter 제공업체 객체의 인스턴스를 생성합니다.\n\n```javascript\nimport { TwitterAuthProvider } from \"firebase/auth\";\nimport { getAuth } from \"firebase/auth\";\n\nfirebase.auth().languageCode = 'it';\nprovider.setCustomParameters({\n  'lang': 'es'\n});\n```\n\n그 다음, Twitter 제공업체 객체를 사용해 Firebase에 인증을 진행합니다. 팝업 창을 띄우거나 로그인 페이지로 리디렉션하여 사용자가 Twitter 계정에 로그인하도록 유도할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "signInWithPopup 메서드를 사용하여 Twitter 인증을 수행하는 예시는 무엇인가요?", "answer": "팝업 창을 사용하여 Twitter 인증을 수행하려면 `signInWithPopup` 메서드를 호출합니다. 아래는 예시 코드입니다.\n\n```javascript\nimport { getAuth, signInWithPopup, TwitterAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().signInWithPopup(provider)\n  .then((result) => {\n    // 로그인 성공 시 처리\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "signInWithRedirect 메서드를 사용하여 Twitter 인증을 수행하는 방법은 무엇인가요?", "answer": "리디렉션을 사용하여 Twitter 인증을 수행하려면 `signInWithRedirect` 메서드를 호출합니다. 아래는 예시 코드입니다.\n\n```javascript\nimport { getAuth, signInWithRedirect, TwitterAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().signInWithRedirect(provider);\n```", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "getRedirectResult 메서드를 사용하여 Twitter OAuth 토큰을 가져오는 방법은 무엇인가요?", "answer": "페이지가 로드될 때 `getRedirectResult`를 호출하여 Twitter 제공업체의 OAuth 토큰을 가져올 수 있습니다. 아래는 예시 코드입니다.\n\n```javascript\nimport { getAuth, getRedirectResult, TwitterAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().getRedirectResult()\n  .then((result) => {\n    if (result.credential) {\n      // OAuth 토큰 처리\n    }\n  })\n  .catch((error) => {\n    // 오류 처리\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "팝업 모드에서 `signInWithPopup`을 사용하는 경우, `auth/account-exists-with-different-credential` 오류를 처리하기 위해 아래와 같은 코드를 사용할 수 있습니다.\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  TwitterAuthProvider,\n} from \"firebase/auth\";\n\n// 오류 처리 로직\n```", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Twitter 로그인을 위한 리디렉션 도메인을 어떻게 설정하나요?", "answer": "Twitter 로그인을 위한 리디렉션 도메인을 설정하려면 다음 단계를 따르세요. 1. Firebase Console에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다. 2. Twitter 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다. 3. 자바스크립트 라이브러리를 초기화할 때는 authDomain 필드를 사용하여 커스텀 도메인을 지정합니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 Twitter 계정을 사용해 인증할 때 OAuth 액세스 토큰과 암호를 어떻게 교환하나요?", "answer": "Firebase에서 Twitter 계정을 사용해 인증할 때 OAuth 액세스 토큰과 암호를 교환하려면 다음 코드를 사용하세요. var credential = firebase.auth.TwitterAuthProvider.credential(token, secret); 이 코드를 사용하여 Firebase 사용자 인증 정보를 생성한 후 Firebase에 인증합니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "signInWithCredential 메서드를 사용하여 Twitter 인증을 처리하는 방법은 무엇인가요?", "answer": "signInWithCredential 메서드를 사용하여 Twitter 인증을 처리하려면 다음과 같은 코드를 사용할 수 있습니다. Web import { getAuth, signInWithCredential, TwitterAuthProvider } from 'firebase/auth';\n\n.then((result) => {\n  // 인증 처리\n});", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 이를 통해 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Twitter 로그인을 위한 OAuth 엔드포인트를 호출하는 방법은 무엇인가요?", "answer": "Twitter 로그인을 위한 OAuth 엔드포인트를 호출하려면 개발자 문서에 따라 앱에 Twitter 인증을 통합해야 합니다. Twitter 로그인 과정의 끝에서 OAuth 액세스 토큰과 OAuth 암호를 받을 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Firebase에서 커스텀 도메인을 설정하는 방법은 무엇인가요?", "answer": "Firebase Hosting으로 커스텀 도메인을 설정하려면 다음 단계를 따르세요: 1. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 2. 도메인 소유권을 확인합니다. 3. Firebase Console [https://console.firebase.google.com/?hl=ko]에서 승인된 도메인 목록에 커스텀 도메인 auth.custom.domain.com을 추가합니다. 4. Twitter 개발자 콘솔 또는 OAuth 설정 페이지에서 커스텀 도메인 https://auth.custom.domain.com/__/auth/handler에서 액세스할 수 있는 리디렉션 페이지의 URL을 허용 목록에 추가합니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 이렇게 하면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/web/manage-users?hl=ko]를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Firebase Realtime Database와 Cloud Storage에서 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?", "answer": "Firebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "여러 인증 제공업체를 통해 사용자가 로그인할 수 있도록 하는 방법은 무엇인가요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결 [https://firebase.google.com/docs/auth/web/account-linking?hl=ko]하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut [https://firebase.google.com/docs/reference/js/auth?hl=ko#signout]을 호출합니다. 예시는 다음과 같습니다: \n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/twitter-login?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_twitter-login_hl=ko.txt"}
{"question": "Yahoo 계정을 통해 Firebase로 인증하기 위해 필요한 초기 설정은 무엇인가요?", "answer": "Yahoo 계정을 통해 로그인하도록 하려면 우선 Firebase 프로젝트에서 Yahoo를 로그인 제공업체로 사용 설정해야 합니다. Firebase Console에서 인증 섹션을 열고 로그인 방법 탭에서 Yahoo 제공업체를 사용 설정합니다. 또한 해당 제공업체의 개발자 콘솔에서 제공되는 클라이언트 ID 및 클라이언트 보안 비밀번호를 제공업체 구성에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase JavaScript SDK를 사용하여 Yahoo 계정으로 인증하는 방법은 무엇인가요?", "answer": "Firebase JavaScript SDK로 로그인 과정을 처리하려면 다음 단계를 따르세요. 제공업체 ID OAuthProvider을 사용하여 OAuthProvider의 인스턴스를 생성합니다. 그런 다음, 팝업 창을 사용해 로그인하려면 signInWithPopup을 호출합니다. 예시는 다음과 같습니다:\n```javascript\nimport { getAuth, signInWithPopup, OAuthProvider } from \"firebase/auth\";\n\nfirebase.auth().signInWithPopup(provider)\n  .then((result) => {\n    // 로그인 성공\n  });\n```", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "로그인 후 사용자의 Yahoo ID를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에 getRedirectResult를 호출하여 로그인 결과를 가져올 수 있습니다. 성공적으로 완료되면 제공업체에 연결된 OAuth ID 토큰 및 액세스 토큰을 반환되는 firebase.auth.UserCredential 객체에서 검색할 수 있습니다. Yahoo 사용자의 ID는 firebase.auth().currentUser.providerData[0].uid 필드 또는 result.additionalUserInfo.profile에서 검색할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "OAuthProvider의 setCustomParameters() 메서드로 어떤 매개변수를 설정할 수 있나요?", "answer": "Firebase에서 요구하는 매개변수는 setCustomParameters()와 함께 전달할 수 없습니다. 이러한 매개변수에는 client_id, redirect_uri, response_type, scope, state가 포함됩니다. 선택사항으로 인증 제공업체에서 요청하고자 하는 profile 및 email 범위를 넘는 OAuth 2.0 범위를 추가로 지정할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase Console에서 이메일 주소당 계정 1개를 사용 설정한 경우 어떤 제한이 있나요?", "answer": "Firebase Console에서 이메일 주소당 계정 1개를 사용 설정한 경우, 다른 Firebase 사용자의 제공업체(예: Google)에 이미 존재하는 이메일 주소로 로그인할 수 없습니다. 이 경우, linkWithPopup/linkWithRedirect를 사용하여 Yahoo 제공업체를 기존 사용자에 연결할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Yahoo API의 비공식 사용자 데이터에 접근하기 위해 필요한 권한 요청 방법은 무엇인가요?", "answer": "Yahoo API의 비공식 사용자 데이터에 대한 액세스가 필요한 경우, Yahoo 개발자 콘솔의 API 권한에서 Yahoo API에 대한 권한을 요청해야 합니다. 요청받은 OAuth 범위는 앱의 API 권한에서 사전 구성된 범위와 정확하게 일치해야 하며, 예를 들어 사용자 연락처에 읽기/쓰기 액세스 권한이 요청되면 읽기 전용 OAuth 범위 sdct-r 대신 sdct-w를 전달해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 계정으로 인증 후 로그인 결과를 가져오는 방법은 무엇인가요?", "answer": "사용자가 로그인을 완료하고 페이지로 돌아간 후에 getRedirectResult를 호출하여 로그인 결과를 가져올 수 있습니다. 예를 들어, 다음과 같이 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, signInWithRedirect } from \"firebase/auth\";\n\nfirebase.auth().signInWithRedirect(provider);\n```", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 계정으로 로그인할 때 발생할 수 있는 오류는 무엇인가요?", "answer": "Firebase Console에서 이메일 주소당 계정 1개를 사용 설정한 경우, 다른 Firebase 사용자의 제공업체(예: Google)에 이미 존재하는 이메일을 사용하여 Yahoo와 같은 제공업체에 로그인을 시도하면 auth/account-exists-with-different-credential 오류가 발생합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 계정과 기존 사용자 계정을 연결하는 방법은 무엇인가요?", "answer": "linkWithPopup 또는 linkWithRedirect를 사용하여 Yahoo 제공업체를 기존 사용자에 연결할 수 있습니다. 예를 들어, 다음과 같은 코드를 사용할 수 있습니다:\n\n```javascript\nimport { getAuth, linkWithPopup, OAuthProvider } from \"firebase/auth\";\n\n.then((result) => {\n  // 연결 성공 후 처리\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 OAuth 로그인을 위한 리디렉션 도메인을 커스터마이즈하는 방법은 무엇인가요?", "answer": "Firebase에서는 프로젝트의 고유한 하위 도메인을 프로비저닝합니다. 이 도메인을 OAuth 로그인을 위한 리디렉션 메커니즘으로 사용하려면 Firebase Hosting으로 커스텀 도메인을 설정해야 합니다. 도메인 소유권을 확인한 후, 승인된 도메인 목록에 커스텀 도메인을 추가하고 Yahoo 개발자 콘솔에서 해당 URL을 허용 목록에 추가해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 계정으로 로그인할 때 auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?", "answer": "signInWithPopup을 사용하는 경우 다음 예시와 같은 코드를 사용해 auth/account-exists-with-different-credential 오류를 처리할 수 있습니다.\n\n```javascript\nimport {\n  getAuth,\n  linkWithCredential,\n  signInWithPopup,\n  OAuthProvider,\n} from \"firebase/auth\";\n```\n이 코드를 통해 사용자가 원하는 제공업체에 로그인하기 위해 기존 제공업체에 먼저 로그인한 후 신규 제공업체의 AuthCredential에 연결해야 합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 Yahoo 로그인을 위한 리디렉션 도메인을 커스터마이즈하는 방법은 무엇인가요?", "answer": "하위 도메인이 표시되지 않게 하려면 Firebase Hosting으로 커스텀 도메인을 설정하면 됩니다. Hosting용 도메인 설정 [https://firebase.google.com/docs/hosting/custom-domain?hl=ko]의 1~3단계를 따릅니다. 도메인 소유권을 확인하면 Hosting에서 커스텀 도메인의 SSL 인증서를 프로비저닝합니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 사용자의 인증 상태를 파악하는 권장 방법은 무엇인가요?", "answer": "앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 그러면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 사용자가 여러 인증 제공업체를 통해 로그인할 수 있도록 하려면 어떻게 해야 하나요?", "answer": "인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다. 자세한 내용은 사용자 인증 정보 연결 [https://firebase.google.com/docs/auth/web/account-linking?hl=ko]를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 사용자를 로그아웃시키는 방법은 무엇인가요?", "answer": "사용자를 로그아웃시키려면 signOut을 호출합니다. 다음은 로그아웃을 위한 코드 예시입니다.\n\n```javascript\nimport { getAuth, signOut } from \"firebase/auth\";\n\nfirebase.auth().signOut().then(() => {\n  // 로그아웃 성공\n});\n```", "source": ["https://firebase.google.com/docs/auth/web/yahoo-oauth?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_web_yahoo-oauth_hl=ko.txt"}
{"question": "Firebase에서 커스텀 인증을 구현하려면 어떤 절차를 따라야 하나요?", "answer": "커스텀 인증을 사용하면 개발자가 선택한 시스템으로 사용자를 로그인시키고 백엔드에서 사용자의 Firebase 토큰을 만든 다음 클라이언트의 토큰을 사용하여 Firebase로 인증할 수 있습니다. 자세한 내용은 iOS, Android, 웹, Flutter, Unity 또는 C++용 문서를 참조하세요.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "FirebaseUI 인증을 사용하여 인증을 추가하는 방법은 무엇인가요?", "answer": "앱에 인증을 추가하는 가장 빠르고 쉬운 방법은 삽입형 UI 라이브러리인 FirebaseUI 인증을 사용하는 것입니다. FirebaseUI는 Firebase Authentication에서 지원하는 모든 로그인 방법에 대해 완전한 사용자 과정을 구현합니다. FirebaseUI 인증 문서는 iOS, Android 또는 웹에서 확인할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "Firebase에서 로그인 환경을 완전하게 제어하고 싶다면 어떻게 해야 하나요?", "answer": "앱의 로그인 환경을 더 세밀하게 제어하기 위해 자체 인증 과정을 구현하고 Firebase SDK를 사용하여 Firebase의 인증 서비스와 연동할 수 있습니다. 예를 들어, 자체 이메일 주소와 비밀번호 과정 또는 Google 로그인 과정을 만들고 사용자의 이메일 주소와 비밀번호 또는 Google ID 토큰을 Firebase에 전달하여 사용자를 인증합니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "익명 인증을 사용하면 어떤 기능을 제공할 수 있나요?", "answer": "익명 인증을 사용하여 사용자가 실제로 로그인하기 전에 로그인 상태에서 제공되는 앱 기능을 사용하도록 설정할 수 있습니다. 익명 '로그인'을 사용하면 실제 계정처럼 사용할 수 있는 임시 단일 세션 계정이 생성됩니다. 그런 다음 사용자가 로그인하거나 가입한 후에 이어서 앱을 계속 사용할 수 있도록 임시 계정을 실제 계정에 연결할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "Firebase Authentication에서 지원하는 로그인 방법은 무엇이 있나요?", "answer": "Firebase Authentication은 비밀번호, 제휴 ID 공급업체, 이메일, SMS를 통한 로그인을 지원하는 완전한 백엔드 솔루션입니다. 지원되는 제휴 ID 공급업체로는 Google, Facebook, Apple, Microsoft, Twitter, GitHub 등이 있습니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "FirebaseUI 인증의 UX를 변경하려면 어떻게 해야 하나요?", "answer": "FirebaseUI 인증은 삽입형 솔루션이므로 특정한 UX가 있습니다. 이 UX가 개발자의 니즈에 맞지 않을 경우, 오픈소스인 라이브러리를 가져와 자체 버전을 사용하면 됩니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "Firebase SDK를 사용하여 자체 인증 과정을 구현하는 방법은 무엇인가요?", "answer": "앱의 로그인 환경을 더 세밀하게 제어하기 위해 Firebase SDK를 사용하여 Firebase의 인증 서비스와 연동할 수 있습니다. 예를 들어, 자체 이메일 주소와 비밀번호 과정 또는 Google 로그인 과정을 만들고 사용자의 이메일 주소와 비밀번호 또는 Google ID 토큰을 Firebase에 전달하여 사용자를 인증합니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "익명 인증을 사용하면 어떤 기능을 제공할 수 있나요?", "answer": "익명 인증을 사용하면 사용자가 실제로 로그인하기 전에 로그인 상태에서 제공되는 앱 기능을 사용하도록 설정할 수 있습니다. 익명 '로그인'을 사용하면 실제 계정처럼 사용할 수 있는 임시 단일 세션 계정이 생성됩니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "임시 계정을 실제 계정에 연결하는 방법은 무엇인가요?", "answer": "익명 인증을 사용하여 생성된 임시 계정은 사용자가 로그인하거나 가입한 후에 이어서 앱을 계속 사용할 수 있도록 실제 계정에 연결할 수 있습니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}
{"question": "서버에서 Firebase 서비스에 액세스하려면 어떤 방법을 사용해야 하나요?", "answer": "서버에서 Firebase 서비스에 액세스하기 위해 Firebase Authentication을 사용할 필요가 없습니다. 대신 Admin SDK를 사용하고, Admin SDK를 초기화할 때 서비스 계정 사용자 인증 정보로 인증합니다.", "source": ["https://firebase.google.com/docs/auth/where-to-start?hl=ko"], "tags": "firebase_authentication", "last_verified": "2025-08-19", "source_file": "firebase.google.com_docs_auth_where-to-start_hl=ko.txt"}