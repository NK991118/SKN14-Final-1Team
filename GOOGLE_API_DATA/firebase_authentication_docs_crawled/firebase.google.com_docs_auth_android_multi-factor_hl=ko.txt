Source URL: https://firebase.google.com/docs/auth/android/multi-factor?hl=ko
Title: Android 앱에 다중 인증(MFA) 추가

의견 보내기

Android 앱에 다중 인증(MFA) 추가

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Firebase Authentication with Identity Platform으로 업그레이드했다면 Android 앱에 SMS 다중 인증(MFA)을 추가할 수 있습니다.

다중 인증(MFA)을 통해 앱의 보안이 강화됩니다. 공격자는 종종 비밀번호와 소셜 미디어 계정을 유출시키지만 문자 메시지를 가로채는 것은 더 어렵습니다.

시작하기 전에
참고: 여러 테넌트 [https://cloud.google.com/identity-platform/docs/multi-tenancy?hl=ko]에서 다중 인증(MFA) 사용은 Android에서 지원되지 않습니다.
다중 인증(MFA)을 지원하는 제공업체를 하나 이상 사용 설정합니다.
전화 인증, 익명 인증, Apple Game Center를 제외한 모든 제공업체는 MFA를 지원합니다.
앱이 사용자 이메일을 확인하고 있는지 확인합니다. MFA를 사용하려면 이메일 인증이 필요합니다.
이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일에 서비스를 등록한 후 두 번째 단계를 추가하여 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.
Firebase Console에 앱의 SHA-1 해시를 등록합니다(변경사항은 자동으로 Google Cloud Firebase에 적용됩니다).

클라이언트 인증 [https://developers.google.com/android/guides/client-auth?hl=ko]의 단계에 따라 앱의 SHA-1 해시를 가져옵니다.
Firebase Console [https://console.firebase.google.com/?hl=ko]을 엽니다.
프로젝트 설정으로 이동합니다.
내 앱에서 Android 아이콘을 클릭합니다.
안내에 따라 SHA-1 해시를 추가합니다.

다중 인증(MFA) 사용 설정

Firebase Console의 인증 > 로그인 방법 [https://console.firebase.google.com/project/_/authentication/providers?hl=ko] 페이지를 엽니다.
고급 섹션에서 SMS 다중 인증(MFA)을 사용 설정합니다.

앱을 테스트할 전화번호도 입력해야 합니다.
선택사항이지만 개발 중 제한이 발생하지 않도록 테스트 전화번호를 등록하는 것이 좋습니다.
아직 앱 도메인을 승인하지 않았다면 Firebase Console의 인증 > 설정 [https://console.firebase.google.com/project/_/authentication/settings?hl=ko] 페이지에서 허용 목록에 추가합니다.

등록 패턴 선택

앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 일반적인 패턴은 다음과 같습니다.

등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.
등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 다중 인증(MFA)을 권고하지만 필수이지는 않은 앱은 이 방법을 사용하는 것이 좋습니다.
가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.
사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.

두 번째 단계 등록

사용자의 새로운 두 번째 단계를 등록하려면 다음 단계를 따르세요.

사용자를 다시 인증합니다.
사용자에게 전화번호를 입력하도록 요청합니다.
참고: Google은 모든 Google 서비스의 스팸 및 악용 방지를 위해 전화번호를 저장하고 사용합니다. 전화번호를 Firebase로 보내기 전에 사용자에게 적절한 동의를 얻어야 합니다.
사용자를 위한 다중 세션을 가져옵니다.

Kotlin user.multiFactor.session.addOnCompleteListener { task ->
if (task.isSuccessful) {
val multiFactorSession: MultiFactorSession? = task.result
Java user.getMultiFactor().getSession()
.addOnCompleteListener(
new OnCompleteListener<MultiFactorSession>() {
@Override
public void onComplete(@NonNull Task<MultiFactorSession> task) {
if (task.isSuccessful()) {
MultiFactorSession multiFactorSession = task.getResult();
verificationId: String, forceResendingToken: ForceResendingToken
) {
this@MainActivity.forceResendingToken = forceResendingToken
Java OnVerificationStateChangedCallbacks callbacks =
new OnVerificationStateChangedCallbacks() {
@Override
public void onVerificationCompleted(PhoneAuthCredential credential) {
String verificationId, PhoneAuthProvider.ForceResendingToken token) {
this.forceResendingToken = token;
Kotlin val phoneAuthOptions = PhoneAuthOptions.newBuilder()
.setPhoneNumber(phoneNumber)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(MultiFactorSession)
.setCallbacks(callbacks)
.build()

Java PhoneAuthOptions phoneAuthOptions =
PhoneAuthOptions.newBuilder()
.setPhoneNumber(phoneNumber)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(multiFactorSession)
.setCallbacks(callbacks)
.build();

기본적으로 즉각적인 인증이 사용 설정되어 있습니다. 사용 중지하려면 requireSmsValidation(true)에 대한 호출을 추가합니다.
사용자 전화로 인증 코드 보내기

Kotlin PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions)

Java PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions);

필수 사항은 아니지만, 사용자에게 SMS 메시지가 전송되고 표준 요금이 적용된다는 점을 미리 알리는 것이 좋습니다.
SMS 코드가 전송되면 사용자에게 코드를 확인하도록 요청합니다.

Kotlin // Ask user for the verification code.
val credential = PhoneAuthProvider.getCredential(verificationId, verificationCode)

Java // Ask user for the verification code.
PhoneAuthCredential credential
= PhoneAuthProvider.getCredential(verificationId, verificationCode);

PhoneAuthCredential로 MultiFactorAssertion 객체를 초기화합니다.

Kotlin val multiFactorAssertion
= PhoneMultiFactorGenerator.getAssertion(credential)

Java MultiFactorAssertion multiFactorAssertion
= PhoneMultiFactorGenerator.getAssertion(credential);

등록을 완료합니다. 선택사항으로 두 번째 단계의 표시 이름을 지정할 수 있습니다. 인증 과정에서 전화번호가 마스킹되므로(예: +1******1234) 두 번째 단계가 여러 개인 사용자에게 유용합니다.

Kotlin // Complete enrollment. This will update the underlying tokens
FirebaseAuth.getInstance()
.currentUser
?.multiFactor
?.enroll(multiFactorAssertion, "My personal phone number")
?.addOnCompleteListener {
Java // Complete enrollment. This will update the underlying tokens
FirebaseAuth.getInstance()
.getCurrentUser()
.getMultiFactor()
.enroll(multiFactorAssertion, "My personal phone number")
.addOnCompleteListener(
new OnCompleteListener<Void>() {
@Override
public void onComplete(@NonNull Task<Void> task) {
Kotlin val multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential)
user.multiFactor.session
val phoneAuthOptions = PhoneAuthOptions.newBuilder()
.setPhoneNumber(phoneNumber)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(multiFactorSession)
.setCallbacks(callbacks)
.build()
PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions)

val multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential)

FirebaseAuth.getInstance()
.currentUser
?.multiFactor
?.enroll(multiFactorAssertion, "My personal phone number")
?.addOnCompleteListener {
Java MultiFactorAssertion multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential);
user.getMultiFactor().getSession()
.addOnCompleteListener(
new OnCompleteListener<MultiFactorSession>() {
@Override
public void onComplete(@NonNull Task<MultiFactorSession> task) {
if (task.isSuccessful()) {
MultiFactorSession multiFactorSession = task.getResult();
PhoneAuthOptions phoneAuthOptions =
PhoneAuthOptions.newBuilder()
.setPhoneNumber(phoneNumber)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(multiFactorSession)
.setCallbacks(callbacks)
.build();
PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions);
PhoneAuthCredential credential =
PhoneAuthProvider.getCredential(verificationId, verificationCode);

MultiFactorAssertion multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential);
FirebaseAuth.getInstance()
.getCurrentUser()
.getMultiFactor()
.enroll(multiFactorAssertion, "My personal phone number")
.addOnCompleteListener(
new OnCompleteListener<Void>() {
@Override
public void onComplete(@NonNull Task<Void> task) {
Kotlin FirebaseAuth.getInstance()
.signInWithEmailAndPassword(email, password)
.addOnCompleteListener(
OnCompleteListener { task ->
if (task.isSuccessful) {
(task.exception as FirebaseAuthMultiFactorException).resolver
Java FirebaseAuth.getInstance()
.signInWithEmailAndPassword(email, password)
.addOnCompleteListener(
new OnCompleteListener<AuthResult>() {
@Override
public void onComplete(@NonNull Task<AuthResult> task) {
if (task.isSuccessful()) {
MultiFactorResolver multiFactorResolver = task.getException().getResolver();
Kotlin // Ask user which second factor to use.
=== PhoneMultiFactorGenerator.FACTOR_ID
) {
multiFactorResolver.hints[selectedIndex] as PhoneMultiFactorInfo
Java // Ask user which second factor to use.
.get(selectedIndex)
.getFactorId()
.equals( PhoneMultiFactorGenerator.FACTOR_ID ) ) {
MultiFactorInfo selectedHint =
multiFactorResolver.getHints().get(selectedIndex);
Kotlin val phoneAuthOptions = PhoneAuthOptions.newBuilder()
.setMultiFactorHint(selectedHint)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(multiFactorResolver.session)
.setCallbacks(callbacks) // Optionally disable instant verification.
Java PhoneAuthOptions phoneAuthOptions =
PhoneAuthOptions.newBuilder()
.setMultiFactorHint(selectedHint)
.setTimeout(30L, TimeUnit.SECONDS)
.setMultiFactorSession(multiFactorResolver.getSession())
.setCallbacks(callbacks)

사용자 전화로 인증 코드 보내기

Kotlin // Send SMS verification code
PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions)

Java // Send SMS verification code
PhoneAuthProvider.verifyPhoneNumber(phoneAuthOptions);

SMS 코드가 전송되면 사용자에게 코드를 확인하도록 요청합니다.

Kotlin // Ask user for the verification code. Then, pass it to getCredential:
val credential =
PhoneAuthProvider.getCredential(verificationId, verificationCode)

Java // Ask user for the verification code. Then, pass it to getCredential:
PhoneAuthCredential credential
= PhoneAuthProvider.getCredential(verificationId, verificationCode);

PhoneAuthCredential로 MultiFactorAssertion 객체를 초기화합니다.

Kotlin val multiFactorAssertion = PhoneMultiFactorGenerator.getAssertion(credential)

Java MultiFactorAssertion multiFactorAssertion
= PhoneMultiFactorGenerator.getAssertion(credential);

resolver.resolveSignIn()을 호출하여 2차 인증을 완료합니다.
그런 다음 표준 공급업체별 데이터 및 인증 사용자 인증 정보가 포함된 원래 로그인 결과에 액세스할 수 있습니다.

Kotlin multiFactorResolver
.resolveSignIn(multiFactorAssertion)
Java multiFactorResolver
.resolveSignIn(multiFactorAssertion)
.addOnCompleteListener(
new OnCompleteListener<AuthResult>() {
@Override
public void onComplete(@NonNull Task<AuthResult> task) {
if (task.isSuccessful()) {
AuthResult authResult = task.getResult();
Kotlin FirebaseAuth.getInstance()
.signInWithEmailAndPassword(email, password)
(task.exception as FirebaseAuthMultiFactorException).resolver

multiFactorResolver.hints[selectedIndex] as PhoneMultiFactorInfo

PhoneAuthProvider.verifyPhoneNumber(
PhoneAuthOptions.newBuilder()
.setActivity(this)
.setMultiFactorSession(multiFactorResolver.session)
.setMultiFactorHint(selectedHint)
.setCallbacks(generateCallbacks())
.setTimeout(30L, TimeUnit.SECONDS)
.build()

PhoneAuthProvider.getCredential(verificationId, verificationCode)

PhoneMultiFactorGenerator.getAssertion(credential)

.resolveSignIn(multiFactorAssertion)
Java FirebaseAuth.getInstance()
.signInWithEmailAndPassword(email, password)
.addOnCompleteListener(
new OnCompleteListener<AuthResult>() {
@Override
public void onComplete(@NonNull Task<AuthResult> task) {
if (task.isSuccessful()) {
FirebaseAuthMultiFactorException e =
(FirebaseAuthMultiFactorException) task.getException();

MultiFactorResolver multiFactorResolver = e.getResolver();

MultiFactorInfo selectedHint =
multiFactorResolver.getHints().get(selectedIndex);

PhoneAuthProvider.verifyPhoneNumber(
PhoneAuthOptions.newBuilder()
.setActivity(this)
.setMultiFactorSession(multiFactorResolver.getSession())
.setMultiFactorHint(selectedHint)
.setCallbacks(generateCallbacks())
.setTimeout(30L, TimeUnit.SECONDS)
.build());

PhoneAuthCredential credential =
PhoneAuthProvider.getCredential(verificationId, verificationCode);

MultiFactorAssertion multiFactorAssertion =
PhoneMultiFactorGenerator.getAssertion(credential);

.resolveSignIn(multiFactorAssertion)
.addOnCompleteListener(
new OnCompleteListener<AuthResult>() {
@Override
public void onComplete(@NonNull Task<AuthResult> task) {
if (task.isSuccessful()) {