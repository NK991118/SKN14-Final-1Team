Source URL: https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko
Title: 서비스 워커로 세션 관리
bookmark_border

의견 보내기

서비스 워커로 세션 관리

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용개요 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#overview]서비스 워커 변경 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#service_worker_changes]클라이언트 측 변경 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#client_side_changes]서버 측 변경 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#server_side_changes]결론 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#conclusion]유용한 링크 [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#useful_links]

Firebase Auth는 서비스 워커에서 세션 관리를 위해 Firebase ID 토큰을 감지하고 전달할 수 있는 기능을 지원합니다. 이는 다음과 같은 이점을 제공합니다.

추가 작업 없이 서버의 모든 HTTP 요청에 ID 토큰을 전달할 수 있습니다.
추가 왕복 또는 지연 없이 ID 토큰을 새로고침할 수 있습니다.
백엔드 및 프런트엔드 동기화 세션을 지원합니다. 실시간 데이터베이스, Firestore 등의 Firebase 서비스와 SQL 데이터베이스 등 일부 외부 서버 측 리소스에 액세스해야 하는 애플리케이션에서 이 솔루션을 사용할 수 있습니다.
또한 서비스 워커, 웹 워커 또는 공유 워커로 동일한 세션에 액세스할 수 있습니다.
페이지마다 Firebase 인증 소스 코드를 포함할 필요가 없습니다(지연 시간 감소). 로드 및 초기화한 서비스 워커로 백그라운드에서 모든 클라이언트의 세션 관리를 처리합니다.

개요

Firebase 인증은 클라이언트 측 실행에 최적화되어 있습니다. 토큰은 웹 스토리지에 저장됩니다. 이에 따라 실시간 데이터베이스, Cloud Firestore, Cloud Storage 등 다른 Firebase 서비스와 쉽게 통합할 수 있습니다. 서버측의 세션 관리를 위해서는 ID 토큰을 검색해 서버에 전달해야 합니다.

--- 탭: Web [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#web-modular-api] ---
import { getAuth, getIdToken } from "firebase/auth";

.then((idToken) => {
.then((idToken) => {

Firebase 인증은 보다 전통적인 쿠키 기반의 세션 관리 솔루션 [https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ko]을 제공합니다. 이 솔루션은 서버 측 httpOnly 쿠키 기반 애플리케이션에 적합하지만 클라이언트 토큰으로 이 솔루션을 관리하기는 더 어렵습니다. 특히, 다른 클라이언트 기반 Firebase 서비스도 사용해야 할 경우 서버 측 토큰이 동기화되지 않을 수 있습니다.

하지만 서비스 워커를 사용하면 사용자 세션의 서버 측 사용 정보를 관리할 수 있습니다. 이는 다음과 같은 점에서 효과적입니다.

서비스 워커는 현재 Firebase 인증 상태에 액세스할 수 있습니다. 현재 사용자 ID 토큰은 서비스 워커에서 검색할 수 있습니다. 토큰이 만료되면 클라이언트 SDK에서 새로고침하고 새 토큰을 반환합니다.
서비스 워커가 가져오기 요청을 가로채 수정할 수 있습니다.

서비스 워커 변경

서비스 워커는 인증 라이브러리를 포함하고 사용자가 로그인한 경우 현재 ID 토큰을 가져올 수 있어야 합니다.

--- 탭: Web [https://firebase.google.com/docs/auth/web/service-worker-sessions?hl=ko#web-modular-api] ---
import { initializeApp } from "firebase/app";
import { getAuth, onAuthStateChanged, getIdToken } from "firebase/auth";

/**
* Returns a promise that resolves with an ID token if available.
* @return {!Promise<?string>} The promise that resolves with an ID token if
*     available. Otherwise, the promise resolves with null.
*/
if (user) {
getIdToken(user).then((idToken) => {
resolve(idToken);

/**
* Returns a promise that resolves with an ID token if available.
* @return {!Promise<?string>} The promise that resolves with an ID token if
*     available. Otherwise, the promise resolves with null.
*/
if (user) {
user.getIdToken().then((idToken) => {
resolve(idToken);
.then((json) => {
return JSON.stringify(json);
(self.location.protocol == 'https:' ||
self.location.hostname == 'localhost') &&
idToken) {
processRequestPromise = getBodyContent(req).then((body) => {
try {
req = new Request(req.url, {
method: req.method,
headers: headers,
mode: 'same-origin',
credentials: req.credentials,
cache: req.cache,
redirect: req.redirect,
referrer: req.referrer,
body,
.then((json) => {
return JSON.stringify(json);
(self.location.protocol == 'https:' ||
self.location.hostname == 'localhost') &&
idToken) {
processRequestPromise = getBodyContent(req).then((body) => {
try {
req = new Request(req.url, {
method: req.method,
headers: headers,
mode: 'same-origin',
credentials: req.credentials,
cache: req.cache,
redirect: req.redirect,
referrer: req.referrer,
body,

.then((result) => {
.then((result) => {

function getIdToken(req) {
import { getAuth } from 'firebase/auth';
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';

export default function MyServerComponent() {