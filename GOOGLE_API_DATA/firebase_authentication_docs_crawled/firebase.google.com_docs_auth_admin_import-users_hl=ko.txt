Source URL: https://firebase.google.com/docs/auth/admin/import-users?hl=ko
Title: 사용자 가져오기
bookmark_border

의견 보내기

사용자 가져오기

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용사용 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#usage]Firebase scrypt 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_firebase_scrypt_hashed_passwords]표준 scrypt 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_standard_scrypt_hashed_passwords]HMAC 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_hmac_hashed_passwords]MD5, SHA, PBKDF 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_md5_sha_and_pbkdf_hashed_passwords]BCRYPT 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_bcrypt_hashed_passwords]Argon2 해시 비밀번호를 사용한 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_with_argon2_hashed_passwords]비밀번호 없이 사용자 가져오기 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#import_users_without_passwords]

Firebase Admin SDK에서 제공하는 Auth.importUsers() [https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth.baseauth?hl=ko#baseauthimportusers] API를 활용하면 승격된 권한으로 Firebase Authentication에 사용자를 일괄 가져올 수 있습니다. Firebase CLI [https://firebase.google.com/docs/cli/auth?hl=ko#authimport]에서도 이 기능을 사용할 수 있지만, Admin SDK를 사용하면 임시 CSV 또는 JSON 파일을 만들지 않고도 프로그래매틱 방식으로 외부 인증 시스템 또는 다른 Firebase 프로젝트에서 기존 사용자를 업로드할 수 있습니다.

사용자 가져오기 API의 이점은 다음과 같습니다.

다른 비밀번호 해싱 알고리즘을 사용하는 외부 인증 시스템에서 사용자를 이전할 수 있습니다.
다른 Firebase 프로젝트에서 사용자를 이전할 수 있습니다.
빠르고 효율적인 일괄 가져오기 작업에 맞춰 최적화되어 있습니다. 이 작업에서는 uid, email, phoneNumber 또는 다른 식별자의 중복 확인 없이 사용자를 처리합니다.
기존 OAuth 사용자를 마이그레이션하거나 새로운 OAuth 사용자(Google, Facebook 등)를 만들 수 있습니다.
맞춤 클레임을 통해 직접 사용자를 일괄적으로 가져올 수 있습니다.

사용

API 호출 한 번으로 최대 1,000명의 사용자를 가져올 수 있습니다. 참고로 이 작업은 속도에 맞춰 최적화되어 있으므로 uid, email, phoneNumber 및 기타 고유 식별자의 중복을 확인하지 않습니다. 기존 uid와 충돌하는 사용자를 가져오면 기존 사용자가 바뀝니다. 다른 필드가 중복된(예: email) 사용자를 가져오면 같은 값이 있는 사용자가 추가됩니다. 따라서 이 API를 사용할 때는 고유한 필드가 중복되지 않는지 확인해야 합니다.
--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
```

--- 탭: Java [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#java] ---
```
List<ImportUserRecord> users = new ArrayList<>();
users.add(ImportUserRecord.builder()
.setUid("uid1")
.setEmail("user1@example.com")
.setPasswordHash("passwordHash1".getBytes())
.setPasswordSalt("salt1".getBytes())
.build());
users.add(ImportUserRecord.builder()
.setUid("uid2")
.setEmail("user2@example.com")
.setPasswordHash("passwordHash2".getBytes())
.setPasswordSalt("salt2".getBytes())
.build());
```

--- 탭: Python [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#python] ---
```
# Up to 1000 users can be imported at once.
users = [
auth.ImportUserRecord(
uid='uid1',
email='user1@example.com',
password_hash=b'password_hash_1',
password_salt=b'salt1'
),
auth.ImportUserRecord(
uid='uid2',
email='user2@example.com',
password_hash=b'password_hash_2',
password_salt=b'salt2'
),
]
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
UID("uid1").
Email("user1@example.com").
PasswordHash([]byte("passwordHash1")).
PasswordSalt([]byte("salt1")))
users = append(users, (&auth.UserToImport{}).
UID("uid2").
Email("user2@example.com").
PasswordHash([]byte("passwordHash2")).
PasswordSalt([]byte("salt2")))
```

--- 탭: tabpanel-c ---
```
Uid = "uid1",
Email = "user1@example.com",
PasswordHash = Encoding.ASCII.GetBytes("passwordHash1"),
PasswordSalt = Encoding.ASCII.GetBytes("salt1"),
Uid = "uid2",
Email = "user2@example.com",
PasswordHash = Encoding.ASCII.GetBytes("passwordHash2"),
PasswordSalt = Encoding.ASCII.GetBytes("salt2"),
Firebase Authentication에서는 사용자별 오류가 발생해도 제공된 전체 사용자 목록의 업로드를 시도합니다. 이 작업으로 가져오기 성공 및 실패 요약을 포함한 결과가 반환됩니다. 오류 세부정보는 사용자 가져오기 실패 작업별로 반환됩니다.
--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(userImportRecords, {
hash: {
algorithm: 'HMAC_SHA256',
key: Buffer.from('secretKey'),
UserImportOptions options = UserImportOptions.withHash(
HmacSha256.builder()
.setKey("secretKey".getBytes())
.build());
try {
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
System.out.println("Successfully imported " + result.getSuccessCount() + " users");
System.out.println("Failed to import " + result.getFailureCount() + " users");
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user at index: " + indexedError.getIndex()
+ " due to error: " + indexedError.getReason());
try:
result = auth.import_users(users, hash_alg=hash_alg)
print(
f'Successfully imported {result.success_count} users. Failed to import '
f'{result.failure_count} users.')
for err in result.errors:
print(f'Failed to import {users[err.index].uid} due to {err.reason}')
except exceptions.FirebaseError:
# Some unrecoverable error occurred that prevented the operation from running.
pass
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
client, err := app.Auth(ctx)
if err != nil {
log.Fatalln("Error initializing Auth client", err)
log.Printf("Failed to import %d users\n", result.FailureCount)
for _, e := range result.Errors {
log.Printf("Failed to import user at index: %d due to error: %s\n", e.Index, e.Reason)
Hash = new HmacSha256()
Key = Encoding.ASCII.GetBytes("secretKey"),
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
Firebase scrypt 해시 비밀번호를 사용한 사용자 가져오기

기본적으로 Firebase는 scrypt 해싱 알고리즘의 수정된 Firebase 버전 [https://github.com/firebase/scrypt]을 사용하여 비밀번호를 저장합니다. 수정된 scrypt로 해싱된 비밀번호를 가져오는 것은 다른 기존 Firebase 프로젝트에서 사용자를 마이그레이션하는 데 유용합니다. 이 경우 원래 프로젝트의 내부 매개변수를 결정해야 합니다.

Firebase에서는 Firebase 프로젝트마다 고유의 비밀번호 해시 매개변수를 생성합니다.
이 매개변수에 액세스하려면 Firebase 콘솔의 사용자 탭 [https://console.firebase.google.com/project/_/authentication/users?hl=ko]으로 이동하고 사용자 테이블 목록의 오른쪽 상단에 있는 드롭다운에서 비밀번호 해시 매개변수를 선택합니다.

이 알고리즘의 해시 옵션을 구성하는 데 필요한 매개변수는 다음과 같습니다.

key: 일반적으로 base64로 인코딩되는 서명자 키입니다.
saltSeparator: 일반적으로 base64로 인코딩되는 솔트 구분자입니다(선택사항).
rounds: 비밀번호를 해시하는 데 사용되는 라운드 수입니다.
memoryCost: 이 알고리즘에 필요한 메모리 비용입니다.

--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(
[
uid: 'some-uid',
email: 'user@example.com',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash(BaseEncoding.base64().decode("password-hash"))
.setPasswordSalt(BaseEncoding.base64().decode("salt"))
.build());
UserImportOptions options = UserImportOptions.withHash(
Scrypt.builder()
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=base64.urlsafe_b64decode('password_hash'),
password_salt=base64.urlsafe_b64decode('salt')
),
]

# All the parameters below can be obtained from the Firebase Console's "Users"
# section. Base64 encoded parameters must be decoded into raw bytes.
hash_alg = auth.UserImportHash.scrypt(
key=base64.b64decode('base64_secret'),
salt_separator=base64.b64decode('base64_salt_separator'),
rounds=8,
memory_cost=14
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
b64URLdecode := func(s string) []byte {
b, err := base64.URLEncoding.DecodeString(s)
if err != nil {
log.Fatalln("Failed to decode string", err)
UID("some-uid").
Email("user@example.com").
PasswordHash(b64URLdecode("password-hash")).
PasswordSalt(b64URLdecode("salt")),
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
Hash = new Scrypt()
Key = Encoding.ASCII.GetBytes("base64-secret"),
SaltSeparator = Encoding.ASCII.GetBytes("base64-salt-separator"),
Rounds = 8,
MemoryCost = 14,
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
Firebase Authentication에서는 표준 scrypt 알고리즘은 물론 위의 수정된 버전도 지원합니다. 표준 scrypt 알고리즘의 경우 다음과 같은 해싱 매개변수가 필요합니다.

memoryCost: 해싱 알고리즘의 CPU/메모리 비용입니다.
parallelization: 해싱 알고리즘의 동시 로드입니다.
blockSize: 해싱 알고리즘의 블록 크기(일반적으로 8)입니다.
derivedKeyLength: 해싱 알고리즘의 파생 키 길이입니다.

--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(
[
uid: 'some-uid',
email: 'user@example.com',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
StandardScrypt.builder()
.setMemoryCost(1024)
.setParallelization(16)
.setBlockSize(8)
.setDerivedKeyLength(64)
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.standard_scrypt(
memory_cost=1024, parallelization=16, block_size=8, derived_key_length=64)
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
Hash = new StandardScrypt()
MemoryCost = 1024,
Parallelization = 16,
BlockSize = 8,
DerivedKeyLength = 64,
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)

HMAC 해싱 알고리즘에는 HMAC_MD5, HMAC_SHA1, HMAC_SHA256, HMAC_SHA512가 포함됩니다. 이 해싱 알고리즘의 경우 해시 서명자 키를 제공해야 합니다.
--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(
[
uid: 'some-uid',
email: 'user@example.com',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
HmacSha256.builder()
.setKey("secret".getBytes())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.hmac_sha256(key=b'secret')
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
Hash = new HmacSha256()
Key = Encoding.ASCII.GetBytes("secret"),
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)

MD5, SHA, PBKDF 해싱 알고리즘에는 MD5, SHA1, SHA256, SHA512, PBKDF_SHA1, PBKDF2_SHA256이 포함됩니다. 이러한 해싱 알고리즘의 경우 비밀번호를 해시하는 데 사용되는 라운드 수(MD5의 경우 0~8192, SHA1, SHA256, SHA512의 경우 1~8192, PBKDF_SHA1 및 PBKDF2_SHA256의 경우 0~120000)를 제공해야 합니다.
--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(
[
uid: 'some-uid',
email: 'user@example.com',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
Pbkdf2Sha256.builder()
.setRounds(100000)
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.pbkdf2_sha256(rounds=100000)
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
Hash = new Pbkdf2Sha256()
Rounds = 100000,
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)

BCRYPT 해시 비밀번호의 경우 추가 해시 매개변수 및 사용자별 비밀번호 솔트가 필요 없습니다.
--- 탭: Node.js [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#node.js] ---
```
getAuth()
.importUsers(
[
uid: 'some-uid',
email: 'user@example.com',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(Bcrypt.getInstance());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.bcrypt()
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
Hash = new Bcrypt(),
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
Argon2 해시 비밀번호를 사용한 사용자 가져오기

Argon2 해시 객체를 구성하여 Argon2 해시 비밀번호가 있는 사용자 레코드를 가져올 수 있습니다. 이 기능은 현재 Admin 자바 SDK에서만 지원됩니다.

이 알고리즘의 해시 옵션을 구성하는 데 필요한 매개변수는 다음과 같습니다.

hashLengthBytes: 원하는 해시 길이(바이트)이며 정수로 제공됩니다.
hashType: 사용할 Argon2 변형(ARGON2_D, ARGON2_ID, ARGON2_I)입니다.
parallelism: 동시 로드 정도이며 정수로 제공됩니다. 1 이상 16 이하여야 합니다.
iterations: 수행할 반복 횟수이며 정수로 제공됩니다. 1 이상 16 이하여야 합니다.
memoryCostKib: 이 알고리즘에 필요한 메모리 비용(키비바이트)이며 32,768 미만이어야 합니다.
version: Argon2 알고리즘의 버전(VERSION_10 또는 VERSION_13)입니다. 선택사항이며 지정하지 않을 경우 기본값은 VERSION_13입니다.
associatedData: 바이트 배열로 제공되는 추가 연결 데이터로, 추가 보안 레이어를 제공하기 위해 해시 값에 추가됩니다. 선택사항이며 이 데이터는 API로 전송되기 전에 base64로 인코딩됩니다.

--- 탭: 자바 [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#%EC%9E%90%EB%B0%94] ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
Argon2.builder()
.setHashLengthBytes(512)
.setHashType(Argon2HashType.ARGON2_ID)
.setParallelism(8)
.setIterations(16)
.setMemoryCostKib(2048)
.setVersion(Argon2Version.VERSION_10)
.setAssociatedData("associated-data".getBytes())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
.importUsers([
uid: 'some-uid',
displayName: 'John Doe',
email: 'johndoe@gmail.com',
photoURL: 'http://www.example.com/12345678/photo.png',
emailVerified: true,
phoneNumber: '+11234567890',
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setDisplayName("John Doe")
.setEmail("johndoe@gmail.com")
.setPhotoUrl("http://www.example.com/12345678/photo.png")
.setEmailVerified(true)
.setPhoneNumber("+11234567890")
.putCustomClaim("admin", true) // set this user as admin
.addUserProvider(UserProvider.builder() // user with Google provider
.setUid("google-uid")
.setEmail("johndoe@gmail.com")
.setDisplayName("John Doe")
.setPhotoUrl("http://www.example.com/12345678/photo.png")
.setProviderId("google.com")
.build())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
System.out.println("Error importing users: " + e.getMessage());
auth.ImportUserRecord(
uid='some-uid',
display_name='John Doe',
email='johndoe@gmail.com',
photo_url='http://www.example.com/12345678/photo.png',
email_verified=True,
phone_number='+11234567890',
custom_claims={'admin': True}, # set this user as admin
provider_data=[ # user with Google provider
auth.UserProvider(
uid='google-uid',
email='johndoe@gmail.com',
display_name='John Doe',
photo_url='http://www.example.com/12345678/photo.png',
provider_id='google.com'
],
),
]
try:
result = auth.import_users(users)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go [https://firebase.google.com/docs/auth/admin/import-users?hl=ko#go] ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
DisplayName("John Doe").
Email("johndoe@gmail.com").
PhotoURL("http://www.example.com/12345678/photo.png").
EmailVerified(true).
PhoneNumber("+11234567890").
CustomClaims(map[string]interface{}{"admin": true}). // set this user as admin
ProviderData([]*auth.UserProvider{                   // user with Google provider
UID:         "google-uid",
Email:       "johndoe@gmail.com",
DisplayName: "John Doe",
PhotoURL:    "http://www.example.com/12345678/photo.png",
ProviderID:  "google.com",
Uid = "some-uid",
DisplayName = "John Doe",
Email = "johndoe@gmail.com",
PhotoUrl = "http://www.example.com/12345678/photo.png",
EmailVerified = true,
PhoneNumber = "+11234567890",
CustomClaims = new Dictionary<string, object>()
UserProviders = new List<UserProvider>
new UserProvider() // user with Google provider
Uid = "google-uid",
Email = "johndoe@gmail.com",
DisplayName = "John Doe",
PhotoUrl = "http://www.example.com/12345678/photo.png",
ProviderId = "google.com",
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users);
foreach (ErrorInfo indexedError in result.Errors)