Source URL: https://firebase.google.com/docs/auth/admin/import-users?hl=ko
Title: 사용자 가져오기
bookmark_border

의견 보내기

사용자 가져오기

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용사용Firebase scrypt 해시 비밀번호를 사용한 사용자 가져오기표준 scrypt 해시 비밀번호를 사용한 사용자 가져오기HMAC 해시 비밀번호를 사용한 사용자 가져오기MD5, SHA, PBKDF 해시 비밀번호를 사용한 사용자 가져오기BCRYPT 해시 비밀번호를 사용한 사용자 가져오기Argon2 해시 비밀번호를 사용한 사용자 가져오기비밀번호 없이 사용자 가져오기

Firebase Admin SDK에서 제공하는 Auth.importUsers() [https://firebase.google.com/docs/reference/admin/node/firebase-admin.auth.baseauth?hl=ko#baseauthimportusers] API를 활용하면 승격된 권한으로 Firebase Authentication에 사용자를 일괄 가져올 수 있습니다. Firebase CLI [https://firebase.google.com/docs/cli/auth?hl=ko#authimport]에서도 이 기능을 사용할 수 있지만, Admin SDK를 사용하면 임시 CSV 또는 JSON 파일을 만들지 않고도 프로그래매틱 방식으로 외부 인증 시스템 또는 다른 Firebase 프로젝트에서 기존 사용자를 업로드할 수 있습니다.

사용자 가져오기 API의 이점은 다음과 같습니다.

다른 비밀번호 해싱 알고리즘을 사용하는 외부 인증 시스템에서 사용자를 이전할 수 있습니다.
다른 Firebase 프로젝트에서 사용자를 이전할 수 있습니다.
빠르고 효율적인 일괄 가져오기 작업에 맞춰 최적화되어 있습니다. 이 작업에서는 uid, email, phoneNumber 또는 다른 식별자의 중복 확인 없이 사용자를 처리합니다.
기존 OAuth 사용자를 마이그레이션하거나 새로운 OAuth 사용자(Google, Facebook 등)를 만들 수 있습니다.
맞춤 클레임을 통해 직접 사용자를 일괄적으로 가져올 수 있습니다.

사용

API 호출 한 번으로 최대 1,000명의 사용자를 가져올 수 있습니다. 참고로 이 작업은 속도에 맞춰 최적화되어 있으므로 uid, email, phoneNumber 및 기타 고유 식별자의 중복을 확인하지 않습니다. 기존 uid와 충돌하는 사용자를 가져오면 기존 사용자가 바뀝니다. 다른 필드가 중복된(예: email) 사용자를 가져오면 같은 값이 있는 사용자가 추가됩니다. 따라서 이 API를 사용할 때는 고유한 필드가 중복되지 않는지 확인해야 합니다.

--- 탭: Node.js ---
```
// Up to 1000 users can be imported at once.
const userImportRecords = [
{
uid: 'uid1',
email: 'user1@example.com',
passwordHash: Buffer.from('passwordHash1'),
passwordSalt: Buffer.from('salt1'),
},
{
uid: 'uid2',
email: 'user2@example.com',
passwordHash: Buffer.from('passwordHash2'),
passwordSalt: Buffer.from('salt2'),
},
//...
];
```

--- 탭: 자바 ---
```
// Up to 1000 users can be imported at once.
List<ImportUserRecord> users = new ArrayList<>();
users.add(ImportUserRecord.builder()
.setUid("uid1")
.setEmail("user1@example.com")
.setPasswordHash("passwordHash1".getBytes())
.setPasswordSalt("salt1".getBytes())
.build());
users.add(ImportUserRecord.builder()
.setUid("uid2")
.setEmail("user2@example.com")
.setPasswordHash("passwordHash2".getBytes())
.setPasswordSalt("salt2".getBytes())
.build());
```

--- 탭: Python ---
```
# Up to 1000 users can be imported at once.
users = [
auth.ImportUserRecord(
uid='uid1',
email='user1@example.com',
password_hash=b'password_hash_1',
password_salt=b'salt1'
),
auth.ImportUserRecord(
uid='uid2',
email='user2@example.com',
password_hash=b'password_hash_2',
password_salt=b'salt2'
),
]
```

--- 탭: Go ---
```
// Up to 1000 users can be imported at once.
var users []*auth.UserToImport
users = append(users, (&auth.UserToImport{}).
UID("uid1").
Email("user1@example.com").
PasswordHash([]byte("passwordHash1")).
PasswordSalt([]byte("salt1")))
users = append(users, (&auth.UserToImport{}).
UID("uid2").
Email("user2@example.com").
PasswordHash([]byte("passwordHash2")).
PasswordSalt([]byte("salt2")))
```

--- 탭: C# ---
```
//  Up to 1000 users can be imported at once.
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "uid1",
Email = "user1@example.com",
PasswordHash = Encoding.ASCII.GetBytes("passwordHash1"),
PasswordSalt = Encoding.ASCII.GetBytes("salt1"),
},
new ImportUserRecordArgs()
{
Uid = "uid2",
Email = "user2@example.com",
PasswordHash = Encoding.ASCII.GetBytes("passwordHash2"),
PasswordSalt = Encoding.ASCII.GetBytes("salt2"),
},
};
```
이 예시에서는 해싱 옵션이 지정되어 있어 이후 사용자가 Firebase Authentication으로 로그인하려고 하면 Firebase에서 안전하게 사용자를 인증할 수 있습니다.
성공적으로 로그인하면 Firebase에서 내부 Firebase 해싱 알고리즘으로 사용자의 비밀번호를 다시 해싱 처리합니다. 아래에서 알고리즘에 따른 필수 필드에 대해 자세히 알아보세요

Firebase Authentication에서는 사용자별 오류가 발생해도 제공된 전체 사용자 목록의 업로드를 시도합니다. 이 작업으로 가져오기 성공 및 실패 요약을 포함한 결과가 반환됩니다. 오류 세부정보는 사용자 가져오기 실패 작업별로 반환됩니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(userImportRecords, {
hash: {
algorithm: 'HMAC_SHA256',
key: Buffer.from('secretKey'),
},
})
.then((userImportResult) => {
// The number of successful imports is determined via: userImportResult.successCount.
// The number of failed imports is determined via: userImportResult.failureCount.
// To get the error details.
userImportResult.errors.forEach((indexedError) => {
// The corresponding user that failed to upload.
console.log(
'Error ' + indexedError.index,
' failed to import: ',
indexedError.error
);
});
})
.catch((error) => {
// Some unrecoverable error occurred that prevented the operation from running.
});
```

--- 탭: 자바 ---
```
UserImportOptions options = UserImportOptions.withHash(
HmacSha256.builder()
.setKey("secretKey".getBytes())
.build());
try {
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
System.out.println("Successfully imported " + result.getSuccessCount() + " users");
System.out.println("Failed to import " + result.getFailureCount() + " users");
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user at index: " + indexedError.getIndex()
+ " due to error: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
// Some unrecoverable error occurred that prevented the operation from running.
}
```

--- 탭: Python ---
```
hash_alg = auth.UserImportHash.hmac_sha256(key=b'secret_key')
try:
result = auth.import_users(users, hash_alg=hash_alg)
print(
f'Successfully imported {result.success_count} users. Failed to import '
f'{result.failure_count} users.')
for err in result.errors:
print(f'Failed to import {users[err.index].uid} due to {err.reason}')
except exceptions.FirebaseError:
# Some unrecoverable error occurred that prevented the operation from running.
pass
```

--- 탭: Go ---
```
client, err := app.Auth(ctx)
if err != nil {
log.Fatalln("Error initializing Auth client", err)
}

h := hash.HMACSHA256{
Key: []byte("secretKey"),
}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Unrecoverable error prevented the operation from running", err)
}

log.Printf("Successfully imported %d users\n", result.SuccessCount)
log.Printf("Failed to import %d users\n", result.FailureCount)
for _, e := range result.Errors {
log.Printf("Failed to import user at index: %d due to error: %s\n", e.Index, e.Reason)
}
```

--- 탭: C# ---
```
var options = new UserImportOptions()
{
Hash = new HmacSha256()
{
Key = Encoding.ASCII.GetBytes("secretKey"),
},
};

try
{
UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
Console.WriteLine($"Successfully imported {result.SuccessCount} users");
Console.WriteLine($"Failed to import {result.FailureCount} users");
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user at index: {indexedError.Index}"
+ $" due to error: {indexedError.Reason}");
}
}
catch (FirebaseAuthException)
{
// Some unrecoverable error occurred that prevented the operation from running.
}
```
비밀번호 해싱이 필요 없는 경우(전화번호, 맞춤 토큰 사용자, OAuth 사용자 등) 해싱 옵션을 제공하지 마세요.

Firebase scrypt 해시 비밀번호를 사용한 사용자 가져오기

기본적으로 Firebase는 scrypt 해싱 알고리즘의 수정된 Firebase 버전 [https://github.com/firebase/scrypt]을 사용하여 비밀번호를 저장합니다. 수정된 scrypt로 해싱된 비밀번호를 가져오는 것은 다른 기존 Firebase 프로젝트에서 사용자를 마이그레이션하는 데 유용합니다. 이 경우 원래 프로젝트의 내부 매개변수를 결정해야 합니다.

Firebase에서는 Firebase 프로젝트마다 고유의 비밀번호 해시 매개변수를 생성합니다.
이 매개변수에 액세스하려면 Firebase 콘솔의 사용자 탭 [https://console.firebase.google.com/project/_/authentication/users?hl=ko]으로 이동하고 사용자 테이블 목록의 오른쪽 상단에 있는 드롭다운에서 비밀번호 해시 매개변수를 선택합니다.

이 알고리즘의 해시 옵션을 구성하는 데 필요한 매개변수는 다음과 같습니다.

key: 일반적으로 base64로 인코딩되는 서명자 키입니다.
saltSeparator: 일반적으로 base64로 인코딩되는 솔트 구분자입니다(선택사항).
rounds: 비밀번호를 해시하는 데 사용되는 라운드 수입니다.
memoryCost: 이 알고리즘에 필요한 메모리 비용입니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(
[
{
uid: 'some-uid',
email: 'user@example.com',
// Must be provided in a byte buffer.
passwordHash: Buffer.from('base64-password-hash', 'base64'),
// Must be provided in a byte buffer.
passwordSalt: Buffer.from('base64-salt', 'base64'),
},
],
{
hash: {
algorithm: 'SCRYPT',
// All the parameters below can be obtained from the Firebase Console's users section.
// Must be provided in a byte buffer.
key: Buffer.from('base64-secret', 'base64'),
saltSeparator: Buffer.from('base64SaltSeparator', 'base64'),
rounds: 8,
memoryCost: 14,
},
}
)
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash(BaseEncoding.base64().decode("password-hash"))
.setPasswordSalt(BaseEncoding.base64().decode("salt"))
.build());
UserImportOptions options = UserImportOptions.withHash(
Scrypt.builder()
// All the parameters below can be obtained from the Firebase Console's "Users"
// section. Base64 encoded parameters must be decoded into raw bytes.
.setKey(BaseEncoding.base64().decode("base64-secret"))
.setSaltSeparator(BaseEncoding.base64().decode("base64-salt-separator"))
.setRounds(8)
.setMemoryCost(14)
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=base64.urlsafe_b64decode('password_hash'),
password_salt=base64.urlsafe_b64decode('salt')
),
]

# All the parameters below can be obtained from the Firebase Console's "Users"
# section. Base64 encoded parameters must be decoded into raw bytes.
hash_alg = auth.UserImportHash.scrypt(
key=base64.b64decode('base64_secret'),
salt_separator=base64.b64decode('base64_salt_separator'),
rounds=8,
memory_cost=14
)
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
b64URLdecode := func(s string) []byte {
b, err := base64.URLEncoding.DecodeString(s)
if err != nil {
log.Fatalln("Failed to decode string", err)
}

return b
}
b64Stddecode := func(s string) []byte {
b, err := base64.StdEncoding.DecodeString(s)
if err != nil {
log.Fatalln("Failed to decode string", err)
}
return b
}
// Users retrieved from Firebase Auth's backend need to be base64URL decoded
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash(b64URLdecode("password-hash")).
PasswordSalt(b64URLdecode("salt")),
}

// All the parameters below can be obtained from the Firebase Console's "Users"
// section. Base64 encoded parameters must be decoded into raw bytes.
h := hash.Scrypt{
Key:           b64Stddecode("base64-secret"),
SaltSeparator: b64Stddecode("base64-salt-separator"),
Rounds:        8,
MemoryCost:    14,
}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
},
};

var options = new UserImportOptions()
{
// All the parameters below can be obtained from the Firebase Console's "Users"
// section. Base64 encoded parameters must be decoded into raw bytes.
Hash = new Scrypt()
{
Key = Encoding.ASCII.GetBytes("base64-secret"),
SaltSeparator = Encoding.ASCII.GetBytes("base64-salt-separator"),
Rounds = 8,
MemoryCost = 14,
},
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```
표준 scrypt 해시 비밀번호를 사용한 사용자 가져오기

Firebase Authentication에서는 표준 scrypt 알고리즘은 물론 위의 수정된 버전도 지원합니다. 표준 scrypt 알고리즘의 경우 다음과 같은 해싱 매개변수가 필요합니다.

memoryCost: 해싱 알고리즘의 CPU/메모리 비용입니다.
parallelization: 해싱 알고리즘의 동시 로드입니다.
blockSize: 해싱 알고리즘의 블록 크기(일반적으로 8)입니다.
derivedKeyLength: 해싱 알고리즘의 파생 키 길이입니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(
[
{
uid: 'some-uid',
email: 'user@example.com',
// Must be provided in a byte buffer.
passwordHash: Buffer.from('password-hash'),
// Must be provided in a byte buffer.
passwordSalt: Buffer.from('salt'),
},
],
{
hash: {
algorithm: 'STANDARD_SCRYPT',
memoryCost: 1024,
parallelization: 16,
blockSize: 8,
derivedKeyLength: 64,
},
}
)
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
StandardScrypt.builder()
.setMemoryCost(1024)
.setParallelization(16)
.setBlockSize(8)
.setDerivedKeyLength(64)
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.standard_scrypt(
memory_cost=1024, parallelization=16, block_size=8, derived_key_length=64)
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
}
h := hash.StandardScrypt{
MemoryCost:       1024,
Parallelization:  16,
BlockSize:        8,
DerivedKeyLength: 64,
}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
},
};

var options = new UserImportOptions()
{
Hash = new StandardScrypt()
{
MemoryCost = 1024,
Parallelization = 16,
BlockSize = 8,
DerivedKeyLength = 64,
},
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```
HMAC 해시 비밀번호를 사용한 사용자 가져오기

HMAC 해싱 알고리즘에는 HMAC_MD5, HMAC_SHA1, HMAC_SHA256, HMAC_SHA512가 포함됩니다. 이 해싱 알고리즘의 경우 해시 서명자 키를 제공해야 합니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(
[
{
uid: 'some-uid',
email: 'user@example.com',
// Must be provided in a byte buffer.
passwordHash: Buffer.from('password-hash'),
// Must be provided in a byte buffer.
passwordSalt: Buffer.from('salt'),
},
],
{
hash: {
algorithm: 'HMAC_SHA256',
// Must be provided in a byte buffer.
key: Buffer.from('secret'),
},
}
)
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
HmacSha256.builder()
.setKey("secret".getBytes())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.hmac_sha256(key=b'secret')
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
}
h := hash.HMACSHA256{
Key: []byte("secret"),
}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
},
};

var options = new UserImportOptions()
{
Hash = new HmacSha256()
{
Key = Encoding.ASCII.GetBytes("secret"),
},
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```
MD5, SHA, PBKDF 해시 비밀번호를 사용한 사용자 가져오기

MD5, SHA, PBKDF 해싱 알고리즘에는 MD5, SHA1, SHA256, SHA512, PBKDF_SHA1, PBKDF2_SHA256이 포함됩니다. 이러한 해싱 알고리즘의 경우 비밀번호를 해시하는 데 원래 사용되는 라운드 수(MD5의 경우 0~8192, SHA1, SHA256, SHA512의 경우 1~8192, PBKDF_SHA1 및 PBKDF2_SHA256의 경우 0~120000)를 제공해야 합니다. 원래 단일 해싱 함수가 적용된 경우 라운드를 1로 설정해야 합니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(
[
{
uid: 'some-uid',
email: 'user@example.com',
// Must be provided in a byte buffer.
passwordHash: Buffer.from('password-hash'),
// Must be provided in a byte buffer.
passwordSalt: Buffer.from('salt'),
},
],
{
hash: {
algorithm: 'PBKDF2_SHA256',
rounds: 100000,
},
}
)
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
Pbkdf2Sha256.builder()
.setRounds(100000)
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.pbkdf2_sha256(rounds=100000)
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
}
h := hash.PBKDF2SHA256{
Rounds: 100000,
}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
},
};

var options = new UserImportOptions()
{
Hash = new Pbkdf2Sha256()
{
Rounds = 100000,
},
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```
BCRYPT 해시 비밀번호를 사용한 사용자 가져오기

BCRYPT 해시 비밀번호의 경우 추가 해시 매개변수 및 사용자별 비밀번호 솔트가 필요 없습니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers(
[
{
uid: 'some-uid',
email: 'user@example.com',
// Must be provided in a byte buffer.
passwordHash: Buffer.from('password-hash'),
},
],
{
hash: {
algorithm: 'BCRYPT',
},
}
)
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(Bcrypt.getInstance());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
email='user@example.com',
password_hash=b'password_hash',
password_salt=b'salt'
),
]

hash_alg = auth.UserImportHash.bcrypt()
try:
result = auth.import_users(users, hash_alg=hash_alg)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
Email("user@example.com").
PasswordHash([]byte("password-hash")).
PasswordSalt([]byte("salt")),
}
h := hash.Bcrypt{}
result, err := client.ImportUsers(ctx, users, auth.WithHash(h))
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
Email = "user@example.com",
PasswordHash = Encoding.ASCII.GetBytes("password-hash"),
PasswordSalt = Encoding.ASCII.GetBytes("salt"),
},
};

var options = new UserImportOptions()
{
Hash = new Bcrypt(),
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users, options);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```
Argon2 해시 비밀번호를 사용한 사용자 가져오기

Argon2 해시 객체를 구성하여 Argon2 해시 비밀번호가 있는 사용자 레코드를 가져올 수 있습니다. 이 기능은 현재 Admin 자바 SDK에서만 지원됩니다.

이 알고리즘의 해시 옵션을 구성하는 데 필요한 매개변수는 다음과 같습니다.

hashLengthBytes: 원하는 해시 길이(바이트)이며 정수로 제공됩니다.
hashType: 사용할 Argon2 변형(ARGON2_D, ARGON2_ID, ARGON2_I)입니다.
parallelism: 동시 로드 정도이며 정수로 제공됩니다. 1 이상 16 이하여야 합니다.
iterations: 수행할 반복 횟수이며 정수로 제공됩니다. 1 이상 16 이하여야 합니다.
memoryCostKib: 이 알고리즘에 필요한 메모리 비용(키비바이트)이며 32,768 미만이어야 합니다.
version: Argon2 알고리즘의 버전(VERSION_10 또는 VERSION_13)입니다. 선택사항이며 지정하지 않을 경우 기본값은 VERSION_13입니다.
associatedData: 바이트 배열로 제공되는 추가 연결 데이터로, 추가 보안 레이어를 제공하기 위해 해시 값에 추가됩니다. 선택사항이며 이 데이터는 API로 전송되기 전에 base64로 인코딩됩니다.

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setEmail("user@example.com")
.setPasswordHash("password-hash".getBytes())
.setPasswordSalt("salt".getBytes())
.build());
UserImportOptions options = UserImportOptions.withHash(
Argon2.builder()
.setHashLengthBytes(512)
.setHashType(Argon2HashType.ARGON2_ID)
.setParallelism(8)
.setIterations(16)
.setMemoryCostKib(2048)
.setVersion(Argon2Version.VERSION_10)
.setAssociatedData("associated-data".getBytes())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users, options);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```
비밀번호 없이 사용자 가져오기

비밀번호 없이 사용자를 가져올 수도 있습니다. 비밀번호 없이 사용자를 가져오려면 OAuth 제공업체, 맞춤 클레임, 전화번호 등을 가진 사용자와 조합하면 됩니다.

--- 탭: Node.js ---
```
getAuth()
.importUsers([
{
uid: 'some-uid',
displayName: 'John Doe',
email: 'johndoe@gmail.com',
photoURL: 'http://www.example.com/12345678/photo.png',
emailVerified: true,
phoneNumber: '+11234567890',
// Set this user as admin.
customClaims: { admin: true },
// User with Google provider.
providerData: [
{
uid: 'google-uid',
email: 'johndoe@gmail.com',
displayName: 'John Doe',
photoURL: 'http://www.example.com/12345678/photo.png',
providerId: 'google.com',
},
],
},
])
.then((results) => {
results.errors.forEach((indexedError) => {
console.log(`Error importing user ${indexedError.index}`);
});
})
.catch((error) => {
console.log('Error importing users :', error);
});
```

--- 탭: 자바 ---
```
try {
List<ImportUserRecord> users = Collections.singletonList(ImportUserRecord.builder()
.setUid("some-uid")
.setDisplayName("John Doe")
.setEmail("johndoe@gmail.com")
.setPhotoUrl("http://www.example.com/12345678/photo.png")
.setEmailVerified(true)
.setPhoneNumber("+11234567890")
.putCustomClaim("admin", true) // set this user as admin
.addUserProvider(UserProvider.builder() // user with Google provider
.setUid("google-uid")
.setEmail("johndoe@gmail.com")
.setDisplayName("John Doe")
.setPhotoUrl("http://www.example.com/12345678/photo.png")
.setProviderId("google.com")
.build())
.build());
UserImportResult result = FirebaseAuth.getInstance().importUsers(users);
for (ErrorInfo indexedError : result.getErrors()) {
System.out.println("Failed to import user: " + indexedError.getReason());
}
} catch (FirebaseAuthException e) {
System.out.println("Error importing users: " + e.getMessage());
}
```

--- 탭: Python ---
```
users = [
auth.ImportUserRecord(
uid='some-uid',
display_name='John Doe',
email='johndoe@gmail.com',
photo_url='http://www.example.com/12345678/photo.png',
email_verified=True,
phone_number='+11234567890',
custom_claims={'admin': True}, # set this user as admin
provider_data=[ # user with Google provider
auth.UserProvider(
uid='google-uid',
email='johndoe@gmail.com',
display_name='John Doe',
photo_url='http://www.example.com/12345678/photo.png',
provider_id='google.com'
)
],
),
]
try:
result = auth.import_users(users)
for err in result.errors:
print('Failed to import user:', err.reason)
except exceptions.FirebaseError as error:
print('Error importing users:', error)
```

--- 탭: Go ---
```
users := []*auth.UserToImport{
(&auth.UserToImport{}).
UID("some-uid").
DisplayName("John Doe").
Email("johndoe@gmail.com").
PhotoURL("http://www.example.com/12345678/photo.png").
EmailVerified(true).
PhoneNumber("+11234567890").
CustomClaims(map[string]interface{}{"admin": true}). // set this user as admin
ProviderData([]*auth.UserProvider{                   // user with Google provider
{
UID:         "google-uid",
Email:       "johndoe@gmail.com",
DisplayName: "John Doe",
PhotoURL:    "http://www.example.com/12345678/photo.png",
ProviderID:  "google.com",
},
}),
}
result, err := client.ImportUsers(ctx, users)
if err != nil {
log.Fatalln("Error importing users", err)
}
for _, e := range result.Errors {
log.Println("Failed to import user", e.Reason)
}
```

--- 탭: C# ---
```
try
{
var users = new List<ImportUserRecordArgs>()
{
new ImportUserRecordArgs()
{
Uid = "some-uid",
DisplayName = "John Doe",
Email = "johndoe@gmail.com",
PhotoUrl = "http://www.example.com/12345678/photo.png",
EmailVerified = true,
PhoneNumber = "+11234567890",
CustomClaims = new Dictionary<string, object>()
{
{ "admin", true }, // set this user as admin
},
UserProviders = new List<UserProvider>
{
new UserProvider() // user with Google provider
{
Uid = "google-uid",
Email = "johndoe@gmail.com",
DisplayName = "John Doe",
PhotoUrl = "http://www.example.com/12345678/photo.png",
ProviderId = "google.com",
},
},
},
};

UserImportResult result = await FirebaseAuth.DefaultInstance.ImportUsersAsync(users);
foreach (ErrorInfo indexedError in result.Errors)
{
Console.WriteLine($"Failed to import user: {indexedError.Reason}");
}
}
catch (FirebaseAuthException e)
{
Console.WriteLine($"Error importing users: {e.Message}");
}
```참고: some-uid는 고유한 Firebase 사용자 ID의 자리표시자이며, 이는 프로젝트 내 사용자의 기본 식별자입니다. 반면 google-uid는 Google 인증 제공업체의 고유 ID 자리표시자입니다. 이 ID는 사용자의 Firebase 계정을 특정 Google 계정에 연결합니다.

의견 보내기