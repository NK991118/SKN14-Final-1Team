Source URL: https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko
Title: C++를 사용하여 익명으로 Firebase에 인증하기
bookmark_border

의견 보내기

C++를 사용하여 익명으로 Firebase에 인증하기

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용시작하기 전에 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#before-you-begin]Firebase에 익명으로 인증 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#authenticate-with-firebase-anonymously]익명 계정을 영구 계정으로 전환 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#convert-an-anonymous-account-to-a-permanent-account]자동 정리 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#auto-cleanup]다음 단계 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#next-steps]

Firebase Authentication을 사용하면 임시 익명 계정을 생성 및 사용하여 Firebase에 인증할 수 있습니다. 이 임시 익명 계정을 통해 아직 앱에 가입하지 않은 사용자들도 보안 규칙으로 보호받는 데이터를 사용할 수 있습니다. 익명 사용자가 앱에 가입하기로 결정하면 이 사용자의 로그인 인증 정보를 해당 익명 계정에 연결 [https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko]하여 사용자가 추후 세션에서도 보호받는 데이터를 계속 사용하도록 할 수 있습니다.

시작하기 전에

C++ 프로젝트에 Firebase를 추가합니다 [https://firebase.google.com/docs/cpp/setup?hl=ko#note_select_platform].

아직 Firebase 프로젝트에 앱을 연결하지 않았다면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 연결합니다.
다음과 같이 익명 인증을 사용 설정합니다.

Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다.
로그인 방법 페이지에서 익명 로그인 방법을 사용 설정합니다.
선택사항: 프로젝트를 Firebase Authentication with Identity Platform [https://firebase.google.com/auth?hl=ko#identity-platform]으로 업그레이드한 경우 자동 정리를 사용 설정할 수 있습니다. 이 설정을 사용하면 30일이 지난 익명 계정은 자동으로 삭제됩니다. 자동 정리가 사용 설정된 프로젝트에서는 익명 인증이 더 이상 사용량 한도 또는 결제 할당량에 포함되지 않습니다. 자동 정리 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#auto-cleanup]를 참조하세요.

Firebase에 익명으로 인증

로그아웃 상태의 사용자가 Firebase의 인증이 필요한 앱 기능을 사용할 때 다음 절차를 밟으면 사용자를 익명으로 로그인시킬 수 있습니다.Auth 클래스는 모든 API 호출에 대한 게이트웨이입니다.
Auth 및 App 헤더 파일을 추가합니다.
#include "firebase/app.h"
#include "firebase/auth.h"

초기화 코드에서 firebase::App [https://firebase.google.com/docs/reference/cpp/class/firebase/app?hl=ko] 클래스를 만듭니다.#if defined(__ANDROID__)
firebase::App* app =
firebase::App::Create(firebase::AppOptions(), my_jni_env, my_activity);
#else
firebase::App* app = firebase::App::Create(firebase::AppOptions());
#endif  // defined(__ANDROID__)

firebase::App의 firebase::auth::Auth 클래스를 획득합니다.
App과 Auth는 일대일 매핑 관계입니다.
firebase::auth::Auth* auth = firebase::auth::Auth::GetAuth(app);

Auth::SignInAnonymously를 호출합니다.
firebase::Future<firebase::auth::AuthResult> result =
auth->SignInAnonymously();

프로그램에 정기적으로 실행되는 업데이트 루프(예: 초당 30회 또는 60회)가 있는 경우 다음과 같이 Auth::SignInAnonymouslyLastResult를 사용해 업데이트 시마다 한 번씩 결과를 확인할 수 있습니다.firebase::Future<firebase::auth::AuthResult> result =
auth->SignInAnonymouslyLastResult();
if (result.status() == firebase::kFutureStatusComplete) {
if (result.error() == firebase::auth::kAuthErrorNone) {
firebase::auth::AuthResult auth_result = *result.result();
printf("Sign in succeeded for `%s`\n",
auth_result.user.display_name().c_str());
} else {
printf("Sign in failed with error '%s'\n", result.error_message());
}
}
또는 프로그램이 이벤트 기반이라면 Future에 콜백을 등록 [https://firebase.google.com/docs/auth/cpp/anonymous-auth?hl=ko#register_callback_on_future]하는 것이 나을 수도 있습니다.

프로젝트 악용을 방지하기 위해 Firebase에서는 짧은 시간 동안 같은 IP 주소에서 이메일/비밀번호 및 익명 방식으로 애플리케이션에 새로 가입할 수 있는 횟수를 제한합니다. Firebase Console [https://console.firebase.google.com/project/_/authentication/providers?hl=ko]에서 이 할당량의 한시적 변경을 요청하거나 예약할 수 있습니다.

익명 계정을 영구 계정으로 전환

익명 사용자가 앱에 가입하면 사용자가 가입 전에 하던 작업을 신규 계정에서 이어서 하게 할 수 있습니다. 예를 들면 사용자가 가입 전에 장바구니에 담은 물품이 신규 계정의 장바구니에 나타나도록 할 수 있습니다. 그러려면 다음 절차를 완료하세요.

사용자가 가입하면 사용자가 선택한 인증 제공업체의 로그인 과정을 진행하되 Auth::SignInWith 메서드 호출 전까지만 진행합니다. 예를 들어 사용자의 Google ID 토큰, Facebook 액세스
토큰 또는 이메일 주소와 비밀번호를 가져옵니다.

다음과 같이 새로운 인증 제공업체의 auth::Credential을 가져옵니다.

Google 로그인
firebase::auth::Credential credential =
firebase::auth::GoogleAuthProvider::GetCredential(google_id_token,
nullptr);
Facebook 로그이
firebase::auth::Credential credential =
firebase::auth::FacebookAuthProvider::GetCredential(access_token);
이메일-비밀번호 로그인
firebase::auth::Credential credential =
firebase::auth::EmailAuthProvider::GetCredential(email, password);

다음과 같이 로그인한 사용자의 LinkWithCredential 메서드에 auth::Credential 객체를 전달합니다.

// Link the new credential to the currently active user.
firebase::auth::User current_user = auth->current_user();
firebase::Future<firebase::auth::AuthResult> result =
current_user.LinkWithCredential(credential);

LinkWithCredential 호출이 성공하면 사용자의 신규 계정에서 익명 계정의 Firebase 데이터에 액세스할 수 있습니다.이 방법은 임의의 계정 2개를 연결 [https://firebase.google.com/docs/auth/cpp/account-linking?hl=ko]할 때도 사용할 수 있습니다.자동 정리

프로젝트를 Firebase Authentication with Identity Platform [https://firebase.google.com/docs/auth?hl=ko#identity-platform]으로 업그레이드한 경우 Firebase Console에서 자동 정리를 사용 설정할 수 있습니다. 이 기능을 사용 설정하면 Firebase에서 30일이 지난 익명 계정을 자동으로 삭제할 수 있습니다. 자동 정리가 사용 설정된 프로젝트에서는 익명 인증이 사용량 한도 또는 결제 할당량에 포함되지 않습니다.

자동 정리를 사용 설정한 후 만든 익명 계정은 생성 후 30일이 지나면 언제든지 자동으로 삭제될 수 있습니다.
기존 익명 계정은 자동 정리를 사용 설정한 후 30일이 지나면 자동으로 삭제될 수 있습니다.
자동 정리를 사용 중지해도 삭제 예약된 익명 계정은 삭제가 예약된 상태로 유지됩니다.
익명 계정을 로그인 방법에 연결하여 '업그레이드'할 경우 계정이 자동으로 삭제되지 않습니다.

이 기능을 사용 설정하기 전에 영향을 받는 사용자 수를 확인하고 프로젝트를 Firebase Authentication with Identity Platform [https://firebase.google.com/docs/auth?hl=ko#identity-platform]으로 업그레이드한 경우 Cloud Logging [https://cloud.google.com/logging/docs?hl=ko]에서 is_anon으로 필터링할 수 있습니다.

다음 단계

이제 사용자가 Firebase에 인증할 수 있으므로 Firebase 규칙 [https://firebase.google.com/docs/database/security?hl=ko#section-authorization]을 사용하여 Firebase 데이터베이스의 데이터에 대한 액세스를 제어할 수 있습니다.

의견 보내기