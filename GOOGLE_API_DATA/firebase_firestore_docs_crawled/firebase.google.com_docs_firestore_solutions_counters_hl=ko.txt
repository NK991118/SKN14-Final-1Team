Source URL: https://firebase.google.com/docs/firestore/solutions/counters?hl=ko
Title: 분산 카운터

의견 보내기

분산 카운터

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

많은 실시간 앱에는 카운터 역할을 하는 문서가 있습니다. 예를 들어 게시물의 '좋아요' 또는 특정 항목의 '즐겨찾기' 개수를 셀 수 있습니다.

Cloud Firestore에서는 단일 문서를 무제한 속도로 업데이트할 수 없습니다. 단일 문서를 기반으로 한 카운터가 있고 증분이 자주 발생하는 경우 결국 문서 업데이트에 대한 경합이 발생합니다. 단일 문서 업데이트 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#updates_to_a_single_document]를 참조하세요.

솔루션: 분산 카운터

더욱 빈번한 카운터 업데이트를 지원하려면 분산 카운터를 만드세요.
각 카운터는 '샤드'로 이루어진 하위 컬렉션을 갖는 문서이며 카운터의 값은 샤드 값의 합계입니다.

쓰기 처리량은 샤드 수에 따라 선형적으로 증가하므로 10개의 샤드가 있는 분산 카운터는 기존 카운터보다 10배 많은 쓰기를 처리할 수 있습니다.

웹// counters/${ID}
"num_shards": NUM_SHARDS,
"shards": [subcollection]

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

@end

@implementation FIRCounter
- (instancetype)initWithShardCount:(NSInteger)shardCount {
self = [super init];
if (self != nil) {
_shardCount = shardCount;
@end

@implementation FIRShard
- (instancetype)initWithCount:(NSInteger)count {
self = [super init];
if (self != nil) {
_count = count;

public Counter(int numShards) {
this.numShards = numShards;

public Shard(int count) {
this.count = count;

import random

from google.cloud import firestore

class Shard:
"""
A shard is a distributed counter. Each shard can support being incremented
once per second. Multiple shards are needed within a Counter to allow
more frequent incrementing.
"""

def __init__(self):
self._count = 0

def to_dict(self):
return {"count": self._count}

class Counter:
"""
A counter stores a collection of shards which are
summed to return a total count. This allows for more
frequent incrementing than a single document.
"""

def __init__(self, num_shards):
self._num_shards = num_shards
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/distributed_counters.py#L16-L44]

Python

import random

from google.cloud import firestore

class Shard:
"""
A shard is a distributed counter. Each shard can support being incremented
once per second. Multiple shards are needed within a Counter to allow
more frequent incrementing.
"""

def __init__(self):
self._count = 0

def to_dict(self):
return {"count": self._count}

class Counter:
"""
A counter stores a collection of shards which are
summed to return a total count. This allows for more
frequent incrementing than a single document.
"""

def __init__(self, num_shards):
self._num_shards = num_shards
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/distributed_counters.py#L16-L44]

Node.js 해당되지 않습니다. 아래의 카운터 증분 스니펫을 참조하세요.
Go

import (
"context"
"fmt"
"math/rand"
"strconv"

"cloud.google.com/go/firestore"
"google.golang.org/api/iterator"

C#

[FirestoreProperty(name: "count")]
public int Count { get; set; }

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func createCounter(ref: DocumentReference, numShards: Int) async {
do {
try await ref.setData(["numShards": numShards])
for i in 0...numShards {
try await ref.collection("shards").document(String(i)).setData(["count": 0])
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)createCounterAtReference:(FIRDocumentReference *)reference
shardCount:(NSInteger)shardCount {
[reference setData:@{ @"numShards": @(shardCount) } completion:^(NSError * _Nullable error) {
for (NSInteger i = 0; i < shardCount; i++) {
NSString *shardName = [NSString stringWithFormat:@"%ld", (long)shardCount];
[[[reference collectionWithPath:@"shards"] documentWithPath:shardName]

.document(i.toString())
.set(Shard(0))

tasks.add(makeShard)
Tasks.whenAll(tasks)
.continueWithTask(new Continuation<Void, Task<Void>>() {
@Override
public Task<Void> then(@NonNull Task<Void> task) throws Exception {
if (!task.isSuccessful()) {
throw task.getException();
List<Task<Void>> tasks = new ArrayList<>();

Task<Void> makeShard = ref.collection("shards")
.document(String.valueOf(i))
.set(new Shard(0));

tasks.add(makeShard);

def init_counter(self, doc_ref):
"""
Create a given number of shards as
subcollection of specified document.
"""
col_ref = doc_ref.collection("shards")

# Initialize each shard with count=0
for num in range(self._num_shards):
shard = Shard()
col_ref.document(str(num)).set(shard.to_dict())
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/distributed_counters.py#L48-L59]

Python

async def init_counter(self, doc_ref):
"""
Create a given number of shards as
subcollection of specified document.
"""
col_ref = doc_ref.collection("shards")

# Initialize each shard with count=0
for num in range(self._num_shards):
shard = Shard()
await col_ref.document(str(num)).set(shard.to_dict())
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/distributed_counters.py#L48-L59]

Node.js 해당되지 않습니다. 아래의 카운터 증분 스니펫을 참조하세요.
Go

$numShards = 10;
$ref = $db->collection('samples/php/distributedCounters');
for ($i = 0; $i < $numShards; $i++) {
$doc = $ref->document((string) $i);
$doc->set(['Cnt' => 0]);

CollectionReference colRef = docRef.Collection("shards");
tasks.Add(colRef.Document(i.ToString()).SetAsync(new Shard() { Count = 0 }));

# project_id = "Your Google Cloud Project ID"
# num_shards = "Number of shards for distributed counter"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

shards_ref = firestore.col collection_path

# Initialize each shard with count=0
num_shards.times do |i|
shards_ref.doc(i).set({ count: 0 })
end

puts "Distributed counter shards collection created."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/distributed_counters.rb#L18-L33]

카운터를 늘리려면 샤드를 무작위로 선택하고 카운트를 늘립니다.

웹function incrementCounter(ref, num_shards) {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func incrementCounter(ref: DocumentReference, numShards: Int) {
"count": FieldValue.increment(Int64(1))
])
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)incrementCounterAtReference:(FIRDocumentReference *)reference
shardCount:(NSInteger)shardCount {
NSInteger shardID = (NSInteger)arc4random_uniform((uint32_t)shardCount);
NSString *shardName = [NSString stringWithFormat:@"%ld", (long)shardID];
FIRDocumentReference *shardReference =
[[reference collectionWithPath:@"shards"] documentWithPath:shardName];

[shardReference updateData:@{
@"count": [FIRFieldValue fieldValueForIntegerIncrement:1]
val shardRef = ref.collection("shards").document(shardId.toString())

return shardRef.update("count", FieldValue.increment(1))
DocumentReference shardRef = ref.collection("shards").document(String.valueOf(shardId));

return shardRef.update("count", FieldValue.increment(1));

def increment_counter(self, doc_ref):
"""Increment a randomly picked shard."""
doc_id = random.randint(0, self._num_shards - 1)

shard_ref = doc_ref.collection("shards").document(str(doc_id))
return shard_ref.update({"count": firestore.Increment(1)})
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/distributed_counters.py#L63-L69]

Python

async def increment_counter(self, doc_ref):
"""Increment a randomly picked shard."""
doc_id = random.randint(0, self._num_shards - 1)

shard_ref = doc_ref.collection("shards").document(str(doc_id))
return await shard_ref.update({"count": firestore.Increment(1)})
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/distributed_counters.py#L63-L69]

Node.js

function incrementCounter(docRef, numShards) {

$ref = $db->collection('samples/php/distributedCounters');
$numShards = 0;
$docCollection = $ref->documents();
foreach ($docCollection as $doc) {
$numShards++;
$doc = $ref->document((string) $shardIdx);
$doc->update([
['path' => 'Cnt', 'value' => FieldValue::increment(1)]
]);solution_sharded_counter_increment.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/fb4e5fc6398145491c6197344849d9caeac33811/firestore/src/solution_sharded_counter_increment.php#L42-L52]

C#

int documentId;
lock (s_randLock)
documentId = s_rand.Next(numOfShards);

# project_id = "Your Google Cloud Project ID"
# num_shards = "Number of shards for distributed counter"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

# Select a shard of the counter at random
shard_id = rand 0...num_shards
shard_ref = firestore.doc "#{collection_path}/#{shard_id}"

# increment counter
shard_ref.update({ count: firestore.field_increment(1) })

puts "Counter incremented."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/distributed_counters.rb#L39-L54]

전체 카운트를 가져오려면 모든 샤드를 쿼리하고 count 필드의 합계를 구합니다.

웹function getCount(ref) {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func getCount(ref: DocumentReference) async {
do {
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)getCountWithReference:(FIRDocumentReference *)reference {
[[reference collectionWithPath:@"shards"]
getDocumentsWithCompletion:^(FIRQuerySnapshot *snapshot,
NSError *error) {
NSInteger totalCount = 0;
if (error != nil) {
NSInteger count = [document[@"count"] integerValue];
totalCount += count;
NSLog(@"Total count is %ld", (long)totalCount);
count += shard.count
.continueWith(new Continuation<QuerySnapshot, Integer>() {
@Override
public Integer then(@NonNull Task<QuerySnapshot> task) throws Exception {
int count = 0;
for (DocumentSnapshot snap : task.getResult()) {
Shard shard = snap.toObject(Shard.class);
count += shard.count;

def get_count(self, doc_ref):
"""Return a total count across all shards."""
total = 0
shards = doc_ref.collection("shards").list_documents()
for shard in shards:
total += shard.get().to_dict().get("count", 0)
return total
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/distributed_counters.py#L73-L80]

Python

async def get_count(self, doc_ref):
"""Return a total count across all shards."""
total = 0
shards = doc_ref.collection("shards").list_documents()
async for shard in shards:
total += (await shard.get()).to_dict().get("count", 0)
return total
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/distributed_counters.py#L73-L80]

Node.js

async function getCount(docRef) {

$result = 0;
$docCollection = $db->collection('samples/php/distributedCounters')->documents();
foreach ($docCollection as $doc) {
$result += $doc->data()['Cnt'];

# project_id = "Your Google Cloud Project ID"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

shards_ref = firestore.col_group collection_path

count = 0
shards_ref.get do |doc_ref|
count += doc_ref[:count]
end

puts "Count value is #{count}."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/distributed_counters.rb#L60-L74]

제한사항

위 솔루션은 Cloud Firestore에서 공유 카운터를 만드는 확장 가능한 방법이지만 다음과 같은 제한사항에 유의해야 합니다.

샤드 수 - 샤드 수는 분산 카운터의 성능을 좌우합니다. 샤드가 너무 적으면 일부 트랜잭션을 재시도해야 하므로 쓰기 작업이 느려집니다. 샤드가 너무 많으면 읽기가 느려지고 비용이 증가합니다.  더 느린 주기로 업데이트되는 개별 롤업 문서에서 카운터 합계를 유지하고 클라이언트가 이 문서를 읽어 합계를 가져오도록 하면 읽기 비용을 상쇄할 수 있습니다. 하지만 이 경우 클라이언트가 업데이트 직후 모든 샤드를 읽어 합계를 계산하지 않고 롤업 문서가 업데이트될 때까지 기다려야 한다는 단점이 있습니다.
비용 - 카운터 값을 읽을 때 전체 샤드 하위 컬렉션이 로드되어야 하므로 샤드 수에 따라 비용이 선형으로 증가합니다.

의견 보내기