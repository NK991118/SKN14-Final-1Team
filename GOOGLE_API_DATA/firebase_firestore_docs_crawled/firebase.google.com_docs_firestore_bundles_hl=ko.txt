Source URL: https://firebase.google.com/docs/firestore/bundles?hl=ko
Title: Cloud Firestore 데이터 번들

의견 보내기

Cloud Firestore 데이터 번들

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

참고: 데이터 번들은 선택 가능한 고급 Cloud Firestore 기능입니다. 여기에서는 Cloud Firestore를 이해하는 데 필요한 기본 개념과 함께 데이터 번들을 설명합니다. 이 페이지를 완료하면 앱이 수직 확장된 후 쿼리 비용을 관리하는 데 도움이 되는 기능을 사용할 수 있습니다. 데이터 번들에 대해 알아보기 전에 다른 개요 및 개념 주제 외에도 Cloud Firestore 쿼리 실행 [https://firebase.google.com/docs/firestore/query-data/queries?hl=ko]에 관한 가이드를 읽어보세요.
Cloud Firestore 데이터 번들은 Cloud Firestore 문서 및 쿼리 스냅샷에서 사용자가 빌드한 정적 데이터 파일로, 사용자가 CDN, 호스팅 서비스 또는 기타 솔루션에 게시합니다. 데이터 번들에는 클라이언트 앱에 제공하려는 문서 및 이를 생성한 쿼리에 대한 메타데이터가 모두 포함됩니다. 클라이언트 SDK를 사용하여 네트워크를 통해서 또는 로컬 스토리지에서 번들을 다운로드한 후 번들 데이터를 Cloud Firestore 로컬 캐시에 로드합니다. 번들이 로드되면 클라이언트 앱이 로컬 캐시 또는 백엔드에서 문서를 쿼리할 수 있습니다.

데이터 번들을 사용하면 Cloud Firestore 백엔드 호출 없이도 시작 시에 문서를 사용할 수 있으므로 앱에서 일반 쿼리 결과를 더 빨리 로드할 수 있습니다. 또한 결과가 로컬 캐시에서 로드되면 액세스 비용도 줄어들게 됩니다. 동일한 최초의 100개 문서를 쿼리하는 100만 개의 앱 인스턴스에 대해 비용을 지불하는 대신 해당하는 100개 문서를 번들로 만드는 데 필요한 쿼리에 대해서만 비용을 지불하면 됩니다.

Cloud Firestore 데이터 번들은 다른 Firebase 백엔드 제품과도 잘 작동하도록 빌드되었습니다. 번들이 Cloud Functions에서 빌드되고 Firebase Hosting을 통해 사용자에게 제공되는 통합 솔루션 [https://firebase.google.com/docs/firestore/solutions/serve-bundles?hl=ko]을 살펴보세요.

앱에 번들을 사용하려면 다음 3단계를 따르세요.

Admin SDK로 번들 빌드
로컬 스토리지 또는 CDN에서 번들 제공
클라이언트에 번들 로드

데이터 번들이란?

데이터 번들은 하나 이상의 문서 및 쿼리 스냅샷을 패키지로 만들기 위해 사용자가 빌드하고 이름이 지정된 쿼리를 추출할 수 있는 정적 바이너리 파일입니다. 아래 설명과 같이 서버 측 SDK를 사용하면 번들을 빌드할 수 있으며 클라이언트 SDK를 통해 번들을 로컬 캐시에 로드할 수 있습니다.

이름이 지정된 쿼리는 번들의 특히 강력한 기능 중 하나입니다. 이름이 지정된 쿼리는 번들에서 추출한 다음, 일반적으로 Cloud Firestore와 커뮤니케이션하는 앱의 특정 부분에서 쿼리하는 것과 같이 캐시나 백엔드에서 바로 데이터 쿼리에 사용할 수 있는 Query 객체입니다.

서버에서 데이터 번들 빌드

Node.js 또는 자바 Admin SDK [https://firebase.google.com/docs/admin/setup?hl=ko]를 사용하면 사용자가 번들에 포함할 항목과 제공 방법을 완벽하게 제어할 수 있습니다.
참고: 공개적으로 읽을 수 있는 데이터만 번들로 빌드해야 합니다. Admin SDK는 권한이 있는 사용자 역할을 하며 보안 규칙을 평가하지 않습니다. 따라서 사용자의 보안 규칙에 관계없이 모든 문서 또는 쿼리 데이터를 번들로 빌드합니다.

Node.js
Firestore db = FirestoreClient.getFirestore(app);

QuerySnapshot latestStories = db.collection("stories")
.orderBy("timestamp", Direction.DESCENDING)
.limit(50)
.get()
.get();

FirestoreBundle bundle = db.bundleBuilder("latest-stories")
.add("latest-stories-query", latestStories)
.build();

Python
from google.cloud import firestore
from google.cloud.firestore_bundle import FirestoreBundle

db = firestore.Client()
bundle = FirestoreBundle("latest-stories")

doc_snapshot = db.collection("stories").document("news-item").get()
query = db.collection("stories")._query()

# Build the bundle
# Note how `query` is named "latest-stories-query"
bundle_buffer: str = bundle.add_document(doc_snapshot).add_named_query(
"latest-stories-query", query,
).build()

데이터 번들 제공

Cloud Storage와 같은 서비스에서 번들을 다운로드하는 방식으로 또는 CDN에서 클라이언트 앱에 번들을 제공할 수 있습니다.

이전 섹션에서 만든 번들이 bundle.txt라는 파일에 저장되고 서버에 게시되었다고 가정해 보겠습니다. 이 번들 파일은 여기에서 설명한 간단한 Node.js Express 앱의 경우와 같이 웹을 통해 제공할 수 있는 기타 애셋과 유사합니다.

클라이언트에서 데이터 번들 로드

HTTP 요청, Storage API 호출 또는 네트워크에서 바이너리 파일을 가져오는 기타 기법 사용 여부에 관계없이 원격 서버에서 Firestore 번들을 가져와 로드할 수 있습니다.

가져온 후에는 Cloud Firestore 클라이언트 SDK를 사용해 앱에서 태스크 추적 개체를 반환하는 loadBundle 메서드를 호출하고, 반환된 객체를 통해 프로미스의 상태를 모니터링하는 것과 같이 완료 상태를 모니터링할 수 있습니다.
번들 로드 작업이 성공적으로 완료되면 로컬 캐시에서 번들 콘텐츠를 사용할 수 있습니다.

Web
import { loadBundle, namedQuery, getDocsFromCache } from "firebase/firestore";

async function fetchFromBundle() {

트리 쉐이킹 작업이 가능한 모듈식 웹 API 및 네임스페이스화된 API에 비해 갖는 이점에 대해 자세히 알아보세요 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version].
import "firebase/firestore";
import "firebase/firestore/bundle"; // This line enables bundle loading as a side effect.

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

NSInputStream *inputStream = [NSInputStream inputStreamWithURL:url];
if (inputStream == nil) {
NSError *error =
[self bundleLoadErrorWithReason:
[NSString stringWithFormat:@"Unable to create stream from the given url: %@", url]];
completion(nil, error);
return;
return;
NSError *concreteError =
[self bundleLoadErrorWithReason:
[NSString stringWithFormat:
@"Expected bundle load to be completed, but got %ld instead",
(long)progress.state]];
completion(nil, concreteError);
return;
NSString *errorReason =
[NSString stringWithFormat:@"Could not find query named %@", queryName];
NSError *error = [self bundleLoadErrorWithReason:errorReason];
completion(nil, error);
return;
NSString *queryName = @"latest-stories-query";
FIRFirestore *firestore = [FIRFirestore firestore];
NSURL *bundleURL = [NSURL URLWithString:@"https://example.com/createBundle"];
[self loadQueryNamed:queryName
fromRemoteBundleURL:bundleURL
withFirestore:firestore
completion:^(FIRQuery *query, NSError *error) {
@Throws(IOException::class)
fun getBundleStream(urlString: String?): InputStream {
val url = URL(urlString)
val connection = url.openConnection() as HttpURLConnection
return connection.inputStream

Log.w(TAG, "Bundle loading failed", task.exception)
return@addOnCompleteListener

public InputStream getBundleStream(String urlString) throws IOException {
URL url = new URL(urlString);
HttpURLConnection connection = (HttpURLConnection) url.openConnection();
return connection.getInputStream();
LoadBundleTask loadTask = db.loadBundle(bundleStream);

LoadBundleTaskProgress progress = task.getResult(Exception.class);

Query query = task.getResult(Exception.class);

Log.w(TAG, "Bundle loading failed", task.getException());
return;
QuerySnapshot storiesSnap = task.getResult();

final response = await http.get(url);
String body = response.body;
final buffer = Uint8List.fromList(body.codeUnits);

LoadBundleTask task = FirebaseFirestore.instance.loadBundle(buffer);
await task.stream.toList();

"latest-stories-query",
options: const GetOptions(
source: Source.cache,
),
firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L109-L126]

C++
db->LoadBundle("bundle_name", [](const LoadBundleTaskProgress& progress) {
switch(progress.state()) {
case LoadBundleTaskProgress::State::kError: {
break;