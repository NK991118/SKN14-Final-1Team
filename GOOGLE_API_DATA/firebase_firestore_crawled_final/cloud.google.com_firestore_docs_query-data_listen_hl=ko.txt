Source URL: https://cloud.google.com/firestore/docs/query-data/listen?hl=ko
Title: 실시간 업데이트 가져오기

의견 보내기

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

실시간 업데이트 가져오기

onSnapshot() 메서드로 문서를 리슨할 수 있습니다. 사용자가 제공하는 콜백이 최초로 호출될 때 단일 문서의 현재 콘텐츠로 문서 스냅샷이 즉시 생성됩니다. 그런 다음 콘텐츠가 변경될 때마다 콜백이 호출되어 문서 스냅샷을 업데이트합니다.참고: 실시간 리스너는 PHP 클라이언트 라이브러리에서 지원되지 않습니다.

웹 버전 9
import { doc, onSnapshot } from "firebase/firestore";

.onSnapshot((doc) => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

db.collection("cities").document("SF")
return
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[[self.db collectionWithPath:@"cities"] documentWithPath:@"SF"]
addSnapshotListener:^(FIRDocumentSnapshot *snapshot, NSError *error) {
if (snapshot == nil) {
NSLog(@"Error fetching document: %@", error);
return;
NSLog(@"Current data: %@", snapshot.data);
KotlinAndroid
val docRef = db.collection("cities").document("SF")
docRef.addSnapshotListener { snapshot, e ->
if (e != null) {
Log.w(TAG, "Listen failed.", e)
return@addSnapshotListener
docRef.addSnapshotListener(new EventListener<DocumentSnapshot>() {
@Override
public void onEvent(@Nullable DocumentSnapshot snapshot,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "Listen failed.", e);
return;
Log.d(TAG, "Current data: " + snapshot.getData());
Log.d(TAG, "Current data: null");
final docRef = db.collection("cities").doc("SF");
docRef.snapshots().listen(
(event) => print("current data: ${event.data()}"),
onError: (error) => print("Listen failed: $error"),
firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L525-L530]
종종 UI가 Firestore 문서 또는 컬렉션의 콘텐츠 변경사항에 반응하기를 원합니다. Firestore 스냅샷 스트림을 사용하는 StreamBuilder 위젯을 사용합니다.
class UserInformation extends StatefulWidget {
@override
_UserInformationState createState() => _UserInformationState();
FirebaseFirestore.instance.collection('users').snapshots();

@override
Widget build(BuildContext context) {
return StreamBuilder<QuerySnapshot>(
stream: _usersStream,
builder: (BuildContext context, AsyncSnapshot<QuerySnapshot> snapshot) {
if (snapshot.hasError) {
return const Text('Something went wrong');
children: snapshot.data!.docs
.map((DocumentSnapshot document) {
Map<String, dynamic> data =
subtitle: Text(data['company']),

DocumentReference docRef = db.collection("cities").document("SF");
docRef.addSnapshotListener(
new EventListener<DocumentSnapshot>() {
@Override
public void onEvent(@Nullable DocumentSnapshot snapshot, @Nullable FirestoreException e) {
if (e != null) {
System.err.println("Listen failed: " + e);
return;
System.out.println("Current data: " + snapshot.getData());
System.out.print("Current data: null");

# Create an Event for notifying main thread.
callback_done = threading.Event()

# Create a callback on_snapshot function to capture changes
def on_snapshot(doc_snapshot, changes, read_time):
for doc in doc_snapshot:
print(f"Received document snapshot: {doc.id}")
callback_done.set()

doc_ref = db.collection("cities").document("SF")

# Watch the document
doc_watch = doc_ref.on_snapshot(on_snapshot)snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/ef29ddd43c1e15bf25703c7991fe95392e951425/firestore/cloud-client/snippets.py#L676-L689]

C++
DocumentReference doc_ref = db->Collection("cities").Document("SF");
doc_ref.AddSnapshotListener(
[](const DocumentSnapshot& snapshot, Error error, const std::string& errorMsg) {
if (error == Error::kErrorOk) {
if (snapshot.exists()) {

import (
"context"
"fmt"
"io"
"time"

"cloud.google.com/go/firestore"
"google.golang.org/grpc/codes"
"google.golang.org/grpc/status"

client, err := firestore.NewClient(ctx, projectID)
if err != nil {
return fmt.Errorf("firestore.NewClient: %w", err)

it := client.Collection(collection).Doc("SF").Snapshots(ctx)
for {
snap, err := it.Next()
return nil
DocumentReference docRef = db.Collection("cities").Document("SF");
docRef.Listen(snapshot => {
Debug.Log("Callback received document snapshot.");
Debug.Log(String.Format("Document data for {0} document:", snapshot.Id));
Dictionary<string, object> city = snapshot.ToDictionary();
foreach (KeyValuePair<string, object> pair in city) {
Debug.Log(String.Format("{0}: {1}", pair.Key, pair.Value));

DocumentReference docRef = db.Collection("cities").Document("SF");
FirestoreChangeListener listener = docRef.Listen(snapshot =>
Dictionary<string, object> city = snapshot.ToDictionary();
foreach (KeyValuePair<string, object> pair in city)

doc_ref = firestore.col(collection_path).doc document_path
snapshots = []

# Watch the document.
listener = doc_ref.listen do |snapshot|
puts "Received document snapshot: #{snapshot.document_id}"
snapshots << snapshot
endquery_watch.rb [https://github.com/googleapis/google-cloud-ruby/blob/b053bba99aea863341b7a1c260e508c79f8eeb0a/google-cloud-firestore/samples/query_watch.rb#L24-L31]

로컬 변경 이벤트

앱에서 로컬로 쓰면 즉시 스냅샷 리스너가 호출됩니다.
이는 '지연 시간 보정'이라는 중요한 기능 때문입니다.
쓰기를 수행하면 데이터가 백엔드로 전송되기 전에 리스너에 새 데이터가 통보됩니다.

검색된 문서의 metadata.hasPendingWrites 속성은 문서에 아직 백엔드에 쓰기 처리되지 않은 로컬 변경사항이 있는지 여부를 나타냅니다. 이 속성을 사용하여 스냅샷 리스너가 수신한 이벤트의 소스를 확인할 수 있습니다.

웹 버전 9
import { doc, onSnapshot } from "firebase/firestore";

.onSnapshot((doc) => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

db.collection("cities").document("SF")
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[[self.db collectionWithPath:@"cities"] documentWithPath:@"SF"]
addSnapshotListener:^(FIRDocumentSnapshot *snapshot, NSError *error) {
if (snapshot == nil) {
NSLog(@"Error fetching document: %@", error);
return;
NSString *source = snapshot.metadata.hasPendingWrites ? @"Local" : @"Server";
NSLog(@"%@ data: %@", source, snapshot.data);
KotlinAndroid
val docRef = db.collection("cities").document("SF")
docRef.addSnapshotListener { snapshot, e ->
if (e != null) {
Log.w(TAG, "Listen failed.", e)
return@addSnapshotListener
docRef.addSnapshotListener(new EventListener<DocumentSnapshot>() {
@Override
public void onEvent(@Nullable DocumentSnapshot snapshot,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "Listen failed.", e);
return;
String source = snapshot != null && snapshot.getMetadata().hasPendingWrites()
? "Local" : "Server";

if (snapshot != null && snapshot.exists()) {
Log.d(TAG, source + " data: " + snapshot.getData());
Log.d(TAG, source + " data: null");
final docRef = db.collection("cities").doc("SF");
docRef.snapshots().listen(
(event) {
final source = (event.metadata.hasPendingWrites) ? "Local" : "Server";
print("$source data: ${event.data()}");
firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L536-L544]

자바
# Not yet supported in the Java client library

Python
DocumentReference doc_ref = db->Collection("cities").Document("SF");
doc_ref.AddSnapshotListener([](const DocumentSnapshot& snapshot,
Error error, const std::string& errorMsg) {
if (error == Error::kErrorOk) {
if (snapshot.exists()) {
std::cout << source << " data: " << snapshot.Get("name").string_value()
<< std::endl;
DocumentReference docRef = db.Collection("cities").Document("SF");
docRef.Listen(
snapshot =>
string source = (snapshot != null && snapshot.Metadata.HasPendingWrites) ? "Local" : "Server";
string snapshotData = "null";
if (snapshot != null && snapshot.Exists)
System.Text.StringBuilder builder = new System.Text.StringBuilder();
IDictionary<string, object> dict = snapshot.ToDictionary();
foreach (var KVPair in dict)
builder.Append($"{KVPair.Key}: {KVPair.Value}\n");
Debug.Log($"{source} data: ${snapshotData}");

(doc) => {
.onSnapshot({

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

.addSnapshotListener(includeMetadataChanges: true) { documentSnapshot, error in
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

KotlinAndroid
docRef.addSnapshotListener(MetadataChanges.INCLUDE) { snapshot, e ->
DocumentReference docRef = db.collection("cities").document("SF");
docRef.addSnapshotListener(MetadataChanges.INCLUDE, new EventListener<DocumentSnapshot>() {
@Override
public void onEvent(@Nullable DocumentSnapshot snapshot,
@Nullable FirebaseFirestoreException e) {
final docRef = db.collection("cities").doc("SF");
docRef.snapshots(includeMetadataChanges: true).listen((event) {
DocumentReference doc_ref = db->Collection("cities").Document("SF");
doc_ref.AddSnapshotListener(
MetadataChanges::kInclude,
[](const DocumentSnapshot& snapshot, Error error, const std::string& errorMsg) { /* ... */ });snippets.cpp [https://github.com/firebase/snippets-cpp/blob/778b6bcc8e8e8fcabb1c2e3a8d11ab51a26aa77b/firestore/android/FirestoreSnippetsCpp/app/src/main/cpp/snippets.cpp#L690-L693]

Node.js
DocumentReference docRef = db.Collection("cities").Document("SF");
docRef.Listen(MetadataChanges.Include, snapshot =>
Native 모드의 Firestore 스냅샷 리스너는 로컬 캐시에서 초기 스냅샷을 가져오고 동시에 서버에서 해당 데이터를 가져옵니다.

경우에 따라 서버에서 추가로 데이터 가져오기를 원하지 않을 수 있습니다. 클라이언트 SDK를 사용하면 로컬 캐시에 있는 데이터에 대해서만 리스너가 실행되도록 구성할 수 있습니다. 이렇게 하면 불필요한 서버 호출과 비용을 방지하고 로컬 데이터와 변형을 반영하는 클라이언트 측 캐시를 활용할 수 있습니다.

여기에서는 클라이언트 코드에서 스냅샷 옵션을 설정하여 로컬 변경 사항만 수신할 수 있도록 합니다.

웹 버전 9

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에서 업그레이드 [https://firebase.google.com/docs/web/modular-upgrade?hl=ko]하세요.
includeMetadataChanges: true,
source:'cache'

웹 버전 8

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에서 업그레이드 [https://firebase.google.com/docs/web/modular-upgrade?hl=ko]하세요.

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

.addSnapshotListener(options: options) { documentSnapshot, error in
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRSnapshotListenOptions *options = [[FIRSnapshotListenOptions alloc] init];
FIRSnapshotListenOptions *optionsWithSourceAndMetadata =
[[options optionsWithIncludeMetadataChanges:YES]

KotlinAndroid
.setMetadataChanges(MetadataChanges.INCLUDE)
.setSource(ListenSource.CACHE)
.build();
db.collection("cities").document("SF")
.addSnapshotListener(options) { snapshot, error ->
SnapshotListenOptions options = new SnapshotListenOptions.Builder()
.setMetadataChanges(MetadataChanges.INCLUDE)
.setSource(ListenSource.CACHE)
.build();
db.collection("cities").document("SF").addSnapshotListener(options, new EventListener<DocumentSnapshot>() {

.onSnapshot((querySnapshot) => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

db.collection("cities").whereField("state", isEqualTo: "CA")
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[[self.db collectionWithPath:@"cities"] queryWhereField:@"state" isEqualTo:@"CA"]
addSnapshotListener:^(FIRQuerySnapshot *snapshot, NSError *error) {
if (snapshot == nil) {
NSLog(@"Error fetching documents: %@", error);
return;
NSMutableArray *cities = [NSMutableArray array];
for (FIRDocumentSnapshot *document in snapshot.documents) {
[cities addObject:document.data[@"name"]];
NSLog(@"Current cities in CA: %@", cities);
KotlinAndroid
db.collection("cities")
.whereEqualTo("state", "CA")
Log.w(TAG, "Listen failed.", e)
return@addSnapshotListener
for (doc in value!!) {
doc.getString("name")?.let {
cities.add(it)
.whereEqualTo("state", "CA")
.addSnapshotListener(new EventListener<QuerySnapshot>() {
@Override
public void onEvent(@Nullable QuerySnapshot value,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "Listen failed.", e);
return;
List<String> cities = new ArrayList<>();
for (QueryDocumentSnapshot doc : value) {
if (doc.get("name") != null) {
cities.add(doc.getString("name"));
Log.d(TAG, "Current cites in CA: " + cities);
db
.collection("cities")
.where("state", isEqualTo: "CA")
.snapshots()
.listen((event) {
final cities = [];
for (var doc in event.docs) {
cities.add(doc.data()["name"]);
.whereEqualTo("state", "CA")
.addSnapshotListener(
new EventListener<QuerySnapshot>() {
@Override
public void onEvent(
@Nullable QuerySnapshot snapshots, @Nullable FirestoreException e) {
if (e != null) {
System.err.println("Listen failed:" + e);
return;
List<String> cities = new ArrayList<>();
for (DocumentSnapshot doc : snapshots) {
if (doc.get("name") != null) {
cities.add(doc.getString("name"));
System.out.println("Current cites in CA: " + cities);

# Create an Event for notifying main thread.
callback_done = threading.Event()

# Create a callback on_snapshot function to capture changes
def on_snapshot(col_snapshot, changes, read_time):
print("Callback received query snapshot.")
print("Current cities in California:")
for doc in col_snapshot:
print(f"{doc.id}")
callback_done.set()

col_query = db.collection("cities").where(filter=FieldFilter("state", "==", "CA"))

# Watch the collection query
query_watch = col_query.on_snapshot(on_snapshot)
snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/ef29ddd43c1e15bf25703c7991fe95392e951425/firestore/cloud-client/snippets.py#L712-L728]

C++
db->Collection("cities")
.WhereEqualTo("state", FieldValue::String("CA"))
.AddSnapshotListener([](const QuerySnapshot& snapshot, Error error, const std::string& errorMsg) {
if (error == Error::kErrorOk) {

import (
"context"
"fmt"
"io"
"time"

"cloud.google.com/go/firestore"
"google.golang.org/api/iterator"
"google.golang.org/grpc/codes"
"google.golang.org/grpc/status"

client, err := firestore.NewClient(ctx, projectID)
if err != nil {
return fmt.Errorf("firestore.NewClient: %w", err)

it := client.Collection(collection).Where [https://cloud.google.com/go/docs/reference/cloud.google.com/go/firestore/latest/index.html?hl=ko#cloud_google_com_go_firestore_Query_Where]("state", "==", "CA").Snapshots(ctx)
for {
snap, err := it.Next()
Query query = db.Collection("cities").WhereEqualTo("State", "CA");

ListenerRegistration listener = query.Listen(snapshot => {
Debug.Log("Callback received query snapshot.");
Debug.Log("Current cities in California:");
foreach (DocumentSnapshot documentSnapshot in snapshot.Documents) {
Debug.Log(documentSnapshot.Id);

CollectionReference citiesRef = db.Collection("cities");
Query query = db.Collection("cities").WhereEqualTo("State", "CA");

FirestoreChangeListener listener = query.Listen(snapshot =>

query = firestore.col(collection_path).where :state, :==, "CA"
docs = []

# Watch the collection query.
listener = query.listen do |snapshot|
puts "Callback received query snapshot."
puts "Current cities in California:"
snapshot.docs.each do |doc|
puts doc.document_id
docs << doc
end
endquery_watch.rb [https://github.com/googleapis/google-cloud-ruby/blob/b053bba99aea863341b7a1c260e508c79f8eeb0a/google-cloud-firestore/samples/query_watch.rb#L146-L157]

스냅샷 핸들러는 문서의 추가, 삭제, 수정 등 쿼리 결과가 변경될 때마다 새 쿼리 스냅샷을 수신합니다.
중요: 위 로컬 변경 이벤트 [https://cloud.google.com/firestore/native/docs/query-data/listen?hl=ko#events-local-changes]의 설명대로 로컬 쓰기에 대한 이벤트는 즉시 수신됩니다. 리스너는 각 문서의 metadata.hasPendingWrites 필드를 사용하여 문서에 아직 백엔드에 쓰기 처리되지 않은 로컬 변경사항이 있는지 확인할 수 있습니다.
스냅샷 간 변경사항 보기

단순히 전체 쿼리 스냅샷을 사용하는 대신 쿼리 스냅샷 간에 실제로 변경된 쿼리 결과를 확인하는 것이 유용한 경우가 많습니다. 예를 들어 개별 문서가 추가, 삭제, 수정될 때 캐시를 유지해야 할 수 있습니다.

웹 버전 9
import { collection, query, where, onSnapshot } from "firebase/firestore";

.onSnapshot((snapshot) => {
snapshot.docChanges().forEach((change) => {
if (change.type === "added") {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

db.collection("cities").whereField("state", isEqualTo: "CA")
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[[self.db collectionWithPath:@"cities"] queryWhereField:@"state" isEqualTo:@"CA"]
addSnapshotListener:^(FIRQuerySnapshot *snapshot, NSError *error) {
if (snapshot == nil) {
NSLog(@"Error fetching documents: %@", error);
return;
NSLog(@"New city: %@", diff.document.data);
NSLog(@"Modified city: %@", diff.document.data);
NSLog(@"Removed city: %@", diff.document.data);
KotlinAndroid
db.collection("cities")
.whereEqualTo("state", "CA")
.whereEqualTo("state", "CA")
.addSnapshotListener(new EventListener<QuerySnapshot>() {
@Override
public void onEvent(@Nullable QuerySnapshot snapshots,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "listen:error", e);
return;
Log.d(TAG, "New city: " + dc.getDocument().getData());
break;
case MODIFIED:
Log.d(TAG, "Modified city: " + dc.getDocument().getData());
break;
case REMOVED:
Log.d(TAG, "Removed city: " + dc.getDocument().getData());
break;
db
.collection("cities")
.where("state", isEqualTo: "CA")
.snapshots()
.listen((event) {
for (var change in event.docChanges) {
switch (change.type) {
case DocumentChangeType.added:
print("New City: ${change.doc.data()}");
break;
case DocumentChangeType.modified:
print("Modified City: ${change.doc.data()}");
break;
case DocumentChangeType.removed:
print("Removed City: ${change.doc.data()}");
break;
.whereEqualTo("state", "CA")
.addSnapshotListener(
new EventListener<QuerySnapshot>() {
@Override
public void onEvent(
@Nullable QuerySnapshot snapshots, @Nullable FirestoreException e) {
if (e != null) {
System.err.println("Listen failed: " + e);
return;
System.out.println("New city: " + dc.getDocument().getData());
break;
case MODIFIED:
System.out.println("Modified city: " + dc.getDocument().getData());
break;
case REMOVED:
System.out.println("Removed city: " + dc.getDocument().getData());
break;
default:
break;
db->Collection("cities")
.WhereEqualTo("state", FieldValue::String("CA"))
.AddSnapshotListener([](const QuerySnapshot& snapshot, Error error, const std::string& errorMsg) {
if (error == Error::kErrorOk) {
for (const DocumentChange& dc : snapshot.DocumentChanges()) {
switch (dc.type()) {
case DocumentChange::Type::kAdded:
std::cout << "New city: "
<< dc.document().Get("name").string_value() << std::endl;
break;
case DocumentChange::Type::kModified:
std::cout << "Modified city: "
<< dc.document().Get("name").string_value() << std::endl;
break;
case DocumentChange::Type::kRemoved:
std::cout << "Removed city: "
<< dc.document().Get("name").string_value() << std::endl;
break;

# Create an Event for notifying main thread.
delete_done = threading.Event()

# Create a callback on_snapshot function to capture changes
def on_snapshot(col_snapshot, changes, read_time):
print("Callback received query snapshot.")
print("Current cities in California: ")
for change in changes:
if change.type.name == "ADDED":
print(f"New city: {change.document.id}")
elif change.type.name == "MODIFIED":
print(f"Modified city: {change.document.id}")
elif change.type.name == "REMOVED":
print(f"Removed city: {change.document.id}")
delete_done.set()

col_query = db.collection("cities").where(filter=FieldFilter("state", "==", "CA"))

# Watch the collection query
query_watch = col_query.on_snapshot(on_snapshot)
snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/ef29ddd43c1e15bf25703c7991fe95392e951425/firestore/cloud-client/snippets.py#L747-L768]

Node.js

import (
"context"
"fmt"
"io"
"time"

"cloud.google.com/go/firestore"
"google.golang.org/grpc/codes"
"google.golang.org/grpc/status"

client, err := firestore.NewClient(ctx, projectID)
if err != nil {
return fmt.Errorf("firestore.NewClient: %w", err)

it := client.Collection(collection).Where [https://cloud.google.com/go/docs/reference/cloud.google.com/go/firestore/latest/index.html?hl=ko#cloud_google_com_go_firestore_Query_Where]("state", "==", "CA").Snapshots(ctx)
for {
snap, err := it.Next()
Query query = db.Collection("cities").WhereEqualTo("State", "CA");

ListenerRegistration listener = query.Listen(snapshot =>
foreach (DocumentChange change in snapshot.GetChanges())
if (change.ChangeType == DocumentChange.Type.Added)
Debug.Log(String.Format("New city: {0}", change.Document.Id));
Debug.Log(String.Format("Modified city: {0}", change.Document.Id));
Debug.Log(String.Format("Removed city: {0}", change.Document.Id));

CollectionReference citiesRef = db.Collection("cities");
Query query = db.Collection("cities").WhereEqualTo("State", "CA");

FirestoreChangeListener listener = query.Listen(snapshot =>
foreach (DocumentChange change in snapshot.Changes)
if (change.ChangeType.ToString() == "Added")

query = firestore.col(collection_path).where :state, :==, "CA"
added = []
modified = []
removed = []

# Watch the collection query.
listener = query.listen do |snapshot|
puts "Callback received query snapshot."
puts "Current cities in California:"
snapshot.changes.each do |change|
if change.added?
puts "New city: #{change.doc.document_id}"
added << snapshot
elsif change.modified?
puts "Modified city: #{change.doc.document_id}"
modified << snapshot
elsif change.removed?
puts "Removed city: #{change.doc.document_id}"
removed << snapshot
end
end
endquery_watch.rb [https://github.com/googleapis/google-cloud-ruby/blob/b053bba99aea863341b7a1c260e508c79f8eeb0a/google-cloud-firestore/samples/query_watch.rb#L59-L80]

중요: 첫 번째 쿼리 스냅샷은 쿼리와 일치하는 모든 기존 문서에 대한 added 이벤트를 포함합니다. 쿼리의 초기 상태를 기준으로 쿼리 스냅샷을 현재 상태로 만든 변경사항 집합을 가져오기 때문입니다. 따라서 초기 상태를 처리하는 특수한 로직을 추가할 필요 없이 첫 번째 쿼리 스냅샷으로 수신된 변경사항에 따라 직접 UI에 데이터를 채울 수 있습니다.
초기 상태는 서버에서 직접 가져오거나 로컬 캐시에서 가져올 수 있습니다. 로컬 캐시에 사용 가능한 상태가 있으면 쿼리 스냅샷에 우선 캐시된 데이터가 채워진 후, 클라이언트에서 서버의 상태를 따라잡았을 때 서버의 데이터로 업데이트됩니다.

리스너 분리

더 이상 데이터를 리슨할 필요가 없으면 이벤트 콜백이 호출되지 않도록 리스너를 분리해야 합니다. 이렇게 하면 클라이언트에서 업데이트 수신을 위한 대역폭 사용을 중지합니다. 예를 들면 다음과 같습니다.

웹 버전 9
import { collection, onSnapshot } from "firebase/firestore";

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

id<FIRListenerRegistration> listener = [[self.db collectionWithPath:@"cities"]
addSnapshotListener:^(FIRQuerySnapshot *snapshot, NSError *error) {
KotlinAndroid
val query = db.collection("cities")
val registration = query.addSnapshotListener { snapshots, e ->
Query query = db.collection("cities");
ListenerRegistration registration = query.addSnapshotListener(
new EventListener<QuerySnapshot>() {
final collection = db.collection("cities");
final listener = collection.snapshots().listen((event) {
Query query = db.collection("cities");
ListenerRegistration registration =
query.addSnapshotListener(
new EventListener<QuerySnapshot>() {

# Terminate watch on a document
doc_watch.unsubscribe()snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/ef29ddd43c1e15bf25703c7991fe95392e951425/firestore/cloud-client/snippets.py#L704-L705]

C++
Query query = db->Collection("cities");
ListenerRegistration registration = query.AddSnapshotListener(
[](const QuerySnapshot& snapshot, Error error, const std::string& errorMsg) { /* ... */ });

listener.Stop();

C#

await listener.StopAsync();Program.cs [https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/1f64cab92543aa6daaa1ba04f073e4f1cf239047/firestore/api/ListenData/Program.cs#L73-L73]

Ruby

listener.stopquery_watch.rb [https://github.com/googleapis/google-cloud-ruby/blob/b053bba99aea863341b7a1c260e508c79f8eeb0a/google-cloud-firestore/samples/query_watch.rb#L49-L49]

수신 대기 오류 처리

보안 권한이 부족하거나 잘못된 쿼리를 리슨하는 등의 경우에 리슨이 실패할 수 있습니다. 올바른 쿼리 및 잘못된 쿼리 [https://cloud.google.com/firestore/native/docs/query-data/queries?hl=ko#compound_queries]에 대해 자세히 알아보세요. 이러한 오류를 처리하려면 스냅샷 리스너를 연결할 때 오류 콜백을 제공합니다. 오류가 발생하면 리스너는 이벤트를 더 이상 수신하지 않으므로 리스너를 분리할 필요는 없습니다.

웹 버전 9
import { collection, onSnapshot } from "firebase/firestore";

(snapshot) => {
.onSnapshot((snapshot) => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

db.collection("cities")
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[self.db collectionWithPath:@"cities"]
addSnapshotListener:^(FIRQuerySnapshot *snapshot, NSError *error) {
if (error != nil) {
NSLog(@"Error retreving collection: %@", error);
KotlinAndroid
db.collection("cities")
.addSnapshotListener(new EventListener<QuerySnapshot>() {
@Override
public void onEvent(@Nullable QuerySnapshot snapshots,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "listen:error", e);
return;
Log.d(TAG, "New city: " + dc.getDocument().getData());
final docRef = db.collection("cities");
docRef.snapshots().listen(
(event) => print("listener attached"),
onError: (error) => print("Listen failed: $error"),
);firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L609-L613]

자바

db.collection("cities")
.addSnapshotListener(
new EventListener<QuerySnapshot>() {
@Override
public void onEvent(
@Nullable QuerySnapshot snapshots, @Nullable FirestoreException e) {
if (e != null) {
System.err.println("Listen failed: " + e);
return;
System.out.println("New city: " + dc.getDocument().getData());

db.collection('cities')
.onSnapshot((snapshot) => {

import (
"context"
"fmt"
"io"
"time"

"cloud.google.com/go/firestore"
"google.golang.org/grpc/codes"
"google.golang.org/grpc/status"

client, err := firestore.NewClient(ctx, projectID)
if err != nil {
return fmt.Errorf("firestore.NewClient: %w", err)

it := client.Collection(collection).Snapshots(ctx)
for {
snap, err := it.Next()
ListenerRegistration registration =
db.Collection("cities").Listen(
querySnapshot =>
listenerTask =>
if (listenerTask.IsFaulted)
Debug.LogError($"Listen failed: {listenerTask.Exception}");

listener = firestore.col(collection_path).listen do |snapshot|
snapshot.changes.each do |change|
puts "New city: #{change.doc.document_id}" if change.added?
end
end

# Register to be notified when unhandled errors occur.
listener.on_error do |error|
puts "Listen failed: #{error.message}"
endquery_watch.rb [https://github.com/googleapis/google-cloud-ruby/blob/b053bba99aea863341b7a1c260e508c79f8eeb0a/google-cloud-firestore/samples/query_watch.rb#L125-L134]

다음 단계

리스너에 간단한 쿼리 및 복합 쿼리 결합 [https://cloud.google.com/firestore/native/docs/query-data/queries?hl=ko]
검색된 문서 정렬 및 제한 [https://cloud.google.com/firestore/native/docs/query-data/order-limit-data?hl=ko]
리스너의 결제 이해 [https://cloud.google.com/firestore/native/docs/pricing?hl=ko#operations]

의견 보내기