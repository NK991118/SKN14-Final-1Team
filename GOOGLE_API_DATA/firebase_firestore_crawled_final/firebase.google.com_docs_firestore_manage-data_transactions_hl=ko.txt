Source URL: https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ko
Title: 트랜잭션 및 일괄 쓰기

의견 보내기

트랜잭션 및 일괄 쓰기

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Cloud Firestore는 데이터의 원자적 읽기 및 쓰기 작업을 지원합니다. 원자적 작업 집합에서는 모든 작업이 성공하거나 아니면 모두 적용되지 않습니다. Cloud Firestore에는 다음과 같은 두 가지 유형의 원자적 작업이 있습니다.

트랜잭션: 트랜잭션 [https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ko#transactions]이란 1개 이상의 문서에 대한 읽기 및 쓰기 작업의 집합입니다.
일괄 쓰기: 일괄 쓰기 [https://firebase.google.com/docs/firestore/manage-data/transactions?hl=ko#batched-writes]란 1개 이상의 문서에 대한 쓰기 작업의 집합입니다.

트랜잭션을 사용한 데이터 업데이트

Cloud Firestore 클라이언트 라이브러리를 사용하여 작업 여러 개를 단일 트랜잭션으로 그룹화할 수 있습니다. 트랜잭션은 한 필드의 값을 현재 값 또는 다른 필드의 값에 따라 업데이트하려는 경우에 유용합니다.

트랜잭션은 get() 작업 여러 개와 이어서 수행되는 set(), update(), delete()와 같은 쓰기 작업 여러 개로 구성됩니다. 동시 수정의 경우 Cloud Firestore는 전체 트랜잭션을 다시 실행합니다. 예를 들어 한 트랜잭션에서 문서를 읽고 다른 클라이언트가 이 문서를 수정할 경우 Cloud Firestore는 이 트랜잭션을 다시 시도합니다. 이 기능을 통해 트랜잭션이 일관된 최신 데이터로 실행됩니다.

트랜잭션은 쓰기를 부분적으로 적용하지 않습니다. 모든 쓰기는 트랜잭션을 성공적으로 마칠 때 실행됩니다.

트랜잭션을 사용할 때는 다음을 참고하세요.

읽기 작업은 쓰기 작업 전에 이루어져야 합니다.
트랜잭션에서 읽는 문서에서 동시에 수정이 이뤄지는 경우 트랜잭션을 호출하는 함수(트랜잭션 함수)가 여러 번 실행될 수 있습니다.
트랜잭션 함수가 애플리케이션 상태를 직접 수정하면 안 됩니다.
클라이언트가 오프라인 상태면 트랜잭션이 실패합니다.

다음 예에서는 트랜잭션을 만들고 실행하는 방법을 보여줍니다.

Web
import { runTransaction } from "firebase/firestore";

try {
await runTransaction(db, async (transaction) => {

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

return nil
return nil
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRDocumentReference *sfReference =
[[self.db collectionWithPath:@"cities"] documentWithPath:@"SF"];
[self.db runTransactionWithBlock:^id (FIRTransaction *transaction, NSError **errorPointer) {
FIRDocumentSnapshot *sfDocument = [transaction getDocument:sfReference error:errorPointer];
if (*errorPointer != nil) { return nil; }

if (![sfDocument.data[@"population"] isKindOfClass:[NSNumber class]]) {
*errorPointer = [NSError errorWithDomain:@"AppErrorDomain" code:-1 userInfo:@{
NSLocalizedDescriptionKey: @"Unable to retreive population from snapshot"
NSInteger oldPopulation = [sfDocument.data[@"population"] integerValue];

return nil;
NSLog(@"Transaction failed: %@", error);
NSLog(@"Transaction successfully committed!");
val sfDocRef = db.collection("cities").document("SF")

db.runTransaction { transaction ->
val snapshot = transaction.get(sfDocRef)

transaction.update(sfDocRef, "population", newPopulation)

final DocumentReference sfDocRef = db.collection("cities").document("SF");

db.runTransaction(new Transaction.Function<Void>() {
@Override
public Void apply(@NonNull Transaction transaction) throws FirebaseFirestoreException {
DocumentSnapshot snapshot = transaction.get(sfDocRef);

transaction.update(sfDocRef, "population", newPopulation);

Log.d(TAG, "Transaction success!");
Log.w(TAG, "Transaction failure.", e);
final sfDocRef = db.collection("cities").doc("SF");
db.runTransaction((transaction) async {
final snapshot = await transaction.get(sfDocRef);
transaction.update(sfDocRef, {"population": newPopulation});

City city = new City("SF");
city.setCountry("USA");
city.setPopulation(860000L);
docRef.set(city).get();

ApiFuture<Void> futureTransaction =
db.runTransaction(
transaction -> {
DocumentSnapshot snapshot = transaction.get(docRef).get();
long oldPopulation = snapshot.getLong("population");
transaction.update(docRef, "population", oldPopulation + 1);
return null;

transaction = db.transaction()
city_ref = db.collection("cities").document("SF")

@firestore.transactional
def update_in_transaction(transaction, city_ref):
snapshot = city_ref.get(transaction=transaction)
transaction.update(city_ref, {"population": snapshot.get("population") + 1})

update_in_transaction(transaction, city_ref)snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/snippets.py#L395-L403]

Python

transaction = db.transaction()
city_ref = db.collection("cities").document("SF")

@firestore.async_transactional
async def update_in_transaction(transaction, city_ref):
snapshot = await city_ref.get(transaction=transaction)
transaction.update(city_ref, {"population": snapshot.get("population") + 1})

await update_in_transaction(transaction, city_ref)snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/snippets.py#L389-L397]

C++
DocumentReference sf_doc_ref = db->Collection("cities").Document("SF");
db->RunTransaction([sf_doc_ref](Transaction& transaction,
std::string& out_error_message) -> Error {
Error error = Error::kErrorOk;

DocumentSnapshot snapshot =
transaction.Get(sf_doc_ref, &error, &out_error_message);

transaction.Update(
sf_doc_ref,

return Error::kErrorOk;

import (
"context"
"log"

"cloud.google.com/go/firestore"

func runSimpleTransaction(ctx context.Context, client *firestore.Client) error {

$cityRef = $db->collection('samples/php/cities')->document('SF');
$db->runTransaction(function (Transaction $transaction) use ($cityRef) {
$snapshot = $transaction->snapshot($cityRef);
$newPopulation = $snapshot['population'] + 1;
$transaction->update($cityRef, [
['path' => 'population', 'value' => $newPopulation]
]);
DocumentReference cityRef = db.Collection("cities").Document("SF");
db.RunTransactionAsync(transaction =>
return transaction.GetSnapshotAsync(cityRef).ContinueWith((snapshotTask) =>
DocumentSnapshot snapshot = snapshotTask.Result;
long newPopulation = snapshot.GetValue<long>("Population") + 1;
Dictionary<string, object> updates = new Dictionary<string, object>

DocumentReference cityRef = db.Collection("cities").Document("SF");
await db.RunTransactionAsync(async transaction =>
DocumentSnapshot snapshot = await transaction.GetSnapshotAsync(cityRef);
long newPopulation = snapshot.GetValue<long>("Population") + 1;
Dictionary<string, object> updates = new Dictionary<string, object>

city_ref = firestore.doc "#{collection_path}/SF"

firestore.transaction do |tx|
new_population = tx.get(city_ref).data[:population] + 1
puts "New population is #{new_population}."
tx.update city_ref, { population: new_population }
endtransactions_and_batched_writes.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/transactions_and_batched_writes.rb#L23-L29]

트랜잭션 외부에서 정보 전달

트랜잭션 함수에서 애플리케이션 상태를 수정하면 안 됩니다. 수정 시 트랜잭션 함수가 여러 번 실행될 수 있고 UI 스레드에서의 실행이 보장되지 않아 동시 실행 문제가 발생합니다. 대신 트랜잭션 함수 외부에서 필요한 정보를 전달하세요. 다음 예는 이전 예를 바탕으로 빌드한 것으로, 트랜잭션 외부에서 정보를 전달하는 방법을 보여줍니다.

Web
import { doc, runTransaction } from "firebase/firestore";

return newPop;

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.
return newPopulation;

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

return nil
return nil
return nil
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRDocumentReference *sfReference =
[[self.db collectionWithPath:@"cities"] documentWithPath:@"SF"];
[self.db runTransactionWithBlock:^id (FIRTransaction *transaction, NSError **errorPointer) {
FIRDocumentSnapshot *sfDocument = [transaction getDocument:sfReference error:errorPointer];
if (*errorPointer != nil) { return nil; }

if (![sfDocument.data[@"population"] isKindOfClass:[NSNumber class]]) {
*errorPointer = [NSError errorWithDomain:@"AppErrorDomain" code:-1 userInfo:@{
NSLocalizedDescriptionKey: @"Unable to retreive population from snapshot"
NSInteger population = [sfDocument.data[@"population"] integerValue];

population++;
if (population >= 1000000) {
*errorPointer = [NSError errorWithDomain:@"AppErrorDomain" code:-2 userInfo:@{
NSLocalizedDescriptionKey: @"Population too big"

return nil;
NSLog(@"Transaction failed: %@", error);
NSLog(@"Population increased to %@", result);
val sfDocRef = db.collection("cities").document("SF")

db.runTransaction { transaction ->
val snapshot = transaction.get(sfDocRef)
val newPopulation = snapshot.getDouble("population")!! + 1
if (newPopulation <= 1000000) {
transaction.update(sfDocRef, "population", newPopulation)
newPopulation
"Population too high",
FirebaseFirestoreException.Code.ABORTED,
Log.w(TAG, "Transaction failure.", e)
final DocumentReference sfDocRef = db.collection("cities").document("SF");

db.runTransaction(new Transaction.Function<Double>() {
@Override
public Double apply(@NonNull Transaction transaction) throws FirebaseFirestoreException {
DocumentSnapshot snapshot = transaction.get(sfDocRef);
double newPopulation = snapshot.getDouble("population") + 1;
if (newPopulation <= 1000000) {
transaction.update(sfDocRef, "population", newPopulation);
return newPopulation;
FirebaseFirestoreException.Code.ABORTED);
Log.d(TAG, "Transaction success: " + result);
Log.w(TAG, "Transaction failure.", e);
final sfDocRef = db.collection("cities").doc("SF");
db.runTransaction((transaction) {
return transaction.get(sfDocRef).then((sfDoc) {
final newPopulation = sfDoc.get("population") + 1;
transaction.update(sfDocRef, {"population": newPopulation});
return newPopulation;

final DocumentReference docRef = db.collection("cities").document("SF");
ApiFuture<String> futureTransaction =
db.runTransaction(
transaction -> {
DocumentSnapshot snapshot = transaction.get(docRef).get();
Long newPopulation = snapshot.getLong("population") + 1;
return "Population increased to " + newPopulation;

transaction = db.transaction()
city_ref = db.collection("cities").document("SF")

@firestore.transactional
def update_in_transaction(transaction, city_ref):
snapshot = city_ref.get(transaction=transaction)
new_population = snapshot.get("population") + 1

if new_population < 1000000:
transaction.update(city_ref, {"population": new_population})
return True
else:
return False

result = update_in_transaction(transaction, city_ref)
if result:
print("Population updated")
else:
print("Sorry! Population is too big.")snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/snippets.py#L410-L428]

Python

transaction = db.transaction()
city_ref = db.collection("cities").document("SF")

@firestore.async_transactional
async def update_in_transaction(transaction, city_ref):
snapshot = await city_ref.get(transaction=transaction)
new_population = snapshot.get("population") + 1

if new_population < 1000000:
transaction.update(city_ref, {"population": new_population})
return True
else:
return False

result = await update_in_transaction(transaction, city_ref)
if result:
print("Population updated")
else:
print("Sorry! Population is too big.")snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/snippets.py#L404-L422]

C++

return `Population increased to ${newPopulation}`;

import (
"context"
"errors"
"log"

"cloud.google.com/go/firestore"

func infoTransaction(ctx context.Context, client *firestore.Client) (int64, error) {

$cityRef = $db->collection('samples/php/cities')->document('SF');
$transactionResult = $db->runTransaction(function (Transaction $transaction) use ($cityRef) {
$snapshot = $transaction->snapshot($cityRef);
$newPopulation = $snapshot['population'] + 1;
if ($newPopulation <= 1000000) {
$transaction->update($cityRef, [
['path' => 'population', 'value' => $newPopulation]
]);
return true;
DocumentReference cityRef = db.Collection("cities").Document("SF");
db.RunTransactionAsync(transaction =>
return transaction.GetSnapshotAsync(cityRef).ContinueWith((task) =>
long newPopulation = task.Result.GetValue<long>("Population") + 1;
if (newPopulation <= 1000000)
Dictionary<string, object> updates = new Dictionary<string, object>
return true;
return false;

DocumentReference cityRef = db.Collection("cities").Document("SF");
bool transactionResult = await db.RunTransactionAsync(async transaction =>
DocumentSnapshot snapshot = await transaction.GetSnapshotAsync(cityRef);
long newPopulation = snapshot.GetValue<long>("Population") + 1;
if (newPopulation <= 1000000)
Dictionary<string, object> updates = new Dictionary<string, object>
return true;
return false;

city_ref = firestore.doc "#{collection_path}/SF"

updated = firestore.transaction do |tx|
new_population = tx.get(city_ref).data[:population] + 1
if new_population < 1_000_000
tx.update city_ref, { population: new_population }
true
end
end

if updated
puts "Population updated!"
else
puts "Sorry! Population is too big."
endtransactions_and_batched_writes.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/transactions_and_batched_writes.rb#L40-L54]

트랜잭션 실패

트랜잭션에 실패하는 이유는 다음과 같습니다.

트랜잭션에서 쓰기 작업 다음에 읽기 작업이 포함되어 있습니다.
읽기 작업은 항상 쓰기 작업 전에 이루어져야 합니다.
트랜잭션이 트랜잭션 외부에서 수정된 문서를 읽습니다.
이 경우 트랜잭션이 자동으로 다시 실행됩니다. 트랜잭션은 제한된 횟수만큼 다시 시도됩니다.
트랜잭션이 최대 요청 크기인 10MiB를 초과했습니다.

트랜잭션 크기는 문서의 크기 및 트랜잭션에 의해 수정된 색인 항목에 따라 다릅니다. 삭제 작업의 경우 이 크기에는 대상 문서의 크기와 작업에 대한 응답으로 삭제된 색인 항목의 크기가 포함됩니다.

실패한 트랜잭션은 오류를 반환하며 데이터베이스에 아무것도 쓰지 않습니다. 트랜잭션을 롤백할 필요는 없습니다. Cloud Firestore에서 자동으로 수행됩니다.

일괄 쓰기

작업 집합에서 문서를 읽을 필요가 없는 경우 set(), update() 또는 delete() 작업의 조합을 포함하는 단일 배치로 여러 쓰기 작업을 실행할 수 있습니다.
각 작업은 Cloud Firestore 사용량에 별도로 포함됩니다. 쓰기 배치는 원자적으로 완료되며 여러 문서에 쓸 수 있습니다. 다음 예시에서는 쓰기 배치를 빌드하고 커밋하는 방법을 보여줍니다.

Web
import { writeBatch, doc } from "firebase/firestore";

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

print("Batch write succeeded.")
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRWriteBatch *batch = [self.db batch];

FIRDocumentReference *nycRef =
[[self.db collectionWithPath:@"cities"] documentWithPath:@"NYC"];
[batch setData:@{} forDocument:nycRef];

FIRDocumentReference *sfRef =
[[self.db collectionWithPath:@"cities"] documentWithPath:@"SF"];
[batch updateData:@{ @"population": @1000000 } forDocument:sfRef];

FIRDocumentReference *laRef =
[[self.db collectionWithPath:@"cities"] documentWithPath:@"LA"];
[batch deleteDocument:laRef];

NSLog(@"Error writing batch %@", error);
NSLog(@"Batch write succeeded.");
val nycRef = db.collection("cities").document("NYC")
val sfRef = db.collection("cities").document("SF")
val laRef = db.collection("cities").document("LA")

WriteBatch batch = db.batch();

DocumentReference nycRef = db.collection("cities").document("NYC");
batch.set(nycRef, new City());

DocumentReference sfRef = db.collection("cities").document("SF");
batch.update(sfRef, "population", 1000000L);

DocumentReference laRef = db.collection("cities").document("LA");
batch.delete(laRef);

WriteBatch batch = db.batch();

DocumentReference nycRef = db.collection("cities").document("NYC");
batch.set(nycRef, new City());

DocumentReference sfRef = db.collection("cities").document("SF");
batch.update(sfRef, "population", 1000000L);

DocumentReference laRef = db.collection("cities").document("LA");
batch.delete(laRef);

ApiFuture<List<WriteResult>> future = batch.commit();
System.out.println("Update time : " + result.getUpdateTime());

batch = db.batch()

# Set the data for NYC
nyc_ref = db.collection("cities").document("NYC")
batch.set(nyc_ref, {"name": "New York City"})

# Update the population for SF
sf_ref = db.collection("cities").document("SF")
batch.update(sf_ref, {"population": 1000000})

# Delete DEN
den_ref = db.collection("cities").document("DEN")
batch.delete(den_ref)

# Commit the batch
batch.commit()snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-client/snippets.py#L435-L450]

Python

batch = db.batch()

# Set the data for NYC
nyc_ref = db.collection("cities").document("NYC")
batch.set(nyc_ref, {"name": "New York City"})

# Update the population for SF
sf_ref = db.collection("cities").document("SF")
batch.update(sf_ref, {"population": 1000000})

# Delete DEN
den_ref = db.collection("cities").document("DEN")
batch.delete(den_ref)

# Commit the batch
await batch.commit()snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/467a34a26759d8aeac5f379fbc767854fc238e1e/firestore/cloud-async-client/snippets.py#L429-L444]

C++
WriteBatch batch = db->batch();

DocumentReference nyc_ref = db->Collection("cities").Document("NYC");
batch.Set(nyc_ref, {});

DocumentReference sf_ref = db->Collection("cities").Document("SF");
batch.Update(sf_ref, {{"population", FieldValue::Integer(1000000)}});

DocumentReference la_ref = db->Collection("cities").Document("LA");
batch.Delete(la_ref);

import (
"context"
"log"

"cloud.google.com/go/firestore"

func batchWrite(ctx context.Context, client *firestore.Client) error {

$batch = $db->batch();

# Set the data for NYC
$nycRef = $db->collection('samples/php/cities')->document('NYC');
$batch->set($nycRef, [
'name' => 'New York City'
]);

# Update the population for SF
$sfRef = $db->collection('samples/php/cities')->document('SF');
$batch->update($sfRef, [
['path' => 'population', 'value' => 1000000]
]);

# Delete LA
$laRef = $db->collection('samples/php/cities')->document('LA');
$batch->delete($laRef);

# Commit the batch
$batch->commit();data_batch_writes.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/fb4e5fc6398145491c6197344849d9caeac33811/firestore/src/data_batch_writes.php#L40-L59]

Unity
WriteBatch batch = db.StartBatch();

DocumentReference nycRef = db.Collection("cities").Document("NYC");
Dictionary<string, object> nycData = new Dictionary<string, object>

DocumentReference sfRef = db.Collection("cities").Document("SF");
Dictionary<string, object> updates = new Dictionary<string, object>

DocumentReference laRef = db.Collection("cities").Document("LA");
batch.Delete(laRef);

C#

WriteBatch batch = db.StartBatch();

DocumentReference nycRef = db.Collection("cities").Document("NYC");
Dictionary<string, object> nycData = new Dictionary<string, object>

DocumentReference sfRef = db.Collection("cities").Document("SF");
Dictionary<string, object> updates = new Dictionary<string, object>

DocumentReference laRef = db.Collection("cities").Document("LA");
batch.Delete(laRef);

firestore.batch do |b|
# Set the data for NYC
b.set "#{collection_path}/NYC", { name: "New York City" }

# Update the population for SF
b.update "#{collection_path}/SF", { population: 1_000_000 }

# Delete LA
b.delete "#{collection_path}/LA"
endtransactions_and_batched_writes.rb [https://github.com/googleapis/google-cloud-ruby/blob/d7956313714cca1df943713b9bba442ebd04962a/google-cloud-firestore/samples/transactions_and_batched_writes.rb#L64-L73]

일괄 쓰기는 트랜잭션과 마찬가지로 원자적으로 수행됩니다. 하지만 트랜잭션과 달리, 실패 사례를 줄이기 위해 읽은 문서를 수정되지 않은 상태로 유지할 필요가 없습니다. 재시도나 너무 많은 재시도로 인한 실패가 발생하지 않습니다. 일괄 쓰기는 사용자 기기가 오프라인 상태여도 실행됩니다.

수백 개의 문서가 포함된 일괄 쓰기에는 많은 색인 업데이트가 필요할 수 있으며 트랜잭션 크기 한도가 초과될 수 있습니다. 이 경우 배치당 문서 수를 줄이세요. 많은 수의 문서를 작성하려면 일괄 작성기 또는 동시 개별 쓰기를 사용하는 것이 좋습니다.
참고: 대량 데이터 입력의 경우 동시에 로드되는 개별 쓰기를 지원하는 서버 클라이언트 라이브러리 [https://firebase.google.com/docs/firestore/client/libraries?hl=ko#server_client_libraries]를 사용하세요. 일괄 쓰기의 성능은 직렬화된 쓰기보다 우수하지만 동시 로드 쓰기보다는 떨어집니다. 대량 데이터 작업에는 모바일/웹 SDK가 아니라 서버 클라이언트 라이브러리를 사용해야 합니다.
원자적 작업에 대한 데이터 검증

모바일/웹 클라이언트 라이브러리의 경우, Cloud Firestore Security Rules [https://firebase.google.com/docs/firestore/security/get-started?hl=ko]를 사용하여 데이터를 검증할 수 있습니다. 이를 통해 관련 문서를 항상 원자적으로 업데이트하고 트랜잭션 또는 일괄 쓰기에 포함할 수 있습니다.
일련의 작업이 완료된 후 Cloud Firestore가 작업을 커밋하기 전에 getAfter() [https://firebase.google.com/docs/reference/rules/rules.firestore?hl=ko#.getAfter] 보안 규칙 함수를 사용하여 문서 상태에 액세스하고 검증합니다.

예를 들어 cities 예시의 데이터베이스에 countries 컬렉션도 포함되어 있다고 가정해 보겠습니다. 각 country 문서는 last_updated 필드를 사용하여 해당 국가와 관련된 임의의 도시가 마지막으로 업데이트된 시간을 추적합니다. 다음 보안 규칙에서는 city 문서를 업데이트하면 관련 국가의 last_updated 필드 또한 원자적으로 업데이트되도록 지정합니다.

service cloud.firestore {
match /databases/{database}/documents {
/databases/$(database)/documents/countries/$(request.resource.data.country)
).data.last_updated == request.time;

대량 쓰기 및 일괄 쓰기로 인한 지연 시간 문제, 중복 트랜잭션으로 인한 오류, 기타 문제를 해결하는 방법에 대한 자세한 내용은 문제 해결 페이지 [https://cloud.google.com/firestore/docs/troubleshooting?hl=ko]를 참고하세요.

의견 보내기