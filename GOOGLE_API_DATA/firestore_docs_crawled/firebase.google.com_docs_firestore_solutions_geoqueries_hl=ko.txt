Source URL: https://firebase.google.com/docs/firestore/solutions/geoqueries?hl=ko
Title: 지역 쿼리

의견 보내기

지역 쿼리

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

많은 앱에는 물리적 위치에 따라 색인이 생성되는 문서가 있습니다. 예를 들어 앱에서 사용자가 현재 위치 근처의 매장을 찾아볼 수 있습니다.

솔루션: Geohash

Geohash는 (latitude, longitude) 쌍을 단일 Base32 문자열로 인코딩하기 위한 시스템입니다. Geohash 시스템에서 세계는 직사각형 그리드로 나뉩니다.
Geohash 문자열의 각 문자는 프리픽스 해시의 32개 구획 중 하나를 지정합니다. 예를 들어 Geohash abcd는 더 큰 Geohash abc 내에 완전히 포함된 32개의 4자 해시 중 하나입니다.

두 해시 간의 공유 프리픽스가 길수록 서로 더 가까워집니다. 예를 들어 abcdef는 abcdff보다 abcdeg에 더 가깝습니다. 그러나 그 역은 반드시 성립하지 않습니다. 매우 다른 Geohash를 가진 두 영역도 서로 매우 가까울 수 있습니다.

Geohash를 사용하면 효율적으로 Cloud Firestore에서 위치별로 문서를 저장하고 쿼리할 수 있으며 단일 색인 생성 필드만 있으면 됩니다.

도우미 라이브러리 설치

Geohash를 만들고 파싱하는 작업에는 복잡한 수학 함수가 포함되기 때문에 Android, Apple, 웹에서 가장 어려운 부분을 추상화하는 도우미 라이브러리가 개발되었습니다.

Web // Install from NPM. If you prefer to use a static .js file visit

Web // Install from NPM. If you prefer to use a static .js file visit

Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Kotlin // Add this to your app/build.gradle
implementation 'com.firebase:geofire-android-common:3.2.0'

Java // Add this to your app/build.gradle
implementation 'com.firebase:geofire-android-common:3.1.0'

Geohash 저장

위치별로 색인을 생성하려는 각 문서에 대해 Geohash 필드를 저장해야 합니다.

Web import { doc, updateDoc } from 'firebase/firestore';

Web // Compute the GeoHash for a lat/lng point

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Kotlin // Compute the GeoHash for a lat/lng point
val lat = 51.5074
val lng = 0.1278
val hash = GeoFireUtils.getGeoHashForLocation(GeoLocation(lat, lng))

londonRef.update(updates)
Java // Compute the GeoHash for a lat/lng point
double lat = 51.5074;
double lng = 0.1278;
String hash = GeoFireUtils.getGeoHashForLocation(new GeoLocation(lat, lng));

Map<String, Object> updates = new HashMap<>();
updates.put("geohash", hash);
updates.put("lat", lat);
updates.put("lng", lng);

DocumentReference londonRef = db.collection("cities").document("LON");
londonRef.update(updates)
.addOnCompleteListener(new OnCompleteListener<Void>() {
@Override
public void onComplete(@NonNull Task<Void> task) {

Geohash를 사용하면 Geohash 필드의 쿼리 집합을 조인한 다음 일부 거짓양성을 필터링하여 지역 쿼리를 대략적으로 계산할 수 있습니다.

Web import { collection, query, orderBy, startAt, endAt, getDocs } from 'firebase/firestore';

orderBy('geohash'),
startAt(b[0]),
endAt(b[1]));

promises.push(getDocs(q));
Web // Find cities within 50km of London

promises.push(q.get());

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

.order(by: "geohash")
.start(at: [bound.startValue])
.end(at: [bound.endValue])
Kotlin // Find cities within 50km of London
val center = GeoLocation(51.5074, 0.1278)
val radiusInM = 50.0 * 1000.0

val tasks: MutableList<Task<QuerySnapshot>> = ArrayList()
for (b in bounds) {
val q = db.collection("cities")
.orderBy("geohash")
.startAt(b.startHash)
.endAt(b.endHash)
tasks.add(q.get())
Tasks.whenAllComplete(tasks)
for (doc in snap!!.documents) {
val lat = doc.getDouble("lat")!!
val lng = doc.getDouble("lng")!!

val distanceInM = GeoFireUtils.getDistanceBetween(docLocation, center)
if (distanceInM <= radiusInM) {
matchingDocs.add(doc)
Java // Find cities within 50km of London
final GeoLocation center = new GeoLocation(51.5074, 0.1278);
final double radiusInM = 50 * 1000;

List<GeoQueryBounds> bounds = GeoFireUtils.getGeoHashQueryBounds(center, radiusInM);
final List<Task<QuerySnapshot>> tasks = new ArrayList<>();
for (GeoQueryBounds b : bounds) {
Query q = db.collection("cities")
.orderBy("geohash")
.startAt(b.startHash)
.endAt(b.endHash);

tasks.add(q.get());
Tasks.whenAllComplete(tasks)
.addOnCompleteListener(new OnCompleteListener<List<Task<?>>>() {
@Override
public void onComplete(@NonNull Task<List<Task<?>>> t) {
List<DocumentSnapshot> matchingDocs = new ArrayList<>();

for (Task<QuerySnapshot> task : tasks) {
QuerySnapshot snap = task.getResult();
for (DocumentSnapshot doc : snap.getDocuments()) {
double lat = doc.getDouble("lat");
double lng = doc.getDouble("lng");

GeoLocation docLocation = new GeoLocation(lat, lng);
double distanceInM = GeoFireUtils.getDistanceBetween(docLocation, center);
if (distanceInM <= radiusInM) {
matchingDocs.add(doc);