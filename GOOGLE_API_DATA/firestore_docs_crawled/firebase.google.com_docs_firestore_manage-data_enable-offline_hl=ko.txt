Source URL: https://firebase.google.com/docs/firestore/manage-data/enable-offline?hl=ko
Title: 오프라인으로 데이터에 액세스

의견 보내기

오프라인으로 데이터에 액세스

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Cloud Firestore는 오프라인 데이터 지속성을 지원합니다. 이 기능은 기기가 오프라인 상태일 때 앱에서 데이터에 액세스할 수 있도록 앱에서 자주 사용하는 Cloud Firestore 데이터의 사본을 캐시합니다. 캐시된 데이터를 쓰고, 읽고, 리슨하고, 쿼리할 수 있습니다. 기기가 다시 온라인 상태가 되면 Cloud Firestore는 앱이 적용한 로컬 변경사항을 Cloud Firestore 백엔드에 동기화합니다.
참고: 오프라인 지속성은 Android, Apple, 웹 앱에서만 지원됩니다.오프라인 지속성을 사용하기 위해 Cloud Firestore 데이터에 액세스할 때 사용하는 코드를 변경할 필요는 없습니다. 오프라인 지속성을 사용 설정하면 Cloud Firestore 클라이언트 라이브러리는 온라인 및 오프라인 데이터 액세스를 자동으로 관리하고 기기가 다시 온라인 상태가 되면 로컬 데이터를 동기화합니다.

오프라인 지속성 구성

Cloud Firestore를 초기화할 때 오프라인 지속성을 사용 설정하거나 중지할 수 있습니다.

Android 및 Apple 플랫폼에서는 오프라인 지속성이 기본적으로 사용 설정됩니다. 지속성을 사용 중지하려면 PersistenceEnabled 옵션을 false로 설정하세요.
웹에서는 오프라인 지속성이 기본적으로 사용 중지됩니다. 지속성을 사용 설정하려면 enablePersistence 메서드를 호출하세요. Cloud Firestore의 캐시는 세션 간에 자동으로 삭제되지 않습니다. 따라서 웹 앱에서 중요한 정보를 처리하는 경우 지속성을 사용 설정하기 전에 신뢰할 수 있는 기기인지 사용자에게 확인해야 합니다.중요: 웹의 경우 오프라인 지속성은 Chrome, Safari, Firefox 웹브라우저에서만 지원합니다.

Web

트리 쉐이킹 작업이 가능한 웹 v9 모듈형 SDK에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 버전 8에서 업그레이드 [https://firebase.google.com/docs/web/modular-upgrade?hl=ko]하세요.

persistentLocalCache(/*settings*/{tabManager: persistentSingleTabManager()})
persistentLocalCache(/*settings*/{tabManager: persistentMultipleTabManager()})

트리 쉐이킹 작업이 가능한 웹 v9 모듈형 SDK에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 버전 8에서 업그레이드 [https://firebase.google.com/docs/web/modular-upgrade?hl=ko]하세요.
firebase.firestore().enablePersistence()
.catch((err) => {
if (err.code == 'failed-precondition') {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

MemoryCacheSettings(garbageCollectorSettings: MemoryLRUGCSettings())

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRFirestoreSettings *settings = [[FIRFirestoreSettings alloc] init];

FIRFirestore *db = [FIRFirestore firestore];
db.settings = settings;ViewController.m [https://github.com/firebase/snippets-ios/blob/81f643355f68e16fa9f3f93642cdd19aa372f5fa/firestore/objc/firestore-smoketest-objc/ViewController.m#L1005-L1021]

Kotlin
val settings = firestoreSettings {
FirebaseFirestoreSettings settings =
new FirebaseFirestoreSettings.Builder(db.getFirestoreSettings())
db.setFirestoreSettings(settings);DocSnippets.java [https://github.com/firebase/snippets-android/blob/268a3858585da19107220dbad9ceb8a5fd23241a/firestore/app/src/main/java/com/google/example/firestore/DocSnippets.java#L134-L142]

Dart

.enablePersistence(const PersistenceSettings(synchronizeTabs: true));firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L1072-L1077]

캐시 크기 구성

지속성이 사용 설정되면 Cloud Firestore는 백엔드에서 수신된 모든 문서를 오프라인 액세스용으로 캐시합니다. Cloud Firestore는 캐시 크기의 기본 임곗값을 설정합니다. 기본값을 초과하면 Cloud Firestore는 사용하지 않는 오래된 문서를 주기적으로 정리합니다. 다른 캐시 크기 임곗값을 구성하거나 정리 프로세스를 완전히 사용 중지할 수 있습니다.

Web
import { initializeFirestore, CACHE_SIZE_UNLIMITED } from "firebase/firestore";

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.
firebase.firestore().settings({
cacheSizeBytes: firebase.firestore.CACHE_SIZE_UNLIMITED

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRFirestoreSettings *settings = [FIRFirestore firestore].settings;
[[FIRPersistentCacheSettings alloc] initWithSizeBytes:@(100 * 1024 * 1024)];
[FIRFirestore firestore].settings = settings;ViewController.m [https://github.com/firebase/snippets-ios/blob/81f643355f68e16fa9f3f93642cdd19aa372f5fa/firestore/objc/firestore-smoketest-objc/ViewController.m#L82-L86]

Kotlin

.setCacheSizeBytes(FirebaseFirestoreSettings.CACHE_SIZE_UNLIMITED)
.build()
db.firestoreSettings = settings

Java

FirebaseFirestoreSettings settings = new FirebaseFirestoreSettings.Builder()
.setCacheSizeBytes(FirebaseFirestoreSettings.CACHE_SIZE_UNLIMITED)
.build();
db.setFirestoreSettings(settings);

Dart
db.settings = const Settings(
persistenceEnabled: true,
cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
);firestore.dart [https://github.com/firebase/snippets-flutter/blob/f674af111fe63779c39e79699f7d269231f77563/packages/firebase_snippets_app/lib/snippets/firestore.dart#L1083-L1086]

오프라인 데이터 수신 대기

오프라인 지속성을 사용 설정한 경우 기기가 오프라인 상태이면 로컬에 캐시된
데이터가 변경될 때 리스너가 수신 대기 이벤트를 수신합니다. 문서, 컬렉션, 쿼리를 수신 대기할 수 있습니다.

데이터의 출처가 서버인지 아니면 캐시인지 확인하려면 스냅샷 이벤트의 SnapshotMetadata에 있는 fromCache 속성을 사용합니다. fromCache가 true이면 캐시에서 가져온 데이터이므로 서버와 일치하지 않거나 불완전할 수 있습니다. fromCache가 false이면 서버의 최신 업데이트와 일치하는 완전한 최신 데이터입니다.

기본적으로 SnapshotMetadata만 변경되면 이벤트가 발생하지 않습니다. fromCache 값에 의존하는 경우 수신 대기 핸들러를 연결할 때 includeMetadataChanges 수신 대기 옵션을 지정하세요.

Web
import { collection, onSnapshot, where, query } from "firebase/firestore";

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.
db.collection("cities").where("state", "==", "CA")
.onSnapshot({ includeMetadataChanges: true }, (snapshot) => {
snapshot.docChanges().forEach((change) => {
if (change.type === "added") {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

NSLog(@"Error retreiving snapshot: %@", error);
return;
NSLog(@"New city: %@", diff.document.data);
NSString *source = snapshot.metadata.isFromCache ? @"local cache" : @"server";
NSLog(@"Metadata: Data fetched from %@", source);
db.collection("cities").whereEqualTo("state", "CA")
.addSnapshotListener(MetadataChanges.INCLUDE) { querySnapshot, e ->
if (e != null) {
Log.w(TAG, "Listen error", e)
return@addSnapshotListener
Log.d(TAG, "Data fetched from $source")
db.collection("cities").whereEqualTo("state", "CA")
.addSnapshotListener(MetadataChanges.INCLUDE, new EventListener<QuerySnapshot>() {
@Override
public void onEvent(@Nullable QuerySnapshot querySnapshot,
@Nullable FirebaseFirestoreException e) {
if (e != null) {
Log.w(TAG, "Listen error", e);
return;
Log.d(TAG, "New city:" + change.getDocument().getData());
String source = querySnapshot.getMetadata().isFromCache() ?
"local cache" : "server";
Log.d(TAG, "Data fetched from " + source);
db
.collection("cities")
.where("state", isEqualTo: "CA")
.snapshots(includeMetadataChanges: true)
.listen((querySnapshot) {
for (var change in querySnapshot.docChanges) {
if (change.type == DocumentChangeType.added) {
final source =
(querySnapshot.metadata.isFromCache) ? "local cache" : "server";

print("Data fetched from $source}");
if let indexManager = Firestore.firestore().persistentCacheIndexManager {
Objective-C
PersistentCacheIndexManager *indexManager = [FIRFirestore firestore].persistentCacheIndexManager;
if (indexManager) {
PersistentCacheIndexManager indexManager = FirebaseFirestore.getInstance().getPersistentCacheIndexManager();
if (indexManager != null) {
FirebaseFirestore.getInstance().getPersistentCacheIndexManager().enableIndexAutoCreation();

자동 색인 생성이 사용 설정되면 SDK는 캐시된 문서가 많은 컬렉션을 평가하고 로컬 쿼리의 성능을 최적화합니다.

SDK는 쿼리 색인을 삭제하는 메서드를 제공합니다.

네트워크 액세스 중지 및 사용 설정

다음 방법을 사용하여 Cloud Firestore 클라이언트에 대한 네트워크 액세스를 중지할 수 있습니다. 네트워크 액세스가 중지되어 있으면 모든 스냅샷 리스너와 문서 요청이 캐시에서 결과를 검색합니다. 쓰기 작업은 네트워크 액세스가 다시 사용 설정될 때까지 큐에 추가됩니다.

Web
import { disableNetwork } from "firebase/firestore";

await disableNetwork(db);

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.
firebase.firestore().disableNetwork()
.then(() => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Firestore.firestore().disableNetwork { (error) in
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[FIRFirestore firestore] disableNetworkWithCompletion:^(NSError *_Nullable error) {
db.disableNetwork().addOnCompleteListener {
db.disableNetwork()
.addOnCompleteListener(new OnCompleteListener<Void>() {
@Override
public void onComplete(@NonNull Task<Void> task) {
db.disableNetwork().then((_) {
import { enableNetwork } from "firebase/firestore";

await enableNetwork(db);

트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.
firebase.firestore().enableNetwork()
.then(() => {

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

Firestore.firestore().enableNetwork { (error) in
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

[[FIRFirestore firestore] enableNetworkWithCompletion:^(NSError *_Nullable error) {
db.enableNetwork().addOnCompleteListener {
db.enableNetwork()
.addOnCompleteListener(new OnCompleteListener<Void>() {
@Override
public void onComplete(@NonNull Task<Void> task) {
db.enableNetwork().then((_) {