Source URL: https://developers.google.com/maps/documentation/navigation/android-sdk/multi-destination?hl=ko
Title: 다중 대상 경로 탐색

의견 보내기

다중 대상 경로 탐색

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

공지: fromLatLng() 및 fromPlaceId()은 지원이 중단되었지만 추가 업데이트 없이 계속 사용할 수 있습니다. 새 Waypoint.Builder [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Waypoint.Builder?hl=ko]로 마이그레이션하는 것이 좋습니다.

이 가이드에 따라 Android용 Navigation SDK를 사용하여 앱 내에서 여러 목적지(경유지라고도 함)로 가는 경로를 계획하세요.

개요

프로젝트 설정 [https://developers.google.com/maps/documentation/navigation/android-sdk/set-up-project?hl=ko]에 설명된 대로 내비게이션 SDK를 앱에 통합합니다.
앱에 SupportNavigationFragment [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko] 또는 NavigationView [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationView?hl=ko]을 추가합니다. 이 UI 요소는 활동에 대화형 지도와 턴바이턴 탐색 UI를 추가합니다.
NavigationApi [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationApi?hl=ko] 클래스를 사용하여 SDK를 초기화합니다.
Navigator [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Navigator?hl=ko]를 정의하여 세부 경로 안내를 제어합니다.

setDestinations() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Navigator?hl=ko#setDestinations(java.util.List%3Ccom.google.android.libraries.navigation.Waypoint%3E)]을 사용하여 대상을 추가합니다.
startGuidance() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Navigator?hl=ko#startGuidance()]로 내비게이션을 시작합니다.
getSimulator() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Navigator?hl=ko#getSimulator()]를 사용하여 테스트, 디버깅, 앱 데모를 위해 경로를 따라 차량의 진행 상황을 시뮬레이션합니다.

앱을 빌드하고 실행합니다.

코드 보기

탐색 활동의 Java 코드를 표시하거나 숨깁니다.

package com.example.navsdkmultidestination;

import android.content.pm.PackageManager;
import android.location.Location;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import com.google.android.gms.maps.GoogleMap.CameraPerspective;
import com.google.android.libraries.navigation.ArrivalEvent;
import com.google.android.libraries.navigation.ListenableResultFuture;
import com.google.android.libraries.navigation.NavigationApi;
import com.google.android.libraries.navigation.Navigator;
import com.google.android.libraries.navigation.RoadSnappedLocationProvider;
import com.google.android.libraries.navigation.SimulationOptions;
import com.google.android.libraries.navigation.SupportNavigationFragment;
import com.google.android.libraries.navigation.TimeAndDistance;
import com.google.android.libraries.navigation.Waypoint;
import java.util.ArrayList;
import java.util.List;

/**
* An activity that displays a map and a navigation UI, guiding the user from their current location
* to multiple destinations, also known as waypoints.
*/
public class NavigationActivityMultiDestination extends AppCompatActivity {

private static final String TAG = NavigationActivityMultiDestination.class.getSimpleName();
private static final String DISPLAY_BOTH = "both";
private static final String DISPLAY_TOAST = "toast";
private static final String DISPLAY_LOG = "log";

private Navigator mNavigator;
private RoadSnappedLocationProvider mRoadSnappedLocationProvider;
private SupportNavigationFragment mNavFragment;
private final List<Waypoint> mWaypoints = new ArrayList<>();

private Navigator.ArrivalListener mArrivalListener;
private Navigator.RouteChangedListener mRouteChangedListener;
private Navigator.RemainingTimeOrDistanceChangedListener mRemainingTimeOrDistanceChangedListener;
private RoadSnappedLocationProvider.LocationListener mLocationListener;

private Bundle mSavedInstanceState;
private static final String KEY_JOURNEY_IN_PROGRESS = "journey_in_progress";
private boolean mJourneyInProgress = false;

private boolean mLocationPermissionGranted;

/**
* Sets up the navigator when the activity is created.
* @param savedInstanceState The activity state bundle.
*/
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);

if (mSavedInstanceState != null && mSavedInstanceState.containsKey(KEY_JOURNEY_IN_PROGRESS)) {
mJourneyInProgress = (mSavedInstanceState.getInt(KEY_JOURNEY_IN_PROGRESS) != 0);

if ((mJourneyInProgress) && (this.isFinishing())) {
mNavigator.removeArrivalListener(mArrivalListener);
mNavigator.removeRouteChangedListener(mRouteChangedListener);
mNavigator.removeRemainingTimeOrDistanceChangedListener(
mRemainingTimeOrDistanceChangedListener);
if (mRoadSnappedLocationProvider != null) {
mRoadSnappedLocationProvider.removeLocationListener(mLocationListener);
if (mJourneyInProgress) {
outState.putInt(KEY_JOURNEY_IN_PROGRESS, 1);
this.getApplicationContext(), android.Manifest.permission.ACCESS_FINE_LOCATION)
== PackageManager.PERMISSION_GRANTED) {
mLocationPermissionGranted = true;
ActivityCompat.requestPermissions(
this,
new String[] {android.Manifest.permission.ACCESS_FINE_LOCATION},
PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION);
"Error loading Navigation SDK: " + "The user has not granted location permission.",
DISPLAY_BOTH);
return;
NavigationApi.getNavigator(
this,
new NavigationApi.NavigatorListener() {
mNavigator = navigator;

mNavFragment =
(SupportNavigationFragment)
getSupportFragmentManager().findFragmentById(R.id.navigation_fragment);

googleMap -> googleMap.followMyLocation(CameraPerspective.TILTED));

"Error loading Navigation SDK: Your API key is "
+ "invalid or not authorized to use the Navigation SDK.",
DISPLAY_BOTH);
break;
case NavigationApi.ErrorCode.TERMS_NOT_ACCEPTED:
displayMessage(
"Error loading Navigation SDK: User did not accept "
+ "the Navigation Terms of Use.",
DISPLAY_BOTH);
break;
case NavigationApi.ErrorCode.NETWORK_ERROR:
displayMessage("Error loading Navigation SDK: Network error.", DISPLAY_BOTH);
break;
case NavigationApi.ErrorCode.LOCATION_PERMISSION_MISSING:
displayMessage(
"Error loading Navigation SDK: Location permission " + "is missing.",
DISPLAY_BOTH);
break;
default:
displayMessage("Error loading Navigation SDK: " + errorCode, DISPLAY_BOTH);
createWaypoint("ChIJ3S-JXmauEmsRUcIaWtf4MzE", "Sydney Opera House");
createWaypoint("ChIJLwgLFGmuEmsRzpDhHQuyyoU", "Sydney Conservatorium of Music");

&& mSavedInstanceState.containsKey(KEY_JOURNEY_IN_PROGRESS)
&& mSavedInstanceState.getInt(KEY_JOURNEY_IN_PROGRESS) == 1) {
return;
ListenableResultFuture<Navigator.RouteStatus> pendingRoute =
mNavigator.setDestinations(mWaypoints);

new ListenableResultFuture.OnResultListener<Navigator.RouteStatus>() {
@Override
public void onResult(Navigator.RouteStatus code) {
switch (code) {
case OK:
mJourneyInProgress = true;

.getSimulator()
.simulateLocationsAlongExistingRoute(
new SimulationOptions().speedMultiplier(5));
break;
break;
case NETWORK_ERROR:
displayMessage("Error starting navigation: Network error.", DISPLAY_BOTH);
break;
case ROUTE_CANCELED:
displayMessage("Error starting navigation: Route canceled.", DISPLAY_BOTH);
break;
default:
displayMessage("Error starting navigation: " + String.valueOf(code), DISPLAY_BOTH);
"Error starting navigation: Place ID is not supported: " + placeId, DISPLAY_BOTH);
List<TimeAndDistance> timesAndDistances = mNavigator.getTimeAndDistanceList();
int leg = 1;
String message = "You're on your way!";
for (TimeAndDistance timeAndDistance : timesAndDistances) {
message =
message
+ "\nRoute leg: "
+ leg++
+ ": Travel time (seconds): "
+ timeAndDistance.getSeconds()
+ ". Distance (meters): "
+ timeAndDistance.getMeters();
new Navigator.ArrivalListener() {
@Override
public void onArrival(ArrivalEvent arrivalEvent) {
displayMessage(
"onArrival: You've arrived at a waypoint: "
+ mNavigator.getCurrentRouteSegment().getDestinationWaypoint().getTitle(),
DISPLAY_BOTH);
mNavigator.startGuidance();

mRouteChangedListener =
new Navigator.RouteChangedListener() {
@Override
public void onRouteChanged() {
displayMessage(
"onRouteChanged: The driver's route has changed. Current waypoint: "
+ mNavigator.getCurrentRouteSegment().getDestinationWaypoint().getTitle(),
DISPLAY_LOG);

mLocationListener =
new RoadSnappedLocationProvider.LocationListener() {
@Override
public void onLocationChanged(Location location) {
displayMessage(
"onLocationUpdated: Navigation engine has provided a new"
+ " road-snapped location: "
+ location.toString(),
DISPLAY_LOG);
"onLocationUpdated: Navigation engine has provided a new"
+ " raw location: "
+ location.toString(),
DISPLAY_LOG);
new Navigator.RemainingTimeOrDistanceChangedListener() {
@Override
public void onRemainingTimeOrDistanceChanged() {
displayMessage(
"onRemainingTimeOrDistanceChanged: Time or distance estimate" + " has changed.",
DISPLAY_LOG);
60, 100, mRemainingTimeOrDistanceChangedListener);
int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
mLocationPermissionGranted = false;
switch (requestCode) {
case PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION:
Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show();
Log.d(TAG, errorMessage);
Android 매니페스트에 권한을 <manifest> 요소의 하위 요소로 추가합니다.
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="com.example.navsdkmultidestination">
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
</manifest>

앱에서 런타임 권한을 요청하여 사용자에게 위치 정보 액세스 권한을 허용 또는 거부할 수 있는 기회를 제공합니다. 다음 코드는 사용자가 상세한 위치 정보 액세스 권한을 부여했는지 확인합니다. 부여하지 않은 경우, 해당 권한을 요청합니다.
if (ContextCompat.checkSelfPermission(this.getApplicationContext(),
android.Manifest.permission.ACCESS_FINE_LOCATION)
== PackageManager.PERMISSION_GRANTED) {
mLocationPermissionGranted = true;
ActivityCompat.requestPermissions(this,
new String[] { android.Manifest.permission.ACCESS_FINE_LOCATION },
PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION);
return;
@NonNull int[] grantResults) {
mLocationPermissionGranted = false;
switch (requestCode) {
case PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION: {
&& grantResults[0] == PackageManager.PERMISSION_GRANTED) {
mLocationPermissionGranted = true;
Navigation SDK를 초기화하고 여정 구성

NavigationApi [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationApi?hl=ko] 클래스는 앱이 Google 탐색을 사용할 수 있도록 승인하는 초기화 로직을 제공합니다. Navigator [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/Navigator?hl=ko] 클래스는 탐색 여정의 구성, 시작, 중지를 제어합니다.

화면과 로그에 메시지를 표시하는 도우미 메서드를 만듭니다.
private void displayMessage(String errorMessage, String displayMedium) {
if (displayMedium.equals(DISPLAY_BOTH) || displayMedium.equals(DISPLAY_TOAST)) {
Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show();
Log.d(TAG, errorMessage);
mNavigator = navigator;
mNavFragment = (SupportNavigationFragment) getFragmentManager()
.findFragmentById(R.id.navigation_fragment);

break;
case NavigationApi.ErrorCode.TERMS_NOT_ACCEPTED:
displayMessage("Error loading Navigation SDK: User did not accept "
+ "the Navigation Terms of Use.", DISPLAY_BOTH);
break;
case NavigationApi.ErrorCode.NETWORK_ERROR:
displayMessage("Error loading Navigation SDK: Network error.",
DISPLAY_BOTH);
break;
case NavigationApi.ErrorCode.LOCATION_PERMISSION_MISSING:
displayMessage("Error loading Navigation SDK: Location permission "
+ "is missing.", DISPLAY_BOTH);
break;
default:
displayMessage("Error loading Navigation SDK: " + errorCode,
DISPLAY_BOTH);
Waypoint.builder()
.setPlaceIdString(placeId)
.setTitle(title)
.build()
List<TimeAndDistance> timesAndDistances = mNavigator.getTimeAndDistanceList();
int leg = 1;
String message = "You're on your way!";
for (TimeAndDistance timeAndDistance : timesAndDistances) {
message = message + "\nRoute leg: " + leg++
+ ": Travel time (seconds): " + timeAndDistance.getSeconds()
+ ". Distance (meters): " + timeAndDistance.getMeters();
createWaypoint("ChIJ3S-JXmauEmsRUcIaWtf4MzE", "Sydney Opera House");
createWaypoint("ChIJLwgLFGmuEmsRzpDhHQuyyoU", "Sydney Conservatorium of Music");

&& mSavedInstanceState.containsKey(KEY_JOURNEY_IN_PROGRESS)
&& mSavedInstanceState.getInt(KEY_JOURNEY_IN_PROGRESS) == 1) {
return;
ListenableResultFuture<Navigator.RouteStatus> pendingRoute =
mNavigator.setDestinations(mWaypoints);

new ListenableResultFuture.OnResultListener<Navigator.RouteStatus>() {
@Override
public void onResult(Navigator.RouteStatus code) {
switch (code) {
case OK:
mJourneyInProgress = true;

Navigator.AudioGuidance.VOICE_ALERTS_AND_GUIDANCE);

new SimulationOptions().speedMultiplier(5));
break;
break;
case NETWORK_ERROR:
displayMessage("Error starting navigation: Network error.",
DISPLAY_BOTH);
break;
case ROUTE_CANCELED:
displayMessage("Error starting navigation: Route canceled.",
DISPLAY_BOTH);
break;
default:
displayMessage("Error starting navigation: "
+ String.valueOf(code), DISPLAY_BOTH);
Android 기기에서 개발자 옵션을 사용 설정하고
기기를 감지하도록 시스템을 구성합니다. (또는
Android Virtual Device(AVD) Manager [https://developer.android.com/studio/run/managing-avds.html?hl=ko]를
사용하여
가상 기기를 구성할 수 있습니다. 에뮬레이터를 선택할 때 Google API가 포함된 이미지를 선택해야 합니다.)
Android 스튜디오에서 Run 메뉴 옵션(또는 재생 버튼 아이콘)을 클릭합니다.
표시되는 메시지에 따라 기기를 선택합니다.

사용자 환경 개선을 위한 힌트

탐색을 사용하려면 사용자가 Google 탐색 서비스 약관에 동의해야 합니다. 이 수락은 한 번만 필요합니다. 기본적으로 SDK는 탐색기가 처음 호출될 때 수락을 요청합니다. 원하는 경우 showTermsAndConditionsDialog() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationApi?hl=ko#showTermsAndConditionsDialog(android.app.Activity,%20com.google.android.libraries.navigation.NavigationApi.OnTermsResponseListener)]를 사용하여 앱의 UX 흐름 초기에(예: 가입 또는 로그인 중) 내비게이션 서비스 약관 대화상자를 트리거할 수 있습니다.
위도/경도 대상 대신 장소 ID를 사용하여 경유지를 초기화하면 탐색 품질과 도착 예정 시간 정확도가 크게 향상됩니다.
이 샘플은 특정 장소 ID에서 경유지를 파생합니다. 장소 ID를 가져오는 다른 방법은 다음과 같습니다.
장소 ID 찾기 [https://developers.google.com/maps/documentation/places/web-service/place-id?hl=ko]를 사용하여 특정 위치의 장소 ID를 가져옵니다.
Geocoding API [https://developers.google.com/maps/documentation/geocoding?hl=ko]를 사용하여 지정된 주소의 장소 ID를 찾습니다. 경로의 주소가 완전하고 명확한 경우 Geocoding API가 잘 작동합니다. 지오코딩 권장사항 가이드 [https://developers.google.com/maps/documentation/geocoding/best-practices?hl=ko]를 참고하세요.
Places API 텍스트 검색 [https://developers.google.com/maps/documentation/places/web-service/search?hl=ko#TextSearchRequests]을 사용하여 지정된 주소의 장소 ID를 찾습니다. 경로에 불완전하거나 모호한 주소가 있는 경우 Places API가 유용합니다. 지오코딩 권장사항 가이드 [https://developers.google.com/maps/documentation/geocoding/best-practices?hl=ko]를 참고하세요.

의견 보내기