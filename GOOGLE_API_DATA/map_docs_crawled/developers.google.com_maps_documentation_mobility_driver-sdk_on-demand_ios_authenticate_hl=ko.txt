Source URL: https://developers.google.com/maps/documentation/mobility/driver-sdk/on-demand/ios/authenticate?hl=ko
Title: 승인 토큰 가져오기

승인 토큰 가져오기

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

토큰이란 무엇인가요?

Fleet Engine에서는 신뢰도가 낮은 환경(스마트폰 및 브라우저)에서 API 메서드를 호출할 때 JSON 웹 토큰(JWT)을 사용해야 합니다.

JWT는 서버에서 생성되고 서명, 암호화되어 만료되거나 더 이상 유효하지 않을 때까지 후속 서버 상호작용을 위해 클라이언트에 전달됩니다.

주요 세부정보

애플리케이션 기본 사용자 인증 정보 [https://google.aip.dev/auth/4110]를 사용하여 Fleet Engine에 대해 인증하고 승인합니다.
적절한 서비스 계정을 사용하여 JWT에 서명합니다. Fleet Engine 기본사항의 Fleet Engine 서비스 계정 [https://developers.google.com/maps/documentation/mobility/fleet-engine/essentials/set-up-fleet/service-accounts?hl=ko#fleet_engine_service_account_roles] 역할을 참고하세요.

JSON 웹 토큰에 관한 자세한 내용은 Fleet Engine 필수사항의 JSON 웹 토큰 [https://developers.google.com/maps/documentation/mobility/fleet-engine/essentials/set-up-fleet/jwt?hl=ko]을 참고하세요.

클라이언트가 토큰을 가져오는 방법

운전자 또는 소비자가 적절한 인증 사용자 인증 정보를 사용하여 앱에 로그인하면 해당 기기에서 발행된 업데이트는 앱의 권한을 Fleet Engine에 전달하는 적절한 승인 토큰을 사용해야 합니다.

개발자로서 클라이언트 구현은 다음을 실행할 수 있는 기능을 제공해야 합니다.

서버에서 JSON 웹 토큰을 가져옵니다.
토큰이 만료될 때까지 재사용하여 토큰 새로고침을 최소화합니다.
토큰이 만료되면 토큰을 새로고침합니다.

GMTDAuthorization 프로토콜은 GMTD AuthorizationContext 객체를 기반으로 위치 업데이트 시간에 JSON 웹 토큰을 가져옵니다. SDK는 업데이트 정보와 함께 토큰을 패키징하여 Fleet Engine에 전송해야 합니다.
SDK를 초기화하기 전에 서버 측 구현에서 토큰을 발급할 수 있는지 확인합니다.

Fleet Engine에서 예상하는 토큰에 관한 자세한 내용은 Fleet Engine용 JSON 웹 토큰 발급 [https://developers.google.com/maps/documentation/mobility/fleet-engine/essentials/set-up-fleet/issue-jwt?hl=ko]을 참고하세요.

providerID는 Google Cloud 프로젝트의 프로젝트 ID와 동일합니다. Google Cloud 프로젝트 설정에 관한 자세한 내용은 Fleet Engine 프로젝트 만들기 [https://developers.google.com/maps/documentation/mobility/fleet-engine/essentials/set-up-fleet/create-project?hl=ko]를 참고하세요.

인증 토큰 가져오기의 예

다음 예는 GMTDAuthorization 프로토콜의 구현을 보여줍니다.

Swiftimport GoogleRidesharingDriver

private let providerURL = "INSERT_YOUR_TOKEN_PROVIDER_URL"

class SampleAccessTokenProvider: NSObject, GMTDAuthorization {
private struct AuthToken {
case missingData
with authorizationContext: GMTDAuthorizationContext?,
completion: @escaping GMTDAuthTokenFetchCompletionHandler
) {
return
authToken.expiration > Date.now.timeIntervalSince1970 && authToken.vehicleID == vehicleID
completion(authToken.token, nil)
return
return
return
token: token, expiration: expiration, vehicleID: vehicleID)
completion(token, nil)
Objective-C#import "SampleAccessTokenProvider.h"
#import <GoogleRidesharingDriver/GoogleRidesharingDriver.h>

NSString *_cachedVehicleToken;
NSString *_lastKnownVehicleID;
NSTimeInterval _tokenExpiration;
NSAssert(NO, @"%s encountered an unexpected nil completion.", __PRETTY_FUNCTION__);
return;
NSString *vehicleID = authorizationContext.vehicleID;
if (!vehicleID) {
NSAssert(NO, @"Vehicle ID is missing from authorizationContext.");
return;
_cachedVehicleToken = nil;

return;
NSURL *requestURL = [NSURL URLWithString:PROVIDER_URL];
NSMutableURLRequest *request =
[[NSMutableURLRequest alloc] initWithURL:requestURL];
request.HTTPMethod = @"GET";
NSString *vehicleTokenKey = @"VEHICLE_TOKEN_KEY";
NSString *tokenExpirationKey = @"TOKEN_EXPIRATION";
__weak typeof(self) weakSelf = self;
void (^handler)(NSData *_Nullable data, NSURLResponse *_Nullable response,
NSError *_Nullable error) =
^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) {
typeof(self) strongSelf = weakSelf;
if (error) {
completion(nil, error);
return;
NSError *JSONError;
NSMutableDictionary *JSONResponse =
[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&JSONError];

if (JSONError) {
completion(nil, JSONError);
return;
if ([expirationData isKindOfClass:[NSNumber class]]) {
NSTimeInterval expirationTime = ((NSNumber *)expirationData).doubleValue;
strongSelf->_tokenExpiration = [[NSDate date] timeIntervalSince1970] + expirationTime;
completion(JSONResponse[vehicleTokenKey], nil);
NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
NSURLSession *mainQueueURLSession =
[NSURLSession sessionWithConfiguration:config delegate:nil
NSURLSessionDataTask *task = [mainQueueURLSession dataTaskWithRequest:request completionHandler:handler];
[task resume];