Source URL: https://developers.google.com/maps/documentation/places/web-service/client-library-examples?hl=ko
Title: Places API (신규) 클라이언트 라이브러리 예시

의견 보내기

Places API (신규) 클라이언트 라이브러리 예시

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지에는 Places API (New) 클라이언트 라이브러리를 사용하여 다음 서비스를 호출하는 방법의 예가 나와 있습니다.

Place Details (신규) [https://developers.google.com/maps/documentation/places/web-service/place-details?hl=ko]
주변 지역 검색 (신규) [https://developers.google.com/maps/documentation/places/web-service/nearby-search?hl=ko]
텍스트 검색 (신규) [https://developers.google.com/maps/documentation/places/web-service/text-search?hl=ko]
자동 완성 (신규) [https://developers.google.com/maps/documentation/places/web-service/place-autocomplete?hl=ko]
Place Photos (신규) [https://developers.google.com/maps/documentation/places/web-service/place-photos?hl=ko]

클라이언트 라이브러리 설치

설치 안내는 Places API (신규) 클라이언트 라이브러리 [https://developers.google.com/maps/documentation/places/web-service/client-libraries?hl=ko#install_the_client_library]를 참고하세요.

인증

클라이언트 라이브러리를 사용할 때는 애플리케이션 기본 사용자 인증 정보(ADC) [https://cloud.google.com/docs/authentication/application-default-credentials?hl=ko]를 사용하여 인증합니다. ADC 설정은 애플리케이션 기본 사용자 인증 정보에 대한 사용자 인증 정보 제공 [https://cloud.google.com/docs/authentication/provide-credentials-adc?hl=ko]을 참고하세요.
클라이언트 라이브러리에서 ADC를 사용하는 방법은 클라이언트 라이브러리를 사용하여 인증 [https://cloud.google.com/docs/authentication/client-libraries?hl=ko]을 참고하세요.

API 키를 사용하여 클라이언트 라이브러리에 인증할 수도 있습니다. 예를 들면 다음과 같습니다.

자바
...
Map<String, String> headers = new HashMap<>();
headers.put("x-goog-fieldmask", fieldMaskString);
HeaderProvider headerProvider = FixedHeaderProvider.create(headers);
...
PlacesSettings placesSettings = PlacesSettings.newBuilder()
.setHeaderProvider(headerProvider)
PlacesClient placesClient = PlacesClient.create(placesSettings);
Go
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"google.golang.org/api/option" // Import the option package when using an API key
"google.golang.org/grpc/metadata"
client = places_v1.PlacesAsyncClient(
# Instantiates the Places client, passing the API key
client_options={"api_key": "API_KEY"}
.NET
PlacesClientBuilder builder = new PlacesClientBuilder
ApiKey = "API_KEY"
PlacesClient client = await builder.BuildAsync();

애플리케이션에서 API 키를 사용하는 경우 저장 및 전송 중에 안전하게 보호되도록 해야 합니다. API 키를 공개적으로 노출하면 계정에 예상치 않은 비용이 부과될 수 있습니다. 자세한 내용은 Places API와 함께 API 키 사용 [https://developers.google.com/maps/documentation/places/web-service/get-api-key?hl=ko]을 참고하세요.

이 페이지의 예에서는 애플리케이션 기본 사용자 인증 정보를 사용합니다.

예

Place Details (신규)

다음은 클라이언트 라이브러리를 사용하여 장소 세부정보 [https://developers.google.com/maps/documentation/places/web-service/place-details?hl=ko]를 호출하는 방법의 예입니다.

자바
import com.google.api.gax.rpc.FixedHeaderProvider;
import com.google.api.gax.rpc.HeaderProvider;
import com.google.maps.places.v1.GetPlaceRequest;
import com.google.maps.places.v1.Place;
import com.google.maps.places.v1.PlacesClient;
import com.google.maps.places.v1.PlacesSettings;
...
private static void PlaceDetails() {
String placeId = "ChIJaXQRs6lZwokRY6EFpJnhNNE";
String placeName = "places/" + placeId;
Map<String, String> headers = new HashMap<>();
String fieldMaskString = "displayName,formattedAddress";
headers.put("x-goog-fieldmask", fieldMaskString);
HeaderProvider headerProvider = FixedHeaderProvider.create(headers);
try {
PlacesSettings placesSettings = PlacesSettings.newBuilder()
.setHeaderProvider(headerProvider)
.build();
PlacesClient placesClient = PlacesClient.create(placesSettings);
GetPlaceRequest request = GetPlaceRequest.newBuilder()
.setName(placeName)
.build();
Place place = placesClient.getPlace(request);
System.out.println(place);
placesClient.close();
System.err.println("An error occurred: " + e.getMessage());
package main
import (
"context"
"fmt"
"log"
"strings"
places "cloud.google.com/go/maps/places/apiv1"
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"google.golang.org/grpc/metadata"
func main() {
ctx := context.Background()
const { PlacesClient } = require('@googlemaps/places').v1;
Python
from google.maps import places_v1
async def place_details():
client = places_v1.PlacesAsyncClient()
# Build the request
request = places_v1.GetPlaceRequest(
name="places/ChIJaXQRs6lZwokRY6EFpJnhNNE",
# Set the field mask
fieldMask = "formattedAddress,displayName"
# Make the request
response = await client.get_place(request=request, metadata=[("x-goog-fieldmask",fieldMask)])
return response
print(await place_details())
.NET
using Google.Api.Gax.Grpc;
using Google.Maps.Places.V1;
...
private static async Task PlaceDetails()
PlacesClient client = await PlacesClient.CreateAsync();
PlaceName placeName = PlaceName.FromPlace("ChIJaXQRs6lZwokRY6EFpJnhNNE");
GetPlaceRequest request = new GetPlaceRequest
PlaceName = placeName
CallSettings callSettings = CallSettings.FromHeader("X-Goog-FieldMask", fieldMask);
Place response = await client.GetPlaceAsync(request, callSettings);
import com.google.api.gax.rpc.HeaderProvider;
import com.google.maps.places.v1.Circle;
import com.google.maps.places.v1.PlacesClient;
import com.google.maps.places.v1.PlacesSettings;
import com.google.maps.places.v1.SearchNearbyRequest;
import com.google.maps.places.v1.SearchNearbyResponse;
import com.google.type.LatLng;
...
private static void NearbySearch() {
double longitude = -0.127245;
double radiusMeters = 1000.0;
String placeType = "restaurant";
Map<String, String> headers = new HashMap<>();
String fieldMaskString = "places.displayName,places.formattedAddress,places.id";
headers.put("x-goog-fieldmask", fieldMaskString);
HeaderProvider headerProvider = FixedHeaderProvider.create(headers);
try {
PlacesSettings placesSettings = PlacesSettings.newBuilder()
.setHeaderProvider(headerProvider)
.build();
PlacesClient placesClient = PlacesClient.create(placesSettings);
LatLng centerPoint = LatLng.newBuilder()
.setLatitude(latitude)
.setLongitude(longitude)
.build();
Circle circleArea = Circle.newBuilder()
.setCenter(centerPoint)
.setRadius(radiusMeters)
.build();
SearchNearbyRequest.LocationRestriction locationRestriction
= SearchNearbyRequest.LocationRestriction.newBuilder()
.setCircle(circleArea)
.build();
SearchNearbyRequest request = SearchNearbyRequest.newBuilder()
.addIncludedTypes(placeType)
.setLocationRestriction(locationRestriction)
.build();
SearchNearbyResponse response = placesClient.searchNearby(request);
System.out.println(response);
placesClient.close();
System.err.println("An  error occurred: " + e.getMessage());
package main
import (
"context"
"fmt"
"log"
"strings"
places "cloud.google.com/go/maps/places/apiv1"
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"google.golang.org/genproto/googleapis/type/latlng"
"google.golang.org/grpc/metadata"
func main() {
ctx := context.Background()
fmt.Printf("   Address: %s\n", place.GetFormattedAddress())
fmt.Println("---")
const { PlacesClient } = require('@googlemaps/places').v1;
Python
from google.maps import places_v1
from google.type import latlng_pb2
async def nearby_search():
# Define the coordinates and radius
lat = 51.516177
lng = -0.127245
radius_meters = 1000.0
# Create the LatLng object for the center
center_point = latlng_pb2.LatLng(latitude=lat, longitude=lng)
# Create the circle
circle_area = places_v1.types.Circle(
center=center_point,
radius=radius_meters
# Add the circle to the location restriction
location_restriction = places_v1.SearchNearbyRequest.LocationRestriction(
circle=circle_area
client = places_v1.PlacesAsyncClient()
# Build the request
request = places_v1.SearchNearbyRequest(
location_restriction=location_restriction,
included_types=["restaurant"]
# Set the field mask
fieldMask = "places.formattedAddress,places.displayName"
# Make the request
response = await client.search_nearby(request=request, metadata=[("x-goog-fieldmask",fieldMask)])
return response
print(await nearby_search())
.NET
using Google.Api.Gax.Grpc;
using Google.Maps.Places.V1;
using Google.Type;
...
private static async Task NearbySearch()
PlacesClient client = await PlacesClient.CreateAsync();
double longitude = -0.127245;
double radiusMeters = 1000.0;
string placeType = "restaurant";
LatLng centerPoint = new LatLng { Latitude = latitude, Longitude = longitude };
Circle circleArea = new Circle { Center = centerPoint, Radius = radiusMeters };
SearchNearbyRequest.Types.LocationRestriction locationRestriction = new SearchNearbyRequest.Types.LocationRestriction
Circle = circleArea
SearchNearbyRequest request = new SearchNearbyRequest
IncludedTypes = { placeType },
LocationRestriction = locationRestriction,
CallSettings callSettings = CallSettings.FromHeader("X-Goog-FieldMask", fieldsToFetch);
SearchNearbyResponse searchResponse = await client.SearchNearbyAsync(request, callSettings);
import com.google.api.gax.rpc.HeaderProvider;
import com.google.maps.places.v1.Circle;
import com.google.maps.places.v1.PlacesClient;
import com.google.maps.places.v1.PlacesSettings;
import com.google.maps.places.v1.PriceLevel;
import com.google.maps.places.v1.SearchTextRequest;
import com.google.maps.places.v1.SearchTextResponse;
import com.google.type.LatLng;
...
private static void TextSearch() {
String searchQuery = "restaurants with outdoor seating";
double latitude = 51.516177;
double longitude = -0.127245;
double radiusMeters = 1000.0;
double minPlaceRating = 4.0;
List desiredPriceLevels = Arrays.asList(
PriceLevel.PRICE_LEVEL_MODERATE,
PriceLevel.PRICE_LEVEL_EXPENSIVE
boolean requireOpenNow = true;
Map<String, String> headers = new HashMap<>();
String fieldMaskString = "places.displayName,places.formattedAddress,places.rating,places.priceLevel";
headers.put("x-goog-fieldmask", fieldMaskString);
HeaderProvider headerProvider = FixedHeaderProvider.create(headers);
try {
PlacesSettings placesSettings = PlacesSettings.newBuilder()
.setHeaderProvider(headerProvider)
.build();
PlacesClient placesClient = PlacesClient.create(placesSettings);
LatLng centerPoint = LatLng.newBuilder()
.setLatitude(latitude)
.setLongitude(longitude)
.build();
Circle circleArea = Circle.newBuilder()
.setCenter(centerPoint)
.setRadius(radiusMeters)
.build();
SearchTextRequest.LocationBias locationBias = SearchTextRequest.LocationBias.newBuilder()
.setCircle(circleArea)
.build();
SearchTextRequest request = SearchTextRequest.newBuilder()
.setTextQuery(searchQuery)
.setLocationBias(locationBias)
.setMinRating(minPlaceRating)
.setOpenNow(requireOpenNow)
.addAllPriceLevels(desiredPriceLevels)
.build();
SearchTextResponse response = placesClient.searchText(request);
System.out.println(response);
placesClient.close();
System.err.println("An error occurred: " + e.getMessage());
package main
import (
"context"
"fmt"
"log"
"strings"
places "cloud.google.com/go/maps/places/apiv1"
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"google.golang.org/genproto/googleapis/type/latlng"
"google.golang.org/grpc/metadata"
func main() {
ctx := context.Background()
placespb.PriceLevel_PRICE_LEVEL_EXPENSIVE,
for i, place := range resp.Places {
fmt.Printf("%d. %s\n", i+1, place.DisplayName.GetText())
fmt.Printf("   Address: %s\n", place.GetFormattedAddress())
fmt.Println("---")
const { PlacesClient } = require('@googlemaps/places').v1;
PriceLevel.PRICE_LEVEL_MODERATE,
PriceLevel.PRICE_LEVEL_EXPENSIVE,
];
Python
from google.maps import places_v1
from google.type import latlng_pb2
async def text_search():
# Coordinates and radius for the location bias
lat = 51.516177
lng = -0.127245
radius_meters = 1000.0
# Create the LatLng object for the center
center_point = latlng_pb2.LatLng(latitude=lat, longitude=lng)
# Create the Circle object
circle_area = places_v1.types.Circle(
center=center_point,
radius=radius_meters
# Create the location bias circle
location_bias = places_v1.SearchTextRequest.LocationBias(
circle=circle_area
# Define the search query and other parameters
search_query = "restaurants with outdoor seating"
min_place_rating = 4.0
client = places_v1.PlacesAsyncClient()
# Build the request
request = places_v1.SearchTextRequest(
text_query=search_query,
location_bias=location_bias,
min_rating=min_place_rating,
open_now=True,
price_levels=[
places_v1.types.PriceLevel.PRICE_LEVEL_MODERATE,
places_v1.types.PriceLevel.PRICE_LEVEL_EXPENSIVE
]
# Set the field mask
fieldMask = "places.formattedAddress,places.displayName"
# Make the request
response = await client.search_text(request=request, metadata=[("x-goog-fieldmask",fieldMask)])
return response
print(await text_search())
.NET
using Google.Api.Gax.Grpc;
using Google.Maps.Places.V1;
using Google.Type;
...
private static async Task TextSearch()
PlacesClient client = await PlacesClient.CreateAsync();
double latitude = 51.516177;
double longitude = -0.127245;
double radiusMeters = 1000.0;
double minPlaceRating = 4.0;
List desiredPriceLevels = new List
PriceLevel.Moderate,
PriceLevel.Expensive
LatLng centerPoint = new LatLng { Latitude = latitude, Longitude = longitude };
Circle circleArea = new Circle { Center = centerPoint, Radius = radiusMeters };
SearchTextRequest.Types.LocationBias locationBias = new SearchTextRequest.Types.LocationBias
Circle = circleArea
SearchTextRequest request = new SearchTextRequest
TextQuery = searchQuery,
LocationBias = locationBias,
MinRating = minPlaceRating,
OpenNow = requireOpenNow,
CallSettings callSettings = CallSettings.FromHeader("X-Goog-FieldMask", fieldsToFetch);
SearchTextResponse searchResponse = await client.SearchTextAsync(request, callSettings);
import com.google.maps.places.v1.AutocompletePlacesResponse;
import com.google.maps.places.v1.Circle;
import com.google.maps.places.v1.PlacesClient;
import com.google.type.LatLng;
...
private static void Autocomplete() {
String userInput = "Google Central St Giles";
double biasLatitude = 51.516177;
double biasLongitude = -0.127245;
double biasRadiusMeters = 5000.0;
String language = "en-GB";
String region = "GB";
String sessionToken = UUID.randomUUID().toString();
LatLng biasCenterPoint = LatLng.newBuilder()
.setLatitude(biasLatitude)
.setLongitude(biasLongitude)
.build();
Circle biasCircleArea = Circle.newBuilder()
.setCenter(biasCenterPoint)
.setRadius(biasRadiusMeters)
.build();
AutocompletePlacesRequest.LocationBias locationBias
= AutocompletePlacesRequest.LocationBias.newBuilder()
.setCircle(biasCircleArea)
.build();
AutocompletePlacesRequest request = AutocompletePlacesRequest.newBuilder()
.setInput(userInput)
.setLocationBias(locationBias)
.setLanguageCode(language)
.setRegionCode(region)
.setSessionToken(sessionToken)
.build();
AutocompletePlacesResponse response = placesClient.autocompletePlaces(request);
System.out.println(response);
System.err.println("An error occurred: " + e.getMessage());
package main
import (
"context"
"fmt"
"log"
places "cloud.google.com/go/maps/places/apiv1"
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"github.com/google/uuid"
"google.golang.org/genproto/googleapis/type/latlng"
func main() {
ctx := context.Background()
return
switch kind := suggestion.Kind.(type) {
const { PlacesClient } = require('@googlemaps/places').v1;
Python
import uuid # For generating session tokens
from google.maps import places_v1
from google.type import latlng_pb2
async def autocomplete():
bias_lat = 51.516177
bias_lng = -0.127245
bias_radius_meters = 5000.0
# Create the LatLng object for the bias center
bias_center_point = latlng_pb2.LatLng(latitude=bias_lat, longitude=bias_lng)
# Create the Circle object using a dictionary
bias_circle_dict = {
"center": bias_center_point,
"radius": bias_radius_meters
# Create the LocationBias object using a dictionary
location_bias_dict = {
"circle": bias_circle_area
# The autocomplete text
user_input = "Google Central St Giles"
# Language and region
language = "en-GB"
region = "GB"
# Generate a unique session token for this autocomplete session
session_token = str(uuid.uuid4())
client = places_v1.PlacesAsyncClient()
# Build the request
request = places_v1.AutocompletePlacesRequest(
input=user_input,
language_code=language,
region_code=region,
location_bias=location_bias,
session_token=session_token,
response = await client.autocomplete_places(request=request)
return response
print(await autocomplete())
.NET
using Google.Maps.Places.V1;
using Google.Type;
...
private static async Task Autocomplete()
PlacesClient client = await PlacesClient.CreateAsync();
double biasLatitude = 51.516177;
double biasLongitude = -0.127245;
double biasRadiusMeters = 5000.0;
string language = "en-GB";
string region = "GB";
LatLng biasCenterPoint = new LatLng { Latitude = biasLatitude, Longitude = biasLongitude };
Circle biasCircleArea = new Circle { Center = biasCenterPoint, Radius = biasRadiusMeters };
AutocompletePlacesRequest.Types.LocationBias locationBias = new AutocompletePlacesRequest.Types.LocationBias
Circle = biasCircleArea
AutocompletePlacesRequest request = new AutocompletePlacesRequest
Input = userInput,
LocationBias = locationBias,
LanguageCode = language,
RegionCode = region,
SessionToken = sessionToken,
AutocompletePlacesResponse response = await client.AutocompletePlacesAsync(request);
import com.google.api.gax.rpc.HeaderProvider;
import com.google.maps.places.v1.GetPhotoMediaRequest;
import com.google.maps.places.v1.GetPlaceRequest;
import com.google.maps.places.v1.Photo;
import com.google.maps.places.v1.PhotoMedia;
import com.google.maps.places.v1.Place;
import com.google.maps.places.v1.PlacesClient;
import com.google.maps.places.v1.PlacesSettings;
...
private static void PlacePhoto() {
String placeId = "ChIJaXQRs6lZwokRY6EFpJnhNNE";
String placeName = "places/" + placeId;
int photoMaxWidth = 800;
try {
Map<String, String> getPlaceHeaders = new HashMap<>();
String getPlaceFieldMaskString = "photos";
getPlaceHeaders.put("x-goog-fieldmask", getPlaceFieldMaskString);
HeaderProvider getPlaceHeaderProvider = FixedHeaderProvider.create(getPlaceHeaders);
PlacesSettings getPlaceSettings = PlacesSettings.newBuilder()
.setHeaderProvider(getPlaceHeaderProvider)
.build();
PlacesClient placeDetailsClient = PlacesClient.create(getPlaceSettings);
GetPlaceRequest getPlaceRequest = GetPlaceRequest.newBuilder()
.setName(placeName)
.build();
Place placeResponse = placeDetailsClient.getPlace(getPlaceRequest);
List photos = placeResponse.getPhotosList();
if (photos != null && !photos.isEmpty()) {
Photo firstPhoto = photos.get(0);
String firstPhotoName = firstPhoto.getName();
if (firstPhotoName == null || firstPhotoName.isEmpty()) {
return;
String photoMediaName = firstPhotoName + "/media";
GetPhotoMediaRequest photoRequest = GetPhotoMediaRequest.newBuilder()
.setName(photoMediaName)
.setMaxWidthPx(photoMaxWidth)
.build();
PlacesClient photoMediaClient = PlacesClient.create();
PhotoMedia photoMediaResponse = photoMediaClient.getPhotoMedia(photoRequest);
System.out.println(photoMediaResponse);
placeDetailsClient.close();
photoMediaClient.close();
System.out.println("\nNo photos were found for this place in the Place Details response.");
System.err.println("An error occurred: " + e.getMessage());
package main
import (
"context"
"fmt"
"log"
places "cloud.google.com/go/maps/places/apiv1"
placespb "cloud.google.com/go/maps/places/apiv1/placespb"
"google.golang.org/grpc/metadata"
func main() {
ctx := context.Background()
const { PlacesClient } = require('@googlemaps/places').v1;
Python
from google.maps import places_v1
async def place_photo():
client = places_v1.PlacesAsyncClient()
# Build the request
request = places_v1.GetPlaceRequest(
name="places/ChIJaXQRs6lZwokRY6EFpJnhNNE",
# Set the field mask
fieldMask = "photos"
# Make the request
response = await client.get_place(request=request, metadata=[("x-goog-fieldmask",fieldMask)])
if response.photos:  # Check if the photos list contains photos
# Get the first photo name from the response
first_photo_name = response.photos[0].name + "/media"
# Build the request
photo_request = places_v1.GetPhotoMediaRequest(
name=first_photo_name,
max_width_px=800,
photo_response = await client.get_photo_media(request=photo_request)
return photo_response
else:
return("No photos were returned in the response.")
print(await place_photo())
.NET
using Google.Api.Gax.Grpc;
using Google.Maps.Places.V1;
...
private static async Task PlacePhoto()
PlacesClient client = await PlacesClient.CreateAsync();
PlaceName placeName = PlaceName.FromPlace("ChIJaXQRs6lZwokRY6EFpJnhNNE");
int photoMaxWidth = 800;
GetPlaceRequest getPlaceRequest = new GetPlaceRequest
PlaceName = placeName
CallSettings getPlaceCallSettings = CallSettings.FromHeader("X-Goog-FieldMask", getPlaceFields);
Place placeResponse = await client.GetPlaceAsync(getPlaceRequest, getPlaceCallSettings);
string photoMediaNameString = $"{firstPhotoResourceName}/media";
GetPhotoMediaRequest photoRequest = new GetPhotoMediaRequest
Name = photoMediaNameString,
MaxWidthPx = photoMaxWidth
PhotoMedia photoMediaResponse = await client.GetPhotoMediaAsync(photoRequest);