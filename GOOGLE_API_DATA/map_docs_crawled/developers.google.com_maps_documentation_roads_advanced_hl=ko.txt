Source URL: https://developers.google.com/maps/documentation/roads/advanced?hl=ko
Title: 고급 개념

의견 보내기

고급 개념

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

참고: 아래 예에서는 Google Maps 서비스용 Java 클라이언트 [https://github.com/googlemaps/google-maps-services-java]의 Roads API를 사용합니다. 원하는 언어에 맞게 개념을 적용할 수 있습니다. Python Client [https://github.com/googlemaps/google-maps-services-python], Go Client [https://github.com/googlemaps/google-maps-services-go], Node.js Client [https://github.com/googlemaps/google-maps-services-js]도 GitHub에서 제공됩니다.
데이터 획득

수집된 위치 데이터를 가져오는 여러 가지 방법이 있습니다. 여기서는 Roads API의 도로에 맞추기 [https://developers.google.com/maps/documentation/roads/snap?hl=ko] 기능과 함께 사용할 데이터를 획득하는 두 가지 기법을 설명합니다.

GPX

GPX는 GPS 기기에서 캡처한 경로, 트랙, 경유지를 공유하기 위한 개방형 XML 기반 형식입니다. 이 예에서는 Java 서버와 모바일 환경 모두에서 사용할 수 있는 경량 XML 파서인 XmlPull [http://www.xmlpull.org/] 파서를 사용합니다.

/**
* Parses the waypoint (wpt tags) data into native objects from a GPX stream.
*/
private List<LatLng> loadGpxData(XmlPullParser parser, InputStream gpxIn)
throws XmlPullParserException, IOException {
List<LatLng> latLngs = new ArrayList<>();
parser.setInput(gpxIn, null);
parser.nextTag();

while (parser.next() != XmlPullParser.END_DOCUMENT) {
if (parser.getEventType() != XmlPullParser.START_TAG) {
continue;
Double.valueOf(parser.getAttributeValue(null, "lat")),
Double.valueOf(parser.getAttributeValue(null, "lon"))));
Android 위치 서비스

Android 기기에서 GPS 데이터를 캡처하는 가장 좋은 방법은 사용 사례에 따라 다릅니다. 위치 업데이트 수신 [https://developer.android.com/training/location/receive-location-updates.html?hl=ko]에 관한 Android 교육 클래스와 GitHub의 Google Play 위치 샘플 [https://github.com/googlesamples/android-play-location]을 참고하세요.

긴 경로 처리

도로에 맞추기 [https://developers.google.com/maps/documentation/roads/snap?hl=ko] 기능은 개별 포인트가 아닌 전체 경로를 기반으로 위치를 추론하므로 긴 경로 (즉, 요청당 100포인트 제한을 초과하는 경로)를 처리할 때 주의해야 합니다.

개별 요청을 하나의 긴 경로로 처리하려면 이전 요청의 최종 지점이 후속 요청의 첫 번째 지점으로 포함되도록 일부 중복을 포함해야 합니다. 포함할 포인트 수는 데이터의 정확도에 따라 달라집니다. 정확도가 낮은 요청에는 더 많은 포인트를 포함해야 합니다.

이 예에서는 Google 지도 서비스용 Java 클라이언트 [https://github.com/googlemaps/google-maps-services-java]를 사용하여 페이지로 나눈 요청을 전송한 다음 보간된 점을 포함한 데이터를 반환된 목록에 다시 결합합니다.

/**
* Snaps the points to their most likely position on roads using the Roads API.
*/
private List<SnappedPoint> snapToRoads(GeoApiContext context) throws Exception {
List<SnappedPoint> snappedPoints = new ArrayList<>();

int offset = 0;
while (offset < mCapturedLocations.size()) {
int upperBound = Math.min(offset + PAGE_SIZE_LIMIT, mCapturedLocations.size());

LatLng[] page = mCapturedLocations
.subList(lowerBound, upperBound)
.toArray(new LatLng[upperBound - lowerBound]);

SnappedPoint[] points = RoadsApi.snapToRoads(context, true, page).await();
boolean passedOverlap = false;
for (SnappedPoint point : points) {
if (offset == 0 || point.originalIndex >= PAGINATION_OVERLAP - 1) {
passedOverlap = true;
throws Exception {
Map<String, SpeedLimit> placeSpeeds = new HashMap<>();

String[] uniquePlaceIds =
placeSpeeds.keySet().toArray(new String[placeSpeeds.keySet().size()]);

String[] page = Arrays.copyOfRange(uniquePlaceIds, i,
Math.min(i + PAGE_SIZE_LIMIT, uniquePlaceIds.length));

SpeedLimit[] placeLimits = RoadsApi.speedLimits(context, page).await();
for (SpeedLimit sl : placeLimits) {
placeSpeeds.put(sl.placeId, sl);
GeocodingResult[] results = GeocodingApi.newRequest(context)
.place(point.placeId)
.await();

if (results.length > 0) {
return results[0];