Source URL: https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko
Title: 새 Places SDK 클라이언트로 마이그레이션

의견 보내기

새 Places SDK 클라이언트로 마이그레이션

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

유럽 경제 지역 (EEA) 개발자

청구서 수신 주소가 유럽 경제 지역에 있는 경우 2025년 7월 8일부터
Google Maps Platform EEA 서비스 약관 [https://cloud.google.com/terms/maps-platform/eea?hl=ko]
이 서비스 이용에 적용됩니다. 기능은 리전에 따라 다릅니다.
자세히 알아보기 [https://developers.google.com/maps/comms/eea/faq?hl=ko]

이 가이드에서는 장소 호환성 라이브러리와 새로운 독립형 버전의 Android용 Places SDK [https://developers.google.com/maps/documentation/places/android-sdk?hl=ko] 간의 변경사항을 설명합니다.
Android용 Places SDK의 새로운 독립형 버전으로 이전하는 대신 장소 호환성 라이브러리를 사용해 온 경우 이 가이드에서는 Android용 Places SDK의 새 버전을 사용하도록 프로젝트를 업데이트하는 방법을 보여줍니다.

Android용 Places SDK 버전 2.6.0 이상에서 기능과 버그 수정에 액세스하는 유일한 방법은 Android용 Places SDK를 사용하는 것입니다.
가능한 한 빨리 호환성 라이브러리에서 새로운 Android용 Places SDK 버전으로 업데이트하는 것이 좋습니다.

오류: 9005 PLACES_API_RATE_LIMIT_EXCEEDED

알림: Android 앱에 9005
PLACES_API_RATE_LIMIT_EXCEEDED 오류가 표시되면 Android용 Places SDK의 지원 중단된 버전을 사용 중일 수도 있습니다. Android용 Places SDK의 Google Play 서비스 버전(예: com.google.android.gms:play-services-places)은 2019년 1월 29일부로 지원 중단되었으며 2019년 7월 29일에 사용 중지되었습니다. 이제 새로운 버전의 Android용 Places SDK를 사용할 수 있습니다. 가능한 한 빨리 새 버전으로 업데이트하는 것이 좋습니다.

변경사항

알림:
Android용 Places SDK 버전 2.0.0 이상은 AndroidX [https://developer.android.com/jetpack/androidx?hl=ko]에 종속됩니다.
이 버전부터는 이전 지원 라이브러리가 더 이상 지원되지 않습니다. 호환성을 유지하려면 AndroidX를 사용하도록 프로젝트를 이전해야 합니다.

주요 변경사항은 다음과 같습니다.

새 버전의 Places SDK for Android는 정적 클라이언트 라이브러리로 배포됩니다. 2019년 1월 이전에는 Android용 Places SDK가 Google Play 서비스를 통해 제공되었습니다. 그 후 Android용 새 Places SDK로의 전환을 용이하게 하기 위해 Places 호환성 라이브러리가 제공되었습니다.
완전히 새로운 방법 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#methods]이 있습니다.
이제 장소 세부정보를 반환하는 메서드에 필드 마스크 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#field-masks]가 지원됩니다. 필드 마스크를 사용하여 반환할 장소 데이터 유형을 지정할 수 있습니다.
오류를 보고하는 데 사용되는 상태 코드 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#status-codes]가 개선되었습니다.
이제 Autocomplete에서 세션 토큰 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#session-tokens]을 지원합니다.
장소 선택 도구는 더 이상 사용할 수 없습니다 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#place-picker-deprecation].

장소 호환성 라이브러리 정보

2019년 1월 Android용 독립형 Places SDK 버전 1.0이 출시되면서 Google은 지원이 중단된 Google Play 서비스 버전의 Android용 Places SDK(com.google.android.gms:play-services-places)에서 이전하는 데 도움이 되는 호환성 라이브러리를 제공했습니다.

이 호환성 라이브러리는 개발자가 독립형 SDK에서 새 이름을 사용하도록 코드를 이전할 수 있을 때까지 Google Play 서비스 버전을 대상으로 하는 API 호출을 새 독립형 버전으로 리디렉션하고 변환하기 위해 일시적으로 제공되었습니다. 버전 1.0부터 버전 2.6.0까지 출시된 Android용 Places SDK의 각 버전에 대해 동일한 기능을 제공하는 장소 호환성 라이브러리의 해당 버전이 출시되었습니다.

장소 호환성 라이브러리 고정 및 지원 중단

Android용 Places SDK 호환성 라이브러리의 모든 버전은 2022년 3월 31일부로 지원 중단되었습니다. 버전 2.6.0은 Places 호환성 라이브러리의 마지막 버전입니다. Android용 Places SDK 버전 2.6.0 이상에서 기능과 버그 수정에 액세스하는 유일한 방법은 Android용 Places SDK를 사용하는 것입니다.

버전 2.6.0 이상의 출시에서 새로운 기능과 중요한 버그 수정에 액세스하려면 Android용 Places SDK로 이전하는 것이 좋습니다.
현재 호환성 라이브러리를 사용하고 있다면 Android용 Places SDK 설치 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#install_the_client_library] 섹션의 단계에 따라 Android용 Places SDK로 이전하세요.
참고: 호환성 라이브러리와 Android용 Places SDK는 일부 상태 코드와 Autocomplete 클래스 이름이 서로 다릅니다. 따라서 Android용 Places SDK로 변환할 때 빌드 오류가 발생할 수 있습니다. 이러한 빌드 오류를 해결하는 방법은 아래 섹션을 참고하세요.

클라이언트 라이브러리 설치

알림:
Android용 Places SDK를 사용하려면 다음을 충족해야 합니다.

모든 API 요청에 API 키 [https://developers.google.com/maps/documentation/places/android-sdk/get-api-key?hl=ko]를 포함합니다.
각 프로젝트에서 결제를 사용 설정합니다.
각 프로젝트에 Places API [https://cloud.google.com/console/apis/library/places-backend.googleapis.com?hl=ko]를 사용 설정합니다.

새 버전의 Places SDK for Android는 정적 클라이언트 라이브러리로 배포됩니다.
참고: Android용 Places SDK(com.google.android.libraries.places:places) 또는 호환성 라이브러리(com.google.android.libraries.places:places-compat) 중 하나만 설치할 수 있으며 둘 다 설치할 수는 없습니다.
Maven [https://maven.apache.org/]을 사용하여 Android 스튜디오 프로젝트에 Places SDK for Android를 추가합니다.

현재 장소 호환성 라이브러리를 사용 중인 경우:

dependencies 섹션에서 다음 줄을 바꿉니다.

implementation 'com.google.android.libraries.places:places-compat:X.Y.Z'

다음 줄을 사용하여 Android용 Places SDK로 전환합니다.

implementation("com.google.android.libraries.places:places:4.3.1")

현재 Android용 Places SDK의 Play 서비스 버전을 사용 중인 경우:

dependencies 섹션에서 다음 줄을 바꿉니다.

implementation 'com.google.android.gms:play-services-places:X.Y.Z'

다음 줄을 사용하여 Android용 Places SDK로 전환합니다.

implementation("com.google.android.libraries.places:places:4.3.1")

Gradle 프로젝트를 동기화합니다.
애플리케이션 프로젝트의 minSdkVersion을 23 이상으로 설정합니다.
'Google 제공' 애셋을 업데이트합니다.

@drawable/powered_by_google_light // OLD
@drawable/places_powered_by_google_light // NEW
@drawable/powered_by_google_dark // OLD
@drawable/places_powered_by_google_dark // NEW
앱을 빌드합니다. Android용 Places SDK로의 변환으로 인해 빌드 오류가 표시되면 아래 섹션에서 이러한 오류 해결에 관한 정보를 확인하세요.

새 Places SDK 클라이언트 초기화

다음 예와 같이 새 Places SDK 클라이언트를 초기화합니다.

...

Places.initialize(getApplicationContext(), apiKey);

PlacesClient placesClient = Places.createClient(this);

상태 코드

QPS 한도 오류의 상태 코드가 변경되었습니다. 이제 QPS 한도 오류가 PlaceStatusCodes.OVER_QUERY_LIMIT를 통해 반환됩니다. QPD 한도가 더 이상 없습니다.

다음 상태 코드가 추가되었습니다.

REQUEST_DENIED - 요청이 거부되었습니다. 여기에는 다음과 같은 여러 이유가 있을 수 있습니다.

API 키가 제공되지 않았습니다.
잘못된 API 키가 제공되었습니다.
Cloud 콘솔에서 Places API가 사용 설정되지 않았습니다.
잘못된 키 제한사항이 있는 API 키가 제공되었습니다.

INVALID_REQUEST - 인수가 누락되었거나 잘못되어 요청이 유효하지 않습니다.
NOT_FOUND - 지정된 요청에 대한 결과가 없습니다.

새로운 방법

Android용 Places SDK의 새 버전에는 일관성을 위해 설계된 완전히 새로운 메서드가 도입되었습니다. 새 메서드는 모두 다음을 준수합니다.

엔드포인트는 더 이상 get 동사를 사용하지 않습니다.
요청 및 응답 객체는 해당 클라이언트 메서드와 동일한 이름을 공유합니다.
이제 요청 객체에 빌더가 있습니다. 필수 매개변수는 요청 빌더 매개변수로 전달됩니다.
버퍼는 더 이상 사용되지 않습니다.

이 섹션에서는 새로운 메서드를 소개하고 작동 방식을 보여줍니다.

ID로 장소 가져오기

fetchPlace() [https://developers.google.com/maps/documentation/places/android-sdk/reference/com/google/android/libraries/places/api/net/PlacesClient?hl=ko#fetchPlace(com.google.android.libraries.places.api.net.FetchPlaceRequest)]을 사용하여 특정 장소에 관한 세부정보를 가져옵니다. fetchPlace()는 getPlaceById() [https://developers.google.com/android/reference/com/google/android/gms/location/places/GeoDataClient?hl=ko]와 유사하게 작동합니다.

fetchPlace()를 호출하여 Places Details SKU [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#places-details]를 시작합니다. 이 SKU의 비용에는 요청과 Basic Data SKU [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#basic-data]에 속하는 데이터 필드가 포함됩니다.
추가 요금을 지불하고 Contact Data [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#contact-data] 및 Atmosphere Data [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#atmosphere-data]를 요청할 수도 있습니다. 자세한 내용은 사용량 및 결제 [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko]를 참고하세요.

장소를 가져오려면 다음 단계를 따르세요.

fetchPlace()를 호출하여 장소 ID와 반환할 장소 데이터를 지정하는 필드 [https://developers.google.com/maps/documentation/places/android-sdk/legacy/client-migration?hl=ko#field-masks] 목록을 지정하는 FetchPlaceRequest 객체를 전달합니다.
String placeId = "INSERT_PLACE_ID_HERE";

List<Place.Field> placeFields = Arrays.asList(Place.Field.ID, Place.Field.DISPLAY_NAME);

FetchPlaceRequest request = FetchPlaceRequest.builder(placeId, placeFields)
.build();

addOnSuccessListener()을 호출하여 FetchPlaceResponse을 처리합니다. 단일 Place 결과가 반환됩니다.
Place place = response.getPlace();
Log.i(TAG, "Place found: " + place.getName());
ApiException apiException = (ApiException) exception;
int statusCode = apiException.getStatusCode();
Log.e(TAG, "Place not found: " + exception.getMessage());
List<Place.Field> fields = Arrays.asList(Place.Field.PHOTO_METADATAS);

장소 객체를 가져옵니다 (이 예에서는 fetchPlace()를 사용하지만 findCurrentPlace()를 사용할 수도 있음).
FetchPlaceRequest placeRequest = FetchPlaceRequest.builder(placeId, fields).build();

FetchPlaceResponse에서 결과 Place의 사진 메타데이터를 가져오기 위해 OnSuccessListener를 추가한 다음 결과 사진 메타데이터를 사용하여 비트맵과 저작자 표시 텍스트를 가져옵니다.
placesClient.fetchPlace(placeRequest).addOnSuccessListener((response) -> {
Place place = response.getPlace();

PhotoMetadata photoMetadata = place.getPhotoMetadatas().get(0);

String attributions = photoMetadata.getAttributions();

FetchPhotoRequest photoRequest = FetchPhotoRequest.builder(photoMetadata)
.setMaxWidth(500) // Optional.
.setMaxHeight(300) // Optional.
.build();
placesClient.fetchPhoto(photoRequest).addOnSuccessListener((fetchPhotoResponse) -> {
Bitmap bitmap = fetchPhotoResponse.getBitmap();
imageView.setImageBitmap(bitmap);
ApiException apiException = (ApiException) exception;
int statusCode = apiException.getStatusCode();
Log.e(TAG, "Place not found: " + exception.getMessage());
List<Place.Field> placeFields = Arrays.asList(Place.Field.DISPLAY_NAME);

FindCurrentPlaceRequest request =
FindCurrentPlaceRequest.builder(placeFields).build();

findCurrentPlace를 호출하고 응답을 처리합니다. 먼저 사용자가 기기 위치 사용 권한을 부여했는지 확인합니다.
placeLikelihood.getLikelihood()));
textView.append(String.format("Place '%s' has likelihood: %f\n",
placeLikelihood.getPlace().getName(),
placeLikelihood.getLikelihood()));
ApiException apiException = (ApiException) exception;
Log.e(TAG, "Place not found: " + apiException.getStatusCode());

findAutocompletePredictions() 호출은 다음 SKU를 시작할 수 있습니다. Autocomplete – Per Request [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#ac-per-character] (세션 토큰이 포함되지 않은 경우), Autocomplete without Places Details – Per Session [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#ac-no-details-session] (세션에 Place Details 요청이 포함되지 않은 경우), Autocomplete (included with Places Details) – Per Session [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#ac-with-details-session] (자동 완성 세션이 fetchPlace 호출로 종료된 경우). 자세한 내용은 사용량 및 청구 [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko]를 참고하세요.

다음은 findAutocompletePredictions()를 호출하는 예를 보여줍니다.
AutocompleteSessionToken token = AutocompleteSessionToken.newInstance();
RectangularBounds bounds = RectangularBounds.newInstance(
new LatLng(-33.880490, 151.184363),
new LatLng(-33.858754, 151.229596));
FindAutocompletePredictionsRequest request = FindAutocompletePredictionsRequest.builder()

placesClient.findAutocompletePredictions(request).addOnSuccessListener((response) -> {
for (AutocompletePrediction prediction : response.getAutocompletePredictions()) {
Log.i(TAG, prediction.getPlaceId());
Log.i(TAG, prediction.getPrimaryText(null).toString());
ApiException apiException = (ApiException) exception;
Log.e(TAG, "Place not found: " + apiException.getStatusCode());
List<Place.Field> placeFields = Arrays.asList(Place.Field.FORMATTED_ADDRESS,
Place.Field.ID,
Place.Field.INTERNATIONAL_PHONE_NUMBER);

필드 마스크에서 사용할 수 있는 필드 목록은 장소 데이터 필드 (신규) [https://developers.google.com/maps/documentation/places/android-sdk/data-fields?hl=ko]를 참고하세요.

중요! findCurrentPlace()에서는 Place.Field.ADDRESS_COMPONENTS, Place.Field.OPENING_HOURS, Place.Field.INTERNATIONAL_PHONE_NUMBER, Place.Field.WEBSITE_URI 필드를 지원하지 않습니다.

Places Data SKU [https://developers.google.com/maps/documentation/places/android-sdk/usage-and-billing?hl=ko#data-skus]에 대해 자세히 알아보세요.

Place Picker 및 Autocomplete 업데이트

이 섹션에서는 장소 위젯 (장소 선택 도구 및 자동 완성)의 변경사항을 설명합니다.

프로그래매틱 자동 완성

자동 완성 [https://developers.google.com/maps/documentation/places/android-sdk/autocomplete?hl=ko#get_place_predictions_programmatically]이 다음과 같이 변경되었습니다.

PlaceAutocomplete에서 Autocomplete로 이름이 변경되었습니다.

PlaceAutocomplete.getPlace에서 Autocomplete.getPlaceFromIntent로 이름이 변경되었습니다.
PlaceAutocomplete.getStatus에서 Autocomplete.getStatusFromIntent로 이름이 변경되었습니다.

PlaceAutocomplete.RESULT_ERROR의 이름이 AutocompleteActivity.RESULT_ERROR로 변경되었습니다(자동 완성 프래그먼트의 오류 처리는 변경되지 않음).

장소 선택기

장소 선택 도구는 2019년 1월 29일에 지원 중단되었습니다. 2019년 7월 29일에 사용 중지되었으며 더 이상 사용할 수 없습니다. 계속 사용하면 오류 메시지가 표시됩니다. 새 SDK는 장소 선택기를 지원하지 않습니다.

자동 완성 위젯

자동 완성 위젯이 업데이트되었습니다.

모든 클래스에서 Place 접두사가 삭제되었습니다.
세션 토큰 지원이 추가되었습니다. 위젯은 백그라운드에서 자동으로 토큰을 관리합니다.
사용자가 선택한 후 반환할 장소 데이터 유형을 선택할 수 있는 필드 마스크 지원이 추가되었습니다.

다음 섹션에서는 프로젝트에 자동 완성 위젯을 추가하는 방법을 보여줍니다.

AutocompleteFragment 삽입

자동 완성 프래그먼트를 추가하려면 다음 단계를 따르세요.

다음 예와 같이 활동의 XML 레이아웃에 프래그먼트를 추가합니다.
<fragment
android:id="@+id/autocomplete_fragment"
android:layout_width="match_parent"
android:layout_height="wrap_content"
android:name=
"com.google.android.libraries.places.widget.AutocompleteSupportFragment"
/>

활동에 자동 완성 위젯을 추가하려면 다음 단계를 따르세요.

애플리케이션 컨텍스트와 API 키를 전달하여 Places를 초기화합니다.
AutocompleteSupportFragment를 초기화합니다.
setPlaceFields()를 호출하여 가져올 장소 데이터의 유형을 나타냅니다.
결과를 처리하고 발생할 수 있는 오류를 처리하기 위해 PlaceSelectionListener를 추가합니다.

다음 예는 활동에 자동 완성 위젯을 추가하는 방법을 보여줍니다.
/**
* Initialize Places. For simplicity, the API key is hard-coded. In a production
* environment we recommend using a secure mechanism to manage API keys.
*/
if (!Places.isInitialized()) {
Places.initialize(getApplicationContext(), "YOUR_API_KEY");
AutocompleteSupportFragment autocompleteFragment = (AutocompleteSupportFragment)
getSupportFragmentManager().findFragmentById(R.id.autocomplete_fragment);

autocompleteFragment.setPlaceFields(Arrays.asList(Place.Field.ID, Place.Field.DISPLAY_NAME));

autocompleteFragment.setOnPlaceSelectedListener(new PlaceSelectionListener() {
@Override
public void onPlaceSelected(Place place) {
Log.i(TAG, "Place: " + place.getName() + ", " + place.getId());
Log.i(TAG, "An error occurred: " + status);
Autocomplete.IntentBuilder를 사용하여 원하는 PlaceAutocomplete 모드 (전체 화면 또는 오버레이)를 전달하는 인텐트를 만듭니다. 인텐트는 startActivityForResult를 호출하여 인텐트를 식별하는 요청 코드를 전달해야 합니다.
onActivityResult 콜백을 재정의하여 선택한 장소를 수신합니다.

다음 예에서는 인텐트를 사용하여 자동 완성을 실행한 후 결과를 처리하는 방법을 보여줍니다.
/**
* Initialize Places. For simplicity, the API key is hard-coded. In a production
* environment we recommend using a secure mechanism to manage API keys.
*/
if (!Places.isInitialized()) {
Places.initialize(getApplicationContext(), "YOUR_API_KEY");
List<Place.Field> fields = Arrays.asList(Place.Field.ID, Place.Field.DISPLAY_NAME);

Intent intent = new Autocomplete.IntentBuilder(
AutocompleteActivityMode.FULLSCREEN, fields)
.build(this);
startActivityForResult(intent, AUTOCOMPLETE_REQUEST_CODE);

...

/**
* Override the activity's onActivityResult(), check the request code, and
* do something with the returned place data (in this example its place name and place ID).
*/
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
if (requestCode == AUTOCOMPLETE_REQUEST_CODE) {
if (resultCode == RESULT_OK) {
Place place = Autocomplete.getPlaceFromIntent(data);
Log.i(TAG, "Place: " + place.getName() + ", " + place.getId());
Status status = Autocomplete.getStatusFromIntent(data);
Log.i(TAG, status.getStatusMessage());