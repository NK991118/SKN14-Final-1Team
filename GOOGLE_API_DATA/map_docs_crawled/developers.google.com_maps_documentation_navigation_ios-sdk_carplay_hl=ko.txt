Source URL: https://developers.google.com/maps/documentation/navigation/ios-sdk/carplay?hl=ko
Title: CarPlay 내비게이션 사용 설정

의견 보내기

CarPlay 내비게이션 사용 설정

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 제품 또는 기능은 미리보기(GA 이전) 버전입니다.
GA 이전 제품과 기능은 지원이 제한적일 수 있으며, GA 이전 제품과 기능에 대한 변경사항은 다른 GA 이전 버전과 호환되지 않을 수 있습니다. GA 이전 버전 제품 및 서비스에는 Google Maps Platform 서비스별 약관 [https://cloud.google.com/maps-platform/terms/maps-service-terms?hl=ko]이 적용됩니다. 자세한 내용은 출시 단계 설명 [https://developers.google.com/maps/launch-stages?hl=ko]을 참고하세요.

중요: CarPlay에서 사용하도록 개발된 모든 앱에는 Apple의 CarPlay 권한이 필요하며 Apple의 CarPlay 가이드라인을 따라야 합니다. 이 가이드에서는 따라야 하는 표준 사례를 제공하지만 CarPlay용 앱을 출시하려면 먼저 앱을 제출하여 승인을 받아야 합니다. 자세한 내용은 Apple의 CarPlay 앱 프로그래밍 가이드 [https://developer.apple.com/carplay/documentation/CarPlay-App-Programming-Guide.pdf] 및 CarPlay 인적 인터페이스 가이드라인 [https://developer.apple.com/design/human-interface-guidelines/carplay]을 참고하세요.

이 섹션에서는 Apple CarPlay 라이브러리와 함께 Navigation SDK를 사용하여 대시보드 헤드 유닛 [https://en.wikipedia.org/wiki/Automotive_head_unit]에 앱의 탐색 환경을 표시하는 방법을 설명합니다. 운전자의 대시보드 시스템이 CarPlay를 지원하는 경우 운전자는 휴대전화를 기기에 연결하여 자동차 디스플레이에서 직접 앱을 사용할 수 있습니다. 음성 안내는 차량 스피커에서도 실행됩니다.

Apple에서 제공하는 UI 템플릿 세트에서 CarPlay 앱을 빌드합니다. 앱은 표시할 템플릿을 선택하고 템플릿 내에 데이터를 제공해야 합니다.

대시보드 내 시스템은 안전 승인을 받은 대화형 요소를 표시하므로 운전자는 과도한 주의 분산 없이 안전하게 목적지로 이동할 수 있습니다. 운전자가 주문 수락 또는 거부, 지도에서 고객 위치 보기와 같은 앱별 기능과 상호작용할 수 있도록 앱을 프로그래밍할 수도 있습니다. 주문 상태 업데이트가 대시보드 단위에 표시되도록 프로그래밍할 수도 있습니다.

왼쪽 이미지는 CarPlay 탐색 디스플레이의 예를 보여줍니다. 오른쪽 이미지는 휴대전화에 표시되는 것과 동일한 탐색을 보여줍니다.

설정

CarPlay로 시작

먼저 Apple 문서를 숙지하세요.

Apple CarPlay 개발자 가이드 [https://developer.apple.com/carplay/]
Apple CarPlay 개발자 PDF [https://developer.apple.com/carplay/documentation/CarPlay-App-Programming-Guide.pdf]

Navigation SDK 설정

Apple 문서를 읽었으면 Navigation SDK를 사용할 준비가 된 것입니다.
아직 Navigation SDK를 앱에 통합하지 않은 경우 프로젝트를 설정 [https://developers.google.com/maps/documentation/navigation/ios-sdk/config?hl=ko]합니다.
앱에 대해 턴바이턴 안내 피드를 사용 설정 [https://developers.google.com/maps/documentation/navigation/ios-sdk/nav-only-feed?hl=ko]합니다.
선택사항입니다. Navigation SDK에서 생성된 아이콘 [https://developers.google.com/maps/documentation/navigation/ios-sdk/nav-only-feed?hl=ko#creating_icons_for_maneuvers]을 사용합니다.
UIView 클래스에 제공된 GMSMapView 클래스를 사용하여 지도를 그립니다. 자세한 내용은 경로 탐색 [https://developers.google.com/maps/documentation/navigation/ios-sdk/route?hl=ko]을 참고하세요. TurnByTurn 라이브러리의 데이터로 CPNavigationSession를 채웁니다.

지도 및 탐색 UI 그리기

GMSMapView [https://developers.google.com/maps/documentation/ios-sdk/reference/objc/Classes/GMSMapView?hl=ko] 클래스는 지도를 렌더링하고 CPMapTemplate [https://developer.apple.com/documentation/carplay/cpmaptemplate]는 CarPlay 화면에 UI를 렌더링합니다. 휴대전화용 GMSMapView와 거의 동일한 기능을 제공하지만 상호작용은 제한적입니다.

Swift
init(window: CPWindow) {
super.init(nibName: nil, bundle: nil)
self.window = window

mapViewOptions.frame = self.view.bounds

mapView = GMSMapView(options: mapViewOptions)
mapView.autoresizingMask = [.flexibleHeight, .flexibleWidth]
mapView.settings.isNavigationHeaderEnabled = false
mapView.settings.isNavigationFooterEnabled = false

mapView.settings.isRecenterButtonEnabled = false
mapView.shouldDisplaySpeedometer = false
mapView.isMyLocationEnabled = true

self.view.addSubview(mapView)
Objective-C
- (instancetype)initWithWindow:(CPWindow *)window {
self = [super initWithNibName:nil bundle:nil];
if (self) {
_window = window;

GMSMapViewOptions *options = [[GMSMapViewOptions alloc] init];
options.screen = _window.screen;
options.frame = self.view.bounds;
_mapView = [[GMSMapView alloc] initWithOptions:options];
_mapView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
_mapView.settings.navigationHeaderEnabled = NO;
_mapView.settings.navigationFooterEnabled = NO;

_mapView.settings.recenterButtonEnabled = NO;

_mapView.shouldDisplaySpeedometer = NO;
_mapView.myLocationEnabled = YES;

[self.view addSubview:_mapView];
break;
case .right:
scrollAmount.x += scrollDistance
break;
case .up:
scrollAmount.y += scrollDistance
break;
case .down:
scrollAmount.y -= scrollDistance
break;
default:
break;
Objective-C
#pragma mark - CPMapTemplateDelegate

- (void)mapTemplate:(CPMapTemplate *)mapTemplate panBeganWithDirection:(CPPanDirection)direction {
CGPoint scrollAmount = [self scrollAmountForPanDirection:direction];
GMSCameraUpdate *scroll = [GMSCameraUpdate scrollByX:scrollAmount.x Y:scrollAmount.y];
[_mapView animateWithCameraUpdate:scroll];
CGPoint scrollAmount = {0., 0.};
if (direction & CPPanDirectionLeft) {
scrollAmount.x = -scrollDistance;
CGPointMake(scrollAmount.x * (CGFloat)M_SQRT1_2, scrollAmount.y * (CGFloat)M_SQRT1_2);
Objective-C
#pragma mark - Create Buttons

- (NSArray<CPMapButton *>*)createMapButtons {
NSMutableArray<CPMapButton *> *mapButtons = [NSMutableArray<CPMapButton *> array];

__weak __typeof__(self) weakSelf = self;
CPMapButton *panButton = [self mapButtonWithSystemImageNamed:@"dpad.fill"
handler:^(CPMapButton *_) {
[weakSelf didTapPanButton];

CPMapButton *zoomOutButton =
[self mapButtonWithSystemImageNamed:@"minus.magnifyingglass"
handler:^(CPMapButton *_Nonnull mapButon) {
[weakSelf didTapZoomOutButton];

CPMapButton *zoomInButton =
[self mapButtonWithSystemImageNamed:@"plus.magnifyingglass"
handler:^(CPMapButton *_Nonnull mapButon) {
[weakSelf didTapZoomInButton];

CPMapButton *myLocationButton =
[self mapButtonWithSystemImageNamed:@"location"
handler:^(CPMapButton *_Nonnull mapButton) {
[weakSelf didTapMyLocationButton];
return mapButtons;
CLLocation *location = self.lastLocation;
if (location) {
GMSCameraPosition *position =
[[GMSCameraPosition alloc] initWithTarget:self.lastLocation.coordinate zoom:15.];
[_mapView animateToCameraPosition:position];
_isPanningInterfaceEnabled = YES;
_isPanningInterfaceEnabled = NO;
break
case .destinationLeft:
maneuver.instructionVariants = ["Your destination is ahead on your left."]
break
case .destinationRight:
maneuver.instructionVariants = ["Your destination is ahead on your right."]
break
default:
maneuver.attributedInstructionVariants = currentNavInfo?.instructions(forStep: stepInfo, options: instructionOptions)
break
return maneuver
Objective-C
NSMeasurement<NSUnitLength *> *distanceRemaining = [navInfo roundedDistance:navInfo.distanceToCurrentStepMeters];
NSTimeInterval timeRemaining = [navInfo roundedTime:navInfo.timeToCurrentStepSeconds];
CPTravelEstimate* travelEstimate = [[CPTravelEstimates alloc] initWithDistanceRemaining:distanceRemaining
@property(nonatomic, readonly, getter=isLaneGuidance) BOOL laneGuidance;

- (nonnull instancetype)initWithStepInfo:(GMSNavigationStepInfo *)stepInfo

@end

- (CPManeuverDisplayStyle)mapTemplate:(CPMapTemplate *)mapTemplate
displayStyleForManeuver:(nonnull CPManeuver *)maneuver {
ManeuverUserInfo *userInfo = maneuver.userInfo;
return userInfo.laneGuidance ? CPManeuverDisplayStyleSymbolOnly : CPManeuverDisplayStyleDefault;
CPManeuver *maneuver = [[CPManeuver alloc] init];
maneuver.userInfo = [[ManeuverUserInfo alloc] initWithStepInfo:stepInfo isLaneGuidance:NO];
switch (stepInfo.maneuver) {
case GMSNavigationManeuverDestination:
maneuver.instructionVariants = @[ @"Your destination is ahead." ];
break;
case GMSNavigationManeuverDestinationLeft:
maneuver.instructionVariants = @[ @"Your destination is ahead on your left." ];
break;
case GMSNavigationManeuverDestinationRight:
maneuver.instructionVariants = @[ @"Your destination is ahead on your right." ];
break;
default: {
maneuver.attributedInstructionVariants =
[_currentNavInfo instructionsForStep:stepInfo options:_instructionOptions];
break;
return maneuver;
CPManeuver *maneuver = [[CPManeuver alloc] init];
maneuver.userInfo = [[ManeuverUserInfo alloc] initWithStepInfo:stepInfo isLaneGuidance:YES];
UIImage *lanesImage = [stepInfo lanesImageWithOptions:_imageOptions];
if (!lanesImage) {
return nil;
return maneuver;