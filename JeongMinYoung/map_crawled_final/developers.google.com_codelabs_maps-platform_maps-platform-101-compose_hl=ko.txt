Source URL: https://developers.google.com/codelabs/maps-platform/maps-platform-101-compose?hl=ko
Title: Android 앱에 지도 추가(Compose를 사용한 Kotlin)

의견 보내기

Android 앱에 지도 추가(Compose를 사용한 Kotlin)

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

1. 시작하기 전에

이 Codelab에서는 Android용 Maps SDK를 앱과 통합하고 다양한 유형의 마커를 사용하여 미국 콜로라도의 산 지도를 표시하는 앱을 빌드하여 핵심 기능을 사용하는 방법을 알려줍니다. 또한 지도에 다른 도형을 그리는 방법도 알아봅니다.
이 Codelab을 마치면 다음과 같이 표시됩니다.

기본 요건

Kotlin, Jetpack Compose [https://developer.android.com/develop/ui/compose?hl=ko], Android 개발 [https://developer.android.com/modern-android-development?hl=ko]에 관한 기본 지식

실습할 내용

Android용 Maps SDK의 지도 Compose 라이브러리를 사용 설정하고 사용하여 Android 앱에 GoogleMap [https://googlemaps.github.io/android-maps-compose/maps-compose/com.google.maps.android.compose/-google-map.html] 추가
마커 추가 및 맞춤설정
지도에 다각형 그리기
프로그래매틱 방식으로 카메라의 시점 조정

필요한 항목

Android용 Maps SDK [https://developers.google.com/maps/documentation/android-sdk/intro?hl=ko]
결제가 사용 설정된 Google 계정
Android 스튜디오 [https://developer.android.com/studio?hl=ko]의 최신 안정화 버전
Android 5.0 이상 기반의 Google API 플랫폼을 실행하는 Android 기기 또는 Android Emulator [https://developer.android.com/studio/run/managing-avds?hl=ko] (설치 단계는 Android Emulator에서 앱 실행 [https://developer.android.com/studio/run/emulator?hl=ko#install] 참고)
인터넷 연결

2. 설정

다음 사용 설정 단계에서는 Android용 Maps SDK를 사용 설정해야 합니다.
Google Maps Platform 설정하기
Google Cloud Platform 계정 및 결제가 사용 설정된 프로젝트가 없는 경우 Google Maps Platform 시작하기 [https://developers.google.com/maps/gmp-get-started?hl=ko] 가이드를 참고하여 결제 계정 및 프로젝트를 만듭니다.

Cloud Console [https://console.cloud.google.com/?hl=ko]에서 프로젝트 드롭다운 메뉴를 클릭하고 이 Codelab에 사용할 프로젝트를 선택합니다.

Google Cloud Marketplace [https://console.cloud.google.com/marketplace?hl=ko]에서 이 Codelab에 필요한 Google Maps Platform API 및 SDK를 사용 설정합니다. 사용 설정을 위해 이 동영상 [https://youtu.be/n1UorU1PALk] 또는 이 문서 [https://developers.google.com/maps/gmp-get-started?hl=ko#enable-api-sdk]에서 설명하고 있는 단계를 따르세요.
Cloud Console의 사용자 인증 정보 [https://console.cloud.google.com/apis/credentials?hl=ko] 페이지에서 API 키를 생성합니다. 이 동영상 [https://youtu.be/2_HZObVbe-g] 또는 이 문서 [https://developers.google.com/maps/gmp-get-started?hl=ko#api-key]에서 설명하고 있는 단계를 따릅니다. Google Maps Platform에 대한 모든 요청에는 API 키가 필요합니다.

3. 빠른 시작

빠르게 시작할 수 있도록 이 Codelab을 따라 하는 데 도움이 되는 시작 코드가 있습니다. 솔루션으로 바로 넘어갈 수도 있지만, 모든 단계를 따라 하면서 직접 빌드하려면 계속 읽어주시기 바랍니다.

git를 설치한 경우 저장소를 클론합니다.

git clone https://github.com/googlemaps-samples/codelab-maps-platform-101-compose.git

또는 다음 버튼을 클릭하여 소스 코드를 다운로드할 수도 있습니다.
코드 받기 [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/archive/main.zip]

코드를 받으면 Android 스튜디오의 starter 디렉터리 내에 있는 프로젝트를 엽니다.

참고: GitHub 저장소에는 솔루션 프로젝트 [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/blob/main/solution]가 포함되어 있습니다. 이 Codelab을 진행하는 동안 문제가 발생하면 해당 프로젝트를 참고하세요.

4. 프로젝트에 API 키 추가

이 섹션에서는 앱에서 안전하게 참조할 수 있도록 API 키를 저장하는 방법을 설명합니다. API 키는 버전 제어 시스템에 체크인하면 안 되며, 프로젝트의 루트 디렉터리의 로컬 사본에 배치될 secrets.properties 파일에 저장하는 것이 좋습니다. secrets.properties 파일에 관한 자세한 내용은 Gradle 속성 파일 [https://developer.android.com/studio/build?hl=ko#properties-files]을 참고하세요.
이 작업을 간소화하려면 Android용 Secrets Gradle 플러그인 [https://github.com/google/secrets-gradle-plugin]을 사용하는 것이 좋습니다.
참고: 최신 시스템 요구사항 및 설치 안내는 GitHub의 Android용 Secrets Gradle 플러그인 [https://github.com/google/secrets-gradle-plugin] 문서를 참고하세요.

Google 지도 프로젝트에 Android용 Secrets Gradle 플러그인을 설치하려면 다음 단계를 따르세요.

Android 스튜디오에서 최상위 수준 build.gradle.kts 파일을 열고 다음 코드를 buildscript 아래 dependencies 요소에 추가합니다.buildscript {
dependencies {
classpath("com.google.android.libraries.mapsplatform.secrets-gradle-plugin:secrets-gradle-plugin:2.0.1")

이 파일의 목적은 secrets.properties 파일이 없는 경우 빌드에 실패하지 않도록 API 키의 백업 위치를 제공하는 것입니다. 이는 버전 제어 시스템에서 앱을 복제하고 API 키를 제공하는 secrets.properties 파일을 아직 로컬에서 생성하지 않은 경우 발생합니다.
파일을 저장합니다.
AndroidManifest.xml 파일에서 com.google.android.geo.API_KEY로 이동한 후 android:value 속성을 업데이트합니다. <meta-data> 태그가 존재하지 않으면 <application> 태그의 하위 요소로 태그를 만듭니다.    <meta-data
android:name="com.google.android.geo.API_KEY"
android:value="${MAPS_API_KEY}" />

참고: com.google.android.geo.API_KEY는 API 키의 권장되는 메타데이터 이름입니다. 이 이름의 키는 Android 플랫폼에서 Android용 Maps SDK 등 여러 Google 지도 기반 API를 인증하는 데 사용할 수 있습니다. 이전 버전과의 호환성을 위해 API에서는 com.google.android.maps.v2.API_KEY 이름도 지원합니다. 이 레거시 이름은 Android Maps API v2만 인증할 수 있습니다. 애플리케이션은 API 키 메타데이터 이름 중에 하나만 지정할 수 있습니다. 두 개 모두 지정되면 API가 예외를 발생시킵니다.

Android 스튜디오에서 모듈 수준 build.gradle.kts 파일을 열고 secrets 속성을 수정합니다. secrets 속성이 없으면 추가합니다.플러그인의 속성을 수정하여 propertiesFileName을 secrets.properties로 설정하고, defaultPropertiesFileName을 local.defaults.properties로 설정하고, 다른 속성을 설정합니다.secrets {

implementation("com.google.maps.android:maps-compose:$mapsComposeVersion")
Google 지도 컴포저블 추가
MountainMap.kt [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/blob/main/starter/app/src/main/java/com/example/mountainmarkers/MountainMap.kt]에서 MapMountain 컴포저블 내에 중첩된 Box 컴포저블 내에 GoogleMap 컴포저블을 추가합니다.
import com.google.maps.android.compose.GoogleMap
import com.google.maps.android.compose.GoogleMapComposable
paddingValues: PaddingValues,
viewState: MountainsScreenViewState.MountainList,
eventFlow: Flow<MountainsScreenEvent>,
selectedMarkerType: MarkerType,
) {
modifier = Modifier
.fillMaxSize()
.padding(paddingValues)
) {
modifier = Modifier.fillMaxSize(),
onMapLoaded = { isMapLoaded = true }

GoogleMapOptions().mapId("MyMapId")
Mountain 데이터 클래스는 각 산에 관한 모든 데이터를 보유합니다.
data class Mountain(
val id: Int,
val name: String,
val location: LatLng,
val elevation: Meters,

산은 나중에 고도에 따라 파티셔닝됩니다. 높이가 14,000피트 이상인 산을 14,000피트 봉우리 [https://en.wikipedia.org/wiki/List_of_Colorado_fourteeners]라고 합니다. 시작 코드에는 이 검사를 실행하는 확장 함수가 포함되어 있습니다.
/**
* Extension function to determine whether a mountain is a "14er", i.e., has an elevation greater
* than 14,000 feet (~4267 meters).
*/
fun Mountain.is14er() = elevation >= 14_000.feet

참고: 시작 코드에는 단위 변환을 지원하는 Units.kt [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/blob/main/starter/app/src/main/java/com/example/mountainmarkers/data/utils/Units.kt] 유틸리티 파일이 포함되어 있습니다.  단위 일관성을 적용하는 Meters 값 클래스와 미터, 킬로미터, 피트 또는 마일로 표현된 값을 사용하여 Meters 인스턴스를 만드는 확장 함수가 있습니다. 자세한 내용은 Units.kt 파일을 참고하세요.

MountainsScreenViewState [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/blob/main/starter/app/src/main/java/com/example/mountainmarkers/presentation/MountainsScreenViewState.kt]
MountainsScreenViewState 클래스는 뷰를 렌더링하는 데 필요한 모든 데이터를 보유합니다. 산 목록의 로드가 완료되었는지에 따라 Loading 또는 MountainList 상태일 수 있습니다.
/**
* Sealed class representing the state of the mountain map view.
*/
sealed class MountainsScreenViewState {
data object Loading : MountainsScreenViewState()
data class MountainList(
val mountains: StateFlow<List<Mountain>> = _mountains
private var loaded = false

/**
* Loads the list of mountains from the list of mountains from the raw resource.
*/
suspend fun loadMountains(): StateFlow<List<Mountain>> {
if (!loaded) {
loaded = true
_mountains.value = withContext(Dispatchers.IO) {
context.resources.openRawResource(R.raw.top_peaks).use { inputStream ->
readMountains(inputStream)
@Inject
constructor(
mountainsRepository: MountainsRepository
) : ViewModel() {
private val _eventChannel = Channel<MountainsScreenEvent>()

val mountainsScreenViewState =
mountainsRepository.mountains.combine(showAllMountains) { allMountains, showAllMountains ->
if (allMountains.isEmpty()) {
MountainsScreenViewState.Loading
if (showAllMountains) allMountains else allMountains.filter { it.is14er() }
val boundingBox = filteredMountains.map { it.location }.toLatLngBounds()
MountainsScreenViewState.MountainList(
mountains = filteredMountains,
boundingBox = boundingBox,
showingAllPeaks = showAllMountains,
started = SharingStarted.WhileSubscribed(5000),
initialValue = MountainsScreenViewState.Loading

init {
OnZoomAll -> onZoomAll()
OnToggleAllPeaks -> toggleAllPeaks()
ViewModel 사용
뷰 모델은 MainActivity에서 viewState를 가져오는 데 사용됩니다. 이 Codelab의 후반부에서 viewState를 사용하여 마커를 렌더링합니다. 이 코드는 시작 프로젝트에 이미 포함되어 있으며 참고용으로만 표시됩니다.
val viewModel: MountainsViewModel by viewModels()
val screenViewState = viewModel.mountainsScreenViewState.collectAsState()
val viewState = screenViewState.value

참고: 이 프로젝트에서는 종속 항목 삽입에 Hilt를 사용합니다. 이러한 방식으로 MountainsViewModel는 MountainsRepository에 대한 참조를 가져옵니다. 뷰 모델은 viewModels 위임을 사용하여 가져옵니다. Hilt를 사용한 종속 항목 삽입 [https://developer.android.com/training/dependency-injection/hilt-android?hl=ko]은 Android 개발자 사이트 [https://developer.android.com/?hl=ko]에 자세히 설명되어 있습니다.

8. 카메라 배치

GoogleMap 기본값은 위도 0, 경도 0으로 중앙에 배치됩니다. 렌더링할 마커는 미국 콜로라도주에 있습니다. 뷰 모델에서 제공하는 viewState는 모든 마커를 포함하는 LatLngBounds [https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/model/LatLngBounds?hl=ko]를 표시합니다.
MountainMap.kt에서 경계 상자의 중심으로 초기화된 CameraPositionState [https://googlemaps.github.io/android-maps-compose/maps-compose/com.google.maps.android.compose/-camera-position-state/index.html]을 만듭니다. GoogleMap의 cameraPositionState 매개변수를 방금 만든 cameraPositionState 변수로 설정합니다.
fun MountainMap(
scope: CoroutineScope,
cameraPositionState: CameraPositionState,
boundingBox: LatLngBounds
) {
scope.launch {
cameraPositionState.animate(
update = CameraUpdateFactory.newLatLngBounds(boundingBox, 64),
durationMs = 1000

LaunchedEffect(key1 = viewState.boundingBox) {
zoomAll(scope, cameraPositionState, viewState.boundingBox)
BasicMarkersMapContent(
mountains = viewState.mountains,
AdvancedMarkersMapContent(
mountains = viewState.mountains,
ClusteringMarkersMapContent(
mountains = viewState.mountains,
BasicMarkersMapContent에 @GoogleMapComposable 주석을 답니다. GoogleMap 콘텐츠 블록에서는 @GoogleMapComposable 함수만 사용할 수 있습니다. mountains 객체에는 Mountain 객체 목록이 있습니다. Mountain 객체의 위치, 이름, 고도를 사용하여 목록의 각 산에 마커를 추가합니다. 이 위치는 Marker의 상태 매개변수를 설정하는 데 사용되며, 이 매개변수는 마커의 위치를 제어합니다.
import com.google.maps.android.compose.GoogleMapComposable
import com.google.maps.android.compose.Marker
import com.google.maps.android.compose.rememberMarkerState

@Composable
@GoogleMapComposable
fun BasicMarkersMapContent(
mountains: List<Mountain>,
onMountainClick: (Marker) -> Boolean = { false }
) {
mountains.forEach { mountain ->
Marker(
state = rememberMarkerState(position = mountain.location),
title = mountain.name,
snippet = mountain.elevation.toElevationString(),
tag = mountain,
onClick = { marker ->
onMountainClick(marker)
false
data class BitmapParameters(
@DrawableRes val id: Int,
@ColorInt val iconColor: Int,
@ColorInt val backgroundColor: Int? = null,
val backgroundAlpha: Int = 168,
val padding: Int = 16,

fun vectorToBitmap(context: Context, parameters: BitmapParameters): BitmapDescriptor {
@Composable
@GoogleMapComposable
fun BasicMarkersMapContent(
LocalContext.current,
BitmapParameters(
id = R.drawable.baseline_filter_hdr_24,
iconColor = MaterialTheme.colorScheme.secondary.toArgb(),
backgroundColor = MaterialTheme.colorScheme.secondaryContainer.toArgb(),

val fourteenerIcon = vectorToBitmap(
LocalContext.current,
BitmapParameters(
id = R.drawable.baseline_filter_hdr_24,
iconColor = MaterialTheme.colorScheme.onPrimary.toArgb(),
backgroundColor = MaterialTheme.colorScheme.primary.toArgb(),

mountains.forEach { mountain ->
val icon = if (mountain.is14er()) fourteenerIcon else mountainIcon
Marker(
icon = icon,
AdvancedMarkersMapContent 함수에 @GoogleMapComposable을 추가합니다. mountains를 반복하여 각각에 AdvancedMarker를 추가합니다.
@Composable
@GoogleMapComposable
fun AdvancedMarkersMapContent(
mountains: List<Mountain>,
onMountainClick: (Marker) -> Boolean = { false },
) {
mountains.forEach { mountain ->
AdvancedMarker(
state = rememberMarkerState(position = mountain.location),
title = mountain.name,
snippet = mountain.elevation.toElevationString(),
collisionBehavior = AdvancedMarkerOptions.CollisionBehavior.REQUIRED_AND_HIDES_OPTIONAL,
onClick = { marker ->
onMountainClick(marker)
false
앱을 실행하여 고급 마커를 확인합니다. 하단 탐색 행에서 Advanced markers 탭을 선택해야 합니다.

맞춤 AdvancedMarkers
아이콘은 기본 및 보조 색상 체계를 사용하여 14,000피트 봉우리와 기타 산을 구분합니다. vectorToBitmap 함수를 사용하여 BitmapDescriptor를 두 개 만듭니다. 하나는 14,000피트가 넘는 산용이고 다른 하나는 나머지 산용입니다. 이러한 아이콘을 사용하여 각 유형에 맞는 맞춤 pinConfig를 만듭니다. 마지막으로 is14er() 함수를 기반으로 핀을 해당 AdvancedMarker에 적용합니다.
@Composable
@GoogleMapComposable
fun AdvancedMarkersMapContent(
mountains: List<Mountain>,
onMountainClick: (Marker) -> Boolean = { false },
) {
val mountainIcon = vectorToBitmap(
LocalContext.current,
BitmapParameters(
id = R.drawable.baseline_filter_hdr_24,
iconColor = MaterialTheme.colorScheme.onSecondary.toArgb(),

val mountainPin = with(PinConfig.builder()) {
setGlyph(PinConfig.Glyph(mountainIcon))
setBackgroundColor(MaterialTheme.colorScheme.secondary.toArgb())
setBorderColor(MaterialTheme.colorScheme.onSecondary.toArgb())
build()
LocalContext.current,
BitmapParameters(
id = R.drawable.baseline_filter_hdr_24,
iconColor = MaterialTheme.colorScheme.onPrimary.toArgb(),

val fourteenerPin = with(PinConfig.builder()) {
setGlyph(PinConfig.Glyph(fourteenerIcon))
setBackgroundColor(MaterialTheme.colorScheme.primary.toArgb())
setBorderColor(MaterialTheme.colorScheme.onPrimary.toArgb())
build()
AdvancedMarker(
state = rememberMarkerState(position = mountain.location),
title = mountain.name,
snippet = mountain.elevation.toElevationString(),
collisionBehavior = AdvancedMarkerOptions.CollisionBehavior.REQUIRED_AND_HIDES_OPTIONAL,
pinConfig = pin,
onClick = { marker ->
onMountainClick(marker)
false
val mountain: Mountain,
val snippetString: String
) : ClusterItem {
override fun getPosition() = mountain.location
override fun getTitle() = mountain.name
override fun getSnippet() = snippetString
override fun getZIndex() = 0f
mountains: List<Mountain>,
val resources = LocalContext.current.resources

val mountainClusterItems by remember(mountains) {
mutableStateOf(
mountains.map { mountain ->
MountainClusterItem(
mountain = mountain,
snippetString = unitsConverter.toElevationString(resources, mountain.elevation)
Clustering(
items = mountainClusterItems,
ClusteringMarkersMapContent.kt에서 마커의 색 구성표를 정의하는 데이터 클래스를 만듭니다.
data class IconColor(val iconColor: Color, val backgroundColor: Color, val borderColor: Color)

또한 ClusteringMarkersMapContent.kt에서 지정된 색 구성표의 아이콘을 렌더링하는 컴포저블 함수를 만듭니다.
@Composable
private fun SingleMountain(
colors: IconColor,
) {
Icon(
painterResource(id = R.drawable.baseline_filter_hdr_24),
tint = colors.iconColor,
contentDescription = "",
modifier = Modifier
.size(32.dp)
.padding(1.dp)
drawCircle(color = colors.borderColor, style = Stroke(width = 3f))
mountains: List<Mountain>,

val fourteenerColors = IconColor(
iconColor = MaterialTheme.colorScheme.onPrimary,
backgroundColor = MaterialTheme.colorScheme.primary.copy(alpha = backgroundAlpha),
borderColor = MaterialTheme.colorScheme.primary

val otherColors = IconColor(
iconColor = MaterialTheme.colorScheme.secondary,
backgroundColor = MaterialTheme.colorScheme.secondaryContainer.copy(alpha = backgroundAlpha),
borderColor = MaterialTheme.colorScheme.secondary

Clustering(
items = mountainClusterItems,
clusterItemContent = { mountainItem ->
val colors = if (mountainItem.mountain.is14er()) {
fourteenerColors
SingleMountain(colors)
EAST(1),
SOUTH(-1),
WEST(-1)
val direction: Direction,
val degrees: Double,
val minutes: Double = 0.0,
val seconds: Double = 0.0,

fun DMS.toDecimalDegrees(): Double =
(degrees + (minutes / 60) + (seconds / 3600)) * direction.sign

DMS 클래스를 사용하면 네 개의 모서리 LatLng 위치를 정의하고 이를 Polygon [https://googlemaps.github.io/android-maps-compose/maps-compose/com.google.maps.android.compose/-polygon.html]로 렌더링하여 콜로라도의 테두리를 그릴 수 있습니다. 다음 코드를 MountainMap.kt에 추가합니다.
@Composable
@GoogleMapComposable
fun ColoradoPolygon() {
val north = 41.0
val south = 37.0
val east = DMS(WEST, 102.0, 3.0).toDecimalDegrees()
val west = DMS(WEST, 109.0, 3.0).toDecimalDegrees()

val locations = listOf(
LatLng(north, east),
LatLng(south, east),
LatLng(south, west),
LatLng(north, west),

Polygon(
points = locations,
strokeColor = MaterialTheme.colorScheme.tertiary,
strokeWidth = 3F,
fillColor = MaterialTheme.colorScheme.tertiaryContainer.copy(alpha = 0.3f),
ColoradoPolygon()

GoogleMap(
layer.addLayerToMap()
modifier = Modifier
.padding(top = 5.dp, end = 15.dp)
.align(Alignment.TopEnd),
cameraPositionState = cameraPositionState

$ git clone https://github.com/googlemaps-samples/codelab-maps-platform-101-compose.git

또는 다음 버튼을 클릭하여 소스 코드를 다운로드할 수도 있습니다.
코드 받기 [https://github.com/googlemaps-samples/codelab-maps-platform-101-compose/archive/main.zip]

코드를 받으면 Android 스튜디오의 solution 디렉터리 내에 있는 프로젝트를 엽니다.

15. 축하합니다

축하합니다. 많은 내용을 살펴봤습니다. 이제 Android용 Maps SDK에서 제공하는 핵심 기능에 대해 더 잘 이해하셨기를 바랍니다.
자세히 알아보기

Android용 Maps SDK [https://developers.google.com/maps/documentation/android-sdk?hl=ko] - Android 앱을 위한 양방향의 동적 맞춤 지도, 위치, 지리정보 환경을 구축하세요.
Maps Compose 라이브러리 [https://developers.google.com/maps/documentation/android-sdk/maps-compose?hl=ko] - Jetpack Compose와 함께 사용하여 앱을 빌드할 수 있는 오픈소스 구성 가능한 함수 및 데이터 유형의 집합입니다.
android-maps-compose [https://github.com/googlemaps/android-maps-compose] - 이 Codelab 등에서 다룬 모든 기능을 보여주는 GitHub의 샘플 코드입니다.
Google Maps Platform으로 Android 앱을 빌드하는 추가 Kotlin Codelab [https://codelabs.developers.google.com/?product=googlemapsplatform&text=kotlin&hl=ko]