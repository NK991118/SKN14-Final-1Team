Source URL: https://firebase.google.com/docs/firestore/solutions/aggregation?hl=ko
Title: 쓰기-시간 집계

의견 보내기

쓰기-시간 집계

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Cloud Firestore의 쿼리를 사용하면 대규모 컬렉션에서 문서를 찾을 수 있습니다. 컬렉션의 속성을 전반적으로 파악하려면 컬렉션의 데이터를 집계하면 됩니다.

읽기 시간 또는 쓰기 시간에 데이터를 집계할 수 있습니다.

읽기 시간 집계는 요청 시 결과를 계산합니다.
Cloud Firestore는 읽기 시간에 count(), sum(), average() 집계 쿼리를 지원합니다. 읽기 시간 집계 쿼리는 쓰기 시간 집계보다 앱에 더 쉽게 추가할 수 있습니다. 집계 쿼리에 대한 자세한 내용은 집계 쿼리로 데이터 요약 [https://firebase.google.com/docs/firestore/query-data/aggregation-queries?hl=ko]을 참조하세요.
쓰기 시간 집계는 앱이 관련 쓰기 작업을 수행할 때마다 결과를 계산합니다. 쓰기 시간 집계는 구현해야 할 작업이 더 많지만 다음 이유 중 하나로 읽기 시간 집계 대신 사용할 수도 있습니다.

실시간 업데이트에 대한 집계 결과를 리슨하려고 합니다.
count(), sum(), average() 집계 쿼리는 실시간 업데이트를 지원하지 않습니다.
집계 결과를 클라이언트 측 캐시에 저장하려고 합니다.
count(), sum(), average() 집계 쿼리는 캐싱을 지원하지 않습니다.
각 사용자에 대해 수만 개의 문서에서 데이터를 집계하고 비용을 고려합니다. 문서 수가 적을수록 읽기 시간 집계 비용이 감소합니다. 집계에 있는 문서 수가 많으면 쓰기 시간 집계 비용이 감소할 수 있습니다.

클라이언트 측 트랜잭션 또는 Cloud Functions를 사용해서 쓰기 시간 집계를 구현할 수 있습니다. 다음 섹션에서는 쓰기 시간 집계를 구현하는 방법을 설명합니다.

솔루션: 클라이언트 측 트랜잭션을 사용한 쓰기 시간 집계

맛집 정보를 제공하는 지역 정보 추천 앱을 가정해 보겠습니다.
다음 쿼리는 특정 레스토랑의 평점을 모두 검색합니다.

웹db.collection("restaurants")
.doc("arinell-pizza")
.collection("ratings")
.get();test.solution-aggregation.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/firestore/test.solution-aggregation.js#L31-L34]
Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

do {
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

FIRQuery *query = [[[self.db collectionWithPath:@"restaurants"]
Kotlin db.collection("restaurants")
.document("arinell-pizza")
.collection("ratings")
.get()SolutionAggregation.kt [https://github.com/firebase/snippets-android/blob/268a3858585da19107220dbad9ceb8a5fd23241a/firestore/app/src/main/java/com/google/example/firestore/kotlin/SolutionAggregation.kt#L31-L34]
Java db.collection("restaurants")
.document("arinell-pizza")
.collection("ratings")
.get();SolutionAggregation.java [https://github.com/firebase/snippets-android/blob/268a3858585da19107220dbad9ceb8a5fd23241a/firestore/app/src/main/java/com/google/example/firestore/SolutionAggregation.java#L44-L47]

모든 평점을 가져와서 집계 정보를 계산하는 대신 이 정보를 레스토랑 문서
자체에 저장할 수 있습니다.

웹var arinellDoc = {
name: 'Arinell Pizza',
avgRating: 4.65,
numRatings: 683

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

struct Restaurant {

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

@interface FIRRestaurant : NSObject

@property (nonatomic, readonly) NSString *name;
@property (nonatomic, readonly) float averageRating;
@property (nonatomic, readonly) NSInteger ratingCount;

- (instancetype)initWithName:(NSString *)name
averageRating:(float)averageRating
if (self != nil) {
_name = name;
_averageRating = averageRating;
_ratingCount = ratingCount;
Kotlin data class Restaurant(
String name;
double avgRating;
int numRatings;

public Restaurant(String name, double avgRating, int numRatings) {
this.name = name;
this.avgRating = avgRating;
this.numRatings = numRatings;

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func addRatingTransaction(restaurantRef: DocumentReference, rating: Float) async {
restaurantData["avgRating"] = newAvgRating

Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)addRatingTransactionWithRestaurantReference:(FIRDocumentReference *)restaurant
rating:(float)rating {
FIRDocumentReference *ratingReference =
[[restaurant collectionWithPath:@"ratings"] documentWithAutoID];

[self.db runTransactionWithBlock:^id (FIRTransaction *transaction,
NSError **errorPointer) {
FIRDocumentSnapshot *restaurantSnapshot =
[transaction getDocument:restaurant error:errorPointer];

if (restaurantSnapshot == nil) {
return nil;
NSMutableDictionary *restaurantData = [restaurantSnapshot.data mutableCopy];
if (restaurantData == nil) {
return nil;
NSInteger ratingCount = [restaurantData[@"numRatings"] integerValue];
NSInteger newRatingCount = ratingCount + 1;

float newAverageRating = (averageRating * ratingCount + rating) / newRatingCount;

restaurantData[@"avgRating"] = @(newAverageRating);

[transaction setData:@{@"rating": @(rating)} forDocument:ratingReference];
return nil;

val newAvgRating = (oldRatingTotal + rating) / newNumRatings

restaurant.avgRating = newAvgRating

"rating" to rating,
transaction.set(ratingRef, data, SetOptions.merge())

null

Restaurant restaurant = transaction.get(restaurantRef).toObject(Restaurant.class);

double newAvgRating = (oldRatingTotal + rating) / newNumRatings;

restaurant.avgRating = newAvgRating;

Map<String, Object> data = new HashMap<>();
data.put("rating", rating);
transaction.set(ratingRef, data, SetOptions.merge());

return null;
Node.jsexports.aggregateRatings = functions.firestore
.document('restaurants/{restId}/ratings/{ratingId}')
.onWrite(async (change, context) => {