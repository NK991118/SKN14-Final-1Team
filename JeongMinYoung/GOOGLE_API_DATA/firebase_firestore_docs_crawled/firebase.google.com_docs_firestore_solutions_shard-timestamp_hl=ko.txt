Source URL: https://firebase.google.com/docs/firestore/solutions/shard-timestamp?hl=ko
Title: 샤딩된 타임스탬프

의견 보내기

샤딩된 타임스탬프

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

컬렉션에 순차 색인이 생성된 값이 포함된 문서가 있으면 Cloud Firestore는 쓰기 속도를 초당 500회로 제한합니다. 이 페이지에서는 이 제한을 해결하기 위해 문서 필드를 샤딩하는 방법을 설명합니다. 먼저 '순차적으로 색인이 지정된 필드'를 정의하고 이 제한이 적용되는 조건을 알아보겠습니다.

순차적으로 색인이 지정된 필드

'순차적으로 색인이 지정된 필드'란 단조롭게 증가 또는 감소하는 색인이 지정된 필드가 포함된 문서 컬렉션을 의미합니다. 대부분의 경우 timestamp 필드이지만, 필드 값이 단조롭게 증가 또는 감소하는 경우 초당 500회의 쓰기 제한이 적용될 수 있습니다.

예를 들어 앱이 다음과 같이 userid 값을 할당하는 경우 userid라는 색인 생성 필드가 있는 user 문서 컬렉션에 이 제한이 적용됩니다.

1281, 1282, 1283, 1284, 1285, ...

반면에 timestamp 필드에 이 제한이 적용되지 않는 경우도 있습니다. timestamp 필드가 임의로 분산된 값을 추적하면 쓰기 제한이 적용되지 않습니다. 필드가 단조롭게 증가 또는 감소한다는 사실 외에 필드의 실제 값은 중요하지 않습니다. 예를 들어 다음과 같이 단조롭게 증가하는 필드 값 집합에는 모두 쓰기 제한이 적용됩니다.

100000, 100001, 100002, 100003, ...
0, 1, 2, 3, ...

timestamp 필드 샤딩

앱에서 단조롭게 증가하는 timestamp 필드를 사용한다고 가정해 보겠습니다.
앱이 어떤 쿼리에서도 timestamp 필드를 사용하지 않는다면 timestamp 필드의 색인을 생성하지 않고 초당 500회의 쓰기 제한을 제거할 수 있습니다. 쿼리에 timestamp 필드가 필요한 경우에는 샤딩된 타임스탬프를 사용하여 이 제한을 해결할 수 있습니다.

shard 필드와 timestamp 필드를 함께 추가합니다. 1..n 중에서 고유한 값을 shard 필드에 사용하세요. 그러면 컬렉션에 대한 쓰기 제한이 500*n으로 증가하지만 n개의 쿼리를 집계해야 합니다.
쓰기 로직을 업데이트하여 각 문서에 shard 값을 임의로 할당합니다.
쿼리를 업데이트하여 샤딩된 결과 집합을 집계합니다.
shard 필드 및 timestamp 필드 모두에 대해 단일 필드 색인 사용을 중지합니다. timestamp 필드가 포함된 기존의 복합 색인을 삭제합니다.
복합 색인을 새로 만들어 업데이트된 쿼리를 지원합니다. 색인의 필드 순서가 중요하므로 shard 필드가 timestamp 필드 앞에 와야 합니다. timestamp 필드를 포함하는 색인에는 shard 필드도 포함되어야 합니다.

쓰기 속도가 지속적으로 초당 500회가 넘는 경우에만 샤딩된 타임스탬프를 구현해야 합니다. 그렇지 않으면 조기에 최적화될 수 있습니다. timestamp 필드를 샤딩하면 초당 500회의 쓰기 제한이 제거되지만 클라이언트 측 쿼리 집계가 필요하다는 단점이 있습니다.

다음 예시는 timestamp 필드를 샤딩하는 방법과 샤딩된 결과 집합을 쿼리하는 방법을 보여줍니다.

데이터 모델 및 쿼리 예시

예를 들어 통화, 보통주, ETF 같은 금융 상품을 거의 실시간으로 분석하는 앱이 있다고 가정해 보겠습니다. 이 앱은 다음과 같이 문서를 instruments 컬렉션에 씁니다.

Node.js
async function insertData() {

function createQuery(fieldName, fieldOperator, fieldValue, limit = 5) {
return fs.collection('instruments')
.where(fieldName, fieldOperator, fieldValue)
.orderBy('timestamp', 'desc')
.limit(limit)
.get();
.then(() => {
return Promise.all([commonStock, exchange1Instruments, usdInstruments]);

shard 필드를 문서에 추가합니다. shard 필드를 값 x, y, z로 설정하여 컬렉션에 대한 쓰기 제한을 초당 1,500회로 늘립니다.

Node.js
start = end;

Node.js
function createQuery(fieldName, fieldOperator, fieldValue, limit = 5) {
.where('shard', 'in', shardChunk)  // new shard condition
.where(fieldName, fieldOperator, fieldValue)
.orderBy('timestamp', 'desc')
.limit(limit)
.get();
.then(() => {
return Promise.all([commonStock, exchange1Instruments, usdInstruments]);
Firebase Console
Firebase Console에서 Cloud Firestore 복합 색인 페이지를 엽니다.

복합 색인으로 이동 [https://console.firebase.google.com/project/_/firestore/indexes?hl=ko]
timestamp 필드가 포함된 색인 항목별로 more_vert 버튼과 삭제를 차례로 클릭합니다.

GCP Console
Google Cloud 콘솔에서 데이터베이스 페이지로 이동합니다.

데이터베이스로 이동 [https://console.cloud.google.com/firestore/databases?hl=ko]
데이터베이스 목록에서 필요한 데이터베이스를 선택합니다.
탐색 메뉴에서 색인을 클릭한 다음 복합 탭을 클릭합니다.
필터 필드를 사용하여 timestamp 필드가 포함된 색인 정의를 검색합니다.
이러한 색인 항목별로 more_vert 버튼과 삭제를 차례로 클릭합니다.

Firebase CLI
Firebase CLI를 아직 설정하지 않았으면 이 안내에 따라 CLI를 설치하고 firebase init 명령어를 실행 [https://firebase.google.com/docs/cli?hl=ko#install_the_firebase_cli]합니다. init 명령어 실행 시 Firestore: Deploy rules and create indexes for Firestore를 선택해야 합니다.
설정 도중 Firebase CLI는 기존의 색인 정의를 기본적으로 firestore.indexes.json이라는 이름의 파일로 다운로드합니다.
timestamp 필드가 포함된 색인 정의를 제거합니다. 예를 들면 다음과 같습니다.
"indexes": [
Firebase Console
Firebase Console에서 Cloud Firestore 단일 필드 색인 페이지를 엽니다.

단일 필드 색인으로 이동 [https://console.firebase.google.com/project/_/firestore/indexes/single-field/manage?hl=ko]
예외 추가를 클릭합니다.
컬렉션 ID로 instruments를 입력하고 필드 경로로 timestamp를 입력합니다.
쿼리 범위에서는 컬렉션 및 컬렉션 그룹을 모두 선택합니다.
다음을 클릭합니다.
모든 색인 설정을 사용 중지됨으로 전환하고 저장을 클릭합니다.
shard 필드에도 동일한 단계를 반복합니다.

GCP Console
Google Cloud 콘솔에서 데이터베이스 페이지로 이동합니다.

데이터베이스로 이동 [https://console.cloud.google.com/firestore/databases?hl=ko]
데이터베이스 목록에서 필요한 데이터베이스를 선택합니다.
탐색 메뉴에서 색인을 클릭한 후 단일 필드 탭을 클릭합니다.
단일 필드 탭을 클릭합니다.
예외 추가를 클릭합니다.
컬렉션 ID로 instruments를 입력하고 필드 경로로 timestamp를 입력합니다.
쿼리 범위에서는 컬렉션 및 컬렉션 그룹을 모두 선택합니다.
다음을 클릭합니다.
모든 색인 설정을 사용 중지됨으로 전환하고 저장을 클릭합니다.
shard 필드에도 동일한 단계를 반복합니다.

Firebase CLI
색인 정의 파일의 fieldOverrides 섹션에 다음을 추가합니다.
"fieldOverrides": [

| 컬렉션 | 색인이 생성된 필드 | 쿼리 범위 |
| --- | --- | --- |
| instruments | arrow_downward shard, arrow_upward price.currency, arrow_downward timestamp | 컬렉션 |
| instruments | arrow_downward shard, arrow_upward exchange, arrow_downward timestamp | 컬렉션 |
| instruments | arrow_downward shard, arrow_upward instrumentType, arrow_downward timestamp | 컬렉션 |

오류 메시지이러한 색인은 업데이트된 쿼리를 실행하여 빌드할 수 있습니다.

각 쿼리는 Firebase Console에서 필요한 색인을 생성할 수 있는 링크가 포함된 오류 메시지를 반환합니다.
Firebase CLI
색인 정의 파일에 다음 색인을 추가합니다.
"indexes": [
Cloud Firestore는 사전순으로 가까운 색인 항목을 동일한 태블릿에 배치합니다. timestamp 필드에서와 같이 태블릿의 색인 값들이 서로 너무 가까이에 있으면 Cloud Firestore에서 태블릿을 더 작은 태블릿으로 효율적으로 분할하지 못합니다. 이로 인해 단일 태블릿에서 너무 많은 트래픽을 수신하는 핫스팟이 생성되고 핫스팟에 대한 읽기 및 쓰기 작업 속도가 더 느려집니다.

timestamp 필드를 샤딩하면 Cloud Firestore에서 워크로드를 여러 태블릿에 효율적으로 분할할 수 있습니다. timestamp 필드의 값은 서로 가깝게 유지되더라도 연결된 샤드 및 색인 값 덕분에 Cloud Firestore의 색인 항목 간 공간이 충분히 넓기 때문에 여러 태블릿으로 항목을 분할할 수 있습니다.

다음 단계

규모 확장을 위한 설계 권장사항 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#designing_for_scale] 읽기
단일 문서에 대한 쓰기 속도가 높은 경우 분산 카운터 [https://firebase.google.com/docs/firestore/solutions/counters?hl=ko] 참조
Cloud Firestore의 표준 제한사항 [https://firebase.google.com/docs/firestore/quotas?hl=ko#limits] 참조

의견 보내기