Source URL: https://firebase.google.com/docs/firestore/solutions/counters?hl=ko
Title: 분산 카운터

이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]

의견 보내기

분산 카운터

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

많은 실시간 앱에는 카운터 역할을 하는 문서가 있습니다. 예를 들어 게시물의 '좋아요' 또는 특정 항목의 '즐겨찾기' 개수를 셀 수 있습니다.

Cloud Firestore에서는 단일 문서를 무제한 속도로 업데이트할 수 없습니다. 단일 문서를 기반으로 한 카운터가 있고 증분이 자주 발생하는 경우 결국 문서 업데이트에 대한 경합이 발생합니다. 단일 문서 업데이트 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#updates_to_a_single_document]를 참조하세요.

솔루션: 분산 카운터

더욱 빈번한 카운터 업데이트를 지원하려면 분산 카운터를 만드세요.
각 카운터는 '샤드'로 이루어진 하위 컬렉션을 갖는 문서이며 카운터의 값은 샤드 값의 합계입니다.

쓰기 처리량은 샤드 수에 따라 선형적으로 증가하므로 10개의 샤드가 있는 분산 카운터는 기존 카운터보다 10배 많은 쓰기를 처리할 수 있습니다.

웹// counters/${ID}
{
"num_shards": NUM_SHARDS,
"shards": [subcollection]
}

// counters/${ID}/shards/${NUM}
{
"count": 123
}

Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

// counters/${ID}
struct Counter {
let numShards: Int

init(numShards: Int) {
self.numShards = numShards
}
}

// counters/${ID}/shards/${NUM}
struct Shard {
let count: Int

init(count: Int) {
self.count = count
}
}SolutionCountersViewController.swift [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/swift/firestore-smoketest/SolutionCountersViewController.swift#L32-L48]
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

// counters/${ID}
@interface FIRCounter : NSObject
@property (nonatomic, readonly) NSInteger shardCount;
@end

@implementation FIRCounter
- (instancetype)initWithShardCount:(NSInteger)shardCount {
self = [super init];
if (self != nil) {
_shardCount = shardCount;
}
return self;
}
@end

// counters/${ID}/shards/${NUM}
@interface FIRShard : NSObject
@property (nonatomic, readonly) NSInteger count;
@end

@implementation FIRShard
- (instancetype)initWithCount:(NSInteger)count {
self = [super init];
if (self != nil) {
_count = count;
}
return self;
}
@endFIRSolutionCountersViewController.m [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/objc/firestore-smoketest-objc/FIRSolutionCountersViewController.m#L22-L50]
Kotlin // counters/${ID}
data class Counter(var numShards: Int)

// counters/${ID}/shards/${NUM}
data class Shard(var count: Int)SolutionCounters.kt [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/kotlin/SolutionCounters.kt#L16-L20]
Java // counters/${ID}
public class Counter {
int numShards;

public Counter(int numShards) {
this.numShards = numShards;
}
}

// counters/${ID}/shards/${NUM}
public class Shard {
int count;

public Shard(int count) {
this.count = count;
}
}SolutionCounters.java [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/SolutionCounters.java#L25-L41]
Python

import random

from google.cloud import firestore

class Shard:
"""
A shard is a distributed counter. Each shard can support being incremented
once per second. Multiple shards are needed within a Counter to allow
more frequent incrementing.
"""

def __init__(self):
self._count = 0

def to_dict(self):
return {"count": self._count}

class Counter:
"""
A counter stores a collection of shards which are
summed to return a total count. This allows for more
frequent incrementing than a single document.
"""

def __init__(self, num_shards):
self._num_shards = num_shards
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-client/distributed_counters.py#L16-L44]

Python

import random

from google.cloud import firestore

class Shard:
"""
A shard is a distributed counter. Each shard can support being incremented
once per second. Multiple shards are needed within a Counter to allow
more frequent incrementing.
"""

def __init__(self):
self._count = 0

def to_dict(self):
return {"count": self._count}

class Counter:
"""
A counter stores a collection of shards which are
summed to return a total count. This allows for more
frequent incrementing than a single document.
"""

def __init__(self, num_shards):
self._num_shards = num_shards
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-async-client/distributed_counters.py#L16-L44]

Node.js 해당되지 않습니다. 아래의 카운터 증분 스니펫을 참조하세요.
Go

import (
"context"
"fmt"
"math/rand"
"strconv"

"cloud.google.com/go/firestore"
"google.golang.org/api/iterator"
)

// Counter is a collection of documents (shards)
// to realize counter with high frequency.
type Counter struct {
numShards int
}

// Shard is a single counter, which is used in a group
// of other shards within Counter.
type Shard struct {
Count int
}
solution_counters.go [https://github.com/GoogleCloudPlatform/golang-samples/blob/1420c71e05f2a1aef5eb07e90da7294ffe82a75c/firestore/solution_counters.go#L18-L39]

PHP해당되지 않습니다. 아래의 카운터 초기화 스니펫을 참조하세요.
C#

/// <summary>
/// Shard is a document that contains the count.
/// </summary>
[FirestoreData]
public class Shard
{
[FirestoreProperty(name: "count")]
public int Count { get; set; }
}Program.cs [https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/2b9c8d16206d43588f8f135a85ff3589ba7046b9/firestore/api/SolutionCounter/Program.cs#L42-L50]

다음 코드는 분산 카운터를 초기화합니다.

웹function createCounter(ref, num_shards) {
var batch = db.batch();

// Initialize the counter document
batch.set(ref, { num_shards: num_shards });

// Initialize each shard with count=0
for (let i = 0; i < num_shards; i++) {
const shardRef = ref.collection('shards').doc(i.toString());
batch.set(shardRef, { count: 0 });
}

// Commit the write batch
return batch.commit();
}test.solution-counters.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/firestore/test.solution-counters.js#L7-L21]
Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func createCounter(ref: DocumentReference, numShards: Int) async {
do {
try await ref.setData(["numShards": numShards])
for i in 0...numShards {
try await ref.collection("shards").document(String(i)).setData(["count": 0])
}
} catch {
// ...
}
}SolutionCountersViewController.swift [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/swift/firestore-smoketest/SolutionCountersViewController.swift#L52-L61]
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)createCounterAtReference:(FIRDocumentReference *)reference
shardCount:(NSInteger)shardCount {
[reference setData:@{ @"numShards": @(shardCount) } completion:^(NSError * _Nullable error) {
for (NSInteger i = 0; i < shardCount; i++) {
NSString *shardName = [NSString stringWithFormat:@"%ld", (long)shardCount];
[[[reference collectionWithPath:@"shards"] documentWithPath:shardName]
setData:@{ @"count": @(0) }];
}
}];
}FIRSolutionCountersViewController.m [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/objc/firestore-smoketest-objc/FIRSolutionCountersViewController.m#L65-L74]
Kotlin fun createCounter(ref: DocumentReference, numShards: Int): Task<Void> {
// Initialize the counter document, then initialize each shard.
return ref.set(Counter(numShards))
.continueWithTask { task ->
if (!task.isSuccessful) {
throw task.exception!!
}

val tasks = arrayListOf<Task<Void>>()

// Initialize each shard with count=0
for (i in 0 until numShards) {
val makeShard = ref.collection("shards")
.document(i.toString())
.set(Shard(0))

tasks.add(makeShard)
}

Tasks.whenAll(tasks)
}
}SolutionCounters.kt [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/kotlin/SolutionCounters.kt#L24-L45]
Java public Task<Void> createCounter(final DocumentReference ref, final int numShards) {
// Initialize the counter document, then initialize each shard.
return ref.set(new Counter(numShards))
.continueWithTask(new Continuation<Void, Task<Void>>() {
@Override
public Task<Void> then(@NonNull Task<Void> task) throws Exception {
if (!task.isSuccessful()) {
throw task.getException();
}

List<Task<Void>> tasks = new ArrayList<>();

// Initialize each shard with count=0
for (int i = 0; i < numShards; i++) {
Task<Void> makeShard = ref.collection("shards")
.document(String.valueOf(i))
.set(new Shard(0));

tasks.add(makeShard);
}

return Tasks.whenAll(tasks);
}
});
}SolutionCounters.java [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/SolutionCounters.java#L45-L69]
Python

def init_counter(self, doc_ref):
"""
Create a given number of shards as
subcollection of specified document.
"""
col_ref = doc_ref.collection("shards")

# Initialize each shard with count=0
for num in range(self._num_shards):
shard = Shard()
col_ref.document(str(num)).set(shard.to_dict())
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-client/distributed_counters.py#L48-L59]

Python

async def init_counter(self, doc_ref):
"""
Create a given number of shards as
subcollection of specified document.
"""
col_ref = doc_ref.collection("shards")

# Initialize each shard with count=0
for num in range(self._num_shards):
shard = Shard()
await col_ref.document(str(num)).set(shard.to_dict())
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-async-client/distributed_counters.py#L48-L59]

Node.js 해당되지 않습니다. 아래의 카운터 증분 스니펫을 참조하세요.
Go

// initCounter creates a given number of shards as
// subcollection of specified document.
func (c *Counter) initCounter(ctx context.Context, docRef *firestore.DocumentRef) error {
colRef := docRef.Collection("shards")

// Initialize each shard with count=0
for num := 0; num < c.numShards; num++ {
shard := Shard{0}

if _, err := colRef.Doc(strconv.Itoa(num)).Set(ctx, shard); err != nil {
return fmt.Errorf("Set: %w", err)
}
}
return nil
}
solution_counters.go [https://github.com/GoogleCloudPlatform/golang-samples/blob/1420c71e05f2a1aef5eb07e90da7294ffe82a75c/firestore/solution_counters.go#L43-L59]

PHP

$numShards = 10;
$ref = $db->collection('samples/php/distributedCounters');
for ($i = 0; $i < $numShards; $i++) {
$doc = $ref->document((string) $i);
$doc->set(['Cnt' => 0]);
}solution_sharded_counter_create.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/5be36a7311875e7635e96a0cd9072cfb425c9e84/firestore/src/solution_sharded_counter_create.php#L40-L45]

C#

/// <summary>
/// Create a given number of shards as a
/// subcollection of specified document.
/// </summary>
/// <param name="docRef">The document reference <see cref="DocumentReference"/></param>
private static async Task CreateCounterAsync(DocumentReference docRef, int numOfShards)
{
CollectionReference colRef = docRef.Collection("shards");
var tasks = new List<Task>();
// Initialize each shard with Count=0
for (var i = 0; i < numOfShards; i++)
{
tasks.Add(colRef.Document(i.ToString()).SetAsync(new Shard() { Count = 0 }));
}
await Task.WhenAll(tasks);
}Program.cs [https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/2b9c8d16206d43588f8f135a85ff3589ba7046b9/firestore/api/SolutionCounter/Program.cs#L54-L69]

Ruby

# project_id = "Your Google Cloud Project ID"
# num_shards = "Number of shards for distributed counter"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

shards_ref = firestore.col collection_path

# Initialize each shard with count=0
num_shards.times do |i|
shards_ref.doc(i).set({ count: 0 })
end

puts "Distributed counter shards collection created."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/0539c9e4faccfe857c5cd0999d9f50f1a4404531/google-cloud-firestore/samples/distributed_counters.rb#L18-L33]

카운터를 늘리려면 샤드를 무작위로 선택하고 카운트를 늘립니다.

웹function incrementCounter(ref, num_shards) {
// Select a shard of the counter at random
const shard_id = Math.floor(Math.random() * num_shards).toString();
const shard_ref = ref.collection('shards').doc(shard_id);

// Update count
return shard_ref.update("count", firebase.firestore.FieldValue.increment(1));
}test.solution-counters.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/firestore/test.solution-counters.js#L25-L32]
Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func incrementCounter(ref: DocumentReference, numShards: Int) {
// Select a shard of the counter at random
let shardId = Int(arc4random_uniform(UInt32(numShards)))
let shardRef = ref.collection("shards").document(String(shardId))

shardRef.updateData([
"count": FieldValue.increment(Int64(1))
])
}SolutionCountersViewController.swift [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/swift/firestore-smoketest/SolutionCountersViewController.swift#L65-L73]
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)incrementCounterAtReference:(FIRDocumentReference *)reference
shardCount:(NSInteger)shardCount {
// Select a shard of the counter at random
NSInteger shardID = (NSInteger)arc4random_uniform((uint32_t)shardCount);
NSString *shardName = [NSString stringWithFormat:@"%ld", (long)shardID];
FIRDocumentReference *shardReference =
[[reference collectionWithPath:@"shards"] documentWithPath:shardName];

[shardReference updateData:@{
@"count": [FIRFieldValue fieldValueForIntegerIncrement:1]
}];
}FIRSolutionCountersViewController.m [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/objc/firestore-smoketest-objc/FIRSolutionCountersViewController.m#L78-L89]
Kotlin fun incrementCounter(ref: DocumentReference, numShards: Int): Task<Void> {
val shardId = Math.floor(Math.random() * numShards).toInt()
val shardRef = ref.collection("shards").document(shardId.toString())

return shardRef.update("count", FieldValue.increment(1))
}SolutionCounters.kt [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/kotlin/SolutionCounters.kt#L49-L54]
Java public Task<Void> incrementCounter(final DocumentReference ref, final int numShards) {
int shardId = (int) Math.floor(Math.random() * numShards);
DocumentReference shardRef = ref.collection("shards").document(String.valueOf(shardId));

return shardRef.update("count", FieldValue.increment(1));
}SolutionCounters.java [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/SolutionCounters.java#L73-L78]
Python

def increment_counter(self, doc_ref):
"""Increment a randomly picked shard."""
doc_id = random.randint(0, self._num_shards - 1)

shard_ref = doc_ref.collection("shards").document(str(doc_id))
return shard_ref.update({"count": firestore.Increment(1)})
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-client/distributed_counters.py#L63-L69]

Python

async def increment_counter(self, doc_ref):
"""Increment a randomly picked shard."""
doc_id = random.randint(0, self._num_shards - 1)

shard_ref = doc_ref.collection("shards").document(str(doc_id))
return await shard_ref.update({"count": firestore.Increment(1)})
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-async-client/distributed_counters.py#L63-L69]

Node.js

function incrementCounter(docRef, numShards) {
const shardId = Math.floor(Math.random() * numShards);
const shardRef = docRef.collection('shards').doc(shardId.toString());
return shardRef.set({count: FieldValue.increment(1)}, {merge: true});
}solution-counters.js [https://github.com/googleapis/nodejs-firestore/blob/1b97377a096bbcbf94b0911027dfb8366770b545/samples/solution-counters.js#L20-L24]

Go

// incrementCounter increments a randomly picked shard.
func (c *Counter) incrementCounter(ctx context.Context, docRef *firestore.DocumentRef) (*firestore.WriteResult, error) {
docID := strconv.Itoa(rand.Intn(c.numShards))

shardRef := docRef.Collection("shards").Doc(docID)
return shardRef.Update(ctx, []firestore.Update{
{Path: "Count", Value: firestore.Increment(1)},
})
}
solution_counters.go [https://github.com/GoogleCloudPlatform/golang-samples/blob/1420c71e05f2a1aef5eb07e90da7294ffe82a75c/firestore/solution_counters.go#L63-L73]

PHP

$ref = $db->collection('samples/php/distributedCounters');
$numShards = 0;
$docCollection = $ref->documents();
foreach ($docCollection as $doc) {
$numShards++;
}
$shardIdx = random_int(0, max(1, $numShards) - 1);
$doc = $ref->document((string) $shardIdx);
$doc->update([
['path' => 'Cnt', 'value' => FieldValue::increment(1)]
]);solution_sharded_counter_increment.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/5be36a7311875e7635e96a0cd9072cfb425c9e84/firestore/src/solution_sharded_counter_increment.php#L42-L52]

C#

/// <summary>
/// Increment a randomly picked shard by 1.
/// </summary>
/// <param name="docRef">The document reference <see cref="DocumentReference"/></param>
/// <returns>The <see cref="Task"/></returns>
private static async Task IncrementCounterAsync(DocumentReference docRef, int numOfShards)
{
int documentId;
lock (s_randLock)
{
documentId = s_rand.Next(numOfShards);
}
var shardRef = docRef.Collection("shards").Document(documentId.ToString());
await shardRef.UpdateAsync("count", FieldValue.Increment(1));
}Program.cs [https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/2b9c8d16206d43588f8f135a85ff3589ba7046b9/firestore/api/SolutionCounter/Program.cs#L73-L87]

Ruby

# project_id = "Your Google Cloud Project ID"
# num_shards = "Number of shards for distributed counter"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

# Select a shard of the counter at random
shard_id = rand 0...num_shards
shard_ref = firestore.doc "#{collection_path}/#{shard_id}"

# increment counter
shard_ref.update({ count: firestore.field_increment(1) })

puts "Counter incremented."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/0539c9e4faccfe857c5cd0999d9f50f1a4404531/google-cloud-firestore/samples/distributed_counters.rb#L39-L54]

전체 카운트를 가져오려면 모든 샤드를 쿼리하고 count 필드의 합계를 구합니다.

웹function getCount(ref) {
// Sum the count of each shard in the subcollection
return ref.collection('shards').get().then((snapshot) => {
let total_count = 0;
snapshot.forEach((doc) => {
total_count += doc.data().count;
});

return total_count;
});
}test.solution-counters.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/firestore/test.solution-counters.js#L36-L46]
Swift

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

func getCount(ref: DocumentReference) async {
do {
let querySnapshot = try await ref.collection("shards").getDocuments()
var totalCount = 0
for document in querySnapshot.documents {
let count = document.data()["count"] as! Int
totalCount += count
}

print("Total count is \(totalCount)")
} catch {
// handle error
}
}SolutionCountersViewController.swift [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/swift/firestore-smoketest/SolutionCountersViewController.swift#L77-L90]
Objective-C

참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.

- (void)getCountWithReference:(FIRDocumentReference *)reference {
[[reference collectionWithPath:@"shards"]
getDocumentsWithCompletion:^(FIRQuerySnapshot *snapshot,
NSError *error) {
NSInteger totalCount = 0;
if (error != nil) {
// Error getting shards
// ...
} else {
for (FIRDocumentSnapshot *document in snapshot.documents) {
NSInteger count = [document[@"count"] integerValue];
totalCount += count;
}

NSLog(@"Total count is %ld", (long)totalCount);
}
}];
}FIRSolutionCountersViewController.m [https://github.com/firebase/snippets-ios/blob/cdce007fedb3bb90dd3a70ce03066178236e1deb/firestore/objc/firestore-smoketest-objc/FIRSolutionCountersViewController.m#L93-L110]
Kotlin fun getCount(ref: DocumentReference): Task<Int> {
// Sum the count of each shard in the subcollection
return ref.collection("shards").get()
.continueWith { task ->
var count = 0
for (snap in task.result!!) {
val shard = snap.toObject<Shard>()
count += shard.count
}
count
}
}SolutionCounters.kt [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/kotlin/SolutionCounters.kt#L58-L69]
Java public Task<Integer> getCount(final DocumentReference ref) {
// Sum the count of each shard in the subcollection
return ref.collection("shards").get()
.continueWith(new Continuation<QuerySnapshot, Integer>() {
@Override
public Integer then(@NonNull Task<QuerySnapshot> task) throws Exception {
int count = 0;
for (DocumentSnapshot snap : task.getResult()) {
Shard shard = snap.toObject(Shard.class);
count += shard.count;
}
return count;
}
});
}SolutionCounters.java [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/firestore/app/src/main/java/com/google/example/firestore/SolutionCounters.java#L82-L96]
Python

def get_count(self, doc_ref):
"""Return a total count across all shards."""
total = 0
shards = doc_ref.collection("shards").list_documents()
for shard in shards:
total += shard.get().to_dict().get("count", 0)
return total
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-client/distributed_counters.py#L73-L80]

Python

async def get_count(self, doc_ref):
"""Return a total count across all shards."""
total = 0
shards = doc_ref.collection("shards").list_documents()
async for shard in shards:
total += (await shard.get()).to_dict().get("count", 0)
return total
distributed_counters.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-async-client/distributed_counters.py#L73-L80]

Node.js

async function getCount(docRef) {
const querySnapshot = await docRef.collection('shards').get();
const documents = querySnapshot.docs;

let count = 0;
for (const doc of documents) {
count += doc.get('count');
}
return count;
}solution-counters.js [https://github.com/googleapis/nodejs-firestore/blob/1b97377a096bbcbf94b0911027dfb8366770b545/samples/solution-counters.js#L28-L37]

Go

// getCount returns a total count across all shards.
func (c *Counter) getCount(ctx context.Context, docRef *firestore.DocumentRef) (int64, error) {
var total int64
shards := docRef.Collection("shards").Documents(ctx)
for {
doc, err := shards.Next()
if err == iterator.Done {
break
}
if err != nil {
return 0, fmt.Errorf("Next: %w", err)
}

vTotal := doc.Data()["Count"]
shardCount, ok := vTotal.(int64)
if !ok {
return 0, fmt.Errorf("firestore: invalid dataType %T, want int64", vTotal)
}
total += shardCount
}
return total, nil
}
solution_counters.go [https://github.com/GoogleCloudPlatform/golang-samples/blob/1420c71e05f2a1aef5eb07e90da7294ffe82a75c/firestore/solution_counters.go#L77-L100]

PHP

$result = 0;
$docCollection = $db->collection('samples/php/distributedCounters')->documents();
foreach ($docCollection as $doc) {
$result += $doc->data()['Cnt'];
}solution_sharded_counter_get.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/5be36a7311875e7635e96a0cd9072cfb425c9e84/firestore/src/solution_sharded_counter_get.php#L40-L44]

C#

/// <summary>
/// Get total count across all shards.
/// </summary>
/// <param name="docRef">The document reference <see cref="DocumentReference"/></param>
/// <returns>The <see cref="int"/></returns>
private static async Task<int> GetCountAsync(DocumentReference docRef)
{
var snapshotList = await docRef.Collection("shards").GetSnapshotAsync();
return snapshotList.Sum(shard => shard.GetValue<int>("count"));
}Program.cs [https://github.com/GoogleCloudPlatform/dotnet-docs-samples/blob/2b9c8d16206d43588f8f135a85ff3589ba7046b9/firestore/api/SolutionCounter/Program.cs#L91-L100]

Ruby

# project_id = "Your Google Cloud Project ID"
# collection_path = "shards"

require "google/cloud/firestore"

firestore = Google::Cloud::Firestore.new project_id: project_id

shards_ref = firestore.col_group collection_path

count = 0
shards_ref.get do |doc_ref|
count += doc_ref[:count]
end

puts "Count value is #{count}."distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/0539c9e4faccfe857c5cd0999d9f50f1a4404531/google-cloud-firestore/samples/distributed_counters.rb#L60-L74]

제한사항

위 솔루션은 Cloud Firestore에서 공유 카운터를 만드는 확장 가능한 방법이지만 다음과 같은 제한사항에 유의해야 합니다.

샤드 수 - 샤드 수는 분산 카운터의 성능을 좌우합니다. 샤드가 너무 적으면 일부 트랜잭션을 재시도해야 하므로 쓰기 작업이 느려집니다. 샤드가 너무 많으면 읽기가 느려지고 비용이 증가합니다.  더 느린 주기로 업데이트되는 개별 롤업 문서에서 카운터 합계를 유지하고 클라이언트가 이 문서를 읽어 합계를 가져오도록 하면 읽기 비용을 상쇄할 수 있습니다. 하지만 이 경우 클라이언트가 업데이트 직후 모든 샤드를 읽어 합계를 계산하지 않고 롤업 문서가 업데이트될 때까지 기다려야 한다는 단점이 있습니다.
비용 - 카운터 값을 읽을 때 전체 샤드 하위 컬렉션이 로드되어야 하므로 샤드 수에 따라 비용이 선형으로 증가합니다.

의견 보내기