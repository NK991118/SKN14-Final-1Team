Source URL: https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko
Title: 전화번호를 사용하여 Apple 플랫폼에서 Firebase 인증
bookmark_border

의견 보내기

전화번호를 사용하여 Apple 플랫폼에서 Firebase 인증

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용시작하기 전에보안 문제Firebase 프로젝트에서 전화번호 로그인 사용 설정앱 인증 사용 설정자동 알림 수신 시작reCAPTCHA 인증 설정사용자 전화로 인증 코드 전송인증 코드로 사용자 로그인 처리가상 전화번호로 테스트가상 전화번호 및 인증 코드 생성수동 테스트통합 테스트부록: 재구성 없이 전화 로그인 사용다음 단계

Firebase Authentication을 사용하면 사용자의 전화로 SMS 메시지를 전송하여 로그인하는 것이 가능합니다. 사용자는 SMS 메시지에 포함된 일회용 코드를 사용하여 로그인합니다.

앱에 전화번호 로그인을 추가하는 가장 쉬운 방법은 FirebaseUI를 사용하는 것입니다. 여기에는 비밀번호 기반 및 제휴 로그인뿐만 아니라 전화번호 로그인의 과정을 구현하는 삽입형 로그인 위젯이 포함됩니다. 이 문서에서는 Firebase SDK를 사용하여 전화번호 로그인 과정을 구현하는 방법을 설명합니다.

Google은 Firebase를 비롯한 Google 서비스 전반에서 스팸 및 악용 사례를 방지하기 위해 최종 사용자가 인증용으로 제공하는 전화번호를 전송하고 저장합니다. 개발자는 Firebase Authentication 전화번호 로그인 서비스를 사용하기 전에 최종 사용자로부터 적절한 동의를 얻어야 합니다.

시작하기 전에

아직 Firebase 프로젝트에 앱을 연결하지 않았다면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 연결합니다.

Swift Package Manager를 사용해 Firebase 종속 항목을 설치하고 관리하세요.

설치 가이드 [https://firebase.google.com/docs/ios/installation-methods?hl=ko]를 참조하여 직접 프레임워크 가져오기, CocoaPods 사용 등 Firebase SDK를 Apple 프로젝트에 추가하는 다양한 방법을 알아보세요.

앱 프로젝트를 연 상태로 Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동합니다.

메시지가 표시되면 Firebase Apple 플랫폼 SDK 저장소를 추가합니다.

https://github.com/firebase/firebase-ios-sdk.git

참고: 새 프로젝트에서 기본(최신) SDK 버전을 사용해야 하지만, 필요하면 이전 버전을 선택할 수도 있습니다.

Firebase Authentication 라이브러리를 선택합니다.

타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다.

완료되면 Xcode가 백그라운드에서 자동으로 종속 항목을 확인하고 다운로드하기 시작합니다.

보안 문제

전화번호만 사용하는 인증은 편리하기는 하지만, 전화번호 소유권은 사용자 간에 쉽게 이전될 수 있으므로 다른 방식보다 보안성이 떨어집니다. 또한 기기에 여러 사용자 프로필이 있는 경우 SMS 메시지를 받을 수 있는 사람이라면 누구든지 기기의 전화번호로 계정에 로그인할 수 있습니다.

앱에서 전화번호 기반 로그인을 사용하는 경우 더 안전한 로그인 방법을
함께 제공해야 하고, 전화번호 로그인을 사용하면 보안이 약화된다는
점을 사용자에게 알려야 합니다.

Firebase 프로젝트에서 전화번호 로그인 사용 설정

SMS 메시지로 사용자를 로그인 처리하려면 우선 Firebase 프로젝트에서 전화번호 로그인 방법을 사용 설정해야 합니다.

Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다.
로그인 방법 페이지에서 전화번호 로그인 방법을 사용 설정합니다.
선택사항: 설정 페이지에서 SMS 메시지 전송을 허용하거나 거부할 리전에 대한 정책을 설정합니다. SMS 리전 정책을 설정하면 SMS 악용으로부터 앱을 보호할 수 있습니다.

앱 인증 사용 설정

전화번호 인증을 사용하려면 Firebase에서 전화번호 로그인 요청이 앱에서 발생한 것인지 확인할 수 있어야 합니다. Firebase Authentication은 다음 두 가지 방법으로 이를 수행합니다.

자동 APN 알림: 기기에서 처음으로 전화번호를 통해 사용자를 로그인 처리하면 Firebase Authentication에서 사용자 모르게 기기로 푸시 알림을 전송하여 토큰을 보냅니다. 앱이 Firebase의 알림을 성공적으로 수신하면 전화번호 로그인을 진행할 수 있습니다.
iOS 8.0 이상에서는 자동 알림이 명시적인 사용자 동의를 요구하지 않으므로 사용자가 앱에서 APN 알림 수신을 거부하더라도 영향을 받지 않습니다. 따라서 Firebase 전화번호 인증을 구현할 때 푸시 알림을 수신할 수 있는 사용자 권한을 앱에서 요청할 필요가 없습니다.

reCAPTCHA 인증: 사용자가 앱의 백그라운드 새로고침을 중지했거나 iOS 시뮬레이터에서 앱을 테스트하는 경우와 같이 자동 푸시 알림을 주고받을 수 없는 경우, Firebase Authentication은 reCAPTCHA 인증을 사용하여 전화번호 로그인 과정을 완료합니다. 사용자가 문제를 풀지 않아도 reCAPTCHA 챌린지를 완료할 수 있는 경우도 많습니다.

iOS의 전화 인증은 클라이언트 앱 인증에 자동 푸시 알림을 사용합니다. 이 방법이 실패하면 reCAPTCHA로 대체됩니다. 이 reCAPTCHA 흐름을 사용하려면 API 키가 제한되지 않거나 '${PROJECT_NAME}.firebaseapp.com'이 허용 목록에 추가되어야 합니다.

자동 푸시 알림이 올바르게 구성되었으면 사용자 중 극소수만 reCAPTCHA 흐름을 경험합니다. 그러나 자동 푸시 알림을 사용할 수 있는지 여부와 관계없이 전화번호 로그인 기능이 제대로 작동하도록 철저히 대비하는 것이 중요합니다.

두 시나리오가 모두 제대로 작동하는지 확인하려면 백그라운드 앱 새로고침을 사용 설정한 상태와 중지한 상태로 실제 기기에서 앱을 테스트합니다. 백그라운드 앱 새로고침을 중지했을 때는 reCAPTCHA 테스트를 완료하여 로그인할 수 있어야 합니다. 항상 reCAPTCHA 흐름이 사용되는 iOS 시뮬레이터에서 앱을 실행하여 reCAPTCHA 흐름을 테스트할 수도 있습니다.

자동 알림 수신 시작

Firebase Authentication와 함께 사용하기 위해 APN 알림을 사용 설정하는 방법은 다음과 같습니다.

Xcode에서 프로젝트에 푸시 알림을 사용 설정 [http://help.apple.com/xcode/mac/current/#/devdfd3d04a1]합니다.

Firebase에 APNs 인증 키를 업로드합니다.
아직 APNs 인증 키가 없다면 Apple Developer Member Center [https://developer.apple.com/membercenter/index.action]에서 만드세요.

Firebase Console 프로젝트 내에서 톱니바퀴 아이콘을 선택하고 프로젝트 설정을 선택한 다음 클라우드 메시징 탭을 선택합니다.

iOS 앱 구성의 APN 인증 키에서 업로드를 클릭하여 개발 인증 키, 프로덕션 인증 키 또는 둘 다를 업로드합니다. 최소 하나 이상이 필요합니다.

키를 저장한 위치로 이동하여 키를 선택하고 열기를 클릭합니다. 해당하는 키 ID(Apple Developer Member Center [https://developer.apple.com/membercenter/index.action]에서 확인 가능)를 추가하고 업로드를 클릭합니다.

APN 인증서가 이미 있다면 인증서를 대신 업로드 할 수
있습니다.

Xcode에서 프로젝트에 백그라운드 모드 기능을 사용 설정 [https://developer.apple.com/documentation/xcode/configuring-background-execution-modes]한 다음 백그라운드 가져오기 및 원격 알림 모드의 체크박스를 선택합니다.

reCAPTCHA 인증 설정

Firebase SDK에서 reCAPTCHA 인증을 사용하도록 설정하는 방법은 다음과 같습니다.

다음과 같이 Xcode 프로젝트에 커스텀 URL 스킴을 추가합니다.

왼쪽 트리 보기에서 프로젝트 이름을 더블클릭하여 프로젝트 구성을 엽니다. 대상 섹션에서 앱을 선택하고 정보 탭을 선택한 후 URL 유형 섹션을 펼칩니다.

+ 버튼을 클릭하고 인코딩된 앱 ID를 URL 스키마로 추가합니다. 인코딩된 앱 ID는 Firebase Console의 일반 설정 [https://console.firebase.google.com/project/_/settings/general/?hl=ko] 페이지에 있는 iOS 앱 섹션에서 찾을 수 있습니다. 다른 필드는 비워 둡니다.
완성된 구성은 다음과 같은 형태이며 애플리케이션별 값이 적용됩니다.

선택사항: 사용자에게 reCAPTCHA를 제시할 때 앱에서 SFSafariViewController를 표시하는 방식을 맞춤설정하려면 AuthUIDelegate 프로토콜을 준수하는 커스텀 클래스를 만들어 verifyPhoneNumber(_:uiDelegate:completion:)에 전달합니다.

사용자 전화로 인증 코드 전송

전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시하고 verifyPhoneNumber(_:uiDelegate:completion:)을 호출하여 Firebase가 사용자의 전화에 SMS로 인증 코드를 전송하도록 요청합니다.

사용자의 전화번호를 확인합니다.
지역에 따라 현지 법규가 다르지만, 일반적으로는 사용자가 제반 상황을 미리 알 수 있도록 휴대전화 로그인을 사용하면 인증용 SMS 메시지가 발송되고 일반 요금이 부과될 수 있다는 점을 알려야 합니다.

verifyPhoneNumber(_:uiDelegate:completion:)을 호출하면서 사용자의 전화번호를 전달합니다.

--- 탭: Swift ---
PhoneAuthProvider.provider()
.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in
if let error = error {
self.showMessagePrompt(error.localizedDescription)
return
}
// Sign in using the verificationID and the code sent to the user
// ...
}

--- 탭: Objective-C ---
[[FIRPhoneAuthProvider provider] verifyPhoneNumber:userInput
UIDelegate:nil
completion:^(NSString * _Nullable verificationID, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
return;
}
// Sign in using the verificationID and the code sent to the user
// ...
}];
참고: 결제 요금제에 따라 전송된 SMS 메시지의 일일 할당량이 제한될 수 있습니다. Firebase Authentication 한도 [https://firebase.google.com/docs/auth/limits?hl=ko#phone-auth]를 참조하세요.
verifyPhoneNumber 메서드는 재진입이 가능합니다. 즉, 뷰의 onAppear 메서드에서 verifyPhoneNumber 메서드를 여러 번 호출해도 원래 요청이 시간 초과되지 않았다면 SMS를 재차 보내지 않습니다.

verifyPhoneNumber(_:uiDelegate:completion:)을 호출하면 Firebase가 앱에 사용자 모르게 푸시 알림을 보내거나 사용자에게 reCAPTCHA 챌린지를 표시합니다. 앱에서 알림을 수신하거나 사용자가 reCAPTCHA 테스트를 완료하면 Firebase는 인증 코드가 포함된 SMS 메시지를 지정된 전화번호로 보내고 인증 ID를 완료 함수에 전달합니다. 인증 코드와 인증 ID가 모두 있어야 사용자를 로그인 처리할 수 있습니다.

Auth 인스턴스의 languageCode 속성을 통해 인증 언어를 지정하면 Firebase에서 보내는 SMS 메시지를 현지화할 수 있습니다.

--- 탭: Swift ---
// Change language code to french.
Auth.auth().languageCode = "fr";

--- 탭: Objective-C ---
// Change language code to french.
[FIRAuth auth].languageCode = @"fr";

인증 ID를 저장한 후 앱이 로드되면 이를 복원합니다. 이렇게 하면 사용자가 로그인 과정을 완료하기 전에 앱이 종료되더라도(예: SMS 앱으로 전환) 올바른 인증 ID를 유지할 수 있습니다.
인증 ID를 유지하는 방법에는 제한이 없습니다. 간단한 방법은 다음과 같이 NSUserDefaults 객체로 인증 ID를 저장하는 것입니다.

--- 탭: Swift ---
UserDefaults.standard.set(verificationID, forKey: "authVerificationID")

--- 탭: Objective-C ---
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
[defaults setObject:verificationID forKey:@"authVerificationID"];
저장된 값을 복원하는 방법은 다음과 같습니다.

--- 탭: Swift ---
let verificationID = UserDefaults.standard.string(forKey: "authVerificationID")

--- 탭: Objective-C ---
NSString *verificationID = [defaults stringForKey:@"authVerificationID"];

verifyPhoneNumber(_:uiDelegate:completion:) 호출이 성공하면 사용자에게 SMS 메시지로 받은 인증 코드를 입력하라는 메시지를 표시할 수 있습니다.

Firebase는 악용을 방지하고자 단일 전화번호로 일정 기간 내에 보낼 수 있는 SMS 메시지 수를 제한합니다.
이 한도를 초과하면 전화번호 인증 요청이 제한될 수 있습니다.
개발 중에 이 문제가 발생하면 테스트에 다른 전화번호를 사용하거나 나중에 요청을 다시 시도하세요.

인증 코드로 사용자 로그인 처리

사용자가 SMS 메시지의 인증 코드를 앱에 제공하면 인증 코드와 인증 ID를 사용하여 FIRPhoneAuthCredential 객체를 만들고 이 객체를 signInWithCredential:completion:에 전달합니다.

사용자로부터 인증 코드를 받습니다.
인증 코드와 인증 ID를 사용하여 FIRPhoneAuthCredential 객체를 만듭니다.

--- 탭: Swift ---
let credential = PhoneAuthProvider.provider().credential(
withVerificationID: verificationID,
verificationCode: verificationCode
)

--- 탭: Objective-C ---
FIRAuthCredential *credential = [[FIRPhoneAuthProvider provider]
credentialWithVerificationID:verificationID
verificationCode:userInput];

FIRPhoneAuthCredential 객체로 사용자를 로그인시킵니다.

--- 탭: Swift ---
Auth.auth().signIn(with: credential) { authResult, error in
if let error = error {
let authError = error as NSError
if isMFAEnabled, authError.code == AuthErrorCode.secondFactorRequired.rawValue {
// The user is a multi-factor user. Second factor challenge is required.
let resolver = authError
.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as! MultiFactorResolver
var displayNameString = ""
for tmpFactorInfo in resolver.hints {
displayNameString += tmpFactorInfo.displayName ?? ""
displayNameString += " "
}
self.showTextInputPrompt(
withMessage: "Select factor to sign in\n\(displayNameString)",
completionBlock: { userPressedOK, displayName in
var selectedHint: PhoneMultiFactorInfo?
for tmpFactorInfo in resolver.hints {
if displayName == tmpFactorInfo.displayName {
selectedHint = tmpFactorInfo as? PhoneMultiFactorInfo
}
}
PhoneAuthProvider.provider()
.verifyPhoneNumber(with: selectedHint!, uiDelegate: nil,
multiFactorSession: resolver
.session) { verificationID, error in
if error != nil {
print(
"Multi factor start sign in failed. Error: \(error.debugDescription)"
)
} else {
self.showTextInputPrompt(
withMessage: "Verification code for \(selectedHint?.displayName ?? "")",
completionBlock: { userPressedOK, verificationCode in
let credential: PhoneAuthCredential? = PhoneAuthProvider.provider()
.credential(withVerificationID: verificationID!,
verificationCode: verificationCode!)
let assertion: MultiFactorAssertion? = PhoneMultiFactorGenerator
.assertion(with: credential!)
resolver.resolveSignIn(with: assertion!) { authResult, error in
if error != nil {
print(
"Multi factor finanlize sign in failed. Error: \(error.debugDescription)"
)
} else {
self.navigationController?.popViewController(animated: true)
}
}
}
)
}
}
}
)
} else {
self.showMessagePrompt(error.localizedDescription)
return
}
// ...
return
}
// User is signed in
// ...
}

--- 탭: Objective-C ---
[[FIRAuth auth] signInWithCredential:credential
completion:^(FIRAuthDataResult * _Nullable authResult,
NSError * _Nullable error) {
if (isMFAEnabled && error && error.code == FIRAuthErrorCodeSecondFactorRequired) {
FIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];
NSMutableString *displayNameString = [NSMutableString string];
for (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {
[displayNameString appendString:tmpFactorInfo.displayName];
[displayNameString appendString:@" "];
}
[self showTextInputPromptWithMessage:[NSString stringWithFormat:@"Select factor to sign in\n%@", displayNameString]
completionBlock:^(BOOL userPressedOK, NSString *_Nullable displayName) {
FIRPhoneMultiFactorInfo* selectedHint;
for (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {
if ([displayName isEqualToString:tmpFactorInfo.displayName]) {
selectedHint = (FIRPhoneMultiFactorInfo *)tmpFactorInfo;
}
}
[FIRPhoneAuthProvider.provider
verifyPhoneNumberWithMultiFactorInfo:selectedHint
UIDelegate:nil
multiFactorSession:resolver.session
completion:^(NSString * _Nullable verificationID, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
} else {
[self showTextInputPromptWithMessage:[NSString stringWithFormat:@"Verification code for %@", selectedHint.displayName]
completionBlock:^(BOOL userPressedOK, NSString *_Nullable verificationCode) {
FIRPhoneAuthCredential *credential =
[[FIRPhoneAuthProvider provider] credentialWithVerificationID:verificationID
verificationCode:verificationCode];
FIRMultiFactorAssertion *assertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];
[resolver resolveSignInWithAssertion:assertion completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
} else {
NSLog(@"Multi factor finanlize sign in succeeded.");
}
}];
}];
}
}];
}];
}
else if (error) {
// ...
return;
}
// User successfully signed in. Get user data from the FIRUser object
if (authResult == nil) { return; }
FIRUser *user = authResult.user;
// ...
}];

가상 전화번호로 테스트

Firebase Console을 통해 개발용 가상 전화번호를 설정할 수 있습니다. 가상 전화번호로 테스트하면 다음과 같은 이점이 있습니다.

사용 할당량을 소비하지 않고 전화번호 인증을 테스트할 수 있습니다.
실제 SMS 메시지를 보내지 않고 전화번호 인증을 테스트할 수 있습니다.제한 없이 동일한 전화번호로 연속 테스트를 실행할 수 있습니다. 앱 스토어 검토 절차 중에 검토자가 동일한 전화번호를 테스트에 사용하게 될 경우 번호가 거부될 위험이 최소화됩니다.
별도의 노력 없이도 개발 환경에서 쉽게 테스트할 수 있습니다. 예를 들어 Google Play 서비스 없이 iOS 시뮬레이터 또는 Android Emulator에서 개발할 수 있습니다.프로덕션 환경에서 실제 전화번호에 일반적으로 적용되는 보안 검사에 의해 차단되지 않고 통합 테스트를 작성할 수 있습니다.

가상 전화번호는 다음 요구사항을 충족해야 합니다.

실제로 존재하지 않는 가상의 전화번호여야 합니다.
Firebase Authentication에서는 실제 사용자가 사용하는 기존 전화번호를 테스트 전화번호로 설정할 수 없습니다.
전화번호를 만드는 방법 중 하나는 555로 시작하는 번호(예: +1 650-555-3434)를 미국 테스트 전화번호로 사용하는 것입니다.
길이 및 기타 조건에 맞게 전화번호 형식을 올바르게 지정해야 합니다. 테스트 전화번호도 실제 사용자의 전화번호와 동일한 유효성 검사를 거칩니다.
개발용으로 최대 10개의 전화번호를 추가할 수 있습니다.
다른 사람이 추측하기 어려운 테스트 전화번호와 코드를 사용하고 자주 변경합니다.

가상 전화번호 및 인증 코드 생성

Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다.
전화 제공업체를 아직 사용 설정하지 않은 경우 로그인 방법 탭에서 사용 설정합니다.
테스트용 전화번호 아코디언 메뉴를 엽니다.
테스트할 전화번호(예: +1 650-555-3434)를 입력합니다.
해당 번호에 사용할 6자리 인증 코드(예: 654321)를 입력합니다.
번호를 추가합니다. 필요한 경우 해당 행 위에 마우스를 가져가서 휴지통 아이콘을 클릭하면 전화번호와 코드를 삭제할 수 있습니다.

수동 테스트

애플리케이션에서 직접 가상 전화번호를 사용할 수 있습니다. 따라서 할당량 문제나 제한 없이 개발 단계 중에 직접 테스트를 수행할 수 있습니다.
또한 Google Play 서비스를 설치하지 않고 iOS 시뮬레이터 또는 Android 에뮬레이터에서 바로 테스트할 수 있습니다.

가상 전화번호를 입력하고 인증 코드를 보내도 실제 SMS 메시지가 전송되지 않습니다. 그 대신 이전에 구성한 인증 코드를 입력하여 로그인을 완료해야 합니다.

로그인이 완료되면 해당 전화번호로 Firebase 사용자가 생성됩니다. 사용자는 실제 전화번호 사용자와 동일한 행동과 속성을 가지며 동일한 방식으로 Realtime Database/Cloud Firestore 및 기타 서비스에 액세스할 수 있습니다. 이 절차 중에 발급된 ID 토큰에는 실제 전화번호 사용자와 같은 서명이 있습니다.

가상 전화번호의 ID 토큰에 실제 전화번호 사용자와 같은 서명이 있으므로 가상 전화번호를 안전하게 저장하고 지속적으로 재활용해야 합니다.

액세스 권한을 좀 더 제한하려는 경우 사용할 수 있는 다른 방법은 가상 전화번호 사용자에게 커스텀 클레임을 통해 테스트 역할을 설정 [https://firebase.google.com/docs/auth/admin/custom-claims?hl=ko]하여 허위 사용자로 구분하는 것입니다.

통합 테스트

Firebase Authentication은 직접 테스트 외에도 전화 인증 테스트용 통합 테스트를 작성할 수 있는 API를 제공합니다. 이러한 API는 웹에서 reCAPTCHA 요구사항을, iOS에서 백그라운드 푸시 알림을 중지하여 앱 인증을 사용 중지합니다. 따라서 이러한 흐름에서 테스트를 자동화하고 더 쉽게 구현할 수 있습니다. 또한 Android에서 즉시 인증 흐름을 테스트하는 기능도 제공합니다.

프로덕션 앱에서 앱 인증이 사용 중지되거나 가상 전화번호가 프로덕션 앱에 하드코딩되어서는 안 됩니다.

iOS에서는 verifyPhoneNumber를 호출하기 전에 appVerificationDisabledForTesting 설정을 TRUE로 설정해야 합니다. 백그라운드에서 APN 토큰이 요청되거나 자동 푸시 알림이 전송되는 일 없이 처리되므로 시뮬레이터에서 훨씬 쉽게 테스트할 수 있습니다. 이 경우 reCAPTCHA 대체 흐름도 사용 중지됩니다.

앱 인증이 사용 중지될 경우 실제 전화번호를 사용하면 로그인에 실패하게 됩니다. 이 API로는 가상 전화번호만 사용할 수 있습니다.

--- 탭: Swift ---
let phoneNumber = "+16505554567"

// This test verification code is specified for the given test phone number in the developer console.
let testVerificationCode = "123456"

Auth.auth().settings.isAppVerificationDisabledForTesting = TRUE
PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate:nil) {
verificationID, error in
if (error) {
// Handles error
self.handleError(error)
return
}
let credential = PhoneAuthProvider.provider().credential(withVerificationID: verificationID ?? "",
verificationCode: testVerificationCode)
Auth.auth().signInAndRetrieveData(with: credential) { authData, error in
if (error) {
// Handles error
self.handleError(error)
return
}
_user = authData.user
}];
}];

--- 탭: Objective-C ---
NSString *phoneNumber = @"+16505554567";

// This test verification code is specified for the given test phone number in the developer console.
NSString *testVerificationCode = @"123456";

[FIRAuth auth].settings.appVerificationDisabledForTesting = YES;
[[FIRPhoneAuthProvider provider] verifyPhoneNumber:phoneNumber
completion:^(NSString *_Nullable verificationID,
NSError *_Nullable error) {
if (error) {
// Handles error
[self handleError:error];
return;
}
FIRAuthCredential *credential =
[FIRPhoneAuthProvider credentialWithVerificationID:verificationID
verificationCode:testVerificationCode];
[FIRAuth auth] signInWithAndRetrieveDataWithCredential:credential
completion:^(FIRUser *_Nullable user,
NSError *_Nullable error) {
if (error) {
// Handles error
[self handleError:error];
return;
}
_user = user;
}];
}];

부록: 재구성 없이 전화 로그인 사용

Firebase Authentication에서는 메서드 재구성을 사용하여 앱의 APN 토큰을 자동으로 가져오고, Firebase가 사용자 모르게 앱으로 전송하는 푸시 알림을 처리하고, 인증 중에 reCAPTCHA 인증 페이지의 커스텀 스키마 리디렉션을 자동으로 가로챕니다.

재구성을 사용하지 않으려는 경우 앱의 Info.plist 파일에 FirebaseAppDelegateProxyEnabled 플래그를 추가하고 NO로 설정하여 재구성을 비활성화할 수 있습니다. 이 플래그를 NO로 설정하면 Firebase Cloud Messaging을 비롯한 기타 Firebase 제품에서도 재구성이 비활성화됩니다.

재구성을 비활성화한 경우 Firebase Authentication에 APN 기기 토큰, 푸시 알림, 커스텀 스키마 리디렉션 URL을 명시적으로 전달해야 합니다.

SwiftUI 애플리케이션을 빌드하는 경우 APN 기기 토큰, 푸시 알림, 커스텀 스키마 리디렉션 URL을 Firebase Authentication에 명시적으로 전달해야 합니다.

APN 기기 토큰을 가져오려면 application(_:didRegisterForRemoteNotificationsWithDeviceToken:) 메서드를 구현하고 이 메서드에서 Auth의 setAPNSToken(_:type:) 메서드에 기기 토큰을 전달합니다.

참고: SwiftUI 앱은 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor 속성 래퍼를 사용하여 적절한 앱 대리자 프로토콜에 해당하는 유형을 제공해야 합니다.

--- 탭: Swift ---
func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
// Pass device token to auth
Auth.auth().setAPNSToken(deviceToken, type: .unknown)

// Further handling of the device token if needed by the app
// ...
}

--- 탭: Objective-C ---
- (void)application:(UIApplication *)application
didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
// Pass device token to auth.
[[FIRAuth auth] setAPNSToken:deviceToken type:FIRAuthAPNSTokenTypeProd];
// Further handling of the device token if needed by the app.
}

푸시 알림을 처리하려면 application(_:didReceiveRemoteNotification:fetchCompletionHandler:): 메서드에서 Auth의 canHandleNotification(_:) 메서드를 호출하여 Firebase 인증 관련 알림이 있는지 확인합니다.

--- 탭: Swift ---
func application(_ application: UIApplication,
didReceiveRemoteNotification notification: [AnyHashable : Any],
fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
if Auth.auth().canHandleNotification(notification) {
completionHandler(.noData)
return
}
// This notification is not auth related; it should be handled separately.
}

--- 탭: Objective-C ---
- (void)application:(UIApplication *)application
didReceiveRemoteNotification:(NSDictionary *)notification
fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
// Pass notification to auth and check if they can handle it.
if ([[FIRAuth auth] canHandleNotification:notification]) {
completionHandler(UIBackgroundFetchResultNoData);
return;
}
// This notification is not auth related; it should be handled separately.
}

커스텀 스키마 리디렉션 URL을 처리하려면 application(_:open:options:) 메서드를 구현하고 이 메서드에서 URL을 Auth의 canHandleURL(_:) 메서드에 전달합니다.

--- 탭: Swift ---
func application(_ application: UIApplication, open url: URL,
options: [UIApplicationOpenURLOptionsKey : Any]) -> Bool {
if Auth.auth().canHandle(url) {
return true
}
// URL not auth related; it should be handled separately.
}

--- 탭: Objective-C ---
- (BOOL)application:(UIApplication *)app
openURL:(NSURL *)url
options:(NSDictionary<UIApplicationOpenURLOptionsKey, id> *)options {
if ([[FIRAuth auth] canHandleURL:url]) {
return YES;
}
// URL not auth related; it should be handled separately.
}

SwiftUI 또는 UISceneDelegate를 사용하는 경우 리디렉션 URL을 처리하려면 scene(_:openURLContexts:) 메서드를 구현하고 이 메서드에서 URL을 Auth의 canHandleURL(_:) 메서드에 전달합니다.

--- 탭: Swift ---
func scene(_ scene: UIScene, openURLContexts URLContexts: Set&ltUIOpenURLContext&gt) {
for urlContext in URLContexts {
let url = urlContext.url
_ = Auth.auth().canHandle(url)
}
// URL not auth related; it should be handled separately.
}

--- 탭: Objective-C ---
- (void)scene:(UIScene *)scene openURLContexts:(NSSet&ltUIOpenURLContext *&gt *)URLContexts {
for (UIOpenURLContext *urlContext in URLContexts) {
[FIRAuth.auth canHandleURL:urlContext.url];
// URL not auth related; it should be handled separately.
}
}

다음 단계

사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트의 일부로 저장되며 사용자의 로그인 방법에 관계없이 프로젝트 내 모든 앱에서 사용자를 식별하는 데 사용될 수 있습니다.

앱의 User [https://firebase.google.com/docs/reference/ios/firebaseauth/interface_f_i_r_user?hl=ko] 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/ios/manage-users?hl=ko]를 참조하세요.

Firebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.

인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결 [https://firebase.google.com/docs/auth/ios/account-linking?hl=ko]하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.

사용자를 로그아웃시키려면 signOut: [https://firebase.google.com/docs/reference/ios/firebaseauth/interface_f_i_r_auth?hl=ko#ab0d5111f05c3f1906243852cc8ef41b1]을 호출합니다.

--- 탭: Swift ---
let firebaseAuth = Auth.auth()
do {
try firebaseAuth.signOut()
} catch let signOutError as NSError {
print("Error signing out: %@", signOutError)
}

--- 탭: Objective-C ---
NSError *signOutError;
BOOL status = [[FIRAuth auth] signOut:&signOutError];
if (!status) {
NSLog(@"Error signing out: %@", signOutError);
return;
}

또한 모든 인증 오류에 대한 오류 처리 코드를 추가할 수도 있습니다. 오류 처리 [https://firebase.google.com/docs/auth/ios/errors?hl=ko]를 참조하세요.

의견 보내기