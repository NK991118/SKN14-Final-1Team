Source URL: https://firebase.google.com/docs/auth/ios/facebook-login?hl=ko
Title: Apple 플랫폼에서 Facebook 로그인을 사용하여 인증
bookmark_border

의견 보내기

Apple 플랫폼에서 Facebook 로그인을 사용하여 인증

bookmark_borderbookmark

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

이 페이지의 내용시작하기 전에Facebook 로그인 구현Facebook Limited 로그인 구현Firebase 인증다음 단계

Facebook 로그인 또는 Facebook Limited 로그인을 앱에 통합하여 사용자가 Facebook 계정으로 Firebase 인증을 받도록 설정할 수 있습니다.

시작하기 전에

Swift Package Manager를 사용해 Firebase 종속 항목을 설치하고 관리하세요.

설치 가이드 [https://firebase.google.com/docs/ios/installation-methods?hl=ko]를 참조하여 직접 프레임워크 가져오기, CocoaPods 사용 등 Firebase SDK를 Apple 프로젝트에 추가하는 다양한 방법을 알아보세요.

앱 프로젝트를 연 상태로 Xcode에서 File(파일) > Add Packages(패키지 추가)로 이동합니다.

메시지가 표시되면 Firebase Apple 플랫폼 SDK 저장소를 추가합니다.

https://github.com/firebase/firebase-ios-sdk.git

참고: 새 프로젝트에서 기본(최신) SDK 버전을 사용해야 하지만, 필요하면 이전 버전을 선택할 수도 있습니다.

Firebase Authentication 라이브러리를 선택합니다.

타겟 빌드 설정의 Other Linker Flags(기타 링커 플래그) 섹션에 -ObjC 플래그를 추가합니다.

완료되면 Xcode가 백그라운드에서 자동으로 종속 항목을 확인하고 다운로드하기 시작합니다.

그런 다음 몇 가지 구성 단계를 수행합니다.

Facebook for Developers [https://developers.facebook.com/] 사이트에서 내 앱의 앱 ID와 앱 비밀번호를 가져옵니다.
다음과 같이 Facebook 로그인을 사용 설정합니다.
Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 엽니다.
로그인 방법 탭에서 Facebook 로그인 방법을 사용 설정하고 Facebook에서 받은 앱 ID와 앱 비밀번호를 지정합니다.
Facebook for Developers [https://developers.facebook.com/] 사이트의 Facebook 앱 설정 페이지에서 제품 설정 > Facebook 로그인 구성에 개발자의 OAuth 리디렉션 URI(예: my-app-12345.firebaseapp.com/__/auth/handler)가 OAuth 리디렉션 URI 중 하나로 표시되어 있는지 확인합니다.

Facebook 로그인 구현

'기본' Facebook 로그인을 사용하려면 다음 단계를 완료하세요. 또는 다음 섹션에서와 같이 Facebook Limited 로그인을 사용할 수 있습니다.

개발자 문서 [https://developers.facebook.com/docs/facebook-login/ios]를 참고해 앱에 Facebook 로그인을 통합합니다. FBSDKLoginButton 객체를 초기화할 때 로그인 및 로그아웃 이벤트를 받을 대리자를 설정합니다. 예를 들면 다음과 같습니다.

--- 탭: Swift ---
let loginButton = FBSDKLoginButton()
loginButton.delegate = self

--- 탭: Objective-C ---
FBSDKLoginButton *loginButton = [[FBSDKLoginButton alloc] init];
loginButton.delegate = self;대리자에서 didCompleteWithResult:error:를 구현합니다.

--- 탭: Swift ---
func loginButton(_ loginButton: FBSDKLoginButton!, didCompleteWith result: FBSDKLoginManagerLoginResult!, error: Error!) {
if let error = error {
print(error.localizedDescription)
return
}
// ...
}

--- 탭: Objective-C ---
- (void)loginButton:(FBSDKLoginButton *)loginButton
didCompleteWithResult:(FBSDKLoginManagerLoginResult *)result
error:(NSError *)error {
if (error == nil) {
// ...
} else {
NSLog(error.localizedDescription);
}
}

UIApplicationDelegate의 FirebaseCore 모듈과 앱 대리자가 사용하는 다른 Firebase 모듈 [https://firebase.google.com/docs/ios/setup?hl=ko#available-pods]을 가져옵니다.
예를 들어 Cloud Firestore와 Authentication을 사용하려면 다음을 따르세요.

--- 탭: SwiftUI ---
import SwiftUI
import FirebaseCore
import FirebaseFirestore
import FirebaseAuth
// ...

--- 탭: Swift ---
import FirebaseCore
import FirebaseFirestore
import FirebaseAuth
// ...

--- 탭: Objective-C ---
@import FirebaseCore;
@import FirebaseFirestore;
@import FirebaseAuth;
// ...

앱 대리자의 application(_:didFinishLaunchingWithOptions:) 메서드에서 FirebaseApp [https://firebase.google.com/docs/reference/swift/firebasecore/api/reference/Classes/FirebaseApp?hl=ko] 공유 인스턴스를 구성합니다.

--- 탭: SwiftUI ---
// Use Firebase library to configure APIs
FirebaseApp.configure()

--- 탭: Swift ---
// Use Firebase library to configure APIs
FirebaseApp.configure()

--- 탭: Objective-C ---
// Use Firebase library to configure APIs
[FIRApp configure];

SwiftUI를 사용하는 경우 앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 앱 대리자 재구성도 중지해야 합니다. 자세한 내용은 SwiftUI 안내 [https://firebase.google.com/docs/ios/learn-more?hl=ko#swiftui]를 참조하세요.

--- 탭: SwiftUI ---
@main
struct YourApp: App {
// register app delegate for Firebase setup
@UIApplicationDelegateAdaptor(AppDelegate.self) var delegate

var body: some Scene {
WindowGroup {
NavigationView {
ContentView()
}
}
}
}

사용자가 정상적으로 로그인한 후에 didCompleteWithResult:error: 구현 코드에서 로그인한 사용자의 액세스 토큰을 가져와서 Firebase 사용자 인증 정보로 교환합니다.

--- 탭: Swift ---
let credential = FacebookAuthProvider
.credential(withAccessToken: AccessToken.current!.tokenString)

--- 탭: Objective-C ---
FIRAuthCredential *credential = [FIRFacebookAuthProvider
credentialWithAccessToken:[FBSDKAccessToken currentAccessToken].tokenString];

Facebook Limited 로그인 구현

'기본' Facebook 로그인 대신 Facebook Limited 로그인을 사용하려면 다음 단계를 완료하세요.

개발자 문서 [https://developers.facebook.com/docs/facebook-login/limited-login/ios]를 참고해 앱에 Facebook Limited 로그인을 통합합니다.

로그인 요청마다 고유한 임의 문자열인 'nonce'가 생성되며 이 문자열은 앱의 인증 요청에 대한 응답으로 ID 토큰이 명시적으로 부여되었는지 확인하는 데 사용됩니다. 재생 공격을 방지하는 데 이 단계가 중요합니다.

다음 예시와 같이 SecRandomCopyBytes(_:_:_)를 사용하여 암호로 보호된 nonce를 생성할 수 있습니다.

--- 탭: Swift ---
private func randomNonceString(length: Int = 32) -> String {
precondition(length > 0)
var randomBytes = [UInt8](repeating: 0, count: length)
let errorCode = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &randomBytes)
if errorCode != errSecSuccess {
fatalError(
"Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)"
)
}

let charset: [Character] =
Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")

let nonce = randomBytes.map { byte in
// Pick a random character from the set, wrapping around if needed.
charset[Int(byte) % charset.count]
}

return String(nonce)
}

--- 탭: Objective-C ---
// Adapted from https://auth0.com/docs/api-auth/tutorials/nonce#generate-a-cryptographically-random-nonce
- (NSString *)randomNonce:(NSInteger)length {
NSAssert(length > 0, @"Expected nonce to have positive length");
NSString *characterSet = @"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._";
NSMutableString *result = [NSMutableString string];
NSInteger remainingLength = length;

while (remainingLength > 0) {
NSMutableArray *randoms = [NSMutableArray arrayWithCapacity:16];
for (NSInteger i = 0; i < 16; i++) {
uint8_t random = 0;
int errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &random);
NSAssert(errorCode == errSecSuccess, @"Unable to generate nonce: OSStatus %i", errorCode);

[randoms addObject:@(random)];
}

for (NSNumber *random in randoms) {
if (remainingLength == 0) {
break;
}

if (random.unsignedIntValue < characterSet.length) {
unichar character = [characterSet characterAtIndex:random.unsignedIntValue];
[result appendFormat:@"%C", character];
remainingLength--;
}
}
}

return [result copy];
}
로그인 요청과 함께 nonce의 SHA-256 해시를 전송하면 Facebook은 이에 대한 응답으로 원래의 값을 전달합니다. Firebase는 원래의 nonce를 해싱하고 Facebook에서 전달한 값과 비교하여 응답을 검증합니다.

--- 탭: Swift ---
@available(iOS 13, *)
private func sha256(_ input: String) -> String {
let inputData = Data(input.utf8)
let hashedData = SHA256.hash(data: inputData)
let hashString = hashedData.compactMap {
String(format: "%02x", $0)
}.joined()

return hashString
}

--- 탭: Objective-C ---
- (NSString *)stringBySha256HashingString:(NSString *)input {
const char *string = [input UTF8String];
unsigned char result[CC_SHA256_DIGEST_LENGTH];
CC_SHA256(string, (CC_LONG)strlen(string), result);

NSMutableString *hashed = [NSMutableString stringWithCapacity:CC_SHA256_DIGEST_LENGTH * 2];
for (NSInteger i = 0; i < CC_SHA256_DIGEST_LENGTH; i++) {
[hashed appendFormat:@"%02x", result[i]];
}
return hashed;
}

FBSDKLoginButton을 설정할 때 로그인 및 로그아웃 이벤트를 받을 대리인을 설정하고 추적 모드를 FBSDKLoginTrackingLimited로 설정한 후 nonce를 연결합니다. 예를 들면 다음과 같습니다.

--- 탭: Swift ---
func setupLoginButton() {
let nonce = randomNonceString()
currentNonce = nonce
loginButton.delegate = self
loginButton.loginTracking = .limited
loginButton.nonce = sha256(nonce)
}

--- 탭: Objective-C ---
- (void)setupLoginButton {
NSString *nonce = [self randomNonce:32];
self.currentNonce = nonce;
self.loginButton.delegate = self;
self.loginButton.loginTracking = FBSDKLoginTrackingLimited
self.loginButton.nonce = [self stringBySha256HashingString:nonce];
}대리자에서 didCompleteWithResult:error:를 구현합니다.

--- 탭: Swift ---
func loginButton(_ loginButton: FBSDKLoginButton!, didCompleteWith result: FBSDKLoginManagerLoginResult!, error: Error!) {
if let error = error {
print(error.localizedDescription)
return
}
// ...
}

--- 탭: Objective-C ---
- (void)loginButton:(FBSDKLoginButton *)loginButton
didCompleteWithResult:(FBSDKLoginManagerLoginResult *)result
error:(NSError *)error {
if (error == nil) {
// ...
} else {
NSLog(error.localizedDescription);
}
}

UIApplicationDelegate의 FirebaseCore 모듈과 앱 대리자가 사용하는 다른 Firebase 모듈 [https://firebase.google.com/docs/ios/setup?hl=ko#available-pods]을 가져옵니다.
예를 들어 Cloud Firestore와 Authentication을 사용하려면 다음을 따르세요.

--- 탭: SwiftUI ---
import SwiftUI
import FirebaseCore
import FirebaseFirestore
import FirebaseAuth
// ...

--- 탭: Swift ---
import FirebaseCore
import FirebaseFirestore
import FirebaseAuth
// ...

--- 탭: Objective-C ---
@import FirebaseCore;
@import FirebaseFirestore;
@import FirebaseAuth;
// ...

앱 대리자의 application(_:didFinishLaunchingWithOptions:) 메서드에서 FirebaseApp [https://firebase.google.com/docs/reference/swift/firebasecore/api/reference/Classes/FirebaseApp?hl=ko] 공유 인스턴스를 구성합니다.

--- 탭: SwiftUI ---
// Use Firebase library to configure APIs
FirebaseApp.configure()

--- 탭: Swift ---
// Use Firebase library to configure APIs
FirebaseApp.configure()

--- 탭: Objective-C ---
// Use Firebase library to configure APIs
[FIRApp configure];

SwiftUI를 사용하는 경우 앱 대리자를 만들고 UIApplicationDelegateAdaptor 또는 NSApplicationDelegateAdaptor를 통해 App 구조체에 연결해야 합니다. 앱 대리자 재구성도 중지해야 합니다. 자세한 내용은 SwiftUI 안내 [https://firebase.google.com/docs/ios/learn-more?hl=ko#swiftui]를 참조하세요.

--- 탭: SwiftUI ---
@main
struct YourApp: App {
// register app delegate for Firebase setup
@UIApplicationDelegateAdaptor(AppDelegate.self) var delegate

var body: some Scene {
WindowGroup {
NavigationView {
ContentView()
}
}
}
}

사용자가 정상적으로 로그인한 후에 didCompleteWithResult:error: 구현에서 해시되지 않은 nonce가 포함된 Facebook의 응답에서 ID 토큰을 사용하여 Firebase 사용자 인증 정보를 가져옵니다.

--- 탭: Swift ---
// Initialize a Firebase credential.
let idTokenString = AuthenticationToken.current?.tokenString
let nonce = currentNonce
let credential = OAuthProvider.credential(withProviderID: "facebook.com",
idToken: idTokenString!,
rawNonce: nonce)

--- 탭: Objective-C ---
// Initialize a Firebase credential.
NSString *idTokenString = FBSDKAuthenticationToken.currentAuthenticationToken.tokenString;
NSString *rawNonce = self.currentNonce;
FIROAuthCredential *credential = [FIROAuthProvider credentialWithProviderID:@"facebook.com"
IDToken:idTokenString
rawNonce:rawNonce];

Firebase 인증

마지막으로 Firebase 사용자 인증 정보를 사용해 Firebase에 인증합니다.

--- 탭: Swift ---
Auth.auth().signIn(with: credential) { authResult, error in
if let error = error {
let authError = error as NSError
if isMFAEnabled, authError.code == AuthErrorCode.secondFactorRequired.rawValue {
// The user is a multi-factor user. Second factor challenge is required.
let resolver = authError
.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as! MultiFactorResolver
var displayNameString = ""
for tmpFactorInfo in resolver.hints {
displayNameString += tmpFactorInfo.displayName ?? ""
displayNameString += " "
}
self.showTextInputPrompt(
withMessage: "Select factor to sign in\n\(displayNameString)",
completionBlock: { userPressedOK, displayName in
var selectedHint: PhoneMultiFactorInfo?
for tmpFactorInfo in resolver.hints {
if displayName == tmpFactorInfo.displayName {
selectedHint = tmpFactorInfo as? PhoneMultiFactorInfo
}
}
PhoneAuthProvider.provider()
.verifyPhoneNumber(with: selectedHint!, uiDelegate: nil,
multiFactorSession: resolver
.session) { verificationID, error in
if error != nil {
print(
"Multi factor start sign in failed. Error: \(error.debugDescription)"
)
} else {
self.showTextInputPrompt(
withMessage: "Verification code for \(selectedHint?.displayName ?? "")",
completionBlock: { userPressedOK, verificationCode in
let credential: PhoneAuthCredential? = PhoneAuthProvider.provider()
.credential(withVerificationID: verificationID!,
verificationCode: verificationCode!)
let assertion: MultiFactorAssertion? = PhoneMultiFactorGenerator
.assertion(with: credential!)
resolver.resolveSignIn(with: assertion!) { authResult, error in
if error != nil {
print(
"Multi factor finanlize sign in failed. Error: \(error.debugDescription)"
)
} else {
self.navigationController?.popViewController(animated: true)
}
}
}
)
}
}
}
)
} else {
self.showMessagePrompt(error.localizedDescription)
return
}
// ...
return
}
// User is signed in
// ...
}

--- 탭: Objective-C ---
[[FIRAuth auth] signInWithCredential:credential
completion:^(FIRAuthDataResult * _Nullable authResult,
NSError * _Nullable error) {
if (isMFAEnabled && error && error.code == FIRAuthErrorCodeSecondFactorRequired) {
FIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];
NSMutableString *displayNameString = [NSMutableString string];
for (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {
[displayNameString appendString:tmpFactorInfo.displayName];
[displayNameString appendString:@" "];
}
[self showTextInputPromptWithMessage:[NSString stringWithFormat:@"Select factor to sign in\n%@", displayNameString]
completionBlock:^(BOOL userPressedOK, NSString *_Nullable displayName) {
FIRPhoneMultiFactorInfo* selectedHint;
for (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {
if ([displayName isEqualToString:tmpFactorInfo.displayName]) {
selectedHint = (FIRPhoneMultiFactorInfo *)tmpFactorInfo;
}
}
[FIRPhoneAuthProvider.provider
verifyPhoneNumberWithMultiFactorInfo:selectedHint
UIDelegate:nil
multiFactorSession:resolver.session
completion:^(NSString * _Nullable verificationID, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
} else {
[self showTextInputPromptWithMessage:[NSString stringWithFormat:@"Verification code for %@", selectedHint.displayName]
completionBlock:^(BOOL userPressedOK, NSString *_Nullable verificationCode) {
FIRPhoneAuthCredential *credential =
[[FIRPhoneAuthProvider provider] credentialWithVerificationID:verificationID
verificationCode:verificationCode];
FIRMultiFactorAssertion *assertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];
[resolver resolveSignInWithAssertion:assertion completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
} else {
NSLog(@"Multi factor finanlize sign in succeeded.");
}
}];
}];
}
}];
}];
}
else if (error) {
// ...
return;
}
// User successfully signed in. Get user data from the FIRUser object
if (authResult == nil) { return; }
FIRUser *user = authResult.user;
// ...
}];

다음 단계

사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트의 일부로 저장되며 사용자의 로그인 방법에 관계없이 프로젝트 내 모든 앱에서 사용자를 식별하는 데 사용될 수 있습니다.

앱의 User [https://firebase.google.com/docs/reference/ios/firebaseauth/interface_f_i_r_user?hl=ko] 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/ios/manage-users?hl=ko]를 참조하세요.

Firebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.

인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결 [https://firebase.google.com/docs/auth/ios/account-linking?hl=ko]하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.

사용자를 로그아웃시키려면 signOut: [https://firebase.google.com/docs/reference/ios/firebaseauth/interface_f_i_r_auth?hl=ko#ab0d5111f05c3f1906243852cc8ef41b1]을 호출합니다.

--- 탭: Swift ---
let firebaseAuth = Auth.auth()
do {
try firebaseAuth.signOut()
} catch let signOutError as NSError {
print("Error signing out: %@", signOutError)
}

--- 탭: Objective-C ---
NSError *signOutError;
BOOL status = [[FIRAuth auth] signOut:&signOutError];
if (!status) {
NSLog(@"Error signing out: %@", signOutError);
return;
}

또한 모든 인증 오류에 대한 오류 처리 코드를 추가할 수도 있습니다. 오류 처리 [https://firebase.google.com/docs/auth/ios/errors?hl=ko]를 참조하세요.

의견 보내기